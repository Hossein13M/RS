(function(f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = f();
    } else if (typeof define === 'function' && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== 'undefined') {
            g = window;
        } else if (typeof global !== 'undefined') {
            g = global;
        } else if (typeof self !== 'undefined') {
            g = self;
        } else {
            g = this;
        }
        g.Minio = f();
    }
})(function() {
    var define, module, exports;
    return (function() {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = 'function' == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error('Cannot find module \'' + i + '\'');
                        throw a.code = 'MODULE_NOT_FOUND', a;
                    }
                    var p = n[i] = { exports: {} };
                    e[i][0].call(p.exports, function(r) {
                        var n = e[i][1][r];
                        return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }
                return n[i].exports;
            }

            for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o;
        }

        return r;
    })()({
        1: [function(require, module, exports) {
            /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

            'use strict';

            Object.defineProperty(exports, '__esModule', {
                value: true
            });

            var _get = function get(_x, _x2, _x3) {
                var _again = true;
                _function: while (_again) {
                    var object = _x, property = _x2, receiver = _x3;
                    _again = false;
                    if (object === null) object = Function.prototype;
                    var desc = Object.getOwnPropertyDescriptor(object, property);
                    if (desc === undefined) {
                        var parent = Object.getPrototypeOf(object);
                        if (parent === null) {
                            return undefined;
                        } else {
                            _x = parent;
                            _x2 = property;
                            _x3 = receiver;
                            _again = true;
                            desc = parent = undefined;

                        }
                    } else if ('value' in desc) {
                        return desc.value;
                    } else {
                        var getter = desc.get;
                        if (getter === undefined) {
                            return undefined;
                        }
                        return getter.call(receiver);
                    }
                }
            };

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { 'default': obj };
            }

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError('Cannot call a class as a function');
                }
            }

            function _inherits(subClass, superClass) {
                if (typeof superClass !== 'function' && superClass !== null) {
                    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }

            var _es6Error = require('es6-error');

            var _es6Error2 = _interopRequireDefault(_es6Error);

// AnonymousRequestError is generated for anonymous keys on specific
// APIs. NOTE: PresignedURL generation always requires access keys.

            var AnonymousRequestError = (function(_ExtendableError) {
                _inherits(AnonymousRequestError, _ExtendableError);

                function AnonymousRequestError(message) {
                    _classCallCheck(this, AnonymousRequestError);

                    _get(Object.getPrototypeOf(AnonymousRequestError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidArgumentError is generated for all invalid arguments.
                return AnonymousRequestError;
            })(_es6Error2['default']);

            exports.AnonymousRequestError = AnonymousRequestError;

            var InvalidArgumentError = (function(_ExtendableError2) {
                _inherits(InvalidArgumentError, _ExtendableError2);

                function InvalidArgumentError(message) {
                    _classCallCheck(this, InvalidArgumentError);

                    _get(Object.getPrototypeOf(InvalidArgumentError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidPortError is generated when a non integer value is provided
                // for ports.
                return InvalidArgumentError;
            })(_es6Error2['default']);

            exports.InvalidArgumentError = InvalidArgumentError;

            var InvalidPortError = (function(_ExtendableError3) {
                _inherits(InvalidPortError, _ExtendableError3);

                function InvalidPortError(message) {
                    _classCallCheck(this, InvalidPortError);

                    _get(Object.getPrototypeOf(InvalidPortError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidEndpointError is generated when an invalid end point value is
                // provided which does not follow domain standards.
                return InvalidPortError;
            })(_es6Error2['default']);

            exports.InvalidPortError = InvalidPortError;

            var InvalidEndpointError = (function(_ExtendableError4) {
                _inherits(InvalidEndpointError, _ExtendableError4);

                function InvalidEndpointError(message) {
                    _classCallCheck(this, InvalidEndpointError);

                    _get(Object.getPrototypeOf(InvalidEndpointError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidBucketNameError is generated when an invalid bucket name is
                // provided which does not follow AWS S3 specifications.
                // http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
                return InvalidEndpointError;
            })(_es6Error2['default']);

            exports.InvalidEndpointError = InvalidEndpointError;

            var InvalidBucketNameError = (function(_ExtendableError5) {
                _inherits(InvalidBucketNameError, _ExtendableError5);

                function InvalidBucketNameError(message) {
                    _classCallCheck(this, InvalidBucketNameError);

                    _get(Object.getPrototypeOf(InvalidBucketNameError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidObjectNameError is generated when an invalid object name is
                // provided which does not follow AWS S3 specifications.
                // http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html
                return InvalidBucketNameError;
            })(_es6Error2['default']);

            exports.InvalidBucketNameError = InvalidBucketNameError;

            var InvalidObjectNameError = (function(_ExtendableError6) {
                _inherits(InvalidObjectNameError, _ExtendableError6);

                function InvalidObjectNameError(message) {
                    _classCallCheck(this, InvalidObjectNameError);

                    _get(Object.getPrototypeOf(InvalidObjectNameError.prototype), 'constructor', this).call(this, message);
                }

                // AccessKeyRequiredError generated by signature methods when access
                // key is not found.
                return InvalidObjectNameError;
            })(_es6Error2['default']);

            exports.InvalidObjectNameError = InvalidObjectNameError;

            var AccessKeyRequiredError = (function(_ExtendableError7) {
                _inherits(AccessKeyRequiredError, _ExtendableError7);

                function AccessKeyRequiredError(message) {
                    _classCallCheck(this, AccessKeyRequiredError);

                    _get(Object.getPrototypeOf(AccessKeyRequiredError.prototype), 'constructor', this).call(this, message);
                }

                // SecretKeyRequiredError generated by signature methods when secret
                // key is not found.
                return AccessKeyRequiredError;
            })(_es6Error2['default']);

            exports.AccessKeyRequiredError = AccessKeyRequiredError;

            var SecretKeyRequiredError = (function(_ExtendableError8) {
                _inherits(SecretKeyRequiredError, _ExtendableError8);

                function SecretKeyRequiredError(message) {
                    _classCallCheck(this, SecretKeyRequiredError);

                    _get(Object.getPrototypeOf(SecretKeyRequiredError.prototype), 'constructor', this).call(this, message);
                }

                // ExpiresParamError generated when expires parameter value is not
                // well within stipulated limits.
                return SecretKeyRequiredError;
            })(_es6Error2['default']);

            exports.SecretKeyRequiredError = SecretKeyRequiredError;

            var ExpiresParamError = (function(_ExtendableError9) {
                _inherits(ExpiresParamError, _ExtendableError9);

                function ExpiresParamError(message) {
                    _classCallCheck(this, ExpiresParamError);

                    _get(Object.getPrototypeOf(ExpiresParamError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidDateError generated when invalid date is found.
                return ExpiresParamError;
            })(_es6Error2['default']);

            exports.ExpiresParamError = ExpiresParamError;

            var InvalidDateError = (function(_ExtendableError10) {
                _inherits(InvalidDateError, _ExtendableError10);

                function InvalidDateError(message) {
                    _classCallCheck(this, InvalidDateError);

                    _get(Object.getPrototypeOf(InvalidDateError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidPrefixError generated when object prefix provided is invalid
                // or does not conform to AWS S3 object key restrictions.
                return InvalidDateError;
            })(_es6Error2['default']);

            exports.InvalidDateError = InvalidDateError;

            var InvalidPrefixError = (function(_ExtendableError11) {
                _inherits(InvalidPrefixError, _ExtendableError11);

                function InvalidPrefixError(message) {
                    _classCallCheck(this, InvalidPrefixError);

                    _get(Object.getPrototypeOf(InvalidPrefixError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidBucketPolicyError generated when the given bucket policy is invalid.
                return InvalidPrefixError;
            })(_es6Error2['default']);

            exports.InvalidPrefixError = InvalidPrefixError;

            var InvalidBucketPolicyError = (function(_ExtendableError12) {
                _inherits(InvalidBucketPolicyError, _ExtendableError12);

                function InvalidBucketPolicyError(message) {
                    _classCallCheck(this, InvalidBucketPolicyError);

                    _get(Object.getPrototypeOf(InvalidBucketPolicyError.prototype), 'constructor', this).call(this, message);
                }

                // IncorrectSizeError generated when total data read mismatches with
                // the input size.
                return InvalidBucketPolicyError;
            })(_es6Error2['default']);

            exports.InvalidBucketPolicyError = InvalidBucketPolicyError;

            var IncorrectSizeError = (function(_ExtendableError13) {
                _inherits(IncorrectSizeError, _ExtendableError13);

                function IncorrectSizeError(message) {
                    _classCallCheck(this, IncorrectSizeError);

                    _get(Object.getPrototypeOf(IncorrectSizeError.prototype), 'constructor', this).call(this, message);
                }

                // InvalidXMLError generated when an unknown XML is found.
                return IncorrectSizeError;
            })(_es6Error2['default']);

            exports.IncorrectSizeError = IncorrectSizeError;

            var InvalidXMLError = (function(_ExtendableError14) {
                _inherits(InvalidXMLError, _ExtendableError14);

                function InvalidXMLError(message) {
                    _classCallCheck(this, InvalidXMLError);

                    _get(Object.getPrototypeOf(InvalidXMLError.prototype), 'constructor', this).call(this, message);
                }

                // S3Error is generated for errors returned from S3 server.
                // see getErrorTransformer for details
                return InvalidXMLError;
            })(_es6Error2['default']);

            exports.InvalidXMLError = InvalidXMLError;

            var S3Error = (function(_ExtendableError15) {
                _inherits(S3Error, _ExtendableError15);

                function S3Error(message) {
                    _classCallCheck(this, S3Error);

                    _get(Object.getPrototypeOf(S3Error.prototype), 'constructor', this).call(this, message);
                }

                return S3Error;
            })(_es6Error2['default']);

            exports.S3Error = S3Error;


        }, { 'es6-error': 96 }],
        2: [function(require, module, exports) {
            (function(Buffer) {
                /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

                'use strict';

                Object.defineProperty(exports, '__esModule', {
                    value: true
                });
                var _slice = Array.prototype.slice;
                exports.promisify = promisify;
                exports.uriEscape = uriEscape;
                exports.uriResourceEscape = uriResourceEscape;
                exports.getScope = getScope;
                exports.isAmazonEndpoint = isAmazonEndpoint;
                exports.isVirtualHostStyle = isVirtualHostStyle;
                exports.isValidIP = isValidIP;
                exports.isValidEndpoint = isValidEndpoint;
                exports.isValidDomain = isValidDomain;
                exports.probeContentType = probeContentType;
                exports.isValidPort = isValidPort;
                exports.isValidBucketName = isValidBucketName;
                exports.isValidObjectName = isValidObjectName;
                exports.isValidPrefix = isValidPrefix;
                exports.isNumber = isNumber;
                exports.isFunction = isFunction;
                exports.isString = isString;
                exports.isObject = isObject;
                exports.isReadableStream = isReadableStream;
                exports.isBoolean = isBoolean;
                exports.isArray = isArray;
                exports.makeDateLong = makeDateLong;
                exports.makeDateShort = makeDateShort;
                exports.pipesetup = pipesetup;
                exports.readableStream = readableStream;
                exports.prependXAMZMeta = prependXAMZMeta;
                exports.isAmzHeader = isAmzHeader;
                exports.isSupportedHeader = isSupportedHeader;
                exports.isStorageclassHeader = isStorageclassHeader;
                exports.extractMetadata = extractMetadata;

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { 'default': obj };
                }

                var _stream = require('stream');

                var _stream2 = _interopRequireDefault(_stream);

                var _mimeTypes = require('mime-types');

                var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

// Returns a wrapper function that will promisify a given callback function.
// It will preserve 'this'.

                function promisify(fn) {
                    return function() {
                        var _this = this;

                        // If the last argument is a function, assume its the callback.
                        var callback = arguments[arguments.length - 1];

                        // If the callback is given, don't promisify, just pass straight in.
                        if (typeof callback === 'function') return fn.apply(this, arguments);

                        // Otherwise, create a new set of arguments, and wrap
                        // it in a promise.
                        var args = [].concat(_slice.call(arguments));

                        return new Promise(function(resolve, reject) {
                            // Add the callback function.
                            args.push(function(err, value) {
                                if (err) return reject(err);

                                resolve(value);
                            });

                            // Call the function with our special adaptor callback added.
                            fn.apply(_this, args);
                        });
                    };
                }

// All characters in string which are NOT unreserved should be percent encoded.
// Unreserved characers are : ALPHA / DIGIT / "-" / "." / "_" / "~"
// Reference https://tools.ietf.org/html/rfc3986#section-2.2

                function uriEscape(string) {
                    return string.split('').reduce(function(acc, elem) {
                        var buf = new Buffer(elem);
                        if (buf.length === 1) {
                            // length 1 indicates that elem is not a unicode character.
                            // Check if it is an unreserved characer.
                            if ('A' <= elem && elem <= 'Z' || 'a' <= elem && elem <= 'z' || '0' <= elem && elem <= '9' || elem === '_' || elem === '.' || elem === '~' || elem === '-') {
                                // Unreserved characer should not be encoded.
                                acc = acc + elem;
                                return acc;
                            }
                        }
                        // elem needs encoding - i.e elem should be encoded if it's not unreserved
                        // character or if it's a unicode character.
                        for (var i = 0; i < buf.length; i++) {
                            acc = acc + '%' + buf[i].toString(16).toUpperCase();
                        }
                        return acc;
                    }, '');
                }

                function uriResourceEscape(string) {
                    return uriEscape(string).replace(/%2F/g, '/');
                }

                function getScope(region, date) {
                    return makeDateShort(date) + '/' + region + '/s3/aws4_request';
                }

// isAmazonEndpoint - true if endpoint is 's3.amazonaws.com' or 's3.cn-north-1.amazonaws.com.cn'

                function isAmazonEndpoint(endpoint) {
                    return endpoint === 's3.amazonaws.com' || endpoint === 's3.cn-north-1.amazonaws.com.cn';
                }

// isVirtualHostStyle - verify if bucket name is support with virtual
// hosts. bucketNames with periods should be always treated as path
// style if the protocol is 'https:', this is due to SSL wildcard
// limitation. For all other buckets and Amazon S3 endpoint we will
// default to virtual host style.

                function isVirtualHostStyle(endpoint, protocol, bucket) {
                    if (protocol === 'https:' && bucket.indexOf('.') > -1) {
                        return false;
                    }
                    return isAmazonEndpoint(endpoint);
                }

                var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;

                function isValidIP(ip) {
                    return ipv4Regex.test(ip);
                }

// isValidEndpoint - true if endpoint is valid domain.

                function isValidEndpoint(endpoint) {
                    if (!isValidDomain(endpoint) && !isValidIP(endpoint)) {
                        return false;
                    }
                    // Return true.
                    return true;
                }

// isValidDomain - true if input host is a valid domain.

                function isValidDomain(host) {
                    if (!isString(host)) return false;
                    // See RFC 1035, RFC 3696.
                    if (host.length === 0 || host.length > 255) {
                        return false;
                    }
                    // Host cannot start or end with a '-'
                    if (host[0] === '-' || host.substr(-1) === '-') {
                        return false;
                    }
                    // Host cannot start or end with a '_'
                    if (host[0] === '_' || host.substr(-1) === '_') {
                        return false;
                    }
                    // Host cannot start or end with a '.'
                    if (host[0] === '.' || host.substr(-1) === '.') {
                        return false;
                    }
                    var alphaNumerics = '`~!@#$%^&*()+={}[]|\\"\';:><?/'.split('');
                    // All non alphanumeric characters are invalid.
                    for (var i in alphaNumerics) {
                        if (host.indexOf(alphaNumerics[i]) > -1) {
                            return false;
                        }
                    }
                    // No need to regexp match, since the list is non-exhaustive.
                    // We let it be valid and fail later.
                    return true;
                }

// Probes contentType using file extensions.
// For example: probeContentType('file.png') returns 'image/png'.

                function probeContentType(path) {
                    var contentType = _mimeTypes2['default'].lookup(path);
                    if (!contentType) {
                        contentType = 'application/octet-stream';
                    }
                    return contentType;
                }

// isValidPort - is input port valid.

                function isValidPort(port) {
                    // verify if port is a number.
                    if (!isNumber(port)) return false;
                    // port cannot be negative.
                    if (port < 0) return false;
                    // port '0' is valid and special case return true.
                    if (port === 0) return true;
                    var min_port = 1;
                    var max_port = 65535;
                    // Verify if port is in range.
                    return port >= min_port && port <= max_port;
                }

                function isValidBucketName(bucket) {
                    if (!isString(bucket)) return false;

                    // bucket length should be less than and no more than 63
                    // characters long.
                    if (bucket.length < 3 || bucket.length > 63) {
                        return false;
                    }
                    // bucket with successive periods is invalid.
                    if (bucket.indexOf('..') > -1) {
                        return false;
                    }
                    // bucket cannot have ip address style.
                    if (bucket.match(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/)) {
                        return false;
                    }
                    // bucket should begin with alphabet/number and end with alphabet/number,
                    // with alphabet/number/.- in the middle.
                    if (bucket.match(/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/)) {
                        return true;
                    }
                    return false;
                }

// check if objectName is a valid object name

                function isValidObjectName(objectName) {
                    if (!isValidPrefix(objectName)) return false;
                    if (objectName.length === 0) return false;
                    return true;
                }

// check if prefix is valid

                function isValidPrefix(prefix) {
                    if (!isString(prefix)) return false;
                    if (prefix.length > 1024) return false;
                    return true;
                }

// check if typeof arg number

                function isNumber(arg) {
                    return typeof arg === 'number';
                }

// check if typeof arg function

                function isFunction(arg) {
                    return typeof arg === 'function';
                }

// check if typeof arg string

                function isString(arg) {
                    return typeof arg === 'string';
                }

// check if typeof arg object

                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }

// check if object is readable stream

                function isReadableStream(arg) {
                    return isObject(arg) && isFunction(arg._read);
                }

// check if arg is boolean

                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }

// check if arg is array

                function isArray(arg) {
                    return Array.isArray(arg);
                }

// Create a Date string with format:
// 'YYYYMMDDTHHmmss' + Z

                function makeDateLong(date) {
                    date = date || new Date();

                    // Gives format like: '2017-08-07T16:28:59.889Z'
                    date = date.toISOString();

                    return date.substr(0, 4) + date.substr(5, 2) + date.substr(8, 5) + date.substr(14, 2) + date.substr(17, 2) + 'Z';
                }

// Create a Date string with format:
// 'YYYYMMDD'

                function makeDateShort(date) {
                    date = date || new Date();

                    // Gives format like: '2017-08-07T16:28:59.889Z'
                    date = date.toISOString();

                    return date.substr(0, 4) + date.substr(5, 2) + date.substr(8, 2);
                }

// pipesetup sets up pipe() from left to right os streams array
// pipesetup will also make sure that error emitted at any of the upstream Stream
// will be emitted at the last stream. This makes error handling simple

                function pipesetup() {
                    for (var _len = arguments.length, streams = Array(_len), _key = 0; _key < _len; _key++) {
                        streams[_key] = arguments[_key];
                    }

                    return streams.reduce(function(src, dst) {
                        src.on('error', function(err) {
                            return dst.emit('error', err);
                        });
                        return src.pipe(dst);
                    });
                }

// return a Readable stream that emits data

                function readableStream(data) {
                    var s = new _stream2['default'].Readable();
                    s._read = function() {
                    };
                    s.push(data);
                    s.push(null);
                    return s;
                }

// Function prepends metadata with the appropriate prefix if it is not already on

                function prependXAMZMeta(metaData) {
                    var newMetadata = Object.assign({}, metaData);
                    for (var key in metaData) {
                        if (!isAmzHeader(key) && !isSupportedHeader(key) && !isStorageclassHeader(key)) {
                            newMetadata['X-Amz-Meta-' + key] = newMetadata[key];
                            delete newMetadata[key];
                        }
                    }
                    return newMetadata;
                }

// Checks if it is a valid header according to the AmazonS3 API

                function isAmzHeader(key) {
                    var temp = key.toLowerCase();
                    return temp.startsWith('x-amz-meta-') || temp === 'x-amz-acl' || temp.startsWith('x-amz-server-side-encryption-') || temp === 'x-amz-server-side-encryption';
                }

//Checks if it is a supported Header

                function isSupportedHeader(key) {
                    var supported_headers = ['content-type', 'cache-control', 'content-encoding', 'content-disposition', 'content-language', 'x-amz-website-redirect-location'];
                    return supported_headers.indexOf(key.toLowerCase()) > -1;
                }

//Checks if it is a storage header

                function isStorageclassHeader(key) {
                    return key.toLowerCase() === 'x-amz-storage-class';
                }

                function extractMetadata(metaData) {
                    var newMetadata = {};
                    for (var key in metaData) {
                        if (isSupportedHeader(key) || isStorageclassHeader(key) || isAmzHeader(key)) {
                            if (key.toLowerCase().startsWith('x-amz-meta-')) {
                                newMetadata[key.slice(11, key.length)] = metaData[key];
                            } else {
                                newMetadata[key] = metaData[key];
                            }
                        }
                    }
                    return newMetadata;
                }


            }).call(this, require('buffer').Buffer);
        }, { 'buffer': 59, 'mime-types': 125, 'stream': 179 }],
        3: [function(require, module, exports) {
            (function(process, Buffer) {
                /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

                'use strict';

                Object.defineProperty(exports, '__esModule', {
                    value: true
                });

                var _createClass = (function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }

                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                })();

                function _interopExportWildcard(obj, defaults) {
                    var newObj = defaults({}, obj);
                    delete newObj['default'];
                    return newObj;
                }

                function _defaults(obj, defaults) {
                    var keys = Object.getOwnPropertyNames(defaults);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = Object.getOwnPropertyDescriptor(defaults, key);
                        if (value && value.configurable && obj[key] === undefined) {
                            Object.defineProperty(obj, key, value);
                        }
                    }
                    return obj;
                }

                function _interopRequireWildcard(obj) {
                    if (obj && obj.__esModule) {
                        return obj;
                    } else {
                        var newObj = {};
                        if (obj != null) {
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                            }
                        }
                        newObj['default'] = obj;
                        return newObj;
                    }
                }

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { 'default': obj };
                }

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError('Cannot call a class as a function');
                    }
                }

                var _fs = require('fs');

                var _fs2 = _interopRequireDefault(_fs);

                var _crypto = require('crypto');

                var _crypto2 = _interopRequireDefault(_crypto);

                var _http = require('http');

                var _http2 = _interopRequireDefault(_http);

                var _https = require('https');

                var _https2 = _interopRequireDefault(_https);

                var _stream = require('stream');

                var _stream2 = _interopRequireDefault(_stream);

                var _blockStream2 = require('block-stream2');

                var _blockStream22 = _interopRequireDefault(_blockStream2);

                var _xml = require('xml');

                var _xml2 = _interopRequireDefault(_xml);

                var _xml2js = require('xml2js');

                var _xml2js2 = _interopRequireDefault(_xml2js);

                var _async = require('async');

                var _async2 = _interopRequireDefault(_async);

                var _querystring = require('querystring');

                var _querystring2 = _interopRequireDefault(_querystring);

                var _mkdirp = require('mkdirp');

                var _mkdirp2 = _interopRequireDefault(_mkdirp);

                var _path = require('path');

                var _path2 = _interopRequireDefault(_path);

                var _lodash = require('lodash');

                var _lodash2 = _interopRequireDefault(_lodash);

                var _helpersJs = require('./helpers.js');

                var _signingJs = require('./signing.js');

                var _objectUploader = require('./object-uploader');

                var _objectUploader2 = _interopRequireDefault(_objectUploader);

                var _transformers = require('./transformers');

                var transformers = _interopRequireWildcard(_transformers);

                var _errorsJs = require('./errors.js');

                var errors = _interopRequireWildcard(_errorsJs);

                var _s3EndpointsJs = require('./s3-endpoints.js');

                var _notification = require('./notification');

                var Package = require('../../package.json');

                var Client = (function() {
                    function Client(params) {
                        _classCallCheck(this, Client);

                        if (typeof params.secure !== 'undefined') throw new Error('"secure" option deprecated, "useSSL" should be used instead');
                        // Default values if not specified.
                        if (typeof params.useSSL === 'undefined') params.useSSL = true;
                        if (!params.port) params.port = 0;
                        // Validate input params.
                        if (!(0, _helpersJs.isValidEndpoint)(params.endPoint)) {
                            throw new errors.InvalidEndpointError('Invalid endPoint : ' + params.endPoint);
                        }
                        if (!(0, _helpersJs.isValidPort)(params.port)) {
                            throw new errors.InvalidArgumentError('Invalid port : ' + params.port);
                        }
                        if (!(0, _helpersJs.isBoolean)(params.useSSL)) {
                            throw new errors.InvalidArgumentError('Invalid useSSL flag type : ' + params.useSSL + ', expected to be of type "boolean"');
                        }

                        // Validate region only if its set.
                        if (params.region) {
                            if (!(0, _helpersJs.isString)(params.region)) {
                                throw new errors.InvalidArgumentError('Invalid region : ' + params.region);
                            }
                        }

                        var host = params.endPoint.toLowerCase();
                        var port = params.port;
                        var protocol = '';
                        var transport;
                        // Validate if configuration is not using SSL
                        // for constructing relevant endpoints.
                        if (params.useSSL === false) {
                            transport = _http2['default'];
                            protocol = 'http:';
                            if (port === 0) {
                                port = 80;
                            }
                        } else {
                            // Defaults to secure.
                            transport = _https2['default'];
                            protocol = 'https:';
                            if (port === 0) {
                                port = 443;
                            }
                        }

                        // if custom transport is set, use it.
                        if (params.transport) {
                            if (!(0, _helpersJs.isObject)(params.transport)) {
                                throw new errors.InvalidArgumentError('Invalid transport type : ${params.transport}, expected to be type "object"');
                            }
                            transport = params.transport;
                        }

                        // User Agent should always following the below style.
                        // Please open an issue to discuss any new changes here.
                        //
                        //       Minio (OS; ARCH) LIB/VER APP/VER
                        //
                        var libraryComments = '(' + process.platform + '; ' + process.arch + ')';
                        var libraryAgent = 'Minio ' + libraryComments + ' minio-js/' + Package.version;
                        // User agent block ends.

                        this.transport = transport;
                        this.host = host;
                        this.port = port;
                        this.protocol = protocol;
                        this.accessKey = params.accessKey;
                        this.secretKey = params.secretKey;
                        this.sessionToken = params.sessionToken;
                        this.userAgent = '' + libraryAgent;

                        if (!this.accessKey) this.accessKey = '';
                        if (!this.secretKey) this.secretKey = '';
                        this.anonymous = !this.accessKey || !this.secretKey;

                        this.regionMap = {};
                        if (params.region) {
                            this.region = params.region;
                        }

                        this.minimumPartSize = 5 * 1024 * 1024;
                        this.maximumPartSize = 5 * 1024 * 1024 * 1024;
                        this.maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024;
                        // SHA256 is enabled only for authenticated http requests. If the request is authenticated
                        // and the connection is https we use x-amz-content-sha256=UNSIGNED-PAYLOAD
                        // header for signature calculation.
                        this.enableSHA256 = !this.anonymous && !params.useSSL;

                        this.reqOptions = {};
                    }

                    // Promisify various public-facing APIs on the Client module.

                    // Sets the supported request options.

                    _createClass(Client, [{
                        key: 'setRequestOptions',
                        value: function setRequestOptions(options) {
                            if (!(0, _helpersJs.isObject)(options)) {
                                throw new TypeError('request options should be of type "object"');
                            }
                            this.reqOptions = _lodash2['default'].pick(options, ['agent', 'ca', 'cert', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureOptions', 'secureProtocol', 'servername', 'sessionIdContext']);
                        }

                        // returns *options* object that can be used with http.request()
                        // Takes care of constructing virtual-host-style or path-style hostname
                    }, {
                        key: 'getRequestOptions',
                        value: function getRequestOptions(opts) {
                            var method = opts.method;
                            var region = opts.region;
                            var bucketName = opts.bucketName;
                            var objectName = opts.objectName;
                            var headers = opts.headers;
                            var query = opts.query;

                            var reqOptions = { method: method };
                            reqOptions.headers = {};

                            // Verify if virtual host supported.
                            var virtualHostStyle;
                            if (bucketName) {
                                virtualHostStyle = (0, _helpersJs.isVirtualHostStyle)(this.host, this.protocol, bucketName);
                            }

                            if (this.port) reqOptions.port = this.port;
                            reqOptions.protocol = this.protocol;

                            if (objectName) {
                                objectName = '' + (0, _helpersJs.uriResourceEscape)(objectName);
                            }

                            reqOptions.path = '/';

                            // Save host.
                            reqOptions.host = this.host;
                            // For Amazon S3 endpoint, get endpoint based on region.
                            if ((0, _helpersJs.isAmazonEndpoint)(reqOptions.host)) {
                                reqOptions.host = (0, _s3EndpointsJs.getS3Endpoint)(region);
                            }

                            if (virtualHostStyle && !opts.pathStyle) {
                                // For all hosts which support virtual host style, `bucketName`
                                // is part of the hostname in the following format:
                                //
                                //  var host = 'bucketName.example.com'
                                //
                                if (bucketName) reqOptions.host = bucketName + '.' + reqOptions.host;
                                if (objectName) reqOptions.path = '/' + objectName;
                            } else {
                                // For all S3 compatible storage services we will fallback to
                                // path style requests, where `bucketName` is part of the URI
                                // path.
                                if (bucketName) reqOptions.path = '/' + bucketName;
                                if (objectName) reqOptions.path = '/' + bucketName + '/' + objectName;
                            }

                            if (query) reqOptions.path += '?' + query;
                            reqOptions.headers.host = reqOptions.host;
                            if (reqOptions.protocol === 'http:' && reqOptions.port !== 80 || reqOptions.protocol === 'https:' && reqOptions.port !== 443) {
                                reqOptions.headers.host = reqOptions.host + ':' + reqOptions.port;
                            }
                            reqOptions.headers['user-agent'] = this.userAgent;
                            if (headers) {
                                // have all header keys in lower case - to make signing easy
                                _lodash2['default'].map(headers, function(v, k) {
                                    return reqOptions.headers[k.toLowerCase()] = v;
                                });
                            }

                            // Use any request option specified in minioClient.setRequestOptions()
                            reqOptions = Object.assign({}, this.reqOptions, reqOptions);

                            return reqOptions;
                        }

                        // Set application specific information.
                        //
                        // Generates User-Agent in the following style.
                        //
                        //       Minio (OS; ARCH) LIB/VER APP/VER
                        //
                        // __Arguments__
                        // * `appName` _string_ - Application name.
                        // * `appVersion` _string_ - Application version.
                    }, {
                        key: 'setAppInfo',
                        value: function setAppInfo(appName, appVersion) {
                            if (!(0, _helpersJs.isString)(appName)) {
                                throw new TypeError('Invalid appName: ' + appName);
                            }
                            if (appName.trim() === '') {
                                throw new errors.InvalidArgumentError('Input appName cannot be empty.');
                            }
                            if (!(0, _helpersJs.isString)(appVersion)) {
                                throw new TypeError('Invalid appName: ' + appVersion);
                            }
                            if (appVersion.trim() === '') {
                                throw new errors.InvalidArgumentError('Input appVersion cannot be empty.');
                            }
                            this.userAgent = this.userAgent + ' ' + appName + '/' + appVersion;
                        }

                        // partSize will be atleast minimumPartSize or a multiple of minimumPartSize
                        // for size <= 50GiB partSize is always 5MiB (10000*5MiB = 50GiB)
                        // for size > 50GiB partSize will be a multiple of 5MiB
                        // for size = 5TiB partSize will be 525MiB
                    }, {
                        key: 'calculatePartSize',
                        value: function calculatePartSize(size) {
                            if (!(0, _helpersJs.isNumber)(size)) {
                                throw new TypeError('size should be of type "number"');
                            }
                            if (size > this.maxObjectSize) {
                                throw new TypeError('size should not be more than ' + this.maxObjectSize);
                            }
                            var partSize = Math.ceil(size / 10000);
                            partSize = Math.ceil(partSize / this.minimumPartSize) * this.minimumPartSize;
                            return partSize;
                        }

                        // log the request, response, error
                    }, {
                        key: 'logHTTP',
                        value: function logHTTP(reqOptions, response, err) {
                            var _this = this;

                            // if no logstreamer available return.
                            if (!this.logStream) return;
                            if (!(0, _helpersJs.isObject)(reqOptions)) {
                                throw new TypeError('reqOptions should be of type "object"');
                            }
                            if (response && !(0, _helpersJs.isReadableStream)(response)) {
                                throw new TypeError('response should be of type "Stream"');
                            }
                            if (err && !(err instanceof Error)) {
                                throw new TypeError('err should be of type "Error"');
                            }
                            var logHeaders = function logHeaders(headers) {
                                _lodash2['default'].forEach(headers, function(v, k) {
                                    if (k == 'authorization') {
                                        var redacter = new RegExp('Signature=([0-9a-f]+)');
                                        v = v.replace(redacter, 'Signature=**REDACTED**');
                                    }
                                    _this.logStream.write(k + ': ' + v + '\n');
                                });
                                _this.logStream.write('\n');
                            };
                            this.logStream.write('REQUEST: ' + reqOptions.method + ' ' + reqOptions.path + '\n');
                            logHeaders(reqOptions.headers);
                            if (response) {
                                this.logStream.write('RESPONSE: ' + response.statusCode + '\n');
                                logHeaders(response.headers);
                            }
                            if (err) {
                                this.logStream.write('ERROR BODY:\n');
                                var errJSON = JSON.stringify(err, null, '\t');
                                this.logStream.write(errJSON + '\n');
                            }
                        }

                        // Enable tracing
                    }, {
                        key: 'traceOn',
                        value: function traceOn(stream) {
                            if (!stream) stream = process.stdout;
                            this.logStream = stream;
                        }

                        // Disable tracing
                    }, {
                        key: 'traceOff',
                        value: function traceOff() {
                            this.logStream = null;
                        }

                        // makeRequest is the primitive used by the apis for making S3 requests.
                        // payload can be empty string in case of no payload.
                        // statusCode is the expected statusCode. If response.statusCode does not match
                        // we parse the XML error and call the callback with the error message.
                        // A valid region is passed by the calls - listBuckets, makeBucket and
                        // getBucketRegion.
                    }, {
                        key: 'makeRequest',
                        value: function makeRequest(options, payload, statusCode, region, returnResponse, cb) {
                            if (!(0, _helpersJs.isObject)(options)) {
                                throw new TypeError('options should be of type "object"');
                            }
                            if (!(0, _helpersJs.isString)(payload) && !(0, _helpersJs.isObject)(payload)) {
                                // Buffer is of type 'object'
                                throw new TypeError('payload should be of type "string" or "Buffer"');
                            }
                            if (!(0, _helpersJs.isNumber)(statusCode)) {
                                throw new TypeError('statusCode should be of type "number"');
                            }
                            if (!(0, _helpersJs.isString)(region)) {
                                throw new TypeError('region should be of type "string"');
                            }
                            if (!(0, _helpersJs.isBoolean)(returnResponse)) {
                                throw new TypeError('returnResponse should be of type "boolean"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            if (!options.headers) options.headers = {};
                            if (options.method === 'POST' || options.method === 'PUT' || options.method === 'DELETE') {
                                options.headers['content-length'] = payload.length;
                            }
                            var sha256sum = '';
                            if (this.enableSHA256) sha256sum = _crypto2['default'].createHash('sha256').update(payload).digest('hex');
                            var stream = (0, _helpersJs.readableStream)(payload);
                            this.makeRequestStream(options, stream, sha256sum, statusCode, region, returnResponse, cb);
                        }

                        // makeRequestStream will be used directly instead of makeRequest in case the payload
                        // is available as a stream. for ex. putObject
                    }, {
                        key: 'makeRequestStream',
                        value: function makeRequestStream(options, stream, sha256sum, statusCode, region, returnResponse, cb) {
                            var _this2 = this;

                            if (!(0, _helpersJs.isObject)(options)) {
                                throw new TypeError('options should be of type "object"');
                            }
                            if (!(0, _helpersJs.isReadableStream)(stream)) {
                                throw new errors.InvalidArgumentError('stream should be a readable Stream');
                            }
                            if (!(0, _helpersJs.isString)(sha256sum)) {
                                throw new TypeError('sha256sum should be of type "string"');
                            }
                            if (!(0, _helpersJs.isNumber)(statusCode)) {
                                throw new TypeError('statusCode should be of type "number"');
                            }
                            if (!(0, _helpersJs.isString)(region)) {
                                throw new TypeError('region should be of type "string"');
                            }
                            if (!(0, _helpersJs.isBoolean)(returnResponse)) {
                                throw new TypeError('returnResponse should be of type "boolean"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            // sha256sum will be empty for anonymous or https requests
                            if (!this.enableSHA256 && sha256sum.length !== 0) {
                                throw new errors.InvalidArgumentError('sha256sum expected to be empty for anonymous or https requests');
                            }
                            // sha256sum should be valid for non-anonymous http requests.
                            if (this.enableSHA256 && sha256sum.length !== 64) {
                                throw new errors.InvalidArgumentError('Invalid sha256sum : ' + sha256sum);
                            }

                            var _makeRequest = function _makeRequest(e, region) {
                                if (e) return cb(e);
                                options.region = region;
                                var reqOptions = _this2.getRequestOptions(options);
                                if (!_this2.anonymous) {
                                    // For non-anonymous https requests sha256sum is 'UNSIGNED-PAYLOAD' for signature calculation.
                                    if (!_this2.enableSHA256) sha256sum = 'UNSIGNED-PAYLOAD';

                                    var date = new Date();

                                    reqOptions.headers['x-amz-date'] = (0, _helpersJs.makeDateLong)(date);
                                    reqOptions.headers['x-amz-content-sha256'] = sha256sum;
                                    if (_this2.sessionToken) {
                                        reqOptions.headers['x-amz-security-token'] = _this2.sessionToken;
                                    }

                                    var authorization = (0, _signingJs.signV4)(reqOptions, _this2.accessKey, _this2.secretKey, region, date);
                                    reqOptions.headers.authorization = authorization;
                                }
                                var req = _this2.transport.request(reqOptions, function(response) {
                                    if (statusCode !== response.statusCode) {
                                        // For an incorrect region, S3 server always sends back 400.
                                        // But we will do cache invalidation for all errors so that,
                                        // in future, if AWS S3 decides to send a different status code or
                                        // XML error code we will still work fine.
                                        delete _this2.regionMap[options.bucketName];
                                        var errorTransformer = transformers.getErrorTransformer(response);
                                        (0, _helpersJs.pipesetup)(response, errorTransformer).on('error', function(e) {
                                            _this2.logHTTP(reqOptions, response, e);
                                            cb(e);
                                        });
                                        return;
                                    }
                                    _this2.logHTTP(reqOptions, response);
                                    if (returnResponse) return cb(null, response);
                                    // We drain the socket so that the connection gets closed. Note that this
                                    // is not expensive as the socket will not have any data.
                                    response.on('data', function() {
                                    });
                                    cb(null);
                                });
                                var pipe = (0, _helpersJs.pipesetup)(stream, req);
                                pipe.on('error', function(e) {
                                    _this2.logHTTP(reqOptions, null, e);
                                    cb(e);
                                });
                            };
                            if (region) return _makeRequest(null, region);
                            this.getBucketRegion(options.bucketName, _makeRequest);
                        }

                        // gets the region of the bucket
                    }, {
                        key: 'getBucketRegion',
                        value: function getBucketRegion(bucketName, cb) {
                            var _this3 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name : ' + bucketName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('cb should be of type "function"');
                            }

                            // Region is set with constructor, return the region right here.
                            if (this.region) return cb(null, this.region);

                            if (this.regionMap[bucketName]) return cb(null, this.regionMap[bucketName]);
                            var extractRegion = function extractRegion(response) {
                                var transformer = transformers.getBucketRegionTransformer();
                                var region = 'us-east-1';
                                (0, _helpersJs.pipesetup)(response, transformer).on('error', cb).on('data', function(data) {
                                    if (data) region = data;
                                }).on('end', function() {
                                    _this3.regionMap[bucketName] = region;
                                    cb(null, region);
                                });
                            };

                            var method = 'GET';
                            var query = 'location';

                            // `getBucketLocation` behaves differently in following ways for
                            // different environments.
                            //
                            // - For nodejs env we default to path style requests.
                            // - For browser env path style requests on buckets yields CORS
                            //   error. To circumvent this problem we make a virtual host
                            //   style request signed with 'us-east-1'. This request fails
                            //   with an error 'AuthorizationHeaderMalformed', additionally
                            //   the error XML also provides Region of the bucket. To validate
                            //   this region is proper we retry the same request with the newly
                            //   obtained region.
                            var pathStyle = typeof window === 'undefined';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query,
                                pathStyle: pathStyle
                            }, '', 200, 'us-east-1', true, function(e, response) {
                                if (e) {
                                    if (e.name === 'AuthorizationHeaderMalformed') {
                                        var region = e.Region;
                                        if (!region) return cb(e);
                                        _this3.makeRequest({
                                            method: method,
                                            bucketName: bucketName,
                                            query: query
                                        }, '', 200, region, true, function(e, response) {
                                            if (e) return cb(e);
                                            extractRegion(response);
                                        });
                                        return;
                                    }
                                    return cb(e);
                                }
                                extractRegion(response);
                            });
                        }

                        // Creates the bucket `bucketName`.
                        //
                        // __Arguments__
                        // * `bucketName` _string_ - Name of the bucket
                        // * `region` _string_ - region valid values are _us-west-1_, _us-west-2_,  _eu-west-1_, _eu-central-1_, _ap-southeast-1_, _ap-northeast-1_, _ap-southeast-2_, _sa-east-1_.
                        // * `callback(err)` _function_ - callback function with `err` as the error argument. `err` is null if the bucket is successfully created.
                    }, {
                        key: 'makeBucket',
                        value: function makeBucket(bucketName, region, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }

                            if ((0, _helpersJs.isFunction)(region)) {
                                cb = region;
                                region = '';
                            }

                            if (!(0, _helpersJs.isString)(region)) {
                                throw new TypeError('region should be of type "string"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var payload = '';

                            // Region already set in constructor, validate if
                            // caller requested bucket location is same.
                            if (region && this.region) {
                                if (region !== this.region) {
                                    throw new errors.InvalidArgumentError('Configured region ' + this.region + ', requested ' + region);
                                }
                            }

                            // sending makeBucket request with XML containing 'us-east-1' fails. For
                            // default region server expects the request without body
                            if (region && region !== 'us-east-1') {
                                var createBucketConfiguration = [];
                                createBucketConfiguration.push({
                                    _attr: {
                                        xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/'
                                    }
                                });
                                createBucketConfiguration.push({
                                    LocationConstraint: region
                                });
                                var payloadObject = {
                                    CreateBucketConfiguration: createBucketConfiguration
                                };
                                payload = (0, _xml2['default'])(payloadObject);
                            }
                            var method = 'PUT';
                            var headers = {};
                            if (!region) region = 'us-east-1';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                headers: headers
                            }, payload, 200, region, false, cb);
                        }

                        // List of buckets created.
                        //
                        // __Arguments__
                        // * `callback(err, buckets)` _function_ - callback function with error as the first argument. `buckets` is an array of bucket information
                        //
                        // `buckets` array element:
                        // * `bucket.name` _string_ : bucket name
                        // * `bucket.creationDate` _Date_: date when bucket was created
                    }, {
                        key: 'listBuckets',
                        value: function listBuckets(cb) {
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'GET';
                            this.makeRequest({ method: method }, '', 200, 'us-east-1', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getListBucketTransformer();
                                var buckets;
                                (0, _helpersJs.pipesetup)(response, transformer).on('data', function(result) {
                                    return buckets = result;
                                }).on('error', function(e) {
                                    return cb(e);
                                }).on('end', function() {
                                    return cb(null, buckets);
                                });
                            });
                        }

                        // Returns a stream that emits objects that are partially uploaded.
                        //
                        // __Arguments__
                        // * `bucketname` _string_: name of the bucket
                        // * `prefix` _string_: prefix of the object names that are partially uploaded (optional, default `''`)
                        // * `recursive` _bool_: directory style listing when false, recursive listing when true (optional, default `false`)
                        //
                        // __Return Value__
                        // * `stream` _Stream_ : emits objects of the format:
                        //   * `object.key` _string_: name of the object
                        //   * `object.uploadId` _string_: upload ID of the object
                        //   * `object.size` _Integer_: size of the partially uploaded object
                    }, {
                        key: 'listIncompleteUploads',
                        value: function listIncompleteUploads(bucket, prefix, recursive) {
                            var _this4 = this;

                            if (prefix === undefined) prefix = '';
                            if (recursive === undefined) recursive = false;
                            if (!(0, _helpersJs.isValidBucketName)(bucket)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucket);
                            }
                            if (!(0, _helpersJs.isValidPrefix)(prefix)) {
                                throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);
                            }
                            if (!(0, _helpersJs.isBoolean)(recursive)) {
                                throw new TypeError('recursive should be of type "boolean"');
                            }
                            var delimiter = recursive ? '' : '/';
                            var keyMarker = '';
                            var uploadIdMarker = '';
                            var uploads = [];
                            var ended = false;
                            var readStream = _stream2['default'].Readable({ objectMode: true });
                            readStream._read = function() {
                                // push one upload info per _read()
                                if (uploads.length) {
                                    return readStream.push(uploads.shift());
                                }
                                if (ended) return readStream.push(null);
                                _this4.listIncompleteUploadsQuery(bucket, prefix, keyMarker, uploadIdMarker, delimiter).on('error', function(e) {
                                    return readStream.emit('error', e);
                                }).on('data', function(result) {
                                    result.prefixes.forEach(function(prefix) {
                                        return uploads.push(prefix);
                                    });
                                    _async2['default'].eachSeries(result.uploads, function(upload, cb) {
                                        // for each incomplete upload add the sizes of its uploaded parts
                                        _this4.listParts(bucket, upload.key, upload.uploadId, function(err, parts) {
                                            if (err) return cb(err);
                                            upload.size = parts.reduce(function(acc, item) {
                                                return acc + item.size;
                                            }, 0);
                                            uploads.push(upload);
                                            cb();
                                        });
                                    }, function(err) {
                                        if (err) {
                                            readStream.emit('error', err);
                                            return;
                                        }
                                        if (result.isTruncated) {
                                            keyMarker = result.nextKeyMarker;
                                            uploadIdMarker = result.nextUploadIdMarker;
                                        } else {
                                            ended = true;
                                        }
                                        readStream._read();
                                    });
                                });
                            };
                            return readStream;
                        }

                        // To check if a bucket already exists.
                        //
                        // __Arguments__
                        // * `bucketName` _string_ : name of the bucket
                        // * `callback(err)` _function_ : `err` is `null` if the bucket exists
                    }, {
                        key: 'bucketExists',
                        value: function bucketExists(bucketName, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'HEAD';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName
                            }, '', 200, '', false, function(err) {
                                if (err) {
                                    if (err.code == 'NoSuchBucket' || err.code == 'NotFound') return cb(null, false);
                                    return cb(err);
                                }
                                cb(null, true);
                            });
                        }

                        // Remove a bucket.
                        //
                        // __Arguments__
                        // * `bucketName` _string_ : name of the bucket
                        // * `callback(err)` _function_ : `err` is `null` if the bucket is removed successfully.
                    }, {
                        key: 'removeBucket',
                        value: function removeBucket(bucketName, cb) {
                            var _this5 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'DELETE';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName
                            }, '', 204, '', false, function(e) {
                                // If the bucket was successfully removed, remove the region map entry.
                                if (!e) delete _this5.regionMap[bucketName];
                                cb(e);
                            });
                        }

                        // Remove the partially uploaded object.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `callback(err)` _function_: callback function is called with non `null` value in case of error
                    }, {
                        key: 'removeIncompleteUpload',
                        value: function removeIncompleteUpload(bucketName, objectName, cb) {
                            var _this6 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.isValidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var removeUploadId;
                            _async2['default'].during(function(cb) {
                                _this6.findUploadId(bucketName, objectName, function(e, uploadId) {
                                    if (e) return cb(e);
                                    removeUploadId = uploadId;
                                    cb(null, uploadId);
                                });
                            }, function(cb) {
                                var method = 'DELETE';
                                var query = 'uploadId=' + removeUploadId;
                                _this6.makeRequest({
                                    method: method,
                                    bucketName: bucketName,
                                    objectName: objectName,
                                    query: query
                                }, '', 204, '', false, function(e) {
                                    return cb(e);
                                });
                            }, cb);
                        }

                        // Callback is called with `error` in case of error or `null` in case of success
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `filePath` _string_: path to which the object data will be written to
                        // * `callback(err)` _function_: callback is called with `err` in case of error.
                    }, {
                        key: 'fGetObject',
                        value: function fGetObject(bucketName, objectName, filePath, cb) {
                            var _this7 = this;

                            // Input validation.
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isString)(filePath)) {
                                throw new TypeError('filePath should be of type "string"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            // Internal data.
                            var partFile;
                            var partFileStream;
                            var objStat;

                            // Rename wrapper.
                            var rename = function rename(err) {
                                if (err) return cb(err);
                                _fs2['default'].rename(partFile, filePath, cb);
                            };

                            _async2['default'].waterfall([function(cb) {
                                return _this7.statObject(bucketName, objectName, cb);
                            }, function(result, cb) {
                                objStat = result;
                                // Create any missing top level directories.
                                (0, _mkdirp2['default'])(_path2['default'].dirname(filePath), cb);
                            }, function(ignore, cb) {
                                partFile = filePath + '.' + objStat.etag + '.part.minio';
                                _fs2['default'].stat(partFile, function(e, stats) {
                                    var offset = 0;
                                    if (e) {
                                        partFileStream = _fs2['default'].createWriteStream(partFile, { flags: 'w' });
                                    } else {
                                        if (objStat.size === stats.size) return rename();
                                        offset = stats.size;
                                        partFileStream = _fs2['default'].createWriteStream(partFile, { flags: 'a' });
                                    }
                                    _this7.getPartialObject(bucketName, objectName, offset, 0, cb);
                                });
                            }, function(downloadStream, cb) {
                                (0, _helpersJs.pipesetup)(downloadStream, partFileStream).on('error', function(e) {
                                    return cb(e);
                                }).on('finish', cb);
                            }, function(cb) {
                                return _fs2['default'].stat(partFile, cb);
                            }, function(stats, cb) {
                                if (stats.size === objStat.size) return cb();
                                cb(new Error('Size mismatch between downloaded file and the object'));
                            }], rename);
                        }

                        // Callback is called with readable stream of the object content.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream
                    }, {
                        key: 'getObject',
                        value: function getObject(bucketName, objectName, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            this.getPartialObject(bucketName, objectName, 0, 0, cb);
                        }

                        // Callback is called with readable stream of the partial object content.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `offset` _number_: offset of the object from where the stream will start
                        // * `length` _number_: length of the object that will be read in the stream (optional, if not specified we read the rest of the file from the offset)
                        // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream
                    }, {
                        key: 'getPartialObject',
                        value: function getPartialObject(bucketName, objectName, offset, length, cb) {
                            if ((0, _helpersJs.isFunction)(length)) {
                                cb = length;
                                length = 0;
                            }
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isNumber)(offset)) {
                                throw new TypeError('offset should be of type "number"');
                            }
                            if (!(0, _helpersJs.isNumber)(length)) {
                                throw new TypeError('length should be of type "number"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var range = '';
                            if (offset || length) {
                                if (offset) {
                                    range = 'bytes=' + +offset + '-';
                                } else {
                                    range = 'bytes=0-';
                                    offset = 0;
                                }
                                if (length) {
                                    range += '' + (+length + offset - 1);
                                }
                            }

                            var headers = {};
                            if (range !== '') {
                                headers.range = range;
                            }

                            var expectedStatus = 200;
                            if (range) {
                                expectedStatus = 206;
                            }
                            var method = 'GET';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName,
                                headers: headers
                            }, '', expectedStatus, '', true, cb);
                        }

                        // Uploads the object using contents from a file
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `filePath` _string_: file path of the file to be uploaded
                        // * `metaData` _Javascript Object_: metaData assosciated with the object
                        // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.
                    }, {
                        key: 'fPutObject',
                        value: function fPutObject(bucketName, objectName, filePath, metaData, callback) {
                            var _this8 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }

                            if (!(0, _helpersJs.isString)(filePath)) {
                                throw new TypeError('filePath should be of type "string"');
                            }
                            if ((0, _helpersJs.isFunction)(metaData)) {
                                callback = metaData;
                                metaData = {}; // Set metaData empty if no metaData provided.
                            }
                            if (!(0, _helpersJs.isObject)(metaData)) {
                                throw new TypeError('metaData should be of type "object"');
                            }

                            //Updates metaData to have the correct prefix if needed
                            metaData = (0, _helpersJs.prependXAMZMeta)(metaData);
                            var size;
                            var partSize;

                            _async2['default'].waterfall([function(cb) {
                                return _fs2['default'].stat(filePath, cb);
                            }, function(stats, cb) {
                                size = stats.size;
                                if (size > _this8.maxObjectSize) {
                                    return cb(new Error(filePath + ' size : ' + stats.size + ', max allowed size : 5TB'));
                                }
                                if (size < _this8.minimumPartSize) {
                                    // simple PUT request, no multipart
                                    var multipart = false;
                                    var uploader = _this8.getUploader(bucketName, objectName, metaData, multipart);
                                    var hash = transformers.getHashSummer(_this8.enableSHA256);
                                    var start = 0;
                                    var end = size - 1;
                                    var autoClose = true;
                                    if (size === 0) end = 0;
                                    var options = { start: start, end: end, autoClose: autoClose };
                                    (0, _helpersJs.pipesetup)(_fs2['default'].createReadStream(filePath, options), hash).on('data', function(data) {
                                        var md5sum = data.md5sum;
                                        var sha256sum = data.sha256sum;
                                        var stream = _fs2['default'].createReadStream(filePath, options);
                                        uploader(stream, size, sha256sum, md5sum, function(err, etag) {
                                            callback(err, etag);
                                            cb(true);
                                        });
                                    }).on('error', function(e) {
                                        return cb(e);
                                    });
                                    return;
                                }
                                _this8.findUploadId(bucketName, objectName, cb);
                            }, function(uploadId, cb) {
                                // if there was a previous incomplete upload, fetch all its uploaded parts info
                                if (uploadId) return _this8.listParts(bucketName, objectName, uploadId, function(e, etags) {
                                    return cb(e, uploadId, etags);
                                });
                                // there was no previous upload, initiate a new one
                                _this8.initiateNewMultipartUpload(bucketName, objectName, metaData, function(e, uploadId) {
                                    return cb(e, uploadId, []);
                                });
                            }, function(uploadId, etags, cb) {
                                partSize = _this8.calculatePartSize(size);
                                var multipart = true;
                                var uploader = _this8.getUploader(bucketName, objectName, metaData, multipart);

                                // convert array to object to make things easy
                                var parts = etags.reduce(function(acc, item) {
                                    if (!acc[item.part]) {
                                        acc[item.part] = item;
                                    }
                                    return acc;
                                }, {});
                                var partsDone = [];
                                var partNumber = 1;
                                var uploadedSize = 0;
                                _async2['default'].whilst(function() {
                                    return uploadedSize < size;
                                }, function(cb) {
                                    var part = parts[partNumber];
                                    var hash = transformers.getHashSummer(_this8.enableSHA256);
                                    var length = partSize;
                                    if (length > size - uploadedSize) {
                                        length = size - uploadedSize;
                                    }
                                    var start = uploadedSize;
                                    var end = uploadedSize + length - 1;
                                    var autoClose = true;
                                    var options = { autoClose: autoClose, start: start, end: end };
                                    // verify md5sum of each part
                                    (0, _helpersJs.pipesetup)(_fs2['default'].createReadStream(filePath, options), hash).on('data', function(data) {
                                        var md5sumHex = new Buffer(data.md5sum, 'base64').toString('hex');
                                        if (part && md5sumHex === part.etag) {
                                            //md5 matches, chunk already uploaded
                                            partsDone.push({ part: partNumber, etag: part.etag });
                                            partNumber++;
                                            uploadedSize += length;
                                            return cb();
                                        }
                                        // part is not uploaded yet, or md5 mismatch
                                        var stream = _fs2['default'].createReadStream(filePath, options);
                                        uploader(uploadId, partNumber, stream, length, data.sha256sum, data.md5sum, function(e, etag) {
                                            if (e) return cb(e);
                                            partsDone.push({ part: partNumber, etag: etag });
                                            partNumber++;
                                            uploadedSize += length;
                                            return cb();
                                        });
                                    }).on('error', function(e) {
                                        return cb(e);
                                    });
                                }, function(e) {
                                    if (e) return cb(e);
                                    cb(null, partsDone, uploadId);
                                });
                            },
                                // all parts uploaded, complete the multipart upload
                                function(etags, uploadId, cb) {
                                    return _this8.completeMultipartUpload(bucketName, objectName, uploadId, etags, cb);
                                }], function(err) {
                                for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                    rest[_key - 1] = arguments[_key];
                                }

                                if (err === true) return;
                                callback.apply(undefined, [err].concat(rest));
                            });
                        }

                        // Uploads the object.
                        //
                        // Uploading a stream
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `stream` _Stream_: Readable stream
                        // * `size` _number_: size of the object (optional)
                        // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.
                        //
                        // Uploading "Buffer" or "string"
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `string or Buffer` _Stream_ or _Buffer_: Readable stream
                        // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.
                    }, {
                        key: 'putObject',
                        value: function putObject(bucketName, objectName, stream, size, metaData, callback) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }

                            // We'll need to shift arguments to the left because of size and metaData.
                            if ((0, _helpersJs.isFunction)(size)) {
                                callback = size;
                                metaData = {};
                            } else if ((0, _helpersJs.isFunction)(metaData)) {
                                callback = metaData;
                                metaData = {};
                            }

                            // We'll need to shift arguments to the left because of metaData
                            // and size being optional.
                            if ((0, _helpersJs.isObject)(size)) {
                                metaData = size;
                            }

                            //Ensures Metadata has appropriate prefix for A3 API
                            metaData = (0, _helpersJs.prependXAMZMeta)(metaData);
                            if (typeof stream === 'string' || stream instanceof Buffer) {
                                // Adapts the non-stream interface into a stream.
                                size = stream.length;
                                stream = (0, _helpersJs.readableStream)(stream);
                            } else if (!(0, _helpersJs.isReadableStream)(stream)) {
                                throw new TypeError('third argument should be of type "stream.Readable" or "Buffer" or "string"');
                            }

                            if (!(0, _helpersJs.isFunction)(callback)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            if ((0, _helpersJs.isNumber)(size) && size < 0) {
                                throw new errors.InvalidArgumentError('size cannot be negative, given size: ' + size);
                            }

                            // Get the part size and forward that to the BlockStream. Default to the
                            // largest block size possible if necessary.
                            if (!(0, _helpersJs.isNumber)(size)) size = this.maxObjectSize;

                            size = this.calculatePartSize(size);

                            // s3 requires that all non-end chunks be at least `this.minimumPartSize`,
                            // so we chunk the stream until we hit either that size or the end before
                            // we flush it to s3.
                            var chunker = (0, _blockStream22['default'])({ size: size, zeroPadding: false });

                            // This is a Writable stream that can be written to in order to upload
                            // to the specified bucket and object automatically.
                            var uploader = new _objectUploader2['default'](this, bucketName, objectName, size, metaData, callback);
                            // stream => chunker => uploader
                            stream.pipe(chunker).pipe(uploader);
                        }

                        // Copy the object.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `srcObject` _string_: path of the source object to be copied
                        // * `conditions` _CopyConditions_: copy conditions that needs to be satisfied (optional, default `null`)
                        // * `callback(err, {etag, lastModified})` _function_: non null `err` indicates error, `etag` _string_ and `listModifed` _Date_ are respectively the etag and the last modified date of the newly copied object
                    }, {
                        key: 'copyObject',
                        value: function copyObject(arg1, arg2, arg3, arg4, arg5) {
                            var bucketName = arg1;
                            var objectName = arg2;
                            var srcObject = arg3;
                            var conditions, cb;
                            if (typeof arg4 == 'function' && arg5 === undefined) {
                                conditions = null;
                                cb = arg4;
                            } else {
                                conditions = arg4;
                                cb = arg5;
                            }
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isString)(srcObject)) {
                                throw new TypeError('srcObject should be of type "string"');
                            }
                            if (srcObject === '') {
                                throw new errors.InvalidPrefixError('Empty source prefix');
                            }

                            if (conditions !== null && !(conditions instanceof CopyConditions)) {
                                throw new TypeError('conditions should be of type "CopyConditions"');
                            }

                            var headers = {};
                            headers['x-amz-copy-source'] = (0, _helpersJs.uriEscape)(srcObject);

                            if (conditions !== null) {
                                if (conditions.modified !== '') {
                                    headers['x-amz-copy-source-if-modified-since'] = conditions.modified;
                                }
                                if (conditions.unmodified !== '') {
                                    headers['x-amz-copy-source-if-unmodified-since'] = conditions.unmodified;
                                }
                                if (conditions.matchETag !== '') {
                                    headers['x-amz-copy-source-if-match'] = conditions.matchETag;
                                }
                                if (conditions.matchEtagExcept !== '') {
                                    headers['x-amz-copy-source-if-none-match'] = conditions.matchETagExcept;
                                }
                            }

                            var method = 'PUT';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName,
                                headers: headers
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getCopyObjectTransformer();
                                (0, _helpersJs.pipesetup)(response, transformer).on('error', function(e) {
                                    return cb(e);
                                }).on('data', function(data) {
                                    return cb(null, data);
                                });
                            });
                        }

                        // list a batch of objects
                    }, {
                        key: 'listObjectsQuery',
                        value: function listObjectsQuery(bucketName, prefix, marker, delimiter, maxKeys) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(marker)) {
                                throw new TypeError('marker should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(delimiter)) {
                                throw new TypeError('delimiter should be of type "string"');
                            }
                            if (!(0, _helpersJs.isNumber)(maxKeys)) {
                                throw new TypeError('maxKeys should be of type "number"');
                            }
                            var queries = [];
                            // escape every value in query string, except maxKeys
                            if (prefix) {
                                prefix = (0, _helpersJs.uriEscape)(prefix);
                                queries.push('prefix=' + prefix);
                            }
                            if (marker) {
                                marker = (0, _helpersJs.uriEscape)(marker);
                                queries.push('marker=' + marker);
                            }
                            if (delimiter) {
                                delimiter = (0, _helpersJs.uriEscape)(delimiter);
                                queries.push('delimiter=' + delimiter);
                            }
                            // no need to escape maxKeys
                            if (maxKeys) {
                                if (maxKeys >= 1000) {
                                    maxKeys = 1000;
                                }
                                queries.push('max-keys=' + maxKeys);
                            }
                            queries.sort();
                            var query = '';
                            if (queries.length > 0) {
                                query = '' + queries.join('&');
                            }

                            var method = 'GET';
                            var transformer = transformers.getListObjectsTransformer();
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return transformer.emit('error', e);
                                (0, _helpersJs.pipesetup)(response, transformer);
                            });
                            return transformer;
                        }

                        // List the objects in the bucket.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)
                        // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)
                        //
                        // __Return Value__
                        // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:
                        //   * `obj.name` _string_: name of the object
                        //   * `obj.prefix` _string_: name of the object prefix
                        //   * `obj.size` _number_: size of the object
                        //   * `obj.etag` _string_: etag of the object
                        //   * `obj.lastModified` _Date_: modified time stamp
                    }, {
                        key: 'listObjects',
                        value: function listObjects(bucketName, prefix, recursive) {
                            var _this9 = this;

                            if (prefix === undefined) prefix = '';
                            if (recursive === undefined) recursive = false;
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidPrefix)(prefix)) {
                                throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix should be of type "string"');
                            }
                            if (!(0, _helpersJs.isBoolean)(recursive)) {
                                throw new TypeError('recursive should be of type "boolean"');
                            }
                            // if recursive is false set delimiter to '/'
                            var delimiter = recursive ? '' : '/';
                            var marker = '';
                            var objects = [];
                            var ended = false;
                            var readStream = _stream2['default'].Readable({ objectMode: true });
                            readStream._read = function() {
                                // push one object per _read()
                                if (objects.length) {
                                    readStream.push(objects.shift());
                                    return;
                                }
                                if (ended) return readStream.push(null);
                                // if there are no objects to push do query for the next batch of objects
                                _this9.listObjectsQuery(bucketName, prefix, marker, delimiter, 1000).on('error', function(e) {
                                    return readStream.emit('error', e);
                                }).on('data', function(result) {
                                    if (result.isTruncated) {
                                        marker = result.nextMarker;
                                    } else {
                                        ended = true;
                                    }
                                    objects = result.objects;
                                    readStream._read();
                                });
                            };
                            return readStream;
                        }

                        // list a batch of objects using S3 ListObjects v2
                    }, {
                        key: 'listObjectsV2Query',
                        value: function listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, maxKeys) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(continuationToken)) {
                                throw new TypeError('continuationToken should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(delimiter)) {
                                throw new TypeError('delimiter should be of type "string"');
                            }
                            if (!(0, _helpersJs.isNumber)(maxKeys)) {
                                throw new TypeError('maxKeys should be of type "number"');
                            }
                            var queries = [];

                            // Call for listing objects v2 API
                            queries.push('list-type=2');

                            // escape every value in query string, except maxKeys
                            if (prefix) {
                                prefix = (0, _helpersJs.uriEscape)(prefix);
                                queries.push('prefix=' + prefix);
                            }
                            if (continuationToken) {
                                continuationToken = (0, _helpersJs.uriEscape)(continuationToken);
                                queries.push('continuation-token=' + continuationToken);
                            }
                            if (delimiter) {
                                delimiter = (0, _helpersJs.uriEscape)(delimiter);
                                queries.push('delimiter=' + delimiter);
                            }
                            // no need to escape maxKeys
                            if (maxKeys) {
                                if (maxKeys >= 1000) {
                                    maxKeys = 1000;
                                }
                                queries.push('max-keys=' + maxKeys);
                            }
                            queries.sort();
                            var query = '';
                            if (queries.length > 0) {
                                query = '' + queries.join('&');
                            }
                            var method = 'GET';
                            var transformer = transformers.getListObjectsV2Transformer();
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return transformer.emit('error', e);
                                (0, _helpersJs.pipesetup)(response, transformer);
                            });
                            return transformer;
                        }

                        // List the objects in the bucket using S3 ListObjects V2
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)
                        // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)
                        //
                        // __Return Value__
                        // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:
                        //   * `obj.name` _string_: name of the object
                        //   * `obj.prefix` _string_: name of the object prefix
                        //   * `obj.size` _number_: size of the object
                        //   * `obj.etag` _string_: etag of the object
                        //   * `obj.lastModified` _Date_: modified time stamp
                    }, {
                        key: 'listObjectsV2',
                        value: function listObjectsV2(bucketName, prefix, recursive) {
                            var _this10 = this;

                            if (prefix === undefined) prefix = '';
                            if (recursive === undefined) recursive = false;
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidPrefix)(prefix)) {
                                throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix should be of type "string"');
                            }
                            if (!(0, _helpersJs.isBoolean)(recursive)) {
                                throw new TypeError('recursive should be of type "boolean"');
                            }
                            // if recursive is false set delimiter to '/'
                            var delimiter = recursive ? '' : '/';
                            var continuationToken = '';
                            var objects = [];
                            var ended = false;
                            var readStream = _stream2['default'].Readable({ objectMode: true });
                            readStream._read = function() {
                                // push one object per _read()
                                if (objects.length) {
                                    readStream.push(objects.shift());
                                    return;
                                }
                                if (ended) return readStream.push(null);
                                // if there are no objects to push do query for the next batch of objects
                                _this10.listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, 1000).on('error', function(e) {
                                    return readStream.emit('error', e);
                                }).on('data', function(result) {
                                    if (result.isTruncated) {
                                        continuationToken = result.nextContinuationToken;
                                    } else {
                                        ended = true;
                                    }
                                    objects = result.objects;
                                    readStream._read();
                                });
                            };
                            return readStream;
                        }

                        // Stat information of the object.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `callback(err, stat)` _function_: `err` is not `null` in case of error, `stat` contains the object information:
                        //   * `stat.size` _number_: size of the object
                        //   * `stat.etag` _string_: etag of the object
                        //   * `stat.metaData` _string_: MetaData of the object
                        //   * `stat.lastModified` _Date_: modified time stamp
                    }, {
                        key: 'statObject',
                        value: function statObject(bucketName, objectName, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var method = 'HEAD';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);

                                // We drain the socket so that the connection gets closed. Note that this
                                // is not expensive as the socket will not have any data.
                                response.on('data', function() {
                                });

                                var result = {
                                    size: +response.headers['content-length'],
                                    metaData: (0, _helpersJs.extractMetadata)(response.headers),
                                    lastModified: new Date(response.headers['last-modified'])
                                };
                                var etag = response.headers.etag;
                                if (etag) {
                                    etag = etag.replace(/^"/, '').replace(/"$/, '');
                                    result.etag = etag;
                                }
                                cb(null, result);
                            });
                        }

                        // Remove the specified object.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `callback(err)` _function_: callback function is called with non `null` value in case of error
                    }, {
                        key: 'removeObject',
                        value: function removeObject(bucketName, objectName, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'DELETE';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName
                            }, '', 204, '', false, cb);
                        }

                        // Remove all the objects residing in the objectsList.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectsList` _array_: array of objects
                    }, {
                        key: 'removeObjects',
                        value: function removeObjects(bucketName, objectsList, cb) {
                            var _this11 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isArray)(objectsList)) {
                                throw new errors.InvalidArgumentError('objectsList should be a list');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var maxEntries = 1000;
                            var query = 'delete';
                            var method = 'POST';

                            var result = objectsList.reduce(function(result, entry) {
                                result.list.push(entry);
                                if (result.list.length === maxEntries) {
                                    result.listOfList.push(result.list);
                                    result.list = [];
                                }
                                return result;
                            }, { listOfList: [], list: [] });

                            if (result.list.length > 0) {
                                result.listOfList.push(result.list);
                            }

                            _async2['default'].eachSeries(result.listOfList, function(list, callback) {
                                var deleteObjects = { 'Delete': [{ 'Quiet': true }] };

                                list.forEach(function(value) {
                                    deleteObjects['Delete'].push({ 'Object': [{ 'Key': value }] });
                                });

                                var payload = (0, _xml2['default'])(deleteObjects);

                                var headers = {};
                                var md5digest = _crypto2['default'].createHash('md5').update(payload).digest();

                                headers['Content-MD5'] = md5digest.toString('base64');

                                _this11.makeRequest({
                                    method: method,
                                    bucketName: bucketName,
                                    query: query,
                                    headers: headers
                                }, payload, 200, '', false, function(e) {
                                    if (e) return callback(e);
                                    callback(null);
                                });
                            }, cb);
                        }

                        // Get the policy on a bucket or an object prefix.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `callback(err, policy)` _function_: callback function
                    }, {
                        key: 'getBucketPolicy',
                        value: function getBucketPolicy(bucketName, cb) {
                            // Validate arguments.
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var method = 'GET';
                            var query = 'policy';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);

                                var policy = new Buffer('');
                                (0, _helpersJs.pipesetup)(response, transformers.getConcater()).on('data', function(data) {
                                    return policy = data;
                                }).on('error', cb).on('end', function() {
                                    cb(null, policy.toString());
                                });
                            });
                        }

                        // Set the policy on a bucket or an object prefix.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `bucketPolicy` _string_: bucket policy (JSON stringify'ed)
                        // * `callback(err)` _function_: callback function
                    }, {
                        key: 'setBucketPolicy',
                        value: function setBucketPolicy(bucketName, policy, cb) {
                            // Validate arguments.
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isString)(policy)) {
                                throw new errors.InvalidBucketPolicyError('Invalid bucket policy: ' + policy + ' - must be "string"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }

                            var method = 'DELETE';
                            var query = 'policy';

                            if (policy) {
                                method = 'PUT';
                            }

                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, policy, 204, '', false, cb);
                        }

                        // Generate a generic presigned URL which can be
                        // used for HTTP methods GET, PUT, HEAD and DELETE
                        //
                        // __Arguments__
                        // * `method` _string_: name of the HTTP method
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `expiry` _number_: expiry in seconds (optional, default 7 days)
                        // * `reqParams` _object_: request parameters (optional)
                    }, {
                        key: 'presignedUrl',
                        value: function presignedUrl(method, bucketName, objectName, expires, reqParams, cb) {
                            var _this12 = this;

                            if (this.anonymous) {
                                throw new errors.AnonymousRequestError('Presigned ' + method + ' url cannot be generated for anonymous requests');
                            }
                            if ((0, _helpersJs.isFunction)(reqParams)) {
                                cb = reqParams;
                                reqParams = {};
                            }
                            if ((0, _helpersJs.isFunction)(expires)) {
                                cb = expires;
                                reqParams = {};
                                expires = 24 * 60 * 60 * 7; // 7 days in seconds
                            }
                            if (!(0, _helpersJs.isNumber)(expires)) {
                                throw new TypeError('expires should be of type "number"');
                            }
                            if (!(0, _helpersJs.isObject)(reqParams)) {
                                throw new TypeError('reqParams should be of type "object"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var requestDate = new Date();
                            var query = _querystring2['default'].stringify(reqParams);
                            this.getBucketRegion(bucketName, function(e, region) {
                                if (e) return cb(e);
                                // This statement is added to ensure that we send error through
                                // callback on presign failure.
                                var url;
                                var reqOptions = _this12.getRequestOptions({
                                    method: method,
                                    region: region,
                                    bucketName: bucketName,
                                    objectName: objectName,
                                    query: query
                                });
                                try {
                                    url = (0, _signingJs.presignSignatureV4)(reqOptions, _this12.accessKey, _this12.secretKey, region, requestDate, expires);
                                } catch (pe) {
                                    return cb(pe);
                                }
                                cb(null, url);
                            });
                        }

                        // Generate a presigned URL for GET
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `expiry` _number_: expiry in seconds (optional, default 7 days)
                        // * `respHeaders` _object_: response headers to override (optional)
                    }, {
                        key: 'presignedGetObject',
                        value: function presignedGetObject(bucketName, objectName, expires, respHeaders, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            var validRespHeaders = ['response-content-type', 'response-content-language', 'response-expires', 'response-cache-control', 'response-content-disposition', 'response-content-encoding'];
                            validRespHeaders.forEach(function(header) {
                                if (respHeaders !== undefined && respHeaders[header] !== undefined && !(0, _helpersJs.isString)(respHeaders[header])) {
                                    throw new TypeError('response header ' + header + ' should be of type "string"');
                                }
                            });
                            return this.presignedUrl('GET', bucketName, objectName, expires, respHeaders, cb);
                        }

                        // Generate a presigned URL for PUT. Using this URL, the browser can upload to S3 only with the specified object name.
                        //
                        // __Arguments__
                        // * `bucketName` _string_: name of the bucket
                        // * `objectName` _string_: name of the object
                        // * `expiry` _number_: expiry in seconds (optional, default 7 days)
                    }, {
                        key: 'presignedPutObject',
                        value: function presignedPutObject(bucketName, objectName, expires, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ${bucketName}');
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ${objectName}');
                            }
                            return this.presignedUrl('PUT', bucketName, objectName, expires, cb);
                        }

                        // return PostPolicy object
                    }, {
                        key: 'newPostPolicy',
                        value: function newPostPolicy() {
                            return new PostPolicy();
                        }

                        // presignedPostPolicy can be used in situations where we want more control on the upload than what
                        // presignedPutObject() provides. i.e Using presignedPostPolicy we will be able to put policy restrictions
                        // on the object's `name` `bucket` `expiry` `Content-Type`
                    }, {
                        key: 'presignedPostPolicy',
                        value: function presignedPostPolicy(postPolicy, cb) {
                            var _this13 = this;

                            if (this.anonymous) {
                                throw new errors.AnonymousRequestError('Presigned POST policy cannot be generated for anonymous requests');
                            }
                            if (!(0, _helpersJs.isObject)(postPolicy)) {
                                throw new TypeError('postPolicy should be of type "object"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('cb should be of type "function"');
                            }
                            this.getBucketRegion(postPolicy.formData.bucket, function(e, region) {
                                if (e) return cb(e);
                                var date = new Date();
                                var dateStr = (0, _helpersJs.makeDateLong)(date);

                                if (!postPolicy.policy.expiration) {
                                    // 'expiration' is mandatory field for S3.
                                    // Set default expiration date of 7 days.
                                    var expires = new Date();
                                    expires.setSeconds(24 * 60 * 60 * 7);
                                    postPolicy.setExpires(expires);
                                }

                                postPolicy.policy.conditions.push(['eq', '$x-amz-date', dateStr]);
                                postPolicy.formData['x-amz-date'] = dateStr;

                                postPolicy.policy.conditions.push(['eq', '$x-amz-algorithm', 'AWS4-HMAC-SHA256']);
                                postPolicy.formData['x-amz-algorithm'] = 'AWS4-HMAC-SHA256';

                                postPolicy.policy.conditions.push(['eq', '$x-amz-credential', _this13.accessKey + '/' + (0, _helpersJs.getScope)(region, date)]);
                                postPolicy.formData['x-amz-credential'] = _this13.accessKey + '/' + (0, _helpersJs.getScope)(region, date);

                                var policyBase64 = new Buffer(JSON.stringify(postPolicy.policy)).toString('base64');

                                postPolicy.formData.policy = policyBase64;

                                var signature = (0, _signingJs.postPresignSignatureV4)(region, date, _this13.secretKey, policyBase64);

                                postPolicy.formData['x-amz-signature'] = signature;
                                var opts = {};
                                opts.region = region;
                                opts.bucketName = postPolicy.formData.bucket;
                                var reqOptions = _this13.getRequestOptions(opts);
                                var portStr = _this13.port == 80 || _this13.port === 443 ? '' : ':' + _this13.port.toString();
                                var urlStr = reqOptions.protocol + '//' + reqOptions.host + portStr + reqOptions.path;
                                cb(null, { postURL: urlStr, formData: postPolicy.formData });
                            });
                        }

                        // Calls implemented below are related to multipart.

                        // Initiate a new multipart upload.
                    }, {
                        key: 'initiateNewMultipartUpload',
                        value: function initiateNewMultipartUpload(bucketName, objectName, metaData, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isObject)(metaData)) {
                                throw new errors.InvalidObjectNameError('contentType should be of type "object"');
                            }
                            var method = 'POST';
                            var headers = Object.assign({}, metaData);
                            var query = 'uploads';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName,
                                query: query,
                                headers: headers
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getInitiateMultipartTransformer();
                                (0, _helpersJs.pipesetup)(response, transformer).on('error', function(e) {
                                    return cb(e);
                                }).on('data', function(uploadId) {
                                    return cb(null, uploadId);
                                });
                            });
                        }

                        // Complete the multipart upload. After all the parts are uploaded issuing
                        // this call will aggregate the parts on the server into a single object.
                    }, {
                        key: 'completeMultipartUpload',
                        value: function completeMultipartUpload(bucketName, objectName, uploadId, etags, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isString)(uploadId)) {
                                throw new TypeError('uploadId should be of type "string"');
                            }
                            if (!(0, _helpersJs.isObject)(etags)) {
                                throw new TypeError('etags should be of type "Array"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('cb should be of type "function"');
                            }

                            if (!uploadId) {
                                throw new errors.InvalidArgumentError('uploadId cannot be empty');
                            }

                            var method = 'POST';
                            var query = 'uploadId=' + (0, _helpersJs.uriEscape)(uploadId);

                            var parts = [];

                            etags.forEach(function(element) {
                                parts.push({
                                    Part: [{
                                        PartNumber: element.part
                                    }, {
                                        ETag: element.etag
                                    }]
                                });
                            });

                            var payloadObject = { CompleteMultipartUpload: parts };
                            var payload = (0, _xml2['default'])(payloadObject);

                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName,
                                query: query
                            }, payload, 200, '', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getCompleteMultipartTransformer();
                                (0, _helpersJs.pipesetup)(response, transformer).on('error', function(e) {
                                    return cb(e);
                                }).on('data', function(result) {
                                    if (result.errCode) {
                                        // Multipart Complete API returns an error XML after a 200 http status
                                        cb(new errors.S3Error(result.errMessage));
                                    } else {
                                        cb(null, result.etag);
                                    }
                                });
                            });
                        }

                        // Get part-info of all parts of an incomplete upload specified by uploadId.
                    }, {
                        key: 'listParts',
                        value: function listParts(bucketName, objectName, uploadId, cb) {
                            var _this14 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isString)(uploadId)) {
                                throw new TypeError('uploadId should be of type "string"');
                            }
                            if (!uploadId) {
                                throw new errors.InvalidArgumentError('uploadId cannot be empty');
                            }
                            var parts = [];
                            var listNext = function listNext(marker) {
                                _this14.listPartsQuery(bucketName, objectName, uploadId, marker, function(e, result) {
                                    if (e) {
                                        cb(e);
                                        return;
                                    }
                                    parts = parts.concat(result.parts);
                                    if (result.isTruncated) {
                                        listNext(result.marker);
                                        return;
                                    }
                                    cb(null, parts);
                                });
                            };
                            listNext(0);
                        }

                        // Called by listParts to fetch a batch of part-info
                    }, {
                        key: 'listPartsQuery',
                        value: function listPartsQuery(bucketName, objectName, uploadId, marker, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isString)(uploadId)) {
                                throw new TypeError('uploadId should be of type "string"');
                            }
                            if (!(0, _helpersJs.isNumber)(marker)) {
                                throw new TypeError('marker should be of type "number"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            if (!uploadId) {
                                throw new errors.InvalidArgumentError('uploadId cannot be empty');
                            }
                            var query = '';
                            if (marker && marker !== 0) {
                                query += 'part-number-marker=' + marker + '&';
                            }
                            query += 'uploadId=' + (0, _helpersJs.uriEscape)(uploadId);

                            var method = 'GET';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                objectName: objectName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getListPartsTransformer();
                                (0, _helpersJs.pipesetup)(response, transformer).on('error', function(e) {
                                    return cb(e);
                                }).on('data', function(data) {
                                    return cb(null, data);
                                });
                            });
                        }

                        // Called by listIncompleteUploads to fetch a batch of incomplete uploads.
                    }, {
                        key: 'listIncompleteUploadsQuery',
                        value: function listIncompleteUploadsQuery(bucketName, prefix, keyMarker, uploadIdMarker, delimiter) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(keyMarker)) {
                                throw new TypeError('keyMarker should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(uploadIdMarker)) {
                                throw new TypeError('uploadIdMarker should be of type "string"');
                            }
                            if (!(0, _helpersJs.isString)(delimiter)) {
                                throw new TypeError('delimiter should be of type "string"');
                            }
                            var queries = [];
                            if (prefix) {
                                queries.push('prefix=' + (0, _helpersJs.uriEscape)(prefix));
                            }
                            if (keyMarker) {
                                keyMarker = (0, _helpersJs.uriEscape)(keyMarker);
                                queries.push('key-marker=' + keyMarker);
                            }
                            if (uploadIdMarker) {
                                queries.push('upload-id-marker=' + uploadIdMarker);
                            }
                            if (delimiter) {
                                queries.push('delimiter=' + (0, _helpersJs.uriEscape)(delimiter));
                            }
                            var maxUploads = 1000;
                            queries.push('max-uploads=' + maxUploads);
                            queries.sort();
                            queries.unshift('uploads');
                            var query = '';
                            if (queries.length > 0) {
                                query = '' + queries.join('&');
                            }
                            var method = 'GET';
                            var transformer = transformers.getListMultipartTransformer();
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return transformer.emit('error', e);
                                (0, _helpersJs.pipesetup)(response, transformer);
                            });
                            return transformer;
                        }

                        // Find uploadId of an incomplete upload.
                    }, {
                        key: 'findUploadId',
                        value: function findUploadId(bucketName, objectName, cb) {
                            var _this15 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('cb should be of type "function"');
                            }
                            var latestUpload;
                            var listNext = function listNext(keyMarker, uploadIdMarker) {
                                _this15.listIncompleteUploadsQuery(bucketName, objectName, keyMarker, uploadIdMarker, '').on('error', function(e) {
                                    return cb(e);
                                }).on('data', function(result) {
                                    result.uploads.forEach(function(upload) {
                                        if (upload.key === objectName) {
                                            if (!latestUpload || upload.initiated.getTime() > latestUpload.initiated.getTime()) {
                                                latestUpload = upload;

                                            }
                                        }
                                    });
                                    if (result.isTruncated) {
                                        listNext(result.nextKeyMarker, result.nextUploadIdMarker);
                                        return;
                                    }
                                    if (latestUpload) return cb(null, latestUpload.uploadId);
                                    cb(null, undefined);
                                });
                            };
                            listNext('', '');
                        }

                        // Returns a function that can be used for uploading objects.
                        // If multipart === true, it returns function that is used to upload
                        // a part of the multipart.
                    }, {
                        key: 'getUploader',
                        value: function getUploader(bucketName, objectName, metaData, multipart) {
                            var _this16 = this;

                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name: ' + objectName);
                            }
                            if (!(0, _helpersJs.isBoolean)(multipart)) {
                                throw new TypeError('multipart should be of type "boolean"');
                            }
                            if (!(0, _helpersJs.isObject)(metaData)) {
                                throw new TypeError('metadata should be of type "object"');
                            }

                            var validate = function validate(stream, length, sha256sum, md5sum, cb) {
                                if (!(0, _helpersJs.isReadableStream)(stream)) {
                                    throw new TypeError('stream should be of type "Stream"');
                                }
                                if (!(0, _helpersJs.isNumber)(length)) {
                                    throw new TypeError('length should be of type "number"');
                                }
                                if (!(0, _helpersJs.isString)(sha256sum)) {
                                    throw new TypeError('sha256sum should be of type "string"');
                                }
                                if (!(0, _helpersJs.isString)(md5sum)) {
                                    throw new TypeError('md5sum should be of type "string"');
                                }
                                if (!(0, _helpersJs.isFunction)(cb)) {
                                    throw new TypeError('callback should be of type "function"');
                                }
                            };
                            var simpleUploader = function simpleUploader() {
                                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                    args[_key2] = arguments[_key2];
                                }

                                validate.apply(undefined, args);
                                var query = '';
                                upload.apply(undefined, [query].concat(args));
                            };
                            var multipartUploader = function multipartUploader(uploadId, partNumber) {
                                for (var _len3 = arguments.length, rest = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                                    rest[_key3 - 2] = arguments[_key3];
                                }

                                if (!(0, _helpersJs.isString)(uploadId)) {
                                    throw new TypeError('uploadId should be of type "string"');
                                }
                                if (!(0, _helpersJs.isNumber)(partNumber)) {
                                    throw new TypeError('partNumber should be of type "number"');
                                }
                                if (!uploadId) {
                                    throw new errors.InvalidArgumentError('Empty uploadId');
                                }
                                if (!partNumber) {
                                    throw new errors.InvalidArgumentError('partNumber cannot be 0');
                                }
                                validate.apply(undefined, rest);
                                var query = 'partNumber=' + partNumber + '&uploadId=' + (0, _helpersJs.uriEscape)(uploadId);
                                upload.apply(undefined, [query].concat(rest));
                            };
                            var upload = function upload(query, stream, length, sha256sum, md5sum, cb) {
                                var method = 'PUT';
                                var headers = Object.assign({}, metaData, { 'Content-Length': length });

                                if (!_this16.enableSHA256) headers['Content-MD5'] = md5sum;
                                _this16.makeRequestStream({
                                    method: method,
                                    bucketName: bucketName,
                                    objectName: objectName,
                                    query: query,
                                    headers: headers
                                }, stream, sha256sum, 200, '', true, function(e, response) {
                                    if (e) return cb(e);
                                    var etag = response.headers.etag;
                                    if (etag) {
                                        etag = etag.replace(/^"/, '').replace(/"$/, '');
                                    }
                                    // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)
                                    response.on('data', function() {
                                    });
                                    cb(null, etag);
                                });
                            };
                            if (multipart) {
                                return multipartUploader;
                            }
                            return simpleUploader;
                        }

                        // Remove all the notification configurations in the S3 provider
                    }, {
                        key: 'setBucketNotification',
                        value: function setBucketNotification(bucketName, config, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isObject)(config)) {
                                throw new TypeError('notification config should be of type "Object"');
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'PUT';
                            var query = 'notification';
                            var builder = new _xml2js2['default'].Builder({
                                rootName: 'NotificationConfiguration',
                                renderOpts: { 'pretty': false },
                                headless: true
                            });
                            var payload = builder.buildObject(config);
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, payload, 200, '', false, cb);
                        }
                    }, {
                        key: 'removeAllBucketNotification',
                        value: function removeAllBucketNotification(bucketName, cb) {
                            this.setBucketNotification(bucketName, new _notification.NotificationConfig(), cb);
                        }

                        // Return the list of notification configurations stored
                        // in the S3 provider
                    }, {
                        key: 'getBucketNotification',
                        value: function getBucketNotification(bucketName, cb) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isFunction)(cb)) {
                                throw new TypeError('callback should be of type "function"');
                            }
                            var method = 'GET';
                            var query = 'notification';
                            this.makeRequest({
                                method: method,
                                bucketName: bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return cb(e);
                                var transformer = transformers.getBucketNotificationTransformer();
                                var bucketNotification;
                                (0, _helpersJs.pipesetup)(response, transformer).on('data', function(result) {
                                    return bucketNotification = result;
                                }).on('error', function(e) {
                                    return cb(e);
                                }).on('end', function() {
                                    return cb(null, bucketNotification);
                                });
                            });
                        }

                        // Listens for bucket notifications. Returns an EventEmitter.
                    }, {
                        key: 'listenBucketNotification',
                        value: function listenBucketNotification(bucketName, prefix, suffix, events) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);
                            }
                            if (!(0, _helpersJs.isString)(prefix)) {
                                throw new TypeError('prefix must be of type string');
                            }
                            if (!(0, _helpersJs.isString)(suffix)) {
                                throw new TypeError('suffix must be of type string');
                            }
                            if (!(0, _helpersJs.isArray)(events)) {
                                throw new TypeError('events must be of type Array');
                            }
                            var listener = new _notification.NotificationPoller(this, bucketName, prefix, suffix, events);
                            listener.start();

                            return listener;
                        }
                    }]);

                    return Client;
                })();

                exports.Client = Client;
                Client.prototype.makeBucket = (0, _helpersJs.promisify)(Client.prototype.makeBucket);
                Client.prototype.listBuckets = (0, _helpersJs.promisify)(Client.prototype.listBuckets);
                Client.prototype.bucketExists = (0, _helpersJs.promisify)(Client.prototype.bucketExists);
                Client.prototype.removeBucket = (0, _helpersJs.promisify)(Client.prototype.removeBucket);

                Client.prototype.getObject = (0, _helpersJs.promisify)(Client.prototype.getObject);
                Client.prototype.getPartialObject = (0, _helpersJs.promisify)(Client.prototype.getPartialObject);
                Client.prototype.fGetObject = (0, _helpersJs.promisify)(Client.prototype.fGetObject);
                Client.prototype.putObject = (0, _helpersJs.promisify)(Client.prototype.putObject);
                Client.prototype.fPutObject = (0, _helpersJs.promisify)(Client.prototype.fPutObject);
                Client.prototype.copyObject = (0, _helpersJs.promisify)(Client.prototype.copyObject);
                Client.prototype.statObject = (0, _helpersJs.promisify)(Client.prototype.statObject);
                Client.prototype.removeObject = (0, _helpersJs.promisify)(Client.prototype.removeObject);
                Client.prototype.removeObjects = (0, _helpersJs.promisify)(Client.prototype.removeObjects);

                Client.prototype.presignedGetObject = (0, _helpersJs.promisify)(Client.prototype.presignedGetObject);
                Client.prototype.presignedPutObject = (0, _helpersJs.promisify)(Client.prototype.presignedPutObject);
                Client.prototype.presignedPostPolicy = (0, _helpersJs.promisify)(Client.prototype.presignedPostPolicy);
                Client.prototype.getBucketNotification = (0, _helpersJs.promisify)(Client.prototype.getBucketNotification);
                Client.prototype.setBucketNotification = (0, _helpersJs.promisify)(Client.prototype.setBucketNotification);
                Client.prototype.removeAllBucketNotification = (0, _helpersJs.promisify)(Client.prototype.removeAllBucketNotification);
                Client.prototype.getBucketPolicy = (0, _helpersJs.promisify)(Client.prototype.getBucketPolicy);
                Client.prototype.setBucketPolicy = (0, _helpersJs.promisify)(Client.prototype.setBucketPolicy);
                Client.prototype.removeIncompleteUpload = (0, _helpersJs.promisify)(Client.prototype.removeIncompleteUpload);

                var CopyConditions = (function() {
                    function CopyConditions() {
                        _classCallCheck(this, CopyConditions);

                        this.modified = '';
                        this.unmodified = '';
                        this.matchETag = '';
                        this.matchETagExcept = '';
                    }

                    // Build PostPolicy object that can be signed by presignedPostPolicy

                    _createClass(CopyConditions, [{
                        key: 'setModified',
                        value: function setModified(date) {
                            if (!(date instanceof Date)) throw new TypeError('date must be of type Date');

                            this.modified = date.toUTCString();
                        }
                    }, {
                        key: 'setUnmodified',
                        value: function setUnmodified(date) {
                            if (!(date instanceof Date)) throw new TypeError('date must be of type Date');

                            this.unmodified = date.toUTCString();
                        }
                    }, {
                        key: 'setMatchETag',
                        value: function setMatchETag(etag) {
                            this.matchETag = etag;
                        }
                    }, {
                        key: 'setMatchETagExcept',
                        value: function setMatchETagExcept(etag) {
                            this.matchETagExcept = etag;
                        }
                    }]);

                    return CopyConditions;
                })();

                exports.CopyConditions = CopyConditions;

                var PostPolicy = (function() {
                    function PostPolicy() {
                        _classCallCheck(this, PostPolicy);

                        this.policy = {
                            conditions: []
                        };
                        this.formData = {};
                    }

                    // set expiration date

                    _createClass(PostPolicy, [{
                        key: 'setExpires',
                        value: function setExpires(date) {
                            if (!date) {
                                throw new errors.InvalidDateError('Invalid date : cannot be null');
                            }
                            this.policy.expiration = date.toISOString();
                        }

                        // set object name
                    }, {
                        key: 'setKey',
                        value: function setKey(objectName) {
                            if (!(0, _helpersJs.isValidObjectName)(objectName)) {
                                throw new errors.InvalidObjectNameError('Invalid object name : ' + objectName);
                            }
                            this.policy.conditions.push(['eq', '$key', objectName]);
                            this.formData.key = objectName;
                        }

                        // set object name prefix, i.e policy allows any keys with this prefix
                    }, {
                        key: 'setKeyStartsWith',
                        value: function setKeyStartsWith(prefix) {
                            if (!(0, _helpersJs.isValidPrefix)(prefix)) {
                                throw new errors.InvalidPrefixError('Invalid prefix : ' + prefix);
                            }
                            this.policy.conditions.push(['starts-with', '$key', prefix]);
                            this.formData.key = prefix;
                        }

                        // set bucket name
                    }, {
                        key: 'setBucket',
                        value: function setBucket(bucketName) {
                            if (!(0, _helpersJs.isValidBucketName)(bucketName)) {
                                throw new errors.InvalidBucketNameError('Invalid bucket name : ' + bucketName);
                            }
                            this.policy.conditions.push(['eq', '$bucket', bucketName]);
                            this.formData.bucket = bucketName;
                        }

                        // set Content-Type
                    }, {
                        key: 'setContentType',
                        value: function setContentType(type) {
                            if (!type) {
                                throw new Error('content-type cannot be null');
                            }
                            this.policy.conditions.push(['eq', '$Content-Type', type]);
                            this.formData['Content-Type'] = type;
                        }

                        // set minimum/maximum length of what Content-Length can be.
                    }, {
                        key: 'setContentLengthRange',
                        value: function setContentLengthRange(min, max) {
                            if (min > max) {
                                throw new Error('min cannot be more than max');
                            }
                            if (min < 0) {
                                throw new Error('min should be > 0');
                            }
                            if (max < 0) {
                                throw new Error('max should be > 0');
                            }
                            this.policy.conditions.push(['content-length-range', min, max]);
                        }
                    }]);

                    return PostPolicy;
                })();

                exports.PostPolicy = PostPolicy;

                _defaults(exports, _interopExportWildcard(_notification, _defaults));


            }).call(this, require('_process'), require('buffer').Buffer);
        }, {
            '../../package.json': 231,
            './errors.js': 1,
            './helpers.js': 2,
            './notification': 4,
            './object-uploader': 5,
            './s3-endpoints.js': 6,
            './signing.js': 7,
            './transformers': 8,
            '_process': 141,
            'async': 24,
            'block-stream2': 26,
            'buffer': 59,
            'crypto': 68,
            'fs': 57,
            'http': 180,
            'https': 113,
            'lodash': 120,
            'mkdirp': 128,
            'path': 134,
            'querystring': 151,
            'stream': 179,
            'xml': 207,
            'xml2js': 205
        }],
        4: [function(require, module, exports) {
            (function(process) {
                /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

                'use strict';

                Object.defineProperty(exports, '__esModule', {
                    value: true
                });

                var _get = function get(_x, _x2, _x3) {
                    var _again = true;
                    _function: while (_again) {
                        var object = _x, property = _x2, receiver = _x3;
                        _again = false;
                        if (object === null) object = Function.prototype;
                        var desc = Object.getOwnPropertyDescriptor(object, property);
                        if (desc === undefined) {
                            var parent = Object.getPrototypeOf(object);
                            if (parent === null) {
                                return undefined;
                            } else {
                                _x = parent;
                                _x2 = property;
                                _x3 = receiver;
                                _again = true;
                                desc = parent = undefined;

                            }
                        } else if ('value' in desc) {
                            return desc.value;
                        } else {
                            var getter = desc.get;
                            if (getter === undefined) {
                                return undefined;
                            }
                            return getter.call(receiver);
                        }
                    }
                };

                var _createClass = (function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }

                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                })();

                function _interopRequireWildcard(obj) {
                    if (obj && obj.__esModule) {
                        return obj;
                    } else {
                        var newObj = {};
                        if (obj != null) {
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                            }
                        }
                        newObj['default'] = obj;
                        return newObj;
                    }
                }

                function _inherits(subClass, superClass) {
                    if (typeof superClass !== 'function' && superClass !== null) {
                        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError('Cannot call a class as a function');
                    }
                }

                var _events = require('events');

                var _transformers = require('./transformers');

                var transformers = _interopRequireWildcard(_transformers);

                var _helpers = require('./helpers');

// Notification config - array of target configs.
// Target configs can be
// 1. Topic (simple notification service)
// 2. Queue (simple queue service)
// 3. CloudFront (lambda function)

                var NotificationConfig = (function() {
                    function NotificationConfig() {
                        _classCallCheck(this, NotificationConfig);
                    }

                    // Base class for three supported configs.

                    _createClass(NotificationConfig, [{
                        key: 'add',
                        value: function add(target) {
                            var instance = '';
                            if (target instanceof TopicConfig) {
                                instance = 'TopicConfiguration';
                            }
                            if (target instanceof QueueConfig) {
                                instance = 'QueueConfiguration';
                            }
                            if (target instanceof CloudFunctionConfig) {
                                instance = 'CloudFunctionConfiguration';
                            }
                            if (!this[instance]) this[instance] = [];
                            this[instance].push(target);
                        }
                    }]);

                    return NotificationConfig;
                })();

                exports.NotificationConfig = NotificationConfig;

                var TargetConfig = (function() {
                    function TargetConfig() {
                        _classCallCheck(this, TargetConfig);
                    }

                    // 1. Topic (simple notification service)

                    _createClass(TargetConfig, [{
                        key: 'setId',
                        value: function setId(id) {
                            this.Id = id;
                        }
                    }, {
                        key: 'addEvent',
                        value: function addEvent(newevent) {
                            if (!this.Event) this.Event = [];
                            this.Event.push(newevent);
                        }
                    }, {
                        key: 'addFilterSuffix',
                        value: function addFilterSuffix(suffix) {
                            if (!this.Filter) this.Filter = { S3Key: { FilterRule: [] } };
                            this.Filter.S3Key.FilterRule.push({ Name: 'suffix', Value: suffix });
                        }
                    }, {
                        key: 'addFilterPrefix',
                        value: function addFilterPrefix(prefix) {
                            if (!this.Filter) this.Filter = { S3Key: { FilterRule: [] } };
                            this.Filter.S3Key.FilterRule.push({ Name: 'prefix', Value: prefix });
                        }
                    }]);

                    return TargetConfig;
                })();

                var TopicConfig = (function(_TargetConfig) {
                    _inherits(TopicConfig, _TargetConfig);

                    function TopicConfig(arn) {
                        _classCallCheck(this, TopicConfig);

                        _get(Object.getPrototypeOf(TopicConfig.prototype), 'constructor', this).call(this);
                        this.Topic = arn;
                    }

                    // 2. Queue (simple queue service)
                    return TopicConfig;
                })(TargetConfig);

                exports.TopicConfig = TopicConfig;

                var QueueConfig = (function(_TargetConfig2) {
                    _inherits(QueueConfig, _TargetConfig2);

                    function QueueConfig(arn) {
                        _classCallCheck(this, QueueConfig);

                        _get(Object.getPrototypeOf(QueueConfig.prototype), 'constructor', this).call(this);
                        this.Queue = arn;
                    }

                    // 3. CloudFront (lambda function)
                    return QueueConfig;
                })(TargetConfig);

                exports.QueueConfig = QueueConfig;

                var CloudFunctionConfig = (function(_TargetConfig3) {
                    _inherits(CloudFunctionConfig, _TargetConfig3);

                    function CloudFunctionConfig(arn) {
                        _classCallCheck(this, CloudFunctionConfig);

                        _get(Object.getPrototypeOf(CloudFunctionConfig.prototype), 'constructor', this).call(this);
                        this.CloudFunction = arn;
                    }

                    return CloudFunctionConfig;
                })(TargetConfig);

                exports.CloudFunctionConfig = CloudFunctionConfig;
                var buildARN = function buildARN(partition, service, region, accountId, resource) {
                    return 'arn:' + partition + ':' + service + ':' + region + ':' + accountId + ':' + resource;
                };

                exports.buildARN = buildARN;
                var ObjectCreatedAll = 's3:ObjectCreated:*';
                exports.ObjectCreatedAll = ObjectCreatedAll;
                var ObjectCreatedPut = 's3:ObjectCreated:Put';
                exports.ObjectCreatedPut = ObjectCreatedPut;
                var ObjectCreatedPost = 's3:ObjectCreated:Post';
                exports.ObjectCreatedPost = ObjectCreatedPost;
                var ObjectCreatedCopy = 's3:ObjectCreated:Copy';
                exports.ObjectCreatedCopy = ObjectCreatedCopy;
                var ObjectCreatedCompleteMultipartUpload = 'sh:ObjectCreated:CompleteMultipartUpload';
                exports.ObjectCreatedCompleteMultipartUpload = ObjectCreatedCompleteMultipartUpload;
                var ObjectRemovedAll = 's3:ObjectRemoved:*';
                exports.ObjectRemovedAll = ObjectRemovedAll;
                var ObjectRemovedDelete = 's3:ObjectRemoved:Delete';
                exports.ObjectRemovedDelete = ObjectRemovedDelete;
                var ObjectRemovedDeleteMarkerCreated = 's3:ObjectRemoved:DeleteMarkerCreated';
                exports.ObjectRemovedDeleteMarkerCreated = ObjectRemovedDeleteMarkerCreated;
                var ObjectReducedRedundancyLostObject = 's3:ReducedRedundancyLostObject';

                exports.ObjectReducedRedundancyLostObject = ObjectReducedRedundancyLostObject;
// Poll for notifications, used in #listenBucketNotification.
// Listening constitutes repeatedly requesting s3 whether or not any
// changes have occurred.

                var NotificationPoller = (function(_EventEmitter) {
                    _inherits(NotificationPoller, _EventEmitter);

                    function NotificationPoller(client, bucketName, prefix, suffix, events) {
                        _classCallCheck(this, NotificationPoller);

                        _get(Object.getPrototypeOf(NotificationPoller.prototype), 'constructor', this).call(this);

                        this.client = client;
                        this.bucketName = bucketName;
                        this.prefix = prefix;
                        this.suffix = suffix;
                        this.events = events;

                        this.ending = false;
                    }

                    // Starts the polling.

                    _createClass(NotificationPoller, [{
                        key: 'start',
                        value: function start() {
                            var _this = this;

                            this.ending = false;

                            process.nextTick(function() {
                                _this.checkForChanges();
                            });
                        }

                        // Stops the polling.
                    }, {
                        key: 'stop',
                        value: function stop() {
                            this.ending = true;
                        }
                    }, {
                        key: 'checkForChanges',
                        value: function checkForChanges() {
                            var _this2 = this;

                            // Don't continue if we're looping again but are cancelled.
                            if (this.ending) return;

                            var method = 'GET';
                            var queries = [];
                            if (this.prefix) {
                                var prefix = (0, _helpers.uriEscape)(this.prefix);
                                queries.push('prefix=' + prefix);
                            }
                            if (this.suffix) {
                                var suffix = (0, _helpers.uriEscape)(this.suffix);
                                queries.push('suffix=' + suffix);
                            }
                            if (this.events) {
                                this.events.forEach(function(s3event) {
                                    return queries.push('events=' + (0, _helpers.uriEscape)(s3event));
                                });
                            }
                            queries.sort();

                            var query = '';
                            if (queries.length > 0) {
                                query = '' + queries.join('&');
                            }
                            this.client.makeRequest({
                                method: method,
                                bucketName: this.bucketName,
                                query: query
                            }, '', 200, '', true, function(e, response) {
                                if (e) return _this2.emit('error', e);

                                var transformer = transformers.getNotificationTransformer();
                                (0, _helpers.pipesetup)(response, transformer).on('data', function(result) {
                                    // Data is flushed periodically (every 5 seconds), so we should
                                    // handle it after flushing from the JSON parser.
                                    var records = result.Records;
                                    // If null (= no records), change to an empty array.
                                    if (!records) records = [];

                                    // Iterate over the notifications and emit them individually.
                                    records.forEach(function(record) {
                                        _this2.emit('notification', record);
                                    });

                                    // If we're done, stop.
                                    if (_this2.ending) response.destroy();
                                }).on('error', function(e) {
                                    return _this2.emit('error', e);
                                }).on('end', function() {
                                    // Do it again, if we haven't cancelled yet.
                                    process.nextTick(function() {
                                        _this2.checkForChanges();
                                    });
                                });
                            });
                        }
                    }]);

                    return NotificationPoller;
                })(_events.EventEmitter);

                exports.NotificationPoller = NotificationPoller;


            }).call(this, require('_process'));
        }, { './helpers': 2, './transformers': 8, '_process': 141, 'events': 97 }],
        5: [function(require, module, exports) {
            (function(process) {
                /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

                'use strict';

                Object.defineProperty(exports, '__esModule', {
                    value: true
                });

                var _createClass = (function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ('value' in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }

                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                })();

                var _get = function get(_x, _x2, _x3) {
                    var _again = true;
                    _function: while (_again) {
                        var object = _x, property = _x2, receiver = _x3;
                        _again = false;
                        if (object === null) object = Function.prototype;
                        var desc = Object.getOwnPropertyDescriptor(object, property);
                        if (desc === undefined) {
                            var parent = Object.getPrototypeOf(object);
                            if (parent === null) {
                                return undefined;
                            } else {
                                _x = parent;
                                _x2 = property;
                                _x3 = receiver;
                                _again = true;
                                desc = parent = undefined;

                            }
                        } else if ('value' in desc) {
                            return desc.value;
                        } else {
                            var getter = desc.get;
                            if (getter === undefined) {
                                return undefined;
                            }
                            return getter.call(receiver);
                        }
                    }
                };

                function _interopRequireWildcard(obj) {
                    if (obj && obj.__esModule) {
                        return obj;
                    } else {
                        var newObj = {};
                        if (obj != null) {
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                            }
                        }
                        newObj['default'] = obj;
                        return newObj;
                    }
                }

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { 'default': obj };
                }

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError('Cannot call a class as a function');
                    }
                }

                function _inherits(subClass, superClass) {
                    if (typeof superClass !== 'function' && superClass !== null) {
                        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }

                var _stream = require('stream');

                var _crypto = require('crypto');

                var _crypto2 = _interopRequireDefault(_crypto);

                var _querystring = require('querystring');

                var querystring = _interopRequireWildcard(_querystring);

// We extend Transform because Writable does not implement ._flush().

                var ObjectUploader = (function(_Transform) {
                    _inherits(ObjectUploader, _Transform);

                    function ObjectUploader(client, bucketName, objectName, partSize, metaData, callback) {
                        _classCallCheck(this, ObjectUploader);

                        _get(Object.getPrototypeOf(ObjectUploader.prototype), 'constructor', this).call(this);
                        this.emptyStream = true;
                        this.client = client;
                        this.bucketName = bucketName;
                        this.objectName = objectName;
                        // The size of each multipart, chunked by BlockStream2.
                        this.partSize = partSize;
                        // This is the metadata for the object.
                        this.metaData = metaData;

                        // Call like: callback(error, etag).
                        this.callback = callback;

                        // We need to keep track of what number chunk/part we're on. This increments
                        // each time _write() is called. Starts with 1, not 0.
                        this.partNumber = 1;

                        // A list of the previously uploaded chunks, for resuming a file upload. This
                        // will be null if we aren't resuming an upload.
                        this.oldParts = null;

                        // Keep track of the etags for aggregating the chunks together later. Each
                        // etag represents a single chunk of the file.
                        this.etags = [];

                        // This is for the multipart upload request — if null, we're either not initiated
                        // yet or we're flushing in one packet.
                        this.id = null;

                        // Handle errors.
                        this.on('error', function(err) {
                            callback(err);
                        });
                    }

                    _createClass(ObjectUploader, [{
                        key: '_transform',
                        value: function _transform(chunk, encoding, callback) {
                            var _this = this;

                            this.emptyStream = false;
                            var method = 'PUT';
                            var headers = Object.assign({}, this.metaData, { 'Content-Length': chunk.length });
                            var md5digest = '';

                            // Calculate and set Content-MD5 header if SHA256 is not set.
                            // This will happen only when there is a secure connection to the s3 server.
                            if (!this.client.enableSHA256) {
                                md5digest = _crypto2['default'].createHash('md5').update(chunk).digest();
                                headers['Content-MD5'] = md5digest.toString('base64');
                            }
                            // We can flush the object in one packet if it fits in one chunk. This is true
                            // if the chunk size is smaller than the part size, signifying the end of the
                            // stream.
                            if (this.partNumber == 1 && chunk.length < this.partSize) {
                                // PUT the chunk in a single request — use an empty query.
                                var _options = {
                                    method: method, headers: headers,
                                    query: '',
                                    bucketName: this.bucketName,
                                    objectName: this.objectName
                                };

                                this.client.makeRequest(_options, chunk, 200, '', true, function(err, response) {
                                    if (err) return callback(err);

                                    var etag = response.headers.etag;
                                    if (etag) {
                                        etag = etag.replace(/^"/, '').replace(/"$/, '');
                                    }

                                    // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)
                                    response.on('data', function() {
                                    });

                                    // Give the etag back, we're done!

                                    process.nextTick(function() {
                                        _this.callback(null, etag);
                                    });

                                    // Because we're sure the stream has ended, allow it to flush and end.
                                    callback();
                                });

                                return;
                            }

                            // If we aren't flushing in one packet, we need to initiate the multipart upload,
                            // if it hasn't already been done. The write will be buffered until the upload has been
                            // initiated.
                            if (this.id === null) {
                                this.once('ready', function() {
                                    _this._transform(chunk, encoding, callback);
                                });

                                // Check for an incomplete previous upload.
                                this.client.findUploadId(this.bucketName, this.objectName, function(err, id) {
                                    if (err) return _this.emit('error', err);

                                    // If no upload ID exists, initiate a new one.
                                    if (!id) {
                                        _this.client.initiateNewMultipartUpload(_this.bucketName, _this.objectName, _this.metaData, function(err, id) {
                                            if (err) return callback(err);

                                            _this.id = id;

                                            // We are now ready to accept new chunks — this will flush the buffered chunk.
                                            _this.emit('ready');
                                        });

                                        return;
                                    }

                                    _this.id = id;

                                    // Retrieve the pre-uploaded parts, if we need to resume the upload.
                                    _this.client.listParts(_this.bucketName, _this.objectName, id, function(err, etags) {
                                        if (err) return _this.emit('error', err);

                                        // It is possible for no parts to be already uploaded.
                                        if (!etags) etags = [];

                                        // oldParts will become an object, allowing oldParts[partNumber].etag
                                        _this.oldParts = etags.reduce(function(prev, item) {
                                            if (!prev[item.part]) {
                                                prev[item.part] = item;
                                            }
                                            return prev;
                                        }, {});

                                        _this.emit('ready');
                                    });
                                });

                                return;
                            }

                            // Continue uploading various parts if we have initiated multipart upload.
                            var partNumber = this.partNumber++;

                            // Check to see if we've already uploaded this chunk. If the hash sums match,
                            // we can skip to the next chunk.
                            if (this.oldParts) {
                                var oldPart = this.oldParts[partNumber];

                                //Calulcate the md5 hash, if it has not already been calculated.
                                if (!md5digest) {
                                    md5digest = _crypto2['default'].createHash('md5').update(chunk).digest();
                                }

                                if (oldPart && md5digest.toString('hex') === oldPart.etag) {
                                    // The md5 matches, the chunk has already been uploaded.
                                    this.etags.push({ part: partNumber, etag: oldPart.etag });

                                    callback();
                                    return;
                                }
                            }

                            // Write the chunk with an uploader.
                            var query = querystring.stringify({
                                partNumber: partNumber,
                                uploadId: this.id
                            });

                            var options = {
                                method: method, query: query, headers: headers,
                                bucketName: this.bucketName,
                                objectName: this.objectName
                            };

                            this.client.makeRequest(options, chunk, 200, '', true, function(err, response) {
                                if (err) return callback(err);

                                // In order to aggregate the parts together, we need to collect the etags.
                                var etag = response.headers.etag;
                                if (etag) etag = etag.replace(/^"/, '').replace(/"$/, '');

                                _this.etags.push({ part: partNumber, etag: etag });

                                // We're ready for the next chunk.
                                callback();
                            });
                        }
                    }, {
                        key: '_flush',
                        value: function _flush(callback) {
                            var _this2 = this;

                            if (this.emptyStream) {
                                var method = 'PUT';
                                var headers = Object.assign({}, this.metaData, { 'Content-Length': 0 });
                                var options = {
                                    method: method, headers: headers,
                                    query: '',
                                    bucketName: this.bucketName,
                                    objectName: this.objectName
                                };

                                this.client.makeRequest(options, '', 200, '', true, function(err, response) {
                                    if (err) return callback(err);

                                    var etag = response.headers.etag;
                                    if (etag) {
                                        etag = etag.replace(/^"/, '').replace(/"$/, '');
                                    }

                                    // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)
                                    response.on('data', function() {
                                    });

                                    // Give the etag back, we're done!
                                    process.nextTick(function() {
                                        _this2.callback(null, etag);
                                    });

                                    // Because we're sure the stream has ended, allow it to flush and end.
                                    callback();
                                });

                                return;
                            }
                            // If it has been uploaded in a single packet, we don't have to do anything.
                            if (this.id === null) {
                                return;
                            }

                            // This is called when all of the chunks uploaded successfully, thus
                            // completing the multipart upload.
                            this.client.completeMultipartUpload(this.bucketName, this.objectName, this.id, this.etags, function(err, etag) {
                                if (err) return callback(err);

                                // Call our callback on the next tick to allow the streams infrastructure
                                // to finish what its doing before we continue.
                                process.nextTick(function() {
                                    _this2.callback(null, etag);
                                });

                                callback();
                            });
                        }
                    }]);

                    return ObjectUploader;
                })(_stream.Transform);

                exports['default'] = ObjectUploader;
                module.exports = exports['default'];


            }).call(this, require('_process'));
        }, { '_process': 141, 'crypto': 68, 'querystring': 151, 'stream': 179 }],
        6: [function(require, module, exports) {
            /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

            'use strict';

            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            exports.getS3Endpoint = getS3Endpoint;

            var _helpersJs = require('./helpers.js');

// List of currently supported endpoints.
            var awsS3Endpoint = {
                'us-east-1': 's3.amazonaws.com',
                'us-east-2': 's3-us-east-2.amazonaws.com',
                'us-west-1': 's3-us-west-1.amazonaws.com',
                'us-west-2': 's3-us-west-2.amazonaws.com',
                'ca-central-1': 's3.ca-central-1.amazonaws.com',
                'eu-west-1': 's3-eu-west-1.amazonaws.com',
                'eu-west-2': 's3-eu-west-2.amazonaws.com',
                'sa-east-1': 's3-sa-east-1.amazonaws.com',
                'eu-central-1': 's3-eu-central-1.amazonaws.com',
                'ap-south-1': 's3-ap-south-1.amazonaws.com',
                'ap-southeast-1': 's3-ap-southeast-1.amazonaws.com',
                'ap-southeast-2': 's3-ap-southeast-2.amazonaws.com',
                'ap-northeast-1': 's3-ap-northeast-1.amazonaws.com',
                'cn-north-1': 's3.cn-north-1.amazonaws.com.cn'
                // Add new endpoints here.
            };

// getS3Endpoint get relevant endpoint for the region.

            function getS3Endpoint(region) {
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('Invalid region: ' + region);
                }
                var endpoint = awsS3Endpoint[region];
                if (endpoint) {
                    return endpoint;
                }
                return 's3.amazonaws.com';
            }


        }, { './helpers.js': 2 }],
        7: [function(require, module, exports) {
            /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

            'use strict';

            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            exports.postPresignSignatureV4 = postPresignSignatureV4;
            exports.signV4 = signV4;
            exports.presignSignatureV4 = presignSignatureV4;

            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) {
                    return obj;
                } else {
                    var newObj = {};
                    if (obj != null) {
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                        }
                    }
                    newObj['default'] = obj;
                    return newObj;
                }
            }

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { 'default': obj };
            }

            var _crypto = require('crypto');

            var _crypto2 = _interopRequireDefault(_crypto);

            var _lodash = require('lodash');

            var _lodash2 = _interopRequireDefault(_lodash);

            var _helpersJs = require('./helpers.js');

            var _errorsJs = require('./errors.js');

            var errors = _interopRequireWildcard(_errorsJs);

            var signV4Algorithm = 'AWS4-HMAC-SHA256';

// getCanonicalRequest generate a canonical request of style.
//
// canonicalRequest =
//  <HTTPMethod>\n
//  <CanonicalURI>\n
//  <CanonicalQueryString>\n
//  <CanonicalHeaders>\n
//  <SignedHeaders>\n
//  <HashedPayload>
//
            function getCanonicalRequest(method, path, headers, signedHeaders, hashedPayload) {
                if (!(0, _helpersJs.isString)(method)) {
                    throw new TypeError('method should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(path)) {
                    throw new TypeError('path should be of type "string"');
                }
                if (!(0, _helpersJs.isObject)(headers)) {
                    throw new TypeError('headers should be of type "object"');
                }
                if (!(0, _helpersJs.isArray)(signedHeaders)) {
                    throw new TypeError('signedHeaders should be of type "array"');
                }
                if (!(0, _helpersJs.isString)(hashedPayload)) {
                    throw new TypeError('hashedPayload should be of type "string"');
                }
                var headersArray = signedHeaders.reduce(function(acc, i) {
                    acc.push(i.toLowerCase() + ':' + headers[i]);
                    return acc;
                }, []);

                var requestResource = path.split('?')[0];
                var requestQuery = path.split('?')[1];
                if (!requestQuery) requestQuery = '';

                if (requestQuery) {
                    requestQuery = requestQuery.split('&').sort().map(function(element) {
                        return element.indexOf('=') === -1 ? element + '=' : element;
                    }).join('&');
                }

                var canonical = [];
                canonical.push(method.toUpperCase());
                canonical.push(requestResource);
                canonical.push(requestQuery);
                canonical.push(headersArray.join('\n') + '\n');
                canonical.push(signedHeaders.join(';').toLowerCase());
                canonical.push(hashedPayload);
                return canonical.join('\n');
            }

// generate a credential string
            function getCredential(accessKey, region, requestDate) {
                if (!(0, _helpersJs.isString)(accessKey)) {
                    throw new TypeError('accessKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }
                if (!(0, _helpersJs.isObject)(requestDate)) {
                    throw new TypeError('requestDate should be of type "object"');
                }
                return accessKey + '/' + (0, _helpersJs.getScope)(region, requestDate);
            }

// Returns signed headers array - alphabetically sorted
            function getSignedHeaders(headers) {
                if (!(0, _helpersJs.isObject)(headers)) {
                    throw new TypeError('request should be of type "object"');
                }
                // Excerpts from @lsegal - https://github.com/aws/aws-sdk-js/issues/659#issuecomment-120477258
                //
                //  User-Agent:
                //
                //      This is ignored from signing because signing this causes problems with generating pre-signed URLs
                //      (that are executed by other agents) or when customers pass requests through proxies, which may
                //      modify the user-agent.
                //
                //  Content-Length:
                //
                //      This is ignored from signing because generating a pre-signed URL should not provide a content-length
                //      constraint, specifically when vending a S3 pre-signed PUT URL. The corollary to this is that when
                //      sending regular requests (non-pre-signed), the signature contains a checksum of the body, which
                //      implicitly validates the payload length (since changing the number of bytes would change the checksum)
                //      and therefore this header is not valuable in the signature.
                //
                //  Content-Type:
                //
                //      Signing this header causes quite a number of problems in browser environments, where browsers
                //      like to modify and normalize the content-type header in different ways. There is more information
                //      on this in https://github.com/aws/aws-sdk-js/issues/244. Avoiding this field simplifies logic
                //      and reduces the possibility of future bugs
                //
                //  Authorization:
                //
                //      Is skipped for obvious reasons

                var ignoredHeaders = ['authorization', 'content-length', 'content-type', 'user-agent'];
                return _lodash2['default'].map(headers, function(v, header) {
                    return header;
                }).filter(function(header) {
                    return ignoredHeaders.indexOf(header) === -1;
                }).sort();
            }

// returns the key used for calculating signature
            function getSigningKey(date, region, secretKey) {
                if (!(0, _helpersJs.isObject)(date)) {
                    throw new TypeError('date should be of type "object"');
                }
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(secretKey)) {
                    throw new TypeError('secretKey should be of type "string"');
                }
                var dateLine = (0, _helpersJs.makeDateShort)(date),
                    hmac1 = _crypto2['default'].createHmac('sha256', 'AWS4' + secretKey).update(dateLine).digest(),
                    hmac2 = _crypto2['default'].createHmac('sha256', hmac1).update(region).digest(),
                    hmac3 = _crypto2['default'].createHmac('sha256', hmac2).update('s3').digest();
                return _crypto2['default'].createHmac('sha256', hmac3).update('aws4_request').digest();
            }

// returns the string that needs to be signed
            function getStringToSign(canonicalRequest, requestDate, region) {
                if (!(0, _helpersJs.isString)(canonicalRequest)) {
                    throw new TypeError('canonicalRequest should be of type "string"');
                }
                if (!(0, _helpersJs.isObject)(requestDate)) {
                    throw new TypeError('requestDate should be of type "object"');
                }
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }
                var hash = _crypto2['default'].createHash('sha256').update(canonicalRequest).digest('hex');
                var scope = (0, _helpersJs.getScope)(region, requestDate);
                var stringToSign = [];
                stringToSign.push(signV4Algorithm);
                stringToSign.push((0, _helpersJs.makeDateLong)(requestDate));
                stringToSign.push(scope);
                stringToSign.push(hash);
                return stringToSign.join('\n');
            }

// calculate the signature of the POST policy

            function postPresignSignatureV4(region, date, secretKey, policyBase64) {
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }
                if (!(0, _helpersJs.isObject)(date)) {
                    throw new TypeError('date should be of type "object"');
                }
                if (!(0, _helpersJs.isString)(secretKey)) {
                    throw new TypeError('secretKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(policyBase64)) {
                    throw new TypeError('policyBase64 should be of type "string"');
                }
                var signingKey = getSigningKey(date, region, secretKey);
                return _crypto2['default'].createHmac('sha256', signingKey).update(policyBase64).digest('hex').toLowerCase();
            }

// Returns the authorization header

            function signV4(request, accessKey, secretKey, region, requestDate) {
                if (!(0, _helpersJs.isObject)(request)) {
                    throw new TypeError('request should be of type "object"');
                }
                if (!(0, _helpersJs.isString)(accessKey)) {
                    throw new TypeError('accessKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(secretKey)) {
                    throw new TypeError('secretKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }

                if (!accessKey) {
                    throw new errors.AccessKeyRequiredError('accessKey is required for signing');
                }
                if (!secretKey) {
                    throw new errors.SecretKeyRequiredError('secretKey is required for signing');
                }

                var sha256sum = request.headers['x-amz-content-sha256'];

                var signedHeaders = getSignedHeaders(request.headers);
                var canonicalRequest = getCanonicalRequest(request.method, request.path, request.headers, signedHeaders, sha256sum);
                var stringToSign = getStringToSign(canonicalRequest, requestDate, region);
                var signingKey = getSigningKey(requestDate, region, secretKey);
                var credential = getCredential(accessKey, region, requestDate);
                var signature = _crypto2['default'].createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();

                return signV4Algorithm + ' Credential=' + credential + ', SignedHeaders=' + signedHeaders.join(';').toLowerCase() + ', Signature=' + signature;
            }

// returns a presigned URL string

            function presignSignatureV4(request, accessKey, secretKey, region, requestDate, expires) {
                if (!(0, _helpersJs.isObject)(request)) {
                    throw new TypeError('request should be of type "object"');
                }
                if (!(0, _helpersJs.isString)(accessKey)) {
                    throw new TypeError('accessKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(secretKey)) {
                    throw new TypeError('secretKey should be of type "string"');
                }
                if (!(0, _helpersJs.isString)(region)) {
                    throw new TypeError('region should be of type "string"');
                }

                if (!accessKey) {
                    throw new errors.AccessKeyRequiredError('accessKey is required for presigning');
                }
                if (!secretKey) {
                    throw new errors.SecretKeyRequiredError('secretKey is required for presigning');
                }

                if (!(0, _helpersJs.isNumber)(expires)) {
                    throw new TypeError('expires should be of type "number"');
                }
                if (expires < 1) {
                    throw new errors.ExpiresParamError('expires param cannot be less than 1 seconds');
                }
                if (expires > 604800) {
                    throw new errors.ExpiresParamError('expires param cannot be greater than 7 days');
                }

                var iso8601Date = (0, _helpersJs.makeDateLong)(requestDate);
                var signedHeaders = getSignedHeaders(request.headers);
                var credential = getCredential(accessKey, region, requestDate);
                var hashedPayload = 'UNSIGNED-PAYLOAD';

                var requestQuery = [];
                requestQuery.push('X-Amz-Algorithm=' + signV4Algorithm);
                requestQuery.push('X-Amz-Credential=' + (0, _helpersJs.uriEscape)(credential));
                requestQuery.push('X-Amz-Date=' + iso8601Date);
                requestQuery.push('X-Amz-Expires=' + expires);
                requestQuery.push('X-Amz-SignedHeaders=' + (0, _helpersJs.uriEscape)(signedHeaders.join(';').toLowerCase()));

                var resource = request.path.split('?')[0];
                var query = request.path.split('?')[1];
                if (query) {
                    query = query + '&' + requestQuery.join('&');
                } else {
                    query = requestQuery.join('&');
                }

                var path = resource + '?' + query;

                var canonicalRequest = getCanonicalRequest(request.method, path, request.headers, signedHeaders, hashedPayload);

                var stringToSign = getStringToSign(canonicalRequest, requestDate, region);
                var signingKey = getSigningKey(requestDate, region, secretKey);
                var signature = _crypto2['default'].createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();
                var presignedUrl = request.protocol + '//' + request.headers.host + path + ('&X-Amz-Signature=' + signature);
                return presignedUrl;
            }


        }, { './errors.js': 1, './helpers.js': 2, 'crypto': 68, 'lodash': 120 }],
        8: [function(require, module, exports) {
            (function(Buffer) {
                /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

                'use strict';

                Object.defineProperty(exports, '__esModule', {
                    value: true
                });
                exports.getConcater = getConcater;
                exports.getErrorTransformer = getErrorTransformer;
                exports.getHashSummer = getHashSummer;
                exports.getCopyObjectTransformer = getCopyObjectTransformer;
                exports.getListBucketTransformer = getListBucketTransformer;
                exports.getListMultipartTransformer = getListMultipartTransformer;
                exports.getListPartsTransformer = getListPartsTransformer;
                exports.getInitiateMultipartTransformer = getInitiateMultipartTransformer;
                exports.getListObjectsTransformer = getListObjectsTransformer;
                exports.getListObjectsV2Transformer = getListObjectsV2Transformer;
                exports.getCompleteMultipartTransformer = getCompleteMultipartTransformer;
                exports.getBucketRegionTransformer = getBucketRegionTransformer;
                exports.getBucketNotificationTransformer = getBucketNotificationTransformer;
                exports.getNotificationTransformer = getNotificationTransformer;

                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { 'default': obj };
                }

                function _interopRequireWildcard(obj) {
                    if (obj && obj.__esModule) {
                        return obj;
                    } else {
                        var newObj = {};
                        if (obj != null) {
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                            }
                        }
                        newObj['default'] = obj;
                        return newObj;
                    }
                }

                var _xmlParsersJs = require('./xml-parsers.js');

                var xmlParsers = _interopRequireWildcard(_xmlParsersJs);

                var _lodash = require('lodash');

                var _ = _interopRequireWildcard(_lodash);

                var _through2 = require('through2');

                var _through22 = _interopRequireDefault(_through2);

                var _crypto = require('crypto');

                var _crypto2 = _interopRequireDefault(_crypto);

                var _jsonStream = require('json-stream');

                var _jsonStream2 = _interopRequireDefault(_jsonStream);

                var _helpersJs = require('./helpers.js');

                var _errorsJs = require('./errors.js');

                var errors = _interopRequireWildcard(_errorsJs);

// getConcater returns a stream that concatenates the input and emits
// the concatenated output when 'end' has reached. If an optional
// parser function is passed upon reaching the 'end' of the stream,
// `parser(concatenated_data)` will be emitted.

                function getConcater(parser, emitError) {
                    var objectMode = false;
                    var bufs = [];

                    if (parser && !(0, _helpersJs.isFunction)(parser)) {
                        throw new TypeError('parser should be of type "function"');
                    }

                    if (parser) {
                        objectMode = true;
                    }

                    return (0, _through22['default'])({ objectMode: objectMode }, function(chunk, enc, cb) {
                        bufs.push(chunk);
                        cb();
                    }, function(cb) {
                        if (emitError) {
                            cb(parser(Buffer.concat(bufs).toString()));
                            // cb(e) would mean we have to emit 'end' by explicitly calling this.push(null)
                            this.push(null);
                            return;
                        }
                        if (bufs.length) {
                            if (parser) {
                                this.push(parser(Buffer.concat(bufs).toString()));
                            } else {
                                this.push(Buffer.concat(bufs));
                            }
                        }
                        cb();
                    });
                }

// Generates an Error object depending on http statusCode and XML body

                function getErrorTransformer(response) {
                    var statusCode = response.statusCode;
                    var code, message;
                    if (statusCode === 301) {
                        code = 'MovedPermanently';
                        message = 'Moved Permanently';
                    } else if (statusCode === 307) {
                        code = 'TemporaryRedirect';
                        message = 'Are you using the correct endpoint URL?';
                    } else if (statusCode === 403) {
                        code = 'AccessDenied';
                        message = 'Valid and authorized credentials required';
                    } else if (statusCode === 404) {
                        code = 'NotFound';
                        message = 'Not Found';
                    } else if (statusCode === 405) {
                        code = 'MethodNotAllowed';
                        message = 'Method Not Allowed';
                    } else if (statusCode === 501) {
                        code = 'MethodNotAllowed';
                        message = 'Method Not Allowed';
                    } else {
                        code = 'UnknownError';
                        message = '' + statusCode;
                    }

                    var headerInfo = {};
                    // A value created by S3 compatible server that uniquely identifies
                    // the request.
                    headerInfo.amzRequestid = response.headersSent ? response.getHeader('x-amz-request-id') : null;
                    // A special token that helps troubleshoot API replies and issues.
                    headerInfo.amzId2 = response.headersSent ? response.getHeader('x-amz-id-2') : null;
                    // Region where the bucket is located. This header is returned only
                    // in HEAD bucket and ListObjects response.
                    headerInfo.amzBucketRegion = response.headersSent ? response.getHeader('x-amz-bucket-region') : null;

                    return getConcater(function(xmlString) {
                        var getError = function getError() {
                            // Message should be instantiated for each S3Errors.
                            var e = new errors.S3Error(message);
                            // S3 Error code.
                            e.code = code;
                            _.each(headerInfo, function(value, key) {
                                e[key] = value;
                            });
                            return e;
                        };
                        if (!xmlString) {
                            return getError();
                        }
                        var e = undefined;
                        try {
                            e = xmlParsers.parseError(xmlString, headerInfo);
                        } catch (ex) {
                            return getError();
                        }
                        return e;
                    }, true);
                }

// A through stream that calculates md5sum and sha256sum

                function getHashSummer(enableSHA256) {
                    var md5 = _crypto2['default'].createHash('md5');
                    var sha256 = _crypto2['default'].createHash('sha256');

                    return _through22['default'].obj(function(chunk, enc, cb) {

                        if (enableSHA256) {
                            sha256.update(chunk);
                        } else {
                            md5.update(chunk);
                        }
                        cb();
                    }, function(cb) {
                        var md5sum = '';
                        var sha256sum = '';
                        if (enableSHA256) {
                            sha256sum = sha256.digest('hex');
                        } else {
                            md5sum = md5.digest('base64');
                        }
                        var hashData = { md5sum: md5sum, sha256sum: sha256sum };
                        this.push(hashData);
                        this.push(null);
                        cb();
                    });
                }

// Following functions return a stream object that parses XML
// and emits suitable Javascript objects.

// Parses CopyObject response.

                function getCopyObjectTransformer() {
                    return getConcater(xmlParsers.parseCopyObject);
                }

// Parses listBuckets response.

                function getListBucketTransformer() {
                    return getConcater(xmlParsers.parseListBucket);
                }

// Parses listMultipartUploads response.

                function getListMultipartTransformer() {
                    return getConcater(xmlParsers.parseListMultipart);
                }

// Parses listParts response.

                function getListPartsTransformer() {
                    return getConcater(xmlParsers.parseListParts);
                }

// Parses initMultipartUpload response.

                function getInitiateMultipartTransformer() {
                    return getConcater(xmlParsers.parseInitiateMultipart);
                }

// Parses listObjects response.

                function getListObjectsTransformer() {
                    return getConcater(xmlParsers.parseListObjects);
                }

// Parses listObjects response.

                function getListObjectsV2Transformer() {
                    return getConcater(xmlParsers.parseListObjectsV2);
                }

// Parses completeMultipartUpload response.

                function getCompleteMultipartTransformer() {
                    return getConcater(xmlParsers.parseCompleteMultipart);
                }

// Parses getBucketLocation response.

                function getBucketRegionTransformer() {
                    return getConcater(xmlParsers.parseBucketRegion);
                }

// Parses GET/SET BucketNotification response

                function getBucketNotificationTransformer() {
                    return getConcater(xmlParsers.parseBucketNotification);
                }

// Parses a notification.

                function getNotificationTransformer() {
                    // This will parse and return each object.
                    return new _jsonStream2['default']();
                }


            }).call(this, require('buffer').Buffer);
        }, {
            './errors.js': 1,
            './helpers.js': 2,
            './xml-parsers.js': 9,
            'buffer': 59,
            'crypto': 68,
            'json-stream': 119,
            'lodash': 120,
            'through2': 191
        }],
        9: [function(require, module, exports) {
            /*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

            'use strict';

            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            exports.parseError = parseError;
            exports.parseCopyObject = parseCopyObject;
            exports.parseListMultipart = parseListMultipart;
            exports.parseListBucket = parseListBucket;
            exports.parseBucketNotification = parseBucketNotification;
            exports.parseBucketRegion = parseBucketRegion;
            exports.parseListParts = parseListParts;
            exports.parseInitiateMultipart = parseInitiateMultipart;
            exports.parseCompleteMultipart = parseCompleteMultipart;
            exports.parseListObjects = parseListObjects;
            exports.parseListObjectsV2 = parseListObjectsV2;

            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) {
                    return obj;
                } else {
                    var newObj = {};
                    if (obj != null) {
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                        }
                    }
                    newObj['default'] = obj;
                    return newObj;
                }
            }

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { 'default': obj };
            }

            var _xml2js = require('xml2js');

            var _xml2js2 = _interopRequireDefault(_xml2js);

            var _lodash = require('lodash');

            var _lodash2 = _interopRequireDefault(_lodash);

            var _errorsJs = require('./errors.js');

            var errors = _interopRequireWildcard(_errorsJs);

            var options = { // options passed to xml2js parser
                explicitRoot: false, // return the root node in the resulting object?
                ignoreAttrs: true
            };

// ignore attributes, only create text nodes
            var parseXml = function parseXml(xml) {
                var result = null;
                var error = null;

                var parser = new _xml2js2['default'].Parser(options);
                parser.parseString(xml, function(e, r) {
                    error = e;
                    result = r;
                });

                if (error) {
                    throw new Error('XML parse error');
                }
                return result;
            };

// Parse XML and return information as Javascript types

// parse error XML response

            function parseError(xml, headerInfo) {
                var xmlError = {};
                var xmlobj = parseXml(xml);
                var message;
                _lodash2['default'].each(xmlobj, function(n, key) {
                    if (key === 'Message') {
                        message = xmlobj[key][0];
                        return;
                    }
                    xmlError[key.toLowerCase()] = xmlobj[key][0];
                });
                var e = new errors.S3Error(message);
                _lodash2['default'].each(xmlError, function(value, key) {
                    e[key] = value;
                });
                _lodash2['default'].each(headerInfo, function(value, key) {
                    e[key] = value;
                });
                return e;
            }

// parse XML response for copy object

            function parseCopyObject(xml) {
                var result = {
                    etag: '',
                    lastModified: ''
                };
                var xmlobj = parseXml(xml);
                if (xmlobj.ETag) result.etag = xmlobj.ETag[0].replace(/^"/g, '').replace(/"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');
                if (xmlobj.LastModified) result.lastModified = new Date(xmlobj.LastModified[0]);

                return result;
            }

// parse XML response for listing in-progress multipart uploads

            function parseListMultipart(xml) {
                var result = {
                    uploads: [],
                    prefixes: [],
                    isTruncated: false
                };
                var xmlobj = parseXml(xml);
                if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;
                if (xmlobj.NextKeyMarker) result.nextKeyMarker = xmlobj.NextKeyMarker[0];
                if (xmlobj.NextUploadIdMarker) result.nextUploadIdMarker = xmlobj.NextUploadIdMarker[0];
                if (xmlobj.CommonPrefixes) xmlobj.CommonPrefixes.forEach(function(prefix) {
                    result.prefixes.push({ prefix: prefix[0] });
                });
                if (xmlobj.Upload) xmlobj.Upload.forEach(function(upload) {
                    result.uploads.push({
                        key: upload.Key[0],
                        uploadId: upload.UploadId[0],
                        initiated: new Date(upload.Initiated[0])
                    });
                });
                return result;
            }

// parse XML response to list all the owned buckets

            function parseListBucket(xml) {
                var result = [];
                var xmlobj = parseXml(xml);
                if (xmlobj.Buckets) {
                    if (xmlobj.Buckets[0].Bucket) {
                        xmlobj.Buckets[0].Bucket.forEach(function(bucket) {
                            var name = bucket.Name[0];
                            var creationDate = new Date(bucket.CreationDate[0]);
                            result.push({ name: name, creationDate: creationDate });
                        });
                    }
                }
                return result;
            }

// parse XML response for bucket notification

            function parseBucketNotification(xml) {
                var result = {
                    TopicConfiguration: [],
                    QueueConfiguration: [],
                    CloudFunctionConfiguration: []
                };
                // Parse the events list
                var genEvents = function genEvents(events) {
                    var result = [];
                    if (events) {
                        events.forEach(function(s3event) {
                            result.push(s3event);
                        });
                    }
                    return result;
                };
                // Parse all filter rules
                var genFilterRules = function genFilterRules(filters) {
                    var result = [];
                    if (filters && filters[0].S3Key && filters[0].S3Key[0].FilterRule) {
                        filters[0].S3Key[0].FilterRule.forEach(function(rule) {
                            var Name = rule.Name[0];
                            var Value = rule.Value[0];
                            result.push({ Name: Name, Value: Value });
                        });
                    }
                    return result;
                };

                var xmlobj = parseXml(xml);

                // Parse all topic configurations in the xml
                if (xmlobj.TopicConfiguration) {
                    xmlobj.TopicConfiguration.forEach(function(config) {
                        var Id = config.Id[0];
                        var Topic = config.Topic[0];
                        var Event = genEvents(config.Event);
                        var Filter = genFilterRules(config.Filter);
                        result.TopicConfiguration.push({ Id: Id, Topic: Topic, Event: Event, Filter: Filter });
                    });
                }
                // Parse all topic configurations in the xml
                if (xmlobj.QueueConfiguration) {
                    xmlobj.QueueConfiguration.forEach(function(config) {
                        var Id = config.Id[0];
                        var Queue = config.Queue[0];
                        var Event = genEvents(config.Event);
                        var Filter = genFilterRules(config.Filter);
                        result.QueueConfiguration.push({ Id: Id, Queue: Queue, Event: Event, Filter: Filter });
                    });
                }
                // Parse all QueueConfiguration arrays
                if (xmlobj.CloudFunctionConfiguration) {
                    xmlobj.CloudFunctionConfiguration.forEach(function(config) {
                        var Id = config.Id[0];
                        var CloudFunction = config.CloudFunction[0];
                        var Event = genEvents(config.Event);
                        var Filter = genFilterRules(config.Filter);
                        result.CloudFunctionConfiguration.push({
                            Id: Id,
                            CloudFunction: CloudFunction,
                            Event: Event,
                            Filter: Filter
                        });
                    });
                }

                return result;
            }

// parse XML response for bucket region

            function parseBucketRegion(xml) {
                return parseXml(xml);
            }

// parse XML response for list parts of an in progress multipart upload

            function parseListParts(xml) {
                var xmlobj = parseXml(xml);
                var result = {
                    isTruncated: false,
                    parts: [],
                    marker: undefined
                };
                if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;
                if (xmlobj.NextPartNumberMarker) result.marker = +xmlobj.NextPartNumberMarker[0];
                if (xmlobj.Part) {
                    xmlobj.Part.forEach(function(p) {
                        var part = +p.PartNumber[0];
                        var lastModified = new Date(p.LastModified[0]);
                        var etag = p.ETag[0].replace(/^"/g, '').replace(/"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');
                        result.parts.push({ part: part, lastModified: lastModified, etag: etag });
                    });
                }
                return result;
            }

// parse XML response when a new multipart upload is initiated

            function parseInitiateMultipart(xml) {
                var xmlobj = parseXml(xml);
                if (xmlobj.UploadId) return xmlobj.UploadId[0];
                throw new errors.InvalidXMLError('UploadId missing in XML');
            }

// parse XML response when a multipart upload is completed

            function parseCompleteMultipart(xml) {
                var xmlobj = parseXml(xml);
                if (xmlobj.Location) {
                    var location = xmlobj.Location[0];
                    var bucket = xmlobj.Bucket[0];
                    var key = xmlobj.Key[0];
                    var etag = xmlobj.ETag[0].replace(/^"/g, '').replace(/"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');

                    return { location: location, bucket: bucket, key: key, etag: etag };
                }
                // Complete Multipart can return XML Error after a 200 OK response
                if (xmlobj.Code && xmlobj.Message) {
                    var errCode = xmlobj.Code[0];
                    var errMessage = xmlobj.Message[0];
                    return { errCode: errCode, errMessage: errMessage };
                }
            }

// parse XML response for list objects in a bucket

            function parseListObjects(xml) {
                var result = {
                    objects: [],
                    isTruncated: false
                };
                var nextMarker;
                var xmlobj = parseXml(xml);
                if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;
                if (xmlobj.Contents) {
                    xmlobj.Contents.forEach(function(content) {
                        var name = content.Key[0];
                        var lastModified = new Date(content.LastModified[0]);
                        var etag = content.ETag[0].replace(/^"/g, '').replace(/"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');
                        var size = +content.Size[0];
                        result.objects.push({ name: name, lastModified: lastModified, etag: etag, size: size });
                        nextMarker = name;
                    });
                }
                if (xmlobj.CommonPrefixes) {
                    xmlobj.CommonPrefixes.forEach(function(commonPrefix) {
                        var prefix = commonPrefix.Prefix[0];
                        var size = 0;
                        result.objects.push({ prefix: prefix, size: size });
                    });
                }
                if (result.isTruncated) {
                    result.nextMarker = xmlobj.NextMarker ? xmlobj.NextMarker[0] : nextMarker;
                }
                return result;
            }

// parse XML response for list objects v2 in a bucket

            function parseListObjectsV2(xml) {
                var result = {
                    objects: [],
                    isTruncated: false
                };
                var xmlobj = parseXml(xml);
                if (xmlobj.IsTruncated && xmlobj.IsTruncated[0] === 'true') result.isTruncated = true;
                if (xmlobj.NextContinuationToken) result.nextContinuationToken = xmlobj.NextContinuationToken[0];

                if (xmlobj.Contents) {
                    xmlobj.Contents.forEach(function(content) {
                        var name = content.Key[0];
                        var lastModified = new Date(content.LastModified[0]);
                        var etag = content.ETag[0].replace(/^"/g, '').replace(/"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/^&#34;$/g, '');
                        var size = +content.Size[0];
                        result.objects.push({ name: name, lastModified: lastModified, etag: etag, size: size });
                    });
                }
                if (xmlobj.CommonPrefixes) {
                    xmlobj.CommonPrefixes.forEach(function(commonPrefix) {
                        var prefix = commonPrefix.Prefix[0];
                        var size = 0;
                        result.objects.push({ prefix: prefix, size: size });
                    });
                }
                return result;
            }


        }, { './errors.js': 1, 'lodash': 120, 'xml2js': 205 }],
        10: [function(require, module, exports) {
            var asn1 = exports;

            asn1.bignum = require('bn.js');

            asn1.define = require('./asn1/api').define;
            asn1.base = require('./asn1/base');
            asn1.constants = require('./asn1/constants');
            asn1.decoders = require('./asn1/decoders');
            asn1.encoders = require('./asn1/encoders');

        }, {
            './asn1/api': 11,
            './asn1/base': 13,
            './asn1/constants': 17,
            './asn1/decoders': 19,
            './asn1/encoders': 22,
            'bn.js': 27
        }],
        11: [function(require, module, exports) {
            var asn1 = require('../asn1');
            var inherits = require('inherits');

            var api = exports;

            api.define = function define(name, body) {
                return new Entity(name, body);
            };

            function Entity(name, body) {
                this.name = name;
                this.body = body;

                this.decoders = {};
                this.encoders = {};
            }

            Entity.prototype._createNamed = function createNamed(base) {
                var named;
                try {
                    named = require('vm').runInThisContext(
                        '(function ' + this.name + '(entity) {\n' +
                        '  this._initNamed(entity);\n' +
                        '})'
                    );
                } catch (e) {
                    named = function(entity) {
                        this._initNamed(entity);
                    };
                }
                inherits(named, base);
                named.prototype._initNamed = function initnamed(entity) {
                    base.call(this, entity);
                };

                return new named(this);
            };

            Entity.prototype._getDecoder = function _getDecoder(enc) {
                enc = enc || 'der';
                // Lazily create decoder
                if (!this.decoders.hasOwnProperty(enc))
                    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
                return this.decoders[enc];
            };

            Entity.prototype.decode = function decode(data, enc, options) {
                return this._getDecoder(enc).decode(data, options);
            };

            Entity.prototype._getEncoder = function _getEncoder(enc) {
                enc = enc || 'der';
                // Lazily create encoder
                if (!this.encoders.hasOwnProperty(enc))
                    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
                return this.encoders[enc];
            };

            Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
                return this._getEncoder(enc).encode(data, reporter);
            };

        }, { '../asn1': 10, 'inherits': 116, 'vm': 199 }],
        12: [function(require, module, exports) {
            var inherits = require('inherits');
            var Reporter = require('../base').Reporter;
            var Buffer = require('buffer').Buffer;

            function DecoderBuffer(base, options) {
                Reporter.call(this, options);
                if (!Buffer.isBuffer(base)) {
                    this.error('Input not Buffer');
                    return;
                }

                this.base = base;
                this.offset = 0;
                this.length = base.length;
            }

            inherits(DecoderBuffer, Reporter);
            exports.DecoderBuffer = DecoderBuffer;

            DecoderBuffer.prototype.save = function save() {
                return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
            };

            DecoderBuffer.prototype.restore = function restore(save) {
                // Return skipped data
                var res = new DecoderBuffer(this.base);
                res.offset = save.offset;
                res.length = this.offset;

                this.offset = save.offset;
                Reporter.prototype.restore.call(this, save.reporter);

                return res;
            };

            DecoderBuffer.prototype.isEmpty = function isEmpty() {
                return this.offset === this.length;
            };

            DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
                if (this.offset + 1 <= this.length)
                    return this.base.readUInt8(this.offset++, true);
                else
                    return this.error(fail || 'DecoderBuffer overrun');
            };

            DecoderBuffer.prototype.currentIndex = function skip(bytes, fail) {
                if (!(this.offset + bytes <= this.length))
                    return this.error(fail || 'DecoderBuffer overrun');

                var res = new DecoderBuffer(this.base);

                // Share reporter state
                res._reporterState = this._reporterState;

                res.offset = this.offset;
                res.length = this.offset + bytes;
                this.offset += bytes;
                return res;
            };

            DecoderBuffer.prototype.raw = function raw(save) {
                return this.base.slice(save ? save.offset : this.offset, this.length);
            };

            function EncoderBuffer(value, reporter) {
                if (Array.isArray(value)) {
                    this.length = 0;
                    this.value = value.map(function(item) {
                        if (!(item instanceof EncoderBuffer))
                            item = new EncoderBuffer(item, reporter);
                        this.length += item.length;
                        return item;
                    }, this);
                } else if (typeof value === 'number') {
                    if (!(0 <= value && value <= 0xff))
                        return reporter.error('non-byte EncoderBuffer value');
                    this.value = value;
                    this.length = 1;
                } else if (typeof value === 'string') {
                    this.value = value;
                    this.length = Buffer.byteLength(value);
                } else if (Buffer.isBuffer(value)) {
                    this.value = value;
                    this.length = value.length;
                } else {
                    return reporter.error('Unsupported type: ' + typeof value);
                }
            }

            exports.EncoderBuffer = EncoderBuffer;

            EncoderBuffer.prototype.join = function join(out, offset) {
                if (!out)
                    out = new Buffer(this.length);
                if (!offset)
                    offset = 0;

                if (this.length === 0)
                    return out;

                if (Array.isArray(this.value)) {
                    this.value.forEach(function(item) {
                        item.join(out, offset);
                        offset += item.length;
                    });
                } else {
                    if (typeof this.value === 'number')
                        out[offset] = this.value;
                    else if (typeof this.value === 'string')
                        out.write(this.value, offset);
                    else if (Buffer.isBuffer(this.value))
                        this.value.copy(out, offset);
                    offset += this.length;
                }

                return out;
            };

        }, { '../base': 13, 'buffer': 59, 'inherits': 116 }],
        13: [function(require, module, exports) {
            var base = exports;

            base.Reporter = require('./reporter').Reporter;
            base.DecoderBuffer = require('./buffer').DecoderBuffer;
            base.EncoderBuffer = require('./buffer').EncoderBuffer;
            base.Node = require('./node');

        }, { './buffer': 12, './node': 14, './reporter': 15 }],
        14: [function(require, module, exports) {
            var Reporter = require('../base').Reporter;
            var EncoderBuffer = require('../base').EncoderBuffer;
            var DecoderBuffer = require('../base').DecoderBuffer;
            var assert = require('minimalistic-assert');

// Supported tags
            var tags = [
                'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
                'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
                'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
                'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
            ];

// Public methods list
            var methods = [
                'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
                'any', 'contains'
            ].concat(tags);

// Overrided methods list
            var overrided = [
                '_peekTag', '_decodeTag', '_use',
                '_decodeStr', '_decodeObjid', '_decodeTime',
                '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

                '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
                '_encodeNull', '_encodeInt', '_encodeBool'
            ];

            function Node(enc, parent) {
                var state = {};
                this._baseState = state;

                state.enc = enc;

                state.parent = parent || null;
                state.children = null;

                // State
                state.tag = null;
                state.args = null;
                state.reverseArgs = null;
                state.choice = null;
                state.optional = false;
                state.any = false;
                state.obj = false;
                state.use = null;
                state.useDecoder = null;
                state.key = null;
                state['default'] = null;
                state.explicit = null;
                state.implicit = null;
                state.contains = null;

                // Should create new instance on each method
                if (!state.parent) {
                    state.children = [];
                    this._wrap();
                }
            }

            module.exports = Node;

            var stateProps = [
                'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
                'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
                'implicit', 'contains'
            ];

            Node.prototype.clone = function clone() {
                var state = this._baseState;
                var cstate = {};
                stateProps.forEach(function(prop) {
                    cstate[prop] = state[prop];
                });
                var res = new this.constructor(cstate.parent);
                res._baseState = cstate;
                return res;
            };

            Node.prototype._wrap = function wrap() {
                var state = this._baseState;
                methods.forEach(function(method) {
                    this[method] = function _wrappedMethod() {
                        var clone = new this.constructor(this);
                        state.children.push(clone);
                        return clone[method].apply(clone, arguments);
                    };
                }, this);
            };

            Node.prototype._init = function init(body) {
                var state = this._baseState;

                assert(state.parent === null);
                body.call(this);

                // Filter children
                state.children = state.children.filter(function(child) {
                    return child._baseState.parent === this;
                }, this);
                assert.equal(state.children.length, 1, 'Root node can have only one child');
            };

            Node.prototype._useArgs = function useArgs(args) {
                var state = this._baseState;

                // Filter children and args
                var children = args.filter(function(arg) {
                    return arg instanceof this.constructor;
                }, this);
                args = args.filter(function(arg) {
                    return !(arg instanceof this.constructor);
                }, this);

                if (children.length !== 0) {
                    assert(state.children === null);
                    state.children = children;

                    // Replace parent to maintain backward link
                    children.forEach(function(child) {
                        child._baseState.parent = this;
                    }, this);
                }
                if (args.length !== 0) {
                    assert(state.args === null);
                    state.args = args;
                    state.reverseArgs = args.map(function(arg) {
                        if (typeof arg !== 'object' || arg.constructor !== Object)
                            return arg;

                        var res = {};
                        Object.keys(arg).forEach(function(key) {
                            if (key == (key | 0))
                                key |= 0;
                            var value = arg[key];
                            res[value] = key;
                        });
                        return res;
                    });
                }
            };

//
// Overrided methods
//

            overrided.forEach(function(method) {
                Node.prototype[method] = function _overrided() {
                    var state = this._baseState;
                    throw new Error(method + ' not implemented for encoding: ' + state.enc);
                };
            });

//
// Public methods
//

            tags.forEach(function(tag) {
                Node.prototype[tag] = function _tagMethod() {
                    var state = this._baseState;
                    var args = Array.prototype.slice.call(arguments);

                    assert(state.tag === null);
                    state.tag = tag;

                    this._useArgs(args);

                    return this;
                };
            });

            Node.prototype.use = function use(item) {
                assert(item);
                var state = this._baseState;

                assert(state.use === null);
                state.use = item;

                return this;
            };

            Node.prototype.optional = function optional() {
                var state = this._baseState;

                state.optional = true;

                return this;
            };

            Node.prototype.def = function def(val) {
                var state = this._baseState;

                assert(state['default'] === null);
                state['default'] = val;
                state.optional = true;

                return this;
            };

            Node.prototype.explicit = function explicit(num) {
                var state = this._baseState;

                assert(state.explicit === null && state.implicit === null);
                state.explicit = num;

                return this;
            };

            Node.prototype.implicit = function implicit(num) {
                var state = this._baseState;

                assert(state.explicit === null && state.implicit === null);
                state.implicit = num;

                return this;
            };

            Node.prototype.obj = function obj() {
                var state = this._baseState;
                var args = Array.prototype.slice.call(arguments);

                state.obj = true;

                if (args.length !== 0)
                    this._useArgs(args);

                return this;
            };

            Node.prototype.key = function key(newKey) {
                var state = this._baseState;

                assert(state.key === null);
                state.key = newKey;

                return this;
            };

            Node.prototype.any = function any() {
                var state = this._baseState;

                state.any = true;

                return this;
            };

            Node.prototype.choice = function choice(obj) {
                var state = this._baseState;

                assert(state.choice === null);
                state.choice = obj;
                this._useArgs(Object.keys(obj).map(function(key) {
                    return obj[key];
                }));

                return this;
            };

            Node.prototype.contains = function contains(item) {
                var state = this._baseState;

                assert(state.use === null);
                state.contains = item;

                return this;
            };

//
// Decoding
//

            Node.prototype._decode = function decode(input, options) {
                var state = this._baseState;

                // Decode root node
                if (state.parent === null)
                    return input.wrapResult(state.children[0]._decode(input, options));

                var result = state['default'];
                var present = true;

                var prevKey = null;
                if (state.key !== null)
                    prevKey = input.enterKey(state.key);

                // Check if tag is there
                if (state.optional) {
                    var tag = null;
                    if (state.explicit !== null)
                        tag = state.explicit;
                    else if (state.implicit !== null)
                        tag = state.implicit;
                    else if (state.tag !== null)
                        tag = state.tag;

                    if (tag === null && !state.any) {
                        // Trial and Error
                        var save = input.save();
                        try {
                            if (state.choice === null)
                                this._decodeGeneric(state.tag, input, options);
                            else
                                this._decodeChoice(input, options);
                            present = true;
                        } catch (e) {
                            present = false;
                        }
                        input.restore(save);
                    } else {
                        present = this._peekTag(input, tag, state.any);

                        if (input.isError(present))
                            return present;
                    }
                }

                // Push object on stack
                var prevObj;
                if (state.obj && present)
                    prevObj = input.enterObject();

                if (present) {
                    // Unwrap explicit values
                    if (state.explicit !== null) {
                        var explicit = this._decodeTag(input, state.explicit);
                        if (input.isError(explicit))
                            return explicit;
                        input = explicit;
                    }

                    var start = input.offset;

                    // Unwrap implicit and normal values
                    if (state.use === null && state.choice === null) {
                        if (state.any)
                            var save = input.save();
                        var body = this._decodeTag(
                            input,
                            state.implicit !== null ? state.implicit : state.tag,
                            state.any
                        );
                        if (input.isError(body))
                            return body;

                        if (state.any)
                            result = input.raw(save);
                        else
                            input = body;
                    }

                    if (options && options.track && state.tag !== null)
                        options.track(input.path(), start, input.length, 'tagged');

                    if (options && options.track && state.tag !== null)
                        options.track(input.path(), input.offset, input.length, 'content');

                    // Select proper method for tag
                    if (state.any)
                        result = result;
                    else if (state.choice === null)
                        result = this._decodeGeneric(state.tag, input, options);
                    else
                        result = this._decodeChoice(input, options);

                    if (input.isError(result))
                        return result;

                    // Decode children
                    if (!state.any && state.choice === null && state.children !== null) {
                        state.children.forEach(function decodeChildren(child) {
                            // NOTE: We are ignoring errors here, to let parser continue with other
                            // parts of encoded data
                            child._decode(input, options);
                        });
                    }

                    // Decode contained/encoded by schema, only in bit or octet strings
                    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
                        var data = new DecoderBuffer(result);
                        result = this._getUse(state.contains, input._reporterState.obj)
                            ._decode(data, options);
                    }
                }

                // Pop object
                if (state.obj && present)
                    result = input.leaveObject(prevObj);

                // Set key
                if (state.key !== null && (result !== null || present === true))
                    input.leaveKey(prevKey, state.key, result);
                else if (prevKey !== null)
                    input.exitKey(prevKey);

                return result;
            };

            Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
                var state = this._baseState;

                if (tag === 'seq' || tag === 'set')
                    return null;
                if (tag === 'seqof' || tag === 'setof')
                    return this._decodeList(input, tag, state.args[0], options);
                else if (/str$/.test(tag))
                    return this._decodeStr(input, tag, options);
                else if (tag === 'objid' && state.args)
                    return this._decodeObjid(input, state.args[0], state.args[1], options);
                else if (tag === 'objid')
                    return this._decodeObjid(input, null, null, options);
                else if (tag === 'gentime' || tag === 'utctime')
                    return this._decodeTime(input, tag, options);
                else if (tag === 'null_')
                    return this._decodeNull(input, options);
                else if (tag === 'bool')
                    return this._decodeBool(input, options);
                else if (tag === 'objDesc')
                    return this._decodeStr(input, tag, options);
                else if (tag === 'int' || tag === 'enum')
                    return this._decodeInt(input, state.args && state.args[0], options);

                if (state.use !== null) {
                    return this._getUse(state.use, input._reporterState.obj)
                        ._decode(input, options);
                } else {
                    return input.error('unknown tag: ' + tag);
                }
            };

            Node.prototype._getUse = function _getUse(entity, obj) {

                var state = this._baseState;
                // Create altered use decoder if implicit is set
                state.useDecoder = this._use(entity, obj);
                assert(state.useDecoder._baseState.parent === null);
                state.useDecoder = state.useDecoder._baseState.children[0];
                if (state.implicit !== state.useDecoder._baseState.implicit) {
                    state.useDecoder = state.useDecoder.clone();
                    state.useDecoder._baseState.implicit = state.implicit;
                }
                return state.useDecoder;
            };

            Node.prototype._decodeChoice = function decodeChoice(input, options) {
                var state = this._baseState;
                var result = null;
                var match = false;

                Object.keys(state.choice).some(function(key) {
                    var save = input.save();
                    var node = state.choice[key];
                    try {
                        var value = node._decode(input, options);
                        if (input.isError(value))
                            return false;

                        result = { type: key, value: value };
                        match = true;
                    } catch (e) {
                        input.restore(save);
                        return false;
                    }
                    return true;
                }, this);

                if (!match)
                    return input.error('Choice not matched');

                return result;
            };

//
// Encoding
//

            Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
                return new EncoderBuffer(data, this.reporter);
            };

            Node.prototype._encode = function encode(data, reporter, parent) {
                var state = this._baseState;
                if (state['default'] !== null && state['default'] === data)
                    return;

                var result = this._encodeValue(data, reporter, parent);
                if (result === undefined)
                    return;

                if (this._skipDefault(result, reporter, parent))
                    return;

                return result;
            };

            Node.prototype._encodeValue = function encode(data, reporter, parent) {
                var state = this._baseState;

                // Decode root node
                if (state.parent === null)
                    return state.children[0]._encode(data, reporter || new Reporter());

                var result = null;

                // Set reporter to share it with a child class
                this.reporter = reporter;

                // Check if data is there
                if (state.optional && data === undefined) {
                    if (state['default'] !== null)
                        data = state['default'];
                    else
                        return;
                }

                // Encode children first
                var content = null;
                var primitive = false;
                if (state.any) {
                    // Anything that was given is translated to buffer
                    result = this._createEncoderBuffer(data);
                } else if (state.choice) {
                    result = this._encodeChoice(data, reporter);
                } else if (state.contains) {
                    content = this._getUse(state.contains, parent)._encode(data, reporter);
                    primitive = true;
                } else if (state.children) {
                    content = state.children.map(function(child) {
                        if (child._baseState.tag === 'null_')
                            return child._encode(null, reporter, data);

                        if (child._baseState.key === null)
                            return reporter.error('Child should have a key');
                        var prevKey = reporter.enterKey(child._baseState.key);

                        if (typeof data !== 'object')
                            return reporter.error('Child expected, but input is not object');

                        var res = child._encode(data[child._baseState.key], reporter, data);
                        reporter.leaveKey(prevKey);

                        return res;
                    }, this).filter(function(child) {
                        return child;
                    });
                    content = this._createEncoderBuffer(content);
                } else {
                    if (state.tag === 'seqof' || state.tag === 'setof') {
                        // TODO(indutny): this should be thrown on DSL level
                        if (!(state.args && state.args.length === 1))
                            return reporter.error('Too many args for : ' + state.tag);

                        if (!Array.isArray(data))
                            return reporter.error('seqof/setof, but data is not Array');

                        var child = this.clone();
                        child._baseState.implicit = null;
                        content = this._createEncoderBuffer(data.map(function(item) {
                            var state = this._baseState;

                            return this._getUse(state.args[0], data)._encode(item, reporter);
                        }, child));
                    } else if (state.use !== null) {
                        result = this._getUse(state.use, parent)._encode(data, reporter);
                    } else {
                        content = this._encodePrimitive(state.tag, data);
                        primitive = true;
                    }
                }

                // Encode data itself
                var result;
                if (!state.any && state.choice === null) {
                    var tag = state.implicit !== null ? state.implicit : state.tag;
                    var cls = state.implicit === null ? 'universal' : 'context';

                    if (tag === null) {
                        if (state.use === null)
                            reporter.error('Tag could be omitted only for .use()');
                    } else {
                        if (state.use === null)
                            result = this._encodeComposite(tag, primitive, cls, content);
                    }
                }

                // Wrap in explicit
                if (state.explicit !== null)
                    result = this._encodeComposite(state.explicit, false, 'context', result);

                return result;
            };

            Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
                var state = this._baseState;

                var node = state.choice[data.type];
                if (!node) {
                    assert(
                        false,
                        data.type + ' not found in ' +
                        JSON.stringify(Object.keys(state.choice)));
                }
                return node._encode(data.value, reporter);
            };

            Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
                var state = this._baseState;

                if (/str$/.test(tag))
                    return this._encodeStr(data, tag);
                else if (tag === 'objid' && state.args)
                    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
                else if (tag === 'objid')
                    return this._encodeObjid(data, null, null);
                else if (tag === 'gentime' || tag === 'utctime')
                    return this._encodeTime(data, tag);
                else if (tag === 'null_')
                    return this._encodeNull();
                else if (tag === 'int' || tag === 'enum')
                    return this._encodeInt(data, state.args && state.reverseArgs[0]);
                else if (tag === 'bool')
                    return this._encodeBool(data);
                else if (tag === 'objDesc')
                    return this._encodeStr(data, tag);
                else
                    throw new Error('Unsupported tag: ' + tag);
            };

            Node.prototype._isNumstr = function isNumstr(str) {
                return /^[0-9 ]*$/.test(str);
            };

            Node.prototype._isPrintstr = function isPrintstr(str) {
                return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
            };

        }, { '../base': 13, 'minimalistic-assert': 126 }],
        15: [function(require, module, exports) {
            var inherits = require('inherits');

            function Reporter(options) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options || {},
                    errors: []
                };
            }

            exports.Reporter = Reporter;

            Reporter.prototype.isError = function isError(obj) {
                return obj instanceof ReporterError;
            };

            Reporter.prototype.save = function save() {
                var state = this._reporterState;

                return { obj: state.obj, pathLen: state.path.length };
            };

            Reporter.prototype.restore = function restore(data) {
                var state = this._reporterState;

                state.obj = data.obj;
                state.path = state.path.slice(0, data.pathLen);
            };

            Reporter.prototype.enterKey = function enterKey(key) {
                return this._reporterState.path.push(key);
            };

            Reporter.prototype.exitKey = function exitKey(index) {
                var state = this._reporterState;

                state.path = state.path.slice(0, index - 1);
            };

            Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
                var state = this._reporterState;

                this.exitKey(index);
                if (state.obj !== null)
                    state.obj[key] = value;
            };

            Reporter.prototype.path = function path() {
                return this._reporterState.path.join('/');
            };

            Reporter.prototype.enterObject = function enterObject() {
                var state = this._reporterState;

                var prev = state.obj;
                state.obj = {};
                return prev;
            };

            Reporter.prototype.leaveObject = function leaveObject(prev) {
                var state = this._reporterState;

                var now = state.obj;
                state.obj = prev;
                return now;
            };

            Reporter.prototype.error = function error(msg) {
                var err;
                var state = this._reporterState;

                var inherited = msg instanceof ReporterError;
                if (inherited) {
                    err = msg;
                } else {
                    err = new ReporterError(state.path.map(function(elem) {
                        return '[' + JSON.stringify(elem) + ']';
                    }).join(''), msg.message || msg, msg.stack);
                }

                if (!state.options.partial)
                    throw err;

                if (!inherited)
                    state.errors.push(err);

                return err;
            };

            Reporter.prototype.wrapResult = function wrapResult(result) {
                var state = this._reporterState;
                if (!state.options.partial)
                    return result;

                return {
                    result: this.isError(result) ? null : result,
                    errors: state.errors
                };
            };

            function ReporterError(path, msg) {
                this.path = path;
                this.rethrow(msg);
            }
            inherits(ReporterError, Error);

            ReporterError.prototype.rethrow = function rethrow(msg) {
                this.message = msg + ' at: ' + (this.path || '(shallow)');
                if (Error.captureStackTrace)
                    Error.captureStackTrace(this, ReporterError);

                if (!this.stack) {
                    try {
                        // IE only adds stack when thrown
                        throw new Error(this.message);
                    } catch (e) {
                        this.stack = e.stack;
                    }
                }
                return this;
            };

        }, { 'inherits': 116 }],
        16: [function(require, module, exports) {
            var constants = require('../constants');

            exports.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            };
            exports.tagClassByName = constants._reverse(exports.tagClass);

            exports.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            };
            exports.tagByName = constants._reverse(exports.tag);

        }, { '../constants': 17 }],
        17: [function(require, module, exports) {
            var constants = exports;

// Helper
            constants._reverse = function reverse(map) {
                var res = {};

                Object.keys(map).forEach(function(key) {
                    // Convert key to integer if it is stringified
                    if ((key | 0) == key)
                        key = key | 0;

                    var value = map[key];
                    res[value] = key;
                });

                return res;
            };

            constants.der = require('./der');

        }, { './der': 16 }],
        18: [function(require, module, exports) {
            var inherits = require('inherits');

            var asn1 = require('../../asn1');
            var base = asn1.base;
            var bignum = asn1.bignum;

// Import DER constants
            var der = asn1.constants.der;

            function DERDecoder(entity) {
                this.enc = 'der';
                this.name = entity.name;
                this.entity = entity;

                // Construct base tree
                this.tree = new DERNode();
                this.tree._init(entity.body);
            }
            module.exports = DERDecoder;

            DERDecoder.prototype.decode = function decode(data, options) {
                if (!(data instanceof base.DecoderBuffer))
                    data = new base.DecoderBuffer(data, options);

                return this.tree._decode(data, options);
            };

// Tree methods

            function DERNode(parent) {
                base.Node.call(this, 'der', parent);
            }

            inherits(DERNode, base.Node);

            DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
                if (buffer.isEmpty())
                    return false;

                var state = buffer.save();
                var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
                if (buffer.isError(decodedTag))
                    return decodedTag;

                buffer.restore(state);

                return decodedTag.tag === tag || decodedTag.tagStr === tag ||
                    (decodedTag.tagStr + 'of') === tag || any;
            };

            DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
                var decodedTag = derDecodeTag(buffer,
                    'Failed to decode tag of "' + tag + '"');
                if (buffer.isError(decodedTag))
                    return decodedTag;

                var len = derDecodeLen(buffer,
                    decodedTag.primitive,
                    'Failed to get length of "' + tag + '"');

                // Failure
                if (buffer.isError(len))
                    return len;

                if (!any &&
                    decodedTag.tag !== tag &&
                    decodedTag.tagStr !== tag &&
                    decodedTag.tagStr + 'of' !== tag) {
                    return buffer.error('Failed to match tag: "' + tag + '"');
                }

                if (decodedTag.primitive || len !== null)
                    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

                // Indefinite length... find END tag
                var state = buffer.save();
                var res = this._skipUntilEnd(
                    buffer,
                    'Failed to skip indefinite length body: "' + this.tag + '"');
                if (buffer.isError(res))
                    return res;

                len = buffer.offset - state.offset;
                buffer.restore(state);
                return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
            };

            DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
                while (true) {
                    var tag = derDecodeTag(buffer, fail);
                    if (buffer.isError(tag))
                        return tag;
                    var len = derDecodeLen(buffer, tag.primitive, fail);
                    if (buffer.isError(len))
                        return len;

                    var res;
                    if (tag.primitive || len !== null)
                        res = buffer.skip(len);
                    else
                        res = this._skipUntilEnd(buffer, fail);

                    // Failure
                    if (buffer.isError(res))
                        return res;

                    if (tag.tagStr === 'end')
                        break;
                }
            };

            DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                                options) {
                var result = [];
                while (!buffer.isEmpty()) {
                    var possibleEnd = this._peekTag(buffer, 'end');
                    if (buffer.isError(possibleEnd))
                        return possibleEnd;

                    var res = decoder.decode(buffer, 'der', options);
                    if (buffer.isError(res) && possibleEnd)
                        break;
                    result.push(res);
                }
                return result;
            };

            DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
                if (tag === 'bitstr') {
                    var unused = buffer.readUInt8();
                    if (buffer.isError(unused))
                        return unused;
                    return { unused: unused, data: buffer.raw() };
                } else if (tag === 'bmpstr') {
                    var raw = buffer.raw();
                    if (raw.length % 2 === 1)
                        return buffer.error('Decoding of string type: bmpstr length mismatch');

                    var str = '';
                    for (var i = 0; i < raw.length / 2; i++) {
                        str += String.fromCharCode(raw.readUInt16BE(i * 2));
                    }
                    return str;
                } else if (tag === 'numstr') {
                    var numstr = buffer.raw().toString('ascii');
                    if (!this._isNumstr(numstr)) {
                        return buffer.error('Decoding of string type: ' +
                            'numstr unsupported characters');
                    }
                    return numstr;
                } else if (tag === 'octstr') {
                    return buffer.raw();
                } else if (tag === 'objDesc') {
                    return buffer.raw();
                } else if (tag === 'printstr') {
                    var printstr = buffer.raw().toString('ascii');
                    if (!this._isPrintstr(printstr)) {
                        return buffer.error('Decoding of string type: ' +
                            'printstr unsupported characters');
                    }
                    return printstr;
                } else if (/str$/.test(tag)) {
                    return buffer.raw().toString();
                } else {
                    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
                }
            };

            DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
                var result;
                var identifiers = [];
                var ident = 0;
                while (!buffer.isEmpty()) {
                    var subident = buffer.readUInt8();
                    ident <<= 7;
                    ident |= subident & 0x7f;
                    if ((subident & 0x80) === 0) {
                        identifiers.push(ident);
                        ident = 0;
                    }
                }
                if (subident & 0x80)
                    identifiers.push(ident);

                var first = (identifiers[0] / 40) | 0;
                var second = identifiers[0] % 40;

                if (relative)
                    result = identifiers;
                else
                    result = [first, second].concat(identifiers.slice(1));

                if (values) {
                    var tmp = values[result.join(' ')];
                    if (tmp === undefined)
                        tmp = values[result.join('.')];
                    if (tmp !== undefined)
                        result = tmp;
                }

                return result;
            };

            DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
                var str = buffer.raw().toString();
                if (tag === 'gentime') {
                    var year = str.slice(0, 4) | 0;
                    var mon = str.slice(4, 6) | 0;
                    var day = str.slice(6, 8) | 0;
                    var hour = str.slice(8, 10) | 0;
                    var min = str.slice(10, 12) | 0;
                    var sec = str.slice(12, 14) | 0;
                } else if (tag === 'utctime') {
                    var year = str.slice(0, 2) | 0;
                    var mon = str.slice(2, 4) | 0;
                    var day = str.slice(4, 6) | 0;
                    var hour = str.slice(6, 8) | 0;
                    var min = str.slice(8, 10) | 0;
                    var sec = str.slice(10, 12) | 0;
                    if (year < 70)
                        year = 2000 + year;
                    else
                        year = 1900 + year;
                } else {
                    return buffer.error('Decoding ' + tag + ' time is not supported yet');
                }

                return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
            };

            DERNode.prototype._decodeNull = function decodeNull(buffer) {
                return null;
            };

            DERNode.prototype._decodeBool = function decodeBool(buffer) {
                var res = buffer.readUInt8();
                if (buffer.isError(res))
                    return res;
                else
                    return res !== 0;
            };

            DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
                // Bigint, return as it is (assume big endian)
                var raw = buffer.raw();
                var res = new bignum(raw);

                if (values)
                    res = values[res.toString(10)] || res;

                return res;
            };

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function')
                    entity = entity(obj);
                return entity._getDecoder('der').tree;
            };

// Utility methods

            function derDecodeTag(buf, fail) {
                var tag = buf.readUInt8(fail);
                if (buf.isError(tag))
                    return tag;

                var cls = der.tagClass[tag >> 6];
                var primitive = (tag & 0x20) === 0;

                // Multi-octet tag - load
                if ((tag & 0x1f) === 0x1f) {
                    var oct = tag;
                    tag = 0;
                    while ((oct & 0x80) === 0x80) {
                        oct = buf.readUInt8(fail);
                        if (buf.isError(oct))
                            return oct;

                        tag <<= 7;
                        tag |= oct & 0x7f;
                    }
                } else {
                    tag &= 0x1f;
                }
                var tagStr = der.tag[tag];

                return {
                    cls: cls,
                    primitive: primitive,
                    tag: tag,
                    tagStr: tagStr
                };
            }

            function derDecodeLen(buf, primitive, fail) {
                var len = buf.readUInt8(fail);
                if (buf.isError(len))
                    return len;

                // Indefinite form
                if (!primitive && len === 0x80)
                    return null;

                // Definite form
                if ((len & 0x80) === 0) {
                    // Short form
                    return len;
                }

                // Long form
                var num = len & 0x7f;
                if (num > 4)
                    return buf.error('length octect is too long');

                len = 0;
                for (var i = 0; i < num; i++) {
                    len <<= 8;
                    var j = buf.readUInt8(fail);
                    if (buf.isError(j))
                        return j;
                    len |= j;
                }

                return len;
            }

        }, { '../../asn1': 10, 'inherits': 116 }],
        19: [function(require, module, exports) {
            var decoders = exports;

            decoders.der = require('./der');
            decoders.pem = require('./pem');

        }, { './der': 18, './pem': 20 }],
        20: [function(require, module, exports) {
            var inherits = require('inherits');
            var Buffer = require('buffer').Buffer;

            var DERDecoder = require('./der');

            function PEMDecoder(entity) {
                DERDecoder.call(this, entity);
                this.enc = 'pem';
            }
            inherits(PEMDecoder, DERDecoder);
            module.exports = PEMDecoder;

            PEMDecoder.prototype.decode = function decode(data, options) {
                var lines = data.toString().split(/[\r\n]+/g);

                var label = options.label.toUpperCase();

                var re = /^-----(BEGIN|END) ([^-]+)-----$/;
                var start = -1;
                var end = -1;
                for (var i = 0; i < lines.length; i++) {
                    var match = lines[i].match(re);
                    if (match === null)
                        continue;

                    if (match[2] !== label)
                        continue;

                    if (start === -1) {
                        if (match[1] !== 'BEGIN')
                            break;
                        start = i;
                    } else {
                        if (match[1] !== 'END')
                            break;
                        end = i;
                        break;
                    }
                }
                if (start === -1 || end === -1)
                    throw new Error('PEM section not found for: ' + label);

                var base64 = lines.slice(start + 1, end).join('');
                // Remove excessive symbols
                base64.replace(/[^a-z0-9\+\/=]+/gi, '');

                var input = new Buffer(base64, 'base64');
                return DERDecoder.prototype.decode.call(this, input, options);
            };

        }, { './der': 18, 'buffer': 59, 'inherits': 116 }],
        21: [function(require, module, exports) {
            var inherits = require('inherits');
            var Buffer = require('buffer').Buffer;

            var asn1 = require('../../asn1');
            var base = asn1.base;

// Import DER constants
            var der = asn1.constants.der;

            function DEREncoder(entity) {
                this.enc = 'der';
                this.name = entity.name;
                this.entity = entity;

                // Construct base tree
                this.tree = new DERNode();
                this.tree._init(entity.body);
            }
            module.exports = DEREncoder;

            DEREncoder.prototype.encode = function encode(data, reporter) {
                return this.tree._encode(data, reporter).join();
            };

// Tree methods

            function DERNode(parent) {
                base.Node.call(this, 'der', parent);
            }

            inherits(DERNode, base.Node);

            DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                                          primitive,
                                                                          cls,
                                                                          content) {
                var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

                // Short form
                if (content.length < 0x80) {
                    var header = new Buffer(2);
                    header[0] = encodedTag;
                    header[1] = content.length;
                    return this._createEncoderBuffer([header, content]);
                }

                // Long form
                // Count octets required to store length
                var lenOctets = 1;
                for (var i = content.length; i >= 0x100; i >>= 8)
                    lenOctets++;

                var header = new Buffer(1 + 1 + lenOctets);
                header[0] = encodedTag;
                header[1] = 0x80 | lenOctets;

                for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
                    header[i] = j & 0xff;

                return this._createEncoderBuffer([header, content]);
            };

            DERNode.prototype._encodeStr = function encodeStr(str, tag) {
                if (tag === 'bitstr') {
                    return this._createEncoderBuffer([str.unused | 0, str.data]);
                } else if (tag === 'bmpstr') {
                    var buf = new Buffer(str.length * 2);
                    for (var i = 0; i < str.length; i++) {
                        buf.writeUInt16BE(str.charCodeAt(i), i * 2);
                    }
                    return this._createEncoderBuffer(buf);
                } else if (tag === 'numstr') {
                    if (!this._isNumstr(str)) {
                        return this.reporter.error('Encoding of string type: numstr supports ' +
                            'only digits and space');
                    }
                    return this._createEncoderBuffer(str);
                } else if (tag === 'printstr') {
                    if (!this._isPrintstr(str)) {
                        return this.reporter.error('Encoding of string type: printstr supports ' +
                            'only latin upper and lower case letters, ' +
                            'digits, space, apostrophe, left and rigth ' +
                            'parenthesis, plus sign, comma, hyphen, ' +
                            'dot, slash, colon, equal sign, ' +
                            'question mark');
                    }
                    return this._createEncoderBuffer(str);
                } else if (/str$/.test(tag)) {
                    return this._createEncoderBuffer(str);
                } else if (tag === 'objDesc') {
                    return this._createEncoderBuffer(str);
                } else {
                    return this.reporter.error('Encoding of string type: ' + tag +
                        ' unsupported');
                }
            };

            DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
                if (typeof id === 'string') {
                    if (!values)
                        return this.reporter.error('string objid given, but no values map found');
                    if (!values.hasOwnProperty(id))
                        return this.reporter.error('objid not found in values map');
                    id = values[id].split(/[\s\.]+/g);
                    for (var i = 0; i < id.length; i++)
                        id[i] |= 0;
                } else if (Array.isArray(id)) {
                    id = id.slice();
                    for (var i = 0; i < id.length; i++)
                        id[i] |= 0;
                }

                if (!Array.isArray(id)) {
                    return this.reporter.error('objid() should be either array or string, ' +
                        'got: ' + JSON.stringify(id));
                }

                if (!relative) {
                    if (id[1] >= 40)
                        return this.reporter.error('Second objid identifier OOB');
                    id.splice(0, 2, id[0] * 40 + id[1]);
                }

                // Count number of octets
                var size = 0;
                for (var i = 0; i < id.length; i++) {
                    var ident = id[i];
                    for (size++; ident >= 0x80; ident >>= 7)
                        size++;
                }

                var objid = new Buffer(size);
                var offset = objid.length - 1;
                for (var i = id.length - 1; i >= 0; i--) {
                    var ident = id[i];
                    objid[offset--] = ident & 0x7f;
                    while ((ident >>= 7) > 0)
                        objid[offset--] = 0x80 | (ident & 0x7f);
                }

                return this._createEncoderBuffer(objid);
            };

            function two(num) {
                if (num < 10)
                    return '0' + num;
                else
                    return num;
            }

            DERNode.prototype._encodeTime = function encodeTime(time, tag) {
                var str;
                var date = new Date(time);

                if (tag === 'gentime') {
                    str = [
                        two(date.getFullYear()),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('');
                } else if (tag === 'utctime') {
                    str = [
                        two(date.getFullYear() % 100),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('');
                } else {
                    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
                }

                return this._encodeStr(str, 'octstr');
            };

            DERNode.prototype._encodeNull = function encodeNull() {
                return this._createEncoderBuffer('');
            };

            DERNode.prototype._encodeInt = function encodeInt(num, values) {
                if (typeof num === 'string') {
                    if (!values)
                        return this.reporter.error('String int or enum given, but no values map');
                    if (!values.hasOwnProperty(num)) {
                        return this.reporter.error('Values map doesn\'t contain: ' +
                            JSON.stringify(num));
                    }
                    num = values[num];
                }

                // Bignum, assume big endian
                if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
                    var numArray = num.toArray();
                    if (!num.sign && numArray[0] & 0x80) {
                        numArray.unshift(0);
                    }
                    num = new Buffer(numArray);
                }

                if (Buffer.isBuffer(num)) {
                    var size = num.length;
                    if (num.length === 0)
                        size++;

                    var out = new Buffer(size);
                    num.copy(out);
                    if (num.length === 0)
                        out[0] = 0;
                    return this._createEncoderBuffer(out);
                }

                if (num < 0x80)
                    return this._createEncoderBuffer(num);

                if (num < 0x100)
                    return this._createEncoderBuffer([0, num]);

                var size = 1;
                for (var i = num; i >= 0x100; i >>= 8)
                    size++;

                var out = new Array(size);
                for (var i = out.length - 1; i >= 0; i--) {
                    out[i] = num & 0xff;
                    num >>= 8;
                }
                if (out[0] & 0x80) {
                    out.unshift(0);
                }

                return this._createEncoderBuffer(new Buffer(out));
            };

            DERNode.prototype._encodeBool = function encodeBool(value) {
                return this._createEncoderBuffer(value ? 0xff : 0);
            };

            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function')
                    entity = entity(obj);
                return entity._getEncoder('der').tree;
            };

            DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
                var state = this._baseState;
                var i;
                if (state['default'] === null)
                    return false;

                var data = dataBuffer.join();
                if (state.defaultBuffer === undefined)
                    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

                if (data.length !== state.defaultBuffer.length)
                    return false;

                for (i = 0; i < data.length; i++)
                    if (data[i] !== state.defaultBuffer[i])
                        return false;

                return true;
            };

// Utility methods

            function encodeTag(tag, primitive, cls, reporter) {
                var res;

                if (tag === 'seqof')
                    tag = 'seq';
                else if (tag === 'setof')
                    tag = 'set';

                if (der.tagByName.hasOwnProperty(tag))
                    res = der.tagByName[tag];
                else if (typeof tag === 'number' && (tag | 0) === tag)
                    res = tag;
                else
                    return reporter.error('Unknown tag: ' + tag);

                if (res >= 0x1f)
                    return reporter.error('Multi-octet tag encoding unsupported');

                if (!primitive)
                    res |= 0x20;

                res |= (der.tagClassByName[cls || 'universal'] << 6);

                return res;
            }

        }, { '../../asn1': 10, 'buffer': 59, 'inherits': 116 }],
        22: [function(require, module, exports) {
            var encoders = exports;

            encoders.der = require('./der');
            encoders.pem = require('./pem');

        }, { './der': 21, './pem': 23 }],
        23: [function(require, module, exports) {
            var inherits = require('inherits');

            var DEREncoder = require('./der');

            function PEMEncoder(entity) {
                DEREncoder.call(this, entity);
                this.enc = 'pem';
            }
            inherits(PEMEncoder, DEREncoder);
            module.exports = PEMEncoder;

            PEMEncoder.prototype.encode = function encode(data, options) {
                var buf = DEREncoder.prototype.encode.call(this, data);

                var p = buf.toString('base64');
                var out = ['-----BEGIN ' + options.label + '-----'];
                for (var i = 0; i < p.length; i += 64)
                    out.push(p.slice(i, i + 64));
                out.push('-----END ' + options.label + '-----');
                return out.join('\n');
            };

        }, { './der': 21, 'inherits': 116 }],
        24: [function(require, module, exports) {
            (function(process, global, setImmediate) {
                /*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
                (function() {

                    var async = {};

                    function noop() {
                    }

                    function identity(v) {
                        return v;
                    }

                    function toBool(v) {
                        return !!v;
                    }

                    function notId(v) {
                        return !v;
                    }

                    // global on the server, window in the browser
                    var previous_async;

                    // Establish the root object, `window` (`self`) in the browser, `global`
                    // on the server, or `this` in some virtual machines. We use `self`
                    // instead of `window` for `WebWorker` support.
                    var root = typeof self === 'object' && self.self === self && self ||
                        typeof global === 'object' && global.global === global && global ||
                        this;

                    if (root != null) {
                        previous_async = root.async;
                    }

                    async.noConflict = function() {
                        root.async = previous_async;
                        return async;
                    };

                    function only_once(fn) {
                        return function() {
                            if (fn === null) throw new Error('Callback was already called.');
                            fn.apply(this, arguments);
                            fn = null;
                        };
                    }

                    function _once(fn) {
                        return function() {
                            if (fn === null) return;
                            fn.apply(this, arguments);
                            fn = null;
                        };
                    }

                    //// cross-browser compatiblity functions ////

                    var _toString = Object.prototype.toString;

                    var _isArray = Array.isArray || function(obj) {
                        return _toString.call(obj) === '[object Array]';
                    };

                    // Ported from underscore.js isObject
                    var _isObject = function(obj) {
                        var type = typeof obj;
                        return type === 'function' || type === 'object' && !!obj;
                    };

                    function _isArrayLike(arr) {
                        return _isArray(arr) || (
                            // has a positive integer length property
                            typeof arr.length === 'number' &&
                            arr.length >= 0 &&
                            arr.length % 1 === 0
                        );
                    }

                    function _arrayEach(arr, iterator) {
                        var index = -1,
                            length = arr.length;

                        while (++index < length) {
                            iterator(arr[index], index, arr);
                        }
                    }

                    function _map(arr, iterator) {
                        var index = -1,
                            length = arr.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iterator(arr[index], index, arr);
                        }
                        return result;
                    }

                    function _range(count) {
                        return _map(Array(count), function(v, i) {
                            return i;
                        });
                    }

                    function _reduce(arr, iterator, memo) {
                        _arrayEach(arr, function(x, i, a) {
                            memo = iterator(memo, x, i, a);
                        });
                        return memo;
                    }

                    function _forEachOf(object, iterator) {
                        _arrayEach(_keys(object), function(key) {
                            iterator(object[key], key);
                        });
                    }

                    function _indexOf(arr, item) {
                        for (var i = 0; i < arr.length; i++) {
                            if (arr[i] === item) return i;
                        }
                        return -1;
                    }

                    var _keys = Object.keys || function(obj) {
                        var keys = [];
                        for (var k in obj) {
                            if (obj.hasOwnProperty(k)) {
                                keys.push(k);
                            }
                        }
                        return keys;
                    };

                    function _keyIterator(coll) {
                        var i = -1;
                        var len;
                        var keys;
                        if (_isArrayLike(coll)) {
                            len = coll.length;
                            return function next() {
                                i++;
                                return i < len ? i : null;
                            };
                        } else {
                            keys = _keys(coll);
                            len = keys.length;
                            return function next() {
                                i++;
                                return i < len ? keys[i] : null;
                            };
                        }
                    }

                    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
                    // This accumulates the arguments passed into an array, after a given index.
                    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
                    function _restParam(func, startIndex) {
                        startIndex = startIndex == null ? func.length - 1 : +startIndex;
                        return function() {
                            var length = Math.max(arguments.length - startIndex, 0);
                            var rest = Array(length);
                            for (var index = 0; index < length; index++) {
                                rest[index] = arguments[index + startIndex];
                            }
                            switch (startIndex) {
                                case 0:
                                    return func.call(this, rest);
                                case 1:
                                    return func.call(this, arguments[0], rest);
                            }
                            // Currently unused but handle cases outside of the switch statement:
                            // var args = Array(startIndex + 1);
                            // for (index = 0; index < startIndex; index++) {
                            //     args[index] = arguments[index];
                            // }
                            // args[startIndex] = rest;
                            // return func.apply(this, args);
                        };
                    }

                    function _withoutIndex(iterator) {
                        return function(value, index, callback) {
                            return iterator(value, callback);
                        };
                    }

                    //// exported async module functions ////

                    //// nextTick implementation with browser-compatible fallback ////

                    // capture the global reference to guard against fakeTimer mocks
                    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

                    var _delay = _setImmediate ? function(fn) {
                        // not a direct alias for IE10 compatibility
                        _setImmediate(fn);
                    } : function(fn) {
                        setTimeout(fn, 0);
                    };

                    if (typeof process === 'object' && typeof process.nextTick === 'function') {
                        async.nextTick = process.nextTick;
                    } else {
                        async.nextTick = _delay;
                    }
                    async.setImmediate = _setImmediate ? _delay : async.nextTick;


                    async.forEach =
                        async.each = function(arr, iterator, callback) {
                            return async.eachOf(arr, _withoutIndex(iterator), callback);
                        };

                    async.forEachSeries =
                        async.eachSeries = function(arr, iterator, callback) {
                            return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
                        };


                    async.forEachLimit =
                        async.eachLimit = function(arr, limit, iterator, callback) {
                            return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
                        };

                    async.forEachOf =
                        async.eachOf = function(object, iterator, callback) {
                            callback = _once(callback || noop);
                            object = object || [];

                            var iter = _keyIterator(object);
                            var key, completed = 0;

                            while ((key = iter()) != null) {
                                completed += 1;
                                iterator(object[key], key, only_once(done));
                            }

                            if (completed === 0) callback(null);

                            function done(err) {
                                completed--;
                                if (err) {
                                    callback(err);
                                }
                                    // Check key is null in case iterator isn't exhausted
                                // and done resolved synchronously.
                                else if (key === null && completed <= 0) {
                                    callback(null);
                                }
                            }
                        };

                    async.forEachOfSeries =
                        async.eachOfSeries = function(obj, iterator, callback) {
                            callback = _once(callback || noop);
                            obj = obj || [];
                            var nextKey = _keyIterator(obj);
                            var key = nextKey();

                            function iterate() {
                                var sync = true;
                                if (key === null) {
                                    return callback(null);
                                }
                                iterator(obj[key], key, only_once(function(err) {
                                    if (err) {
                                        callback(err);
                                    } else {
                                        key = nextKey();
                                        if (key === null) {
                                            return callback(null);
                                        } else {
                                            if (sync) {
                                                async.setImmediate(iterate);
                                            } else {
                                                iterate();
                                            }
                                        }
                                    }
                                }));
                                sync = false;
                            }

                            iterate();
                        };


                    async.forEachOfLimit =
                        async.eachOfLimit = function(obj, limit, iterator, callback) {
                            _eachOfLimit(limit)(obj, iterator, callback);
                        };

                    function _eachOfLimit(limit) {

                        return function(obj, iterator, callback) {
                            callback = _once(callback || noop);
                            obj = obj || [];
                            var nextKey = _keyIterator(obj);
                            if (limit <= 0) {
                                return callback(null);
                            }
                            var done = false;
                            var running = 0;
                            var errored = false;

                            (function replenish() {
                                if (done && running <= 0) {
                                    return callback(null);
                                }

                                while (running < limit && !errored) {
                                    var key = nextKey();
                                    if (key === null) {
                                        done = true;
                                        if (running <= 0) {
                                            callback(null);
                                        }
                                        return;
                                    }
                                    running += 1;
                                    iterator(obj[key], key, only_once(function(err) {
                                        running -= 1;
                                        if (err) {
                                            callback(err);
                                            errored = true;
                                        } else {
                                            replenish();
                                        }
                                    }));
                                }
                            })();
                        };
                    }


                    function doParallel(fn) {
                        return function(obj, iterator, callback) {
                            return fn(async.eachOf, obj, iterator, callback);
                        };
                    }

                    function doParallelLimit(fn) {
                        return function(obj, limit, iterator, callback) {
                            return fn(_eachOfLimit(limit), obj, iterator, callback);
                        };
                    }

                    function doSeries(fn) {
                        return function(obj, iterator, callback) {
                            return fn(async.eachOfSeries, obj, iterator, callback);
                        };
                    }

                    function _asyncMap(eachfn, arr, iterator, callback) {
                        callback = _once(callback || noop);
                        arr = arr || [];
                        var results = _isArrayLike(arr) ? [] : {};
                        eachfn(arr, function(value, index, callback) {
                            iterator(value, function(err, v) {
                                results[index] = v;
                                callback(err);
                            });
                        }, function(err) {
                            callback(err, results);
                        });
                    }

                    async.map = doParallel(_asyncMap);
                    async.mapSeries = doSeries(_asyncMap);
                    async.mapLimit = doParallelLimit(_asyncMap);

                    // reduce only has a series version, as doing reduce in parallel won't
                    // work in many situations.
                    async.inject =
                        async.foldl =
                            async.reduce = function(arr, memo, iterator, callback) {
                                async.eachOfSeries(arr, function(x, i, callback) {
                                    iterator(memo, x, function(err, v) {
                                        memo = v;
                                        callback(err);
                                    });
                                }, function(err) {
                                    callback(err, memo);
                                });
                            };

                    async.foldr =
                        async.reduceRight = function(arr, memo, iterator, callback) {
                            var reversed = _map(arr, identity).reverse();
                            async.reduce(reversed, memo, iterator, callback);
                        };

                    async.transform = function(arr, memo, iterator, callback) {
                        if (arguments.length === 3) {
                            callback = iterator;
                            iterator = memo;
                            memo = _isArray(arr) ? [] : {};
                        }

                        async.eachOf(arr, function(v, k, cb) {
                            iterator(memo, v, k, cb);
                        }, function(err) {
                            callback(err, memo);
                        });
                    };

                    function _filter(eachfn, arr, iterator, callback) {
                        var results = [];
                        eachfn(arr, function(x, index, callback) {
                            iterator(x, function(v) {
                                if (v) {
                                    results.push({ index: index, value: x });
                                }
                                callback();
                            });
                        }, function() {
                            callback(_map(results.sort(function(a, b) {
                                return a.index - b.index;
                            }), function(x) {
                                return x.value;
                            }));
                        });
                    }

                    async.select =
                        async.filter = doParallel(_filter);

                    async.selectLimit =
                        async.filterLimit = doParallelLimit(_filter);

                    async.selectSeries =
                        async.filterSeries = doSeries(_filter);

                    function _reject(eachfn, arr, iterator, callback) {
                        _filter(eachfn, arr, function(value, cb) {
                            iterator(value, function(v) {
                                cb(!v);
                            });
                        }, callback);
                    }

                    async.reject = doParallel(_reject);
                    async.rejectLimit = doParallelLimit(_reject);
                    async.rejectSeries = doSeries(_reject);

                    function _createTester(eachfn, check, getResult) {
                        return function(arr, limit, iterator, cb) {
                            function done() {
                                if (cb) cb(getResult(false, void 0));
                            }

                            function iteratee(x, _, callback) {
                                if (!cb) return callback();
                                iterator(x, function(v) {
                                    if (cb && check(v)) {
                                        cb(getResult(true, x));
                                        cb = iterator = false;
                                    }
                                    callback();
                                });
                            }

                            if (arguments.length > 3) {
                                eachfn(arr, limit, iteratee, done);
                            } else {
                                cb = iterator;
                                iterator = limit;
                                eachfn(arr, iteratee, done);
                            }
                        };
                    }

                    async.any =
                        async.some = _createTester(async.eachOf, toBool, identity);

                    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

                    async.all =
                        async.every = _createTester(async.eachOf, notId, notId);

                    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

                    function _findGetResult(v, x) {
                        return x;
                    }

                    async.detect = _createTester(async.eachOf, identity, _findGetResult);
                    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
                    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

                    async.sortBy = function(arr, iterator, callback) {
                        async.map(arr, function(x, callback) {
                            iterator(x, function(err, criteria) {
                                if (err) {
                                    callback(err);
                                } else {
                                    callback(null, { value: x, criteria: criteria });
                                }
                            });
                        }, function(err, results) {
                            if (err) {
                                return callback(err);
                            } else {
                                callback(null, _map(results.sort(comparator), function(x) {
                                    return x.value;
                                }));
                            }

                        });

                        function comparator(left, right) {
                            var a = left.criteria, b = right.criteria;
                            return a < b ? -1 : a > b ? 1 : 0;
                        }
                    };

                    async.auto = function(tasks, concurrency, callback) {
                        if (typeof arguments[1] === 'function') {
                            // concurrency is optional, shift the args.
                            callback = concurrency;
                            concurrency = null;
                        }
                        callback = _once(callback || noop);
                        var keys = _keys(tasks);
                        var remainingTasks = keys.length;
                        if (!remainingTasks) {
                            return callback(null);
                        }
                        if (!concurrency) {
                            concurrency = remainingTasks;
                        }

                        var results = {};
                        var runningTasks = 0;

                        var hasError = false;

                        var listeners = [];

                        function addListener(fn) {
                            listeners.unshift(fn);
                        }

                        function removeListener(fn) {
                            var idx = _indexOf(listeners, fn);
                            if (idx >= 0) listeners.splice(idx, 1);
                        }

                        function taskComplete() {
                            remainingTasks--;
                            _arrayEach(listeners.slice(0), function(fn) {
                                fn();
                            });
                        }

                        addListener(function() {
                            if (!remainingTasks) {
                                callback(null, results);
                            }
                        });

                        _arrayEach(keys, function(k) {
                            if (hasError) return;
                            var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
                            var taskCallback = _restParam(function(err, args) {
                                runningTasks--;
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                if (err) {
                                    var safeResults = {};
                                    _forEachOf(results, function(val, rkey) {
                                        safeResults[rkey] = val;
                                    });
                                    safeResults[k] = args;
                                    hasError = true;

                                    callback(err, safeResults);
                                } else {
                                    results[k] = args;
                                    async.setImmediate(taskComplete);
                                }
                            });
                            var requires = task.slice(0, task.length - 1);
                            // prevent dead-locks
                            var len = requires.length;
                            var dep;
                            while (len--) {
                                if (!(dep = tasks[requires[len]])) {
                                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                                }
                                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                                    throw new Error('Has cyclic dependencies');
                                }
                            }

                            function ready() {
                                return runningTasks < concurrency && _reduce(requires, function(a, x) {
                                    return (a && results.hasOwnProperty(x));
                                }, true) && !results.hasOwnProperty(k);
                            }

                            if (ready()) {
                                runningTasks++;
                                task[task.length - 1](taskCallback, results);
                            } else {
                                addListener(listener);
                            }

                            function listener() {
                                if (ready()) {
                                    runningTasks++;
                                    removeListener(listener);
                                    task[task.length - 1](taskCallback, results);
                                }
                            }
                        });
                    };


                    async.retry = function(times, task, callback) {
                        var DEFAULT_TIMES = 5;
                        var DEFAULT_INTERVAL = 0;

                        var attempts = [];

                        var opts = {
                            times: DEFAULT_TIMES,
                            interval: DEFAULT_INTERVAL
                        };

                        function parseTimes(acc, t) {
                            if (typeof t === 'number') {
                                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
                            } else if (typeof t === 'object') {
                                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
                            } else {
                                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
                            }
                        }

                        var length = arguments.length;
                        if (length < 1 || length > 3) {
                            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
                        } else if (length <= 2 && typeof times === 'function') {
                            callback = task;
                            task = times;
                        }
                        if (typeof times !== 'function') {
                            parseTimes(opts, times);
                        }
                        opts.callback = callback;
                        opts.task = task;

                        function wrappedTask(wrappedCallback, wrappedResults) {
                            function retryAttempt(task, finalAttempt) {
                                return function(seriesCallback) {
                                    task(function(err, result) {
                                        seriesCallback(!err || finalAttempt, { err: err, result: result });
                                    }, wrappedResults);
                                };
                            }

                            function retryInterval(interval) {
                                return function(seriesCallback) {
                                    setTimeout(function() {
                                        seriesCallback(null);
                                    }, interval);
                                };
                            }

                            while (opts.times) {

                                var finalAttempt = !(opts.times -= 1);
                                attempts.push(retryAttempt(opts.task, finalAttempt));
                                if (!finalAttempt && opts.interval > 0) {
                                    attempts.push(retryInterval(opts.interval));
                                }
                            }

                            async.series(attempts, function(done, data) {
                                data = data[data.length - 1];
                                (wrappedCallback || opts.callback)(data.err, data.result);
                            });
                        }

                        // If a callback is passed, run this as a controll flow
                        return opts.callback ? wrappedTask() : wrappedTask;
                    };

                    async.waterfall = function(tasks, callback) {
                        callback = _once(callback || noop);
                        if (!_isArray(tasks)) {
                            var err = new Error('First argument to waterfall must be an array of functions');
                            return callback(err);
                        }
                        if (!tasks.length) {
                            return callback();
                        }

                        function wrapIterator(iterator) {
                            return _restParam(function(err, args) {
                                if (err) {
                                    callback.apply(null, [err].concat(args));
                                } else {
                                    var next = iterator.next();
                                    if (next) {
                                        args.push(wrapIterator(next));
                                    } else {
                                        args.push(callback);
                                    }
                                    ensureAsync(iterator).apply(null, args);
                                }
                            });
                        }

                        wrapIterator(async.iterator(tasks))();
                    };

                    function _parallel(eachfn, tasks, callback) {
                        callback = callback || noop;
                        var results = _isArrayLike(tasks) ? [] : {};

                        eachfn(tasks, function(task, key, callback) {
                            task(_restParam(function(err, args) {
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                results[key] = args;
                                callback(err);
                            }));
                        }, function(err) {
                            callback(err, results);
                        });
                    }

                    async.parallel = function(tasks, callback) {
                        _parallel(async.eachOf, tasks, callback);
                    };

                    async.parallelLimit = function(tasks, limit, callback) {
                        _parallel(_eachOfLimit(limit), tasks, callback);
                    };

                    async.series = function(tasks, callback) {
                        _parallel(async.eachOfSeries, tasks, callback);
                    };

                    async.iterator = function(tasks) {
                        function makeCallback(index) {
                            function fn() {
                                if (tasks.length) {
                                    tasks[index].apply(null, arguments);
                                }
                                return fn.next();
                            }

                            fn.next = function() {
                                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;
                            };
                            return fn;
                        }

                        return makeCallback(0);
                    };

                    async.apply = _restParam(function(fn, args) {
                        return _restParam(function(callArgs) {
                            return fn.apply(
                                null, args.concat(callArgs)
                            );
                        });
                    });

                    function _concat(eachfn, arr, fn, callback) {
                        var result = [];
                        eachfn(arr, function(x, index, cb) {
                            fn(x, function(err, y) {
                                result = result.concat(y || []);
                                cb(err);
                            });
                        }, function(err) {
                            callback(err, result);
                        });
                    }

                    async.concat = doParallel(_concat);
                    async.concatSeries = doSeries(_concat);

                    async.whilst = function(test, iterator, callback) {
                        callback = callback || noop;
                        if (test()) {
                            var next = _restParam(function(err, args) {
                                if (err) {
                                    callback(err);
                                } else if (test.apply(this, args)) {
                                    iterator(next);
                                } else {
                                    callback.apply(null, [null].concat(args));
                                }
                            });
                            iterator(next);
                        } else {
                            callback(null);
                        }
                    };

                    async.doWhilst = function(iterator, test, callback) {
                        var calls = 0;
                        return async.whilst(function() {
                            return ++calls <= 1 || test.apply(this, arguments);
                        }, iterator, callback);
                    };

                    async.until = function(test, iterator, callback) {
                        return async.whilst(function() {
                            return !test.apply(this, arguments);
                        }, iterator, callback);
                    };

                    async.doUntil = function(iterator, test, callback) {
                        return async.doWhilst(iterator, function() {
                            return !test.apply(this, arguments);
                        }, callback);
                    };

                    async.during = function(test, iterator, callback) {
                        callback = callback || noop;

                        var next = _restParam(function(err, args) {
                            if (err) {
                                callback(err);
                            } else {
                                args.push(check);
                                test.apply(this, args);
                            }
                        });

                        var check = function(err, truth) {
                            if (err) {
                                callback(err);
                            } else if (truth) {
                                iterator(next);
                            } else {
                                callback(null);
                            }
                        };

                        test(check);
                    };

                    async.doDuring = function(iterator, test, callback) {
                        var calls = 0;
                        async.during(function(next) {
                            if (calls++ < 1) {
                                next(null, true);
                            } else {
                                test.apply(this, arguments);
                            }
                        }, iterator, callback);
                    };

                    function _queue(worker, concurrency, payload) {
                        if (concurrency == null) {
                            concurrency = 1;
                        } else if (concurrency === 0) {
                            throw new Error('Concurrency must not be zero');
                        }

                        function _insert(q, data, pos, callback) {
                            if (callback != null && typeof callback !== 'function') {
                                throw new Error('task callback must be a function');
                            }
                            q.started = true;
                            if (!_isArray(data)) {
                                data = [data];
                            }
                            if (data.length === 0 && q.idle()) {
                                // call drain immediately if there are no tasks
                                return async.setImmediate(function() {
                                    q.drain();
                                });
                            }
                            _arrayEach(data, function(task) {
                                var item = {
                                    data: task,
                                    callback: callback || noop
                                };

                                if (pos) {
                                    q.tasks.unshift(item);
                                } else {
                                    q.tasks.push(item);
                                }

                                if (q.tasks.length === q.concurrency) {
                                    q.saturated();
                                }
                            });
                            async.setImmediate(q.process);
                        }

                        function _next(q, tasks) {
                            return function() {
                                workers -= 1;

                                var removed = false;
                                var args = arguments;
                                _arrayEach(tasks, function(task) {
                                    _arrayEach(workersList, function(worker, index) {
                                        if (worker === task && !removed) {
                                            workersList.splice(index, 1);
                                            removed = true;
                                        }
                                    });

                                    task.callback.apply(task, args);
                                });
                                if (q.tasks.length + workers === 0) {
                                    q.drain();
                                }
                                q.process();
                            };
                        }

                        var workers = 0;
                        var workersList = [];
                        var q = {
                            tasks: [],
                            concurrency: concurrency,
                            payload: payload,
                            saturated: noop,
                            empty: noop,
                            drain: noop,
                            started: false,
                            paused: false,
                            push: function(data, callback) {
                                _insert(q, data, false, callback);
                            },
                            kill: function() {
                                q.drain = noop;
                                q.tasks = [];
                            },
                            unshift: function(data, callback) {
                                _insert(q, data, true, callback);
                            },
                            process: function() {
                                while (!q.paused && workers < q.concurrency && q.tasks.length) {

                                    var tasks = q.payload ?
                                        q.tasks.splice(0, q.payload) :
                                        q.tasks.splice(0, q.tasks.length);

                                    var data = _map(tasks, function(task) {
                                        return task.data;
                                    });

                                    if (q.tasks.length === 0) {
                                        q.empty();
                                    }
                                    workers += 1;
                                    workersList.push(tasks[0]);
                                    var cb = only_once(_next(q, tasks));
                                    worker(data, cb);
                                }
                            },
                            length: function() {
                                return q.tasks.length;
                            },
                            running: function() {
                                return workers;
                            },
                            workersList: function() {
                                return workersList;
                            },
                            idle: function() {
                                return q.tasks.length + workers === 0;
                            },
                            pause: function() {
                                q.paused = true;
                            },
                            resume: function() {
                                if (q.paused === false) {
                                    return;
                                }
                                q.paused = false;
                                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                                // Need to call q.process once per concurrent
                                // worker to preserve full concurrency after pause
                                for (var w = 1; w <= resumeCount; w++) {
                                    async.setImmediate(q.process);
                                }
                            }
                        };
                        return q;
                    }

                    async.queue = function(worker, concurrency) {
                        var q = _queue(function(items, cb) {
                            worker(items[0], cb);
                        }, concurrency, 1);

                        return q;
                    };

                    async.priorityQueue = function(worker, concurrency) {

                        function _compareTasks(a, b) {
                            return a.priority - b.priority;
                        }

                        function _binarySearch(sequence, item, compare) {
                            var beg = -1,
                                end = sequence.length - 1;
                            while (beg < end) {
                                var mid = beg + ((end - beg + 1) >>> 1);
                                if (compare(item, sequence[mid]) >= 0) {
                                    beg = mid;
                                } else {
                                    end = mid - 1;
                                }
                            }
                            return beg;
                        }

                        function _insert(q, data, priority, callback) {
                            if (callback != null && typeof callback !== 'function') {
                                throw new Error('task callback must be a function');
                            }
                            q.started = true;
                            if (!_isArray(data)) {
                                data = [data];
                            }
                            if (data.length === 0) {
                                // call drain immediately if there are no tasks
                                return async.setImmediate(function() {
                                    q.drain();
                                });
                            }
                            _arrayEach(data, function(task) {
                                var item = {
                                    data: task,
                                    priority: priority,
                                    callback: typeof callback === 'function' ? callback : noop
                                };

                                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                                if (q.tasks.length === q.concurrency) {
                                    q.saturated();
                                }
                                async.setImmediate(q.process);
                            });
                        }

                        // Start with a normal queue
                        var q = async.queue(worker, concurrency);

                        // Override push to accept second parameter representing priority
                        q.push = function(data, priority, callback) {
                            _insert(q, data, priority, callback);
                        };

                        // Remove unshift function
                        delete q.unshift;

                        return q;
                    };

                    async.cargo = function(worker, payload) {
                        return _queue(worker, 1, payload);
                    };

                    function _console_fn(name) {
                        return _restParam(function(fn, args) {
                            fn.apply(null, args.concat([_restParam(function(err, args) {
                                if (typeof console === 'object') {
                                    if (err) {
                                        if (console.error) {
                                            console.error(err);
                                        }
                                    } else if (console[name]) {
                                        _arrayEach(args, function(x) {
                                            console[name](x);
                                        });
                                    }
                                }
                            })]));
                        });
                    }

                    async.log = _console_fn('log');
                    async.dir = _console_fn('dir');
                    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

                    async.memoize = function(fn, hasher) {
                        var memo = {};
                        var queues = {};
                        var has = Object.prototype.hasOwnProperty;
                        hasher = hasher || identity;
                        var memoized = _restParam(function memoized(args) {
                            var callback = args.pop();
                            var key = hasher.apply(null, args);
                            if (has.call(memo, key)) {
                                async.setImmediate(function() {
                                    callback.apply(null, memo[key]);
                                });
                            } else if (has.call(queues, key)) {
                                queues[key].push(callback);
                            } else {
                                queues[key] = [callback];
                                fn.apply(null, args.concat([_restParam(function(args) {
                                    memo[key] = args;
                                    var q = queues[key];
                                    delete queues[key];
                                    for (var i = 0, l = q.length; i < l; i++) {
                                        q[i].apply(null, args);
                                    }
                                })]));
                            }
                        });
                        memoized.memo = memo;
                        memoized.unmemoized = fn;
                        return memoized;
                    };

                    async.unmemoize = function(fn) {
                        return function() {
                            return (fn.unmemoized || fn).apply(null, arguments);
                        };
                    };

                    function _times(mapper) {
                        return function(count, iterator, callback) {
                            mapper(_range(count), iterator, callback);
                        };
                    }

                    async.times = _times(async.map);
                    async.timesSeries = _times(async.mapSeries);
                    async.timesLimit = function(count, limit, iterator, callback) {
                        return async.mapLimit(_range(count), limit, iterator, callback);
                    };

                    async.seq = function(/* functions... */) {
                        var fns = arguments;
                        return _restParam(function(args) {
                            var that = this;

                            var callback = args[args.length - 1];
                            if (typeof callback == 'function') {
                                args.pop();
                            } else {
                                callback = noop;
                            }

                            async.reduce(fns, args, function(newargs, fn, cb) {
                                    fn.apply(that, newargs.concat([_restParam(function(err, nextargs) {
                                        cb(err, nextargs);
                                    })]));
                                },
                                function(err, results) {
                                    callback.apply(that, [err].concat(results));
                                });
                        });
                    };

                    async.compose = function(/* functions... */) {
                        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
                    };


                    function _applyEach(eachfn) {
                        return _restParam(function(fns, args) {
                            var go = _restParam(function(args) {
                                var that = this;
                                var callback = args.pop();
                                return eachfn(fns, function(fn, _, cb) {
                                        fn.apply(that, args.concat([cb]));
                                    },
                                    callback);
                            });
                            if (args.length) {
                                return go.apply(this, args);
                            } else {
                                return go;
                            }
                        });
                    }

                    async.applyEach = _applyEach(async.eachOf);
                    async.applyEachSeries = _applyEach(async.eachOfSeries);


                    async.forever = function(fn, callback) {
                        var done = only_once(callback || noop);
                        var task = ensureAsync(fn);

                        function next(err) {
                            if (err) {
                                return done(err);
                            }
                            task(next);
                        }

                        next();
                    };

                    function ensureAsync(fn) {
                        return _restParam(function(args) {
                            var callback = args.pop();
                            args.push(function() {
                                var innerArgs = arguments;
                                if (sync) {
                                    async.setImmediate(function() {
                                        callback.apply(null, innerArgs);
                                    });
                                } else {
                                    callback.apply(null, innerArgs);
                                }
                            });
                            var sync = true;
                            fn.apply(this, args);
                            sync = false;
                        });
                    }

                    async.ensureAsync = ensureAsync;

                    async.constant = _restParam(function(values) {
                        var args = [null].concat(values);
                        return function(callback) {
                            return callback.apply(this, args);
                        };
                    });

                    async.wrapSync =
                        async.asyncify = function asyncify(func) {
                            return _restParam(function(args) {
                                var callback = args.pop();
                                var result;
                                try {
                                    result = func.apply(this, args);
                                } catch (e) {
                                    return callback(e);
                                }
                                // if result is Promise object
                                if (_isObject(result) && typeof result.then === 'function') {
                                    result.then(function(value) {
                                        callback(null, value);
                                    })['catch'](function(err) {
                                        callback(err.message ? err : new Error(err));
                                    });
                                } else {
                                    callback(null, result);
                                }
                            });
                        };

                    // Node.js
                    if (typeof module === 'object' && module.exports) {
                        module.exports = async;
                    }
                    // AMD / RequireJS
                    else if (typeof define === 'function' && define.amd) {
                        define([], function() {
                            return async;
                        });
                    }
                    // included directly via <script> tag
                    else {
                        root.async = async;
                    }

                }());

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('timers').setImmediate);
        }, { '_process': 141, 'timers': 192 }],
        25: [function(require, module, exports) {
            var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            ;(function(exports) {
                'use strict';

                var Arr = (typeof Uint8Array !== 'undefined')
                    ? Uint8Array
                    : Array;

                var PLUS = '+'.charCodeAt(0);
                var SLASH = '/'.charCodeAt(0);
                var NUMBER = '0'.charCodeAt(0);
                var LOWER = 'a'.charCodeAt(0);
                var UPPER = 'A'.charCodeAt(0);
                var PLUS_URL_SAFE = '-'.charCodeAt(0);
                var SLASH_URL_SAFE = '_'.charCodeAt(0);

                function decode(elt) {
                    var code = elt.charCodeAt(0);
                    if (code === PLUS ||
                        code === PLUS_URL_SAFE)
                        return 62; // '+'
                    if (code === SLASH ||
                        code === SLASH_URL_SAFE)
                        return 63; // '/'
                    if (code < NUMBER)
                        return -1; //no match
                    if (code < NUMBER + 10)
                        return code - NUMBER + 26 + 26;
                    if (code < UPPER + 26)
                        return code - UPPER;
                    if (code < LOWER + 26)
                        return code - LOWER + 26;
                }

                function b64ToByteArray(b64) {
                    var i, j, l, tmp, placeHolders, arr;

                    if (b64.length % 4 > 0) {
                        throw new Error('Invalid string. Length must be a multiple of 4');
                    }

                    // the number of equal signs (place holders)
                    // if there are two placeholders, than the two characters before it
                    // represent one byte
                    // if there is only one, then the three characters before it represent 2 bytes
                    // this is just a cheap hack to not do indexOf twice
                    var len = b64.length;
                    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

                    // base64 is 4/3 + up to two characters of the original data
                    arr = new Arr(b64.length * 3 / 4 - placeHolders);

                    // if there are placeholders, only get up to the last complete 4 chars
                    l = placeHolders > 0 ? b64.length - 4 : b64.length;

                    var L = 0;

                    function push(v) {
                        arr[L++] = v;
                    }

                    for (i = 0, j = 0; i < l; i += 4, j += 3) {
                        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
                        push((tmp & 0xFF0000) >> 16);
                        push((tmp & 0xFF00) >> 8);
                        push(tmp & 0xFF);
                    }

                    if (placeHolders === 2) {
                        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
                        push(tmp & 0xFF);
                    } else if (placeHolders === 1) {
                        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
                        push((tmp >> 8) & 0xFF);
                        push(tmp & 0xFF);
                    }

                    return arr;
                }

                function uint8ToBase64(uint8) {
                    var i,
                        extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                        output = '',
                        temp, length;

                    function encode(num) {
                        return lookup.charAt(num);
                    }

                    function tripletToBase64(num) {
                        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
                    }

                    // go through the array every three bytes, we'll deal with trailing stuff later
                    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                        output += tripletToBase64(temp);
                    }

                    // pad the end with zeros, but make sure to not forget the extra bytes
                    switch (extraBytes) {
                        case 1:
                            temp = uint8[uint8.length - 1];
                            output += encode(temp >> 2);
                            output += encode((temp << 4) & 0x3F);
                            output += '==';
                            break;
                        case 2:
                            temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
                            output += encode(temp >> 10);
                            output += encode((temp >> 4) & 0x3F);
                            output += encode((temp << 2) & 0x3F);
                            output += '=';
                            break;
                    }

                    return output;
                }

                exports.toByteArray = b64ToByteArray;
                exports.fromByteArray = uint8ToBase64;
            }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));

        }, {}],
        26: [function(require, module, exports) {
            (function(Buffer) {
                var inherits = require('inherits');
                var Transform = require('readable-stream').Transform;
                var defined = require('defined');

                module.exports = Block;
                inherits(Block, Transform);

                function Block(size, opts) {
                    if (!(this instanceof Block)) return new Block(size, opts);
                    Transform.call(this);
                    if (!opts) opts = {};
                    if (typeof size === 'object') {
                        opts = size;
                        size = opts.size;
                    }
                    this.size = size || 512;

                    if (opts.nopad) this._zeroPadding = false;
                    else this._zeroPadding = defined(opts.zeroPadding, true);

                    this._buffered = [];
                    this._bufferedBytes = 0;
                }

                Block.prototype._transform = function(buf, enc, next) {
                    this._bufferedBytes += buf.length;
                    this._buffered.push(buf);

                    while (this._bufferedBytes >= this.size) {
                        var b = Buffer.concat(this._buffered);
                        this._bufferedBytes -= this.size;
                        this.push(b.slice(0, this.size));
                        this._buffered = [b.slice(this.size, b.length)];
                    }
                    next();
                };

                Block.prototype._flush = function() {
                    if (this._bufferedBytes && this._zeroPadding) {
                        var zeroes = new Buffer(this.size - this._bufferedBytes);
                        zeroes.fill(0);
                        this._buffered.push(zeroes);
                        this.push(Buffer.concat(this._buffered));
                        this._buffered = null;
                    } else if (this._bufferedBytes) {
                        this.push(Buffer.concat(this._buffered));
                        this._buffered = null;
                    }
                    this.push(null);
                };

            }).call(this, require('buffer').Buffer);
        }, { 'buffer': 59, 'defined': 69, 'inherits': 116, 'readable-stream': 165 }],
        27: [function(require, module, exports) {
            (function(module, exports) {
                'use strict';

                // Utils
                function assert(val, msg) {
                    if (!val) throw new Error(msg || 'Assertion failed');
                }

                // Could use `inherits` module, but don't want to move from single file
                // architecture yet.
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {
                    };
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor();
                    ctor.prototype.constructor = ctor;
                }

                // BN

                function BN(number, base, endian) {
                    if (BN.isBN(number)) {
                        return number;
                    }

                    this.negative = 0;
                    this.words = null;
                    this.length = 0;

                    // Reduction context
                    this.red = null;

                    if (number !== null) {
                        if (base === 'le' || base === 'be') {
                            endian = base;
                            base = 10;
                        }

                        this._init(number || 0, base || 10, endian || 'be');
                    }
                }

                if (typeof module === 'object') {
                    module.exports = BN;
                } else {
                    exports.BN = BN;
                }

                BN.BN = BN;
                BN.wordSize = 26;

                var Buffer;
                try {
                    Buffer = require('buffer').Buffer;
                } catch (e) {
                }

                BN.isBN = function isBN(num) {
                    if (num instanceof BN) {
                        return true;
                    }

                    return num !== null && typeof num === 'object' &&
                        num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
                };

                BN.max = function max(left, right) {
                    if (left.cmp(right) > 0) return left;
                    return right;
                };

                BN.min = function min(left, right) {
                    if (left.cmp(right) < 0) return left;
                    return right;
                };

                BN.prototype._init = function init(number, base, endian) {
                    if (typeof number === 'number') {
                        return this._initNumber(number, base, endian);
                    }

                    if (typeof number === 'object') {
                        return this._initArray(number, base, endian);
                    }

                    if (base === 'hex') {
                        base = 16;
                    }
                    assert(base === (base | 0) && base >= 2 && base <= 36);

                    number = number.toString().replace(/\s+/g, '');
                    var start = 0;
                    if (number[0] === '-') {
                        start++;
                    }

                    if (base === 16) {
                        this._parseHex(number, start);
                    } else {
                        this._parseBase(number, base, start);
                    }

                    if (number[0] === '-') {
                        this.negative = 1;
                    }

                    this.strip();

                    if (endian !== 'le') return;

                    this._initArray(this.toArray(), base, endian);
                };

                BN.prototype._initNumber = function _initNumber(number, base, endian) {
                    if (number < 0) {
                        this.negative = 1;
                        number = -number;
                    }
                    if (number < 0x4000000) {
                        this.words = [number & 0x3ffffff];
                        this.length = 1;
                    } else if (number < 0x10000000000000) {
                        this.words = [
                            number & 0x3ffffff,
                            (number / 0x4000000) & 0x3ffffff
                        ];
                        this.length = 2;
                    } else {
                        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
                        this.words = [
                            number & 0x3ffffff,
                            (number / 0x4000000) & 0x3ffffff,
                            1
                        ];
                        this.length = 3;
                    }

                    if (endian !== 'le') return;

                    // Reverse the bytes
                    this._initArray(this.toArray(), base, endian);
                };

                BN.prototype._initArray = function _initArray(number, base, endian) {
                    // Perhaps a Uint8Array
                    assert(typeof number.length === 'number');
                    if (number.length <= 0) {
                        this.words = [0];
                        this.length = 1;
                        return this;
                    }

                    this.length = Math.ceil(number.length / 3);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                        this.words[i] = 0;
                    }

                    var j, w;
                    var off = 0;
                    if (endian === 'be') {
                        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                            w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                            this.words[j] |= (w << off) & 0x3ffffff;
                            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                            off += 24;
                            if (off >= 26) {
                                off -= 26;
                                j++;
                            }
                        }
                    } else if (endian === 'le') {
                        for (i = 0, j = 0; i < number.length; i += 3) {
                            w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                            this.words[j] |= (w << off) & 0x3ffffff;
                            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                            off += 24;
                            if (off >= 26) {
                                off -= 26;
                                j++;
                            }
                        }
                    }
                    return this.strip();
                };

                function parseHex(str, start, end) {
                    var r = 0;
                    var len = Math.min(str.length, end);
                    for (var i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;

                        r <<= 4;

                        // 'a' - 'f'
                        if (c >= 49 && c <= 54) {
                            r |= c - 49 + 0xa;

                            // 'A' - 'F'
                        } else if (c >= 17 && c <= 22) {
                            r |= c - 17 + 0xa;

                            // '0' - '9'
                        } else {
                            r |= c & 0xf;
                        }
                    }
                    return r;
                }

                BN.prototype._parseHex = function _parseHex(number, start) {
                    // Create possibly bigger array to ensure that it fits the number
                    this.length = Math.ceil((number.length - start) / 6);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                        this.words[i] = 0;
                    }

                    var j, w;
                    // Scan 24-bit chunks and add them to the number
                    var off = 0;
                    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
                        w = parseHex(number, i, i + 6);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
                        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                    if (i + 6 !== start) {
                        w = parseHex(number, start, i + 6);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                    }
                    this.strip();
                };

                function parseBase(str, start, end, mul) {
                    var r = 0;
                    var len = Math.min(str.length, end);
                    for (var i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;

                        r *= mul;

                        // 'a'
                        if (c >= 49) {
                            r += c - 49 + 0xa;

                            // 'A'
                        } else if (c >= 17) {
                            r += c - 17 + 0xa;

                            // '0' - '9'
                        } else {
                            r += c;
                        }
                    }
                    return r;
                }

                BN.prototype._parseBase = function _parseBase(number, base, start) {
                    // Initialize as zero
                    this.words = [0];
                    this.length = 1;

                    // Find length of limb in base
                    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
                        limbLen++;
                    }
                    limbLen--;
                    limbPow = (limbPow / base) | 0;

                    var total = number.length - start;
                    var mod = total % limbLen;
                    var end = Math.min(total, total - mod) + start;

                    var word = 0;
                    for (var i = start; i < end; i += limbLen) {
                        word = parseBase(number, i, i + limbLen, base);

                        this.imuln(limbPow);
                        if (this.words[0] + word < 0x4000000) {
                            this.words[0] += word;
                        } else {
                            this._iaddn(word);
                        }
                    }

                    if (mod !== 0) {
                        var pow = 1;
                        word = parseBase(number, i, number.length, base);

                        for (i = 0; i < mod; i++) {
                            pow *= base;
                        }

                        this.imuln(pow);
                        if (this.words[0] + word < 0x4000000) {
                            this.words[0] += word;
                        } else {
                            this._iaddn(word);
                        }
                    }
                };

                BN.prototype.copy = function copy(dest) {
                    dest.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                        dest.words[i] = this.words[i];
                    }
                    dest.length = this.length;
                    dest.negative = this.negative;
                    dest.red = this.red;
                };

                BN.prototype.clone = function clone() {
                    var r = new BN(null);
                    this.copy(r);
                    return r;
                };

                BN.prototype._expand = function _expand(size) {
                    while (this.length < size) {
                        this.words[this.length++] = 0;
                    }
                    return this;
                };

                // Remove leading `0` from `this`
                BN.prototype.strip = function strip() {
                    while (this.length > 1 && this.words[this.length - 1] === 0) {
                        this.length--;
                    }
                    return this._normSign();
                };

                BN.prototype._normSign = function _normSign() {
                    // -0 = 0
                    if (this.length === 1 && this.words[0] === 0) {
                        this.negative = 0;
                    }
                    return this;
                };

                BN.prototype.inspect = function inspect() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                };

                /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

                var zeros = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ];

                var groupSizes = [
                    0, 0,
                    25, 16, 12, 11, 10, 9, 8,
                    8, 7, 7, 7, 7, 6, 6,
                    6, 6, 6, 6, 6, 5, 5,
                    5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5
                ];

                var groupBases = [
                    0, 0,
                    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
                    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
                    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
                    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
                    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
                ];

                BN.prototype.toString = function toString(base, padding) {
                    base = base || 10;
                    padding = padding | 0 || 1;

                    var out;
                    if (base === 16 || base === 'hex') {
                        out = '';
                        var off = 0;
                        var carry = 0;
                        for (var i = 0; i < this.length; i++) {
                            var w = this.words[i];
                            var word = (((w << off) | carry) & 0xffffff).toString(16);
                            carry = (w >>> (24 - off)) & 0xffffff;
                            if (carry !== 0 || i !== this.length - 1) {
                                out = zeros[6 - word.length] + word + out;
                            } else {
                                out = word + out;
                            }
                            off += 2;
                            if (off >= 26) {
                                off -= 26;
                                i--;
                            }
                        }
                        if (carry !== 0) {
                            out = carry.toString(16) + out;
                        }
                        while (out.length % padding !== 0) {
                            out = '0' + out;
                        }
                        if (this.negative !== 0) {
                            out = '-' + out;
                        }
                        return out;
                    }

                    if (base === (base | 0) && base >= 2 && base <= 36) {
                        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
                        var groupSize = groupSizes[base];
                        // var groupBase = Math.pow(base, groupSize);
                        var groupBase = groupBases[base];
                        out = '';
                        var c = this.clone();
                        c.negative = 0;
                        while (!c.isZero()) {
                            var r = c.modn(groupBase).toString(base);
                            c = c.idivn(groupBase);

                            if (!c.isZero()) {
                                out = zeros[groupSize - r.length] + r + out;
                            } else {
                                out = r + out;
                            }
                        }
                        if (this.isZero()) {
                            out = '0' + out;
                        }
                        while (out.length % padding !== 0) {
                            out = '0' + out;
                        }
                        if (this.negative !== 0) {
                            out = '-' + out;
                        }
                        return out;
                    }

                    assert(false, 'Base should be between 2 and 36');
                };

                BN.prototype.toNumber = function toNumber() {
                    var ret = this.words[0];
                    if (this.length === 2) {
                        ret += this.words[1] * 0x4000000;
                    } else if (this.length === 3 && this.words[2] === 0x01) {
                        // NOTE: at this stage it is known that the top bit is set
                        ret += 0x10000000000000 + (this.words[1] * 0x4000000);
                    } else if (this.length > 2) {
                        assert(false, 'Number can only safely store up to 53 bits');
                    }
                    return (this.negative !== 0) ? -ret : ret;
                };

                BN.prototype.toJSON = function toJSON() {
                    return this.toString(16);
                };

                BN.prototype.toBuffer = function toBuffer(endian, length) {
                    assert(typeof Buffer !== 'undefined');
                    return this.toArrayLike(Buffer, endian, length);
                };

                BN.prototype.toArray = function toArray(endian, length) {
                    return this.toArrayLike(Array, endian, length);
                };

                BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
                    var byteLength = this.byteLength();
                    var reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, 'byte array longer than desired length');
                    assert(reqLength > 0, 'Requested array length <= 0');

                    this.strip();
                    var littleEndian = endian === 'le';
                    var res = new ArrayType(reqLength);

                    var b, i;
                    var q = this.clone();
                    if (!littleEndian) {
                        // Assume big-endian
                        for (i = 0; i < reqLength - byteLength; i++) {
                            res[i] = 0;
                        }

                        for (i = 0; !q.isZero(); i++) {
                            b = q.andln(0xff);
                            q.iushrn(8);

                            res[reqLength - i - 1] = b;
                        }
                    } else {
                        for (i = 0; !q.isZero(); i++) {
                            b = q.andln(0xff);
                            q.iushrn(8);

                            res[i] = b;
                        }

                        for (; i < reqLength; i++) {
                            res[i] = 0;
                        }
                    }

                    return res;
                };

                if (Math.clz32) {
                    BN.prototype._countBits = function _countBits(w) {
                        return 32 - Math.clz32(w);
                    };
                } else {
                    BN.prototype._countBits = function _countBits(w) {
                        var t = w;
                        var r = 0;
                        if (t >= 0x1000) {
                            r += 13;
                            t >>>= 13;
                        }
                        if (t >= 0x40) {
                            r += 7;
                            t >>>= 7;
                        }
                        if (t >= 0x8) {
                            r += 4;
                            t >>>= 4;
                        }
                        if (t >= 0x02) {
                            r += 2;
                            t >>>= 2;
                        }
                        return r + t;
                    };
                }

                BN.prototype._zeroBits = function _zeroBits(w) {
                    // Short-cut
                    if (w === 0) return 26;

                    var t = w;
                    var r = 0;
                    if ((t & 0x1fff) === 0) {
                        r += 13;
                        t >>>= 13;
                    }
                    if ((t & 0x7f) === 0) {
                        r += 7;
                        t >>>= 7;
                    }
                    if ((t & 0xf) === 0) {
                        r += 4;
                        t >>>= 4;
                    }
                    if ((t & 0x3) === 0) {
                        r += 2;
                        t >>>= 2;
                    }
                    if ((t & 0x1) === 0) {
                        r++;
                    }
                    return r;
                };

                // Return number of used bits in a BN
                BN.prototype.bitLength = function bitLength() {
                    var w = this.words[this.length - 1];
                    var hi = this._countBits(w);
                    return (this.length - 1) * 26 + hi;
                };

                function toBitArray(num) {
                    var w = new Array(num.bitLength());

                    for (var bit = 0; bit < w.length; bit++) {
                        var off = (bit / 26) | 0;
                        var wbit = bit % 26;

                        w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
                    }

                    return w;
                }

                // Number of trailing zero bits
                BN.prototype.zeroBits = function zeroBits() {
                    if (this.isZero()) return 0;

                    var r = 0;
                    for (var i = 0; i < this.length; i++) {
                        var b = this._zeroBits(this.words[i]);
                        r += b;
                        if (b !== 26) break;
                    }
                    return r;
                };

                BN.prototype.byteLength = function byteLength() {
                    return Math.ceil(this.bitLength() / 8);
                };

                BN.prototype.toTwos = function toTwos(width) {
                    if (this.negative !== 0) {
                        return this.abs().inotn(width).iaddn(1);
                    }
                    return this.clone();
                };

                BN.prototype.fromTwos = function fromTwos(width) {
                    if (this.testn(width - 1)) {
                        return this.notn(width).iaddn(1).ineg();
                    }
                    return this.clone();
                };

                BN.prototype.isNeg = function isNeg() {
                    return this.negative !== 0;
                };

                // Return negative clone of `this`
                BN.prototype.neg = function neg() {
                    return this.clone().ineg();
                };

                BN.prototype.ineg = function ineg() {
                    if (!this.isZero()) {
                        this.negative ^= 1;
                    }

                    return this;
                };

                // Or `num` with `this` in-place
                BN.prototype.iuor = function iuor(num) {
                    while (this.length < num.length) {
                        this.words[this.length++] = 0;
                    }

                    for (var i = 0; i < num.length; i++) {
                        this.words[i] = this.words[i] | num.words[i];
                    }

                    return this.strip();
                };

                BN.prototype.ior = function ior(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuor(num);
                };

                // Or `num` with `this`
                BN.prototype.or = function or(num) {
                    if (this.length > num.length) return this.clone().ior(num);
                    return num.clone().ior(this);
                };

                BN.prototype.uor = function uor(num) {
                    if (this.length > num.length) return this.clone().iuor(num);
                    return num.clone().iuor(this);
                };

                // And `num` with `this` in-place
                BN.prototype.iuand = function iuand(num) {
                    // b = min-length(num, this)
                    var b;
                    if (this.length > num.length) {
                        b = num;
                    } else {
                        b = this;
                    }

                    for (var i = 0; i < b.length; i++) {
                        this.words[i] = this.words[i] & num.words[i];
                    }

                    this.length = b.length;

                    return this.strip();
                };

                BN.prototype.iand = function iand(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuand(num);
                };

                // And `num` with `this`
                BN.prototype.and = function and(num) {
                    if (this.length > num.length) return this.clone().iand(num);
                    return num.clone().iand(this);
                };

                BN.prototype.uand = function uand(num) {
                    if (this.length > num.length) return this.clone().iuand(num);
                    return num.clone().iuand(this);
                };

                // Xor `num` with `this` in-place
                BN.prototype.iuxor = function iuxor(num) {
                    // a.length > b.length
                    var a;
                    var b;
                    if (this.length > num.length) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }

                    for (var i = 0; i < b.length; i++) {
                        this.words[i] = a.words[i] ^ b.words[i];
                    }

                    if (this !== a) {
                        for (; i < a.length; i++) {
                            this.words[i] = a.words[i];
                        }
                    }

                    this.length = a.length;

                    return this.strip();
                };

                BN.prototype.ixor = function ixor(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuxor(num);
                };

                // Xor `num` with `this`
                BN.prototype.xor = function xor(num) {
                    if (this.length > num.length) return this.clone().ixor(num);
                    return num.clone().ixor(this);
                };

                BN.prototype.uxor = function uxor(num) {
                    if (this.length > num.length) return this.clone().iuxor(num);
                    return num.clone().iuxor(this);
                };

                // Not ``this`` with ``width`` bitwidth
                BN.prototype.inotn = function inotn(width) {
                    assert(typeof width === 'number' && width >= 0);

                    var bytesNeeded = Math.ceil(width / 26) | 0;
                    var bitsLeft = width % 26;

                    // Extend the buffer with leading zeroes
                    this._expand(bytesNeeded);

                    if (bitsLeft > 0) {
                        bytesNeeded--;
                    }

                    // Handle complete words
                    for (var i = 0; i < bytesNeeded; i++) {
                        this.words[i] = ~this.words[i] & 0x3ffffff;
                    }

                    // Handle the residue
                    if (bitsLeft > 0) {
                        this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
                    }

                    // And remove leading zeroes
                    return this.strip();
                };

                BN.prototype.notn = function notn(width) {
                    return this.clone().inotn(width);
                };

                // Set `bit` of `this`
                BN.prototype.setn = function setn(bit, val) {
                    assert(typeof bit === 'number' && bit >= 0);

                    var off = (bit / 26) | 0;
                    var wbit = bit % 26;

                    this._expand(off + 1);

                    if (val) {
                        this.words[off] = this.words[off] | (1 << wbit);
                    } else {
                        this.words[off] = this.words[off] & ~(1 << wbit);
                    }

                    return this.strip();
                };

                // Add `num` to `this` in-place
                BN.prototype.iadd = function iadd(num) {
                    var r;

                    // negative + positive
                    if (this.negative !== 0 && num.negative === 0) {
                        this.negative = 0;
                        r = this.isub(num);
                        this.negative ^= 1;
                        return this._normSign();

                        // positive + negative
                    } else if (this.negative === 0 && num.negative !== 0) {
                        num.negative = 0;
                        r = this.isub(num);
                        num.negative = 1;
                        return r._normSign();
                    }

                    // a.length > b.length
                    var a, b;
                    if (this.length > num.length) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }

                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                        this.words[i] = r & 0x3ffffff;
                        carry = r >>> 26;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                        r = (a.words[i] | 0) + carry;
                        this.words[i] = r & 0x3ffffff;
                        carry = r >>> 26;
                    }

                    this.length = a.length;
                    if (carry !== 0) {
                        this.words[this.length] = carry;
                        this.length++;
                        // Copy the rest of the words
                    } else if (a !== this) {
                        for (; i < a.length; i++) {
                            this.words[i] = a.words[i];
                        }
                    }

                    return this;
                };

                // Add `num` to `this`
                BN.prototype.add = function add(num) {
                    var res;
                    if (num.negative !== 0 && this.negative === 0) {
                        num.negative = 0;
                        res = this.sub(num);
                        num.negative ^= 1;
                        return res;
                    } else if (num.negative === 0 && this.negative !== 0) {
                        this.negative = 0;
                        res = num.sub(this);
                        this.negative = 1;
                        return res;
                    }

                    if (this.length > num.length) return this.clone().iadd(num);

                    return num.clone().iadd(this);
                };

                // Subtract `num` from `this` in-place
                BN.prototype.isub = function isub(num) {
                    // this - (-num) = this + num
                    if (num.negative !== 0) {
                        num.negative = 0;
                        var r = this.iadd(num);
                        num.negative = 1;
                        return r._normSign();

                        // -this - num = -(this + num)
                    } else if (this.negative !== 0) {
                        this.negative = 0;
                        this.iadd(num);
                        this.negative = 1;
                        return this._normSign();
                    }

                    // At this point both numbers are positive
                    var cmp = this.cmp(num);

                    // Optimization - zeroify
                    if (cmp === 0) {
                        this.negative = 0;
                        this.length = 1;
                        this.words[0] = 0;
                        return this;
                    }

                    // a > b
                    var a, b;
                    if (cmp > 0) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }

                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                        carry = r >> 26;
                        this.words[i] = r & 0x3ffffff;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                        r = (a.words[i] | 0) + carry;
                        carry = r >> 26;
                        this.words[i] = r & 0x3ffffff;
                    }

                    // Copy rest of the words
                    if (carry === 0 && i < a.length && a !== this) {
                        for (; i < a.length; i++) {
                            this.words[i] = a.words[i];
                        }
                    }

                    this.length = Math.max(this.length, i);

                    if (a !== this) {
                        this.negative = 1;
                    }

                    return this.strip();
                };

                // Subtract `num` from `this`
                BN.prototype.sub = function sub(num) {
                    return this.clone().isub(num);
                };

                function smallMulTo(self, num, out) {
                    out.negative = num.negative ^ self.negative;
                    var len = (self.length + num.length) | 0;
                    out.length = len;
                    len = (len - 1) | 0;

                    // Peel one iteration (compiler can't do it, because of code complexity)
                    var a = self.words[0] | 0;
                    var b = num.words[0] | 0;
                    var r = a * b;

                    var lo = r & 0x3ffffff;
                    var carry = (r / 0x4000000) | 0;
                    out.words[0] = lo;

                    for (var k = 1; k < len; k++) {
                        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                        // note that ncarry could be >= 0x3ffffff
                        var ncarry = carry >>> 26;
                        var rword = carry & 0x3ffffff;
                        var maxJ = Math.min(k, num.length - 1);
                        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                            var i = (k - j) | 0;
                            a = self.words[i] | 0;
                            b = num.words[j] | 0;
                            r = a * b + rword;
                            ncarry += (r / 0x4000000) | 0;
                            rword = r & 0x3ffffff;
                        }
                        out.words[k] = rword | 0;
                        carry = ncarry | 0;
                    }
                    if (carry !== 0) {
                        out.words[k] = carry | 0;
                    } else {
                        out.length--;
                    }

                    return out.strip();
                }

                // TODO(indutny): it may be reasonable to omit it for users who don't need
                // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
                // multiplication (like elliptic secp256k1).
                var comb10MulTo = function comb10MulTo(self, num, out) {
                    var a = self.words;
                    var b = num.words;
                    var o = out.words;
                    var c = 0;
                    var lo;
                    var mid;
                    var hi;
                    var a0 = a[0] | 0;
                    var al0 = a0 & 0x1fff;
                    var ah0 = a0 >>> 13;
                    var a1 = a[1] | 0;
                    var al1 = a1 & 0x1fff;
                    var ah1 = a1 >>> 13;
                    var a2 = a[2] | 0;
                    var al2 = a2 & 0x1fff;
                    var ah2 = a2 >>> 13;
                    var a3 = a[3] | 0;
                    var al3 = a3 & 0x1fff;
                    var ah3 = a3 >>> 13;
                    var a4 = a[4] | 0;
                    var al4 = a4 & 0x1fff;
                    var ah4 = a4 >>> 13;
                    var a5 = a[5] | 0;
                    var al5 = a5 & 0x1fff;
                    var ah5 = a5 >>> 13;
                    var a6 = a[6] | 0;
                    var al6 = a6 & 0x1fff;
                    var ah6 = a6 >>> 13;
                    var a7 = a[7] | 0;
                    var al7 = a7 & 0x1fff;
                    var ah7 = a7 >>> 13;
                    var a8 = a[8] | 0;
                    var al8 = a8 & 0x1fff;
                    var ah8 = a8 >>> 13;
                    var a9 = a[9] | 0;
                    var al9 = a9 & 0x1fff;
                    var ah9 = a9 >>> 13;
                    var b0 = b[0] | 0;
                    var bl0 = b0 & 0x1fff;
                    var bh0 = b0 >>> 13;
                    var b1 = b[1] | 0;
                    var bl1 = b1 & 0x1fff;
                    var bh1 = b1 >>> 13;
                    var b2 = b[2] | 0;
                    var bl2 = b2 & 0x1fff;
                    var bh2 = b2 >>> 13;
                    var b3 = b[3] | 0;
                    var bl3 = b3 & 0x1fff;
                    var bh3 = b3 >>> 13;
                    var b4 = b[4] | 0;
                    var bl4 = b4 & 0x1fff;
                    var bh4 = b4 >>> 13;
                    var b5 = b[5] | 0;
                    var bl5 = b5 & 0x1fff;
                    var bh5 = b5 >>> 13;
                    var b6 = b[6] | 0;
                    var bl6 = b6 & 0x1fff;
                    var bh6 = b6 >>> 13;
                    var b7 = b[7] | 0;
                    var bl7 = b7 & 0x1fff;
                    var bh7 = b7 >>> 13;
                    var b8 = b[8] | 0;
                    var bl8 = b8 & 0x1fff;
                    var bh8 = b8 >>> 13;
                    var b9 = b[9] | 0;
                    var bl9 = b9 & 0x1fff;
                    var bh9 = b9 >>> 13;

                    out.negative = self.negative ^ num.negative;
                    out.length = 19;
                    /* k = 0 */
                    lo = Math.imul(al0, bl0);
                    mid = Math.imul(al0, bh0);
                    mid = (mid + Math.imul(ah0, bl0)) | 0;
                    hi = Math.imul(ah0, bh0);
                    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
                    w0 &= 0x3ffffff;
                    /* k = 1 */
                    lo = Math.imul(al1, bl0);
                    mid = Math.imul(al1, bh0);
                    mid = (mid + Math.imul(ah1, bl0)) | 0;
                    hi = Math.imul(ah1, bh0);
                    lo = (lo + Math.imul(al0, bl1)) | 0;
                    mid = (mid + Math.imul(al0, bh1)) | 0;
                    mid = (mid + Math.imul(ah0, bl1)) | 0;
                    hi = (hi + Math.imul(ah0, bh1)) | 0;
                    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
                    w1 &= 0x3ffffff;
                    /* k = 2 */
                    lo = Math.imul(al2, bl0);
                    mid = Math.imul(al2, bh0);
                    mid = (mid + Math.imul(ah2, bl0)) | 0;
                    hi = Math.imul(ah2, bh0);
                    lo = (lo + Math.imul(al1, bl1)) | 0;
                    mid = (mid + Math.imul(al1, bh1)) | 0;
                    mid = (mid + Math.imul(ah1, bl1)) | 0;
                    hi = (hi + Math.imul(ah1, bh1)) | 0;
                    lo = (lo + Math.imul(al0, bl2)) | 0;
                    mid = (mid + Math.imul(al0, bh2)) | 0;
                    mid = (mid + Math.imul(ah0, bl2)) | 0;
                    hi = (hi + Math.imul(ah0, bh2)) | 0;
                    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
                    w2 &= 0x3ffffff;
                    /* k = 3 */
                    lo = Math.imul(al3, bl0);
                    mid = Math.imul(al3, bh0);
                    mid = (mid + Math.imul(ah3, bl0)) | 0;
                    hi = Math.imul(ah3, bh0);
                    lo = (lo + Math.imul(al2, bl1)) | 0;
                    mid = (mid + Math.imul(al2, bh1)) | 0;
                    mid = (mid + Math.imul(ah2, bl1)) | 0;
                    hi = (hi + Math.imul(ah2, bh1)) | 0;
                    lo = (lo + Math.imul(al1, bl2)) | 0;
                    mid = (mid + Math.imul(al1, bh2)) | 0;
                    mid = (mid + Math.imul(ah1, bl2)) | 0;
                    hi = (hi + Math.imul(ah1, bh2)) | 0;
                    lo = (lo + Math.imul(al0, bl3)) | 0;
                    mid = (mid + Math.imul(al0, bh3)) | 0;
                    mid = (mid + Math.imul(ah0, bl3)) | 0;
                    hi = (hi + Math.imul(ah0, bh3)) | 0;
                    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
                    w3 &= 0x3ffffff;
                    /* k = 4 */
                    lo = Math.imul(al4, bl0);
                    mid = Math.imul(al4, bh0);
                    mid = (mid + Math.imul(ah4, bl0)) | 0;
                    hi = Math.imul(ah4, bh0);
                    lo = (lo + Math.imul(al3, bl1)) | 0;
                    mid = (mid + Math.imul(al3, bh1)) | 0;
                    mid = (mid + Math.imul(ah3, bl1)) | 0;
                    hi = (hi + Math.imul(ah3, bh1)) | 0;
                    lo = (lo + Math.imul(al2, bl2)) | 0;
                    mid = (mid + Math.imul(al2, bh2)) | 0;
                    mid = (mid + Math.imul(ah2, bl2)) | 0;
                    hi = (hi + Math.imul(ah2, bh2)) | 0;
                    lo = (lo + Math.imul(al1, bl3)) | 0;
                    mid = (mid + Math.imul(al1, bh3)) | 0;
                    mid = (mid + Math.imul(ah1, bl3)) | 0;
                    hi = (hi + Math.imul(ah1, bh3)) | 0;
                    lo = (lo + Math.imul(al0, bl4)) | 0;
                    mid = (mid + Math.imul(al0, bh4)) | 0;
                    mid = (mid + Math.imul(ah0, bl4)) | 0;
                    hi = (hi + Math.imul(ah0, bh4)) | 0;
                    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
                    w4 &= 0x3ffffff;
                    /* k = 5 */
                    lo = Math.imul(al5, bl0);
                    mid = Math.imul(al5, bh0);
                    mid = (mid + Math.imul(ah5, bl0)) | 0;
                    hi = Math.imul(ah5, bh0);
                    lo = (lo + Math.imul(al4, bl1)) | 0;
                    mid = (mid + Math.imul(al4, bh1)) | 0;
                    mid = (mid + Math.imul(ah4, bl1)) | 0;
                    hi = (hi + Math.imul(ah4, bh1)) | 0;
                    lo = (lo + Math.imul(al3, bl2)) | 0;
                    mid = (mid + Math.imul(al3, bh2)) | 0;
                    mid = (mid + Math.imul(ah3, bl2)) | 0;
                    hi = (hi + Math.imul(ah3, bh2)) | 0;
                    lo = (lo + Math.imul(al2, bl3)) | 0;
                    mid = (mid + Math.imul(al2, bh3)) | 0;
                    mid = (mid + Math.imul(ah2, bl3)) | 0;
                    hi = (hi + Math.imul(ah2, bh3)) | 0;
                    lo = (lo + Math.imul(al1, bl4)) | 0;
                    mid = (mid + Math.imul(al1, bh4)) | 0;
                    mid = (mid + Math.imul(ah1, bl4)) | 0;
                    hi = (hi + Math.imul(ah1, bh4)) | 0;
                    lo = (lo + Math.imul(al0, bl5)) | 0;
                    mid = (mid + Math.imul(al0, bh5)) | 0;
                    mid = (mid + Math.imul(ah0, bl5)) | 0;
                    hi = (hi + Math.imul(ah0, bh5)) | 0;
                    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
                    w5 &= 0x3ffffff;
                    /* k = 6 */
                    lo = Math.imul(al6, bl0);
                    mid = Math.imul(al6, bh0);
                    mid = (mid + Math.imul(ah6, bl0)) | 0;
                    hi = Math.imul(ah6, bh0);
                    lo = (lo + Math.imul(al5, bl1)) | 0;
                    mid = (mid + Math.imul(al5, bh1)) | 0;
                    mid = (mid + Math.imul(ah5, bl1)) | 0;
                    hi = (hi + Math.imul(ah5, bh1)) | 0;
                    lo = (lo + Math.imul(al4, bl2)) | 0;
                    mid = (mid + Math.imul(al4, bh2)) | 0;
                    mid = (mid + Math.imul(ah4, bl2)) | 0;
                    hi = (hi + Math.imul(ah4, bh2)) | 0;
                    lo = (lo + Math.imul(al3, bl3)) | 0;
                    mid = (mid + Math.imul(al3, bh3)) | 0;
                    mid = (mid + Math.imul(ah3, bl3)) | 0;
                    hi = (hi + Math.imul(ah3, bh3)) | 0;
                    lo = (lo + Math.imul(al2, bl4)) | 0;
                    mid = (mid + Math.imul(al2, bh4)) | 0;
                    mid = (mid + Math.imul(ah2, bl4)) | 0;
                    hi = (hi + Math.imul(ah2, bh4)) | 0;
                    lo = (lo + Math.imul(al1, bl5)) | 0;
                    mid = (mid + Math.imul(al1, bh5)) | 0;
                    mid = (mid + Math.imul(ah1, bl5)) | 0;
                    hi = (hi + Math.imul(ah1, bh5)) | 0;
                    lo = (lo + Math.imul(al0, bl6)) | 0;
                    mid = (mid + Math.imul(al0, bh6)) | 0;
                    mid = (mid + Math.imul(ah0, bl6)) | 0;
                    hi = (hi + Math.imul(ah0, bh6)) | 0;
                    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
                    w6 &= 0x3ffffff;
                    /* k = 7 */
                    lo = Math.imul(al7, bl0);
                    mid = Math.imul(al7, bh0);
                    mid = (mid + Math.imul(ah7, bl0)) | 0;
                    hi = Math.imul(ah7, bh0);
                    lo = (lo + Math.imul(al6, bl1)) | 0;
                    mid = (mid + Math.imul(al6, bh1)) | 0;
                    mid = (mid + Math.imul(ah6, bl1)) | 0;
                    hi = (hi + Math.imul(ah6, bh1)) | 0;
                    lo = (lo + Math.imul(al5, bl2)) | 0;
                    mid = (mid + Math.imul(al5, bh2)) | 0;
                    mid = (mid + Math.imul(ah5, bl2)) | 0;
                    hi = (hi + Math.imul(ah5, bh2)) | 0;
                    lo = (lo + Math.imul(al4, bl3)) | 0;
                    mid = (mid + Math.imul(al4, bh3)) | 0;
                    mid = (mid + Math.imul(ah4, bl3)) | 0;
                    hi = (hi + Math.imul(ah4, bh3)) | 0;
                    lo = (lo + Math.imul(al3, bl4)) | 0;
                    mid = (mid + Math.imul(al3, bh4)) | 0;
                    mid = (mid + Math.imul(ah3, bl4)) | 0;
                    hi = (hi + Math.imul(ah3, bh4)) | 0;
                    lo = (lo + Math.imul(al2, bl5)) | 0;
                    mid = (mid + Math.imul(al2, bh5)) | 0;
                    mid = (mid + Math.imul(ah2, bl5)) | 0;
                    hi = (hi + Math.imul(ah2, bh5)) | 0;
                    lo = (lo + Math.imul(al1, bl6)) | 0;
                    mid = (mid + Math.imul(al1, bh6)) | 0;
                    mid = (mid + Math.imul(ah1, bl6)) | 0;
                    hi = (hi + Math.imul(ah1, bh6)) | 0;
                    lo = (lo + Math.imul(al0, bl7)) | 0;
                    mid = (mid + Math.imul(al0, bh7)) | 0;
                    mid = (mid + Math.imul(ah0, bl7)) | 0;
                    hi = (hi + Math.imul(ah0, bh7)) | 0;
                    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
                    w7 &= 0x3ffffff;
                    /* k = 8 */
                    lo = Math.imul(al8, bl0);
                    mid = Math.imul(al8, bh0);
                    mid = (mid + Math.imul(ah8, bl0)) | 0;
                    hi = Math.imul(ah8, bh0);
                    lo = (lo + Math.imul(al7, bl1)) | 0;
                    mid = (mid + Math.imul(al7, bh1)) | 0;
                    mid = (mid + Math.imul(ah7, bl1)) | 0;
                    hi = (hi + Math.imul(ah7, bh1)) | 0;
                    lo = (lo + Math.imul(al6, bl2)) | 0;
                    mid = (mid + Math.imul(al6, bh2)) | 0;
                    mid = (mid + Math.imul(ah6, bl2)) | 0;
                    hi = (hi + Math.imul(ah6, bh2)) | 0;
                    lo = (lo + Math.imul(al5, bl3)) | 0;
                    mid = (mid + Math.imul(al5, bh3)) | 0;
                    mid = (mid + Math.imul(ah5, bl3)) | 0;
                    hi = (hi + Math.imul(ah5, bh3)) | 0;
                    lo = (lo + Math.imul(al4, bl4)) | 0;
                    mid = (mid + Math.imul(al4, bh4)) | 0;
                    mid = (mid + Math.imul(ah4, bl4)) | 0;
                    hi = (hi + Math.imul(ah4, bh4)) | 0;
                    lo = (lo + Math.imul(al3, bl5)) | 0;
                    mid = (mid + Math.imul(al3, bh5)) | 0;
                    mid = (mid + Math.imul(ah3, bl5)) | 0;
                    hi = (hi + Math.imul(ah3, bh5)) | 0;
                    lo = (lo + Math.imul(al2, bl6)) | 0;
                    mid = (mid + Math.imul(al2, bh6)) | 0;
                    mid = (mid + Math.imul(ah2, bl6)) | 0;
                    hi = (hi + Math.imul(ah2, bh6)) | 0;
                    lo = (lo + Math.imul(al1, bl7)) | 0;
                    mid = (mid + Math.imul(al1, bh7)) | 0;
                    mid = (mid + Math.imul(ah1, bl7)) | 0;
                    hi = (hi + Math.imul(ah1, bh7)) | 0;
                    lo = (lo + Math.imul(al0, bl8)) | 0;
                    mid = (mid + Math.imul(al0, bh8)) | 0;
                    mid = (mid + Math.imul(ah0, bl8)) | 0;
                    hi = (hi + Math.imul(ah0, bh8)) | 0;
                    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
                    w8 &= 0x3ffffff;
                    /* k = 9 */
                    lo = Math.imul(al9, bl0);
                    mid = Math.imul(al9, bh0);
                    mid = (mid + Math.imul(ah9, bl0)) | 0;
                    hi = Math.imul(ah9, bh0);
                    lo = (lo + Math.imul(al8, bl1)) | 0;
                    mid = (mid + Math.imul(al8, bh1)) | 0;
                    mid = (mid + Math.imul(ah8, bl1)) | 0;
                    hi = (hi + Math.imul(ah8, bh1)) | 0;
                    lo = (lo + Math.imul(al7, bl2)) | 0;
                    mid = (mid + Math.imul(al7, bh2)) | 0;
                    mid = (mid + Math.imul(ah7, bl2)) | 0;
                    hi = (hi + Math.imul(ah7, bh2)) | 0;
                    lo = (lo + Math.imul(al6, bl3)) | 0;
                    mid = (mid + Math.imul(al6, bh3)) | 0;
                    mid = (mid + Math.imul(ah6, bl3)) | 0;
                    hi = (hi + Math.imul(ah6, bh3)) | 0;
                    lo = (lo + Math.imul(al5, bl4)) | 0;
                    mid = (mid + Math.imul(al5, bh4)) | 0;
                    mid = (mid + Math.imul(ah5, bl4)) | 0;
                    hi = (hi + Math.imul(ah5, bh4)) | 0;
                    lo = (lo + Math.imul(al4, bl5)) | 0;
                    mid = (mid + Math.imul(al4, bh5)) | 0;
                    mid = (mid + Math.imul(ah4, bl5)) | 0;
                    hi = (hi + Math.imul(ah4, bh5)) | 0;
                    lo = (lo + Math.imul(al3, bl6)) | 0;
                    mid = (mid + Math.imul(al3, bh6)) | 0;
                    mid = (mid + Math.imul(ah3, bl6)) | 0;
                    hi = (hi + Math.imul(ah3, bh6)) | 0;
                    lo = (lo + Math.imul(al2, bl7)) | 0;
                    mid = (mid + Math.imul(al2, bh7)) | 0;
                    mid = (mid + Math.imul(ah2, bl7)) | 0;
                    hi = (hi + Math.imul(ah2, bh7)) | 0;
                    lo = (lo + Math.imul(al1, bl8)) | 0;
                    mid = (mid + Math.imul(al1, bh8)) | 0;
                    mid = (mid + Math.imul(ah1, bl8)) | 0;
                    hi = (hi + Math.imul(ah1, bh8)) | 0;
                    lo = (lo + Math.imul(al0, bl9)) | 0;
                    mid = (mid + Math.imul(al0, bh9)) | 0;
                    mid = (mid + Math.imul(ah0, bl9)) | 0;
                    hi = (hi + Math.imul(ah0, bh9)) | 0;
                    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
                    w9 &= 0x3ffffff;
                    /* k = 10 */
                    lo = Math.imul(al9, bl1);
                    mid = Math.imul(al9, bh1);
                    mid = (mid + Math.imul(ah9, bl1)) | 0;
                    hi = Math.imul(ah9, bh1);
                    lo = (lo + Math.imul(al8, bl2)) | 0;
                    mid = (mid + Math.imul(al8, bh2)) | 0;
                    mid = (mid + Math.imul(ah8, bl2)) | 0;
                    hi = (hi + Math.imul(ah8, bh2)) | 0;
                    lo = (lo + Math.imul(al7, bl3)) | 0;
                    mid = (mid + Math.imul(al7, bh3)) | 0;
                    mid = (mid + Math.imul(ah7, bl3)) | 0;
                    hi = (hi + Math.imul(ah7, bh3)) | 0;
                    lo = (lo + Math.imul(al6, bl4)) | 0;
                    mid = (mid + Math.imul(al6, bh4)) | 0;
                    mid = (mid + Math.imul(ah6, bl4)) | 0;
                    hi = (hi + Math.imul(ah6, bh4)) | 0;
                    lo = (lo + Math.imul(al5, bl5)) | 0;
                    mid = (mid + Math.imul(al5, bh5)) | 0;
                    mid = (mid + Math.imul(ah5, bl5)) | 0;
                    hi = (hi + Math.imul(ah5, bh5)) | 0;
                    lo = (lo + Math.imul(al4, bl6)) | 0;
                    mid = (mid + Math.imul(al4, bh6)) | 0;
                    mid = (mid + Math.imul(ah4, bl6)) | 0;
                    hi = (hi + Math.imul(ah4, bh6)) | 0;
                    lo = (lo + Math.imul(al3, bl7)) | 0;
                    mid = (mid + Math.imul(al3, bh7)) | 0;
                    mid = (mid + Math.imul(ah3, bl7)) | 0;
                    hi = (hi + Math.imul(ah3, bh7)) | 0;
                    lo = (lo + Math.imul(al2, bl8)) | 0;
                    mid = (mid + Math.imul(al2, bh8)) | 0;
                    mid = (mid + Math.imul(ah2, bl8)) | 0;
                    hi = (hi + Math.imul(ah2, bh8)) | 0;
                    lo = (lo + Math.imul(al1, bl9)) | 0;
                    mid = (mid + Math.imul(al1, bh9)) | 0;
                    mid = (mid + Math.imul(ah1, bl9)) | 0;
                    hi = (hi + Math.imul(ah1, bh9)) | 0;
                    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
                    w10 &= 0x3ffffff;
                    /* k = 11 */
                    lo = Math.imul(al9, bl2);
                    mid = Math.imul(al9, bh2);
                    mid = (mid + Math.imul(ah9, bl2)) | 0;
                    hi = Math.imul(ah9, bh2);
                    lo = (lo + Math.imul(al8, bl3)) | 0;
                    mid = (mid + Math.imul(al8, bh3)) | 0;
                    mid = (mid + Math.imul(ah8, bl3)) | 0;
                    hi = (hi + Math.imul(ah8, bh3)) | 0;
                    lo = (lo + Math.imul(al7, bl4)) | 0;
                    mid = (mid + Math.imul(al7, bh4)) | 0;
                    mid = (mid + Math.imul(ah7, bl4)) | 0;
                    hi = (hi + Math.imul(ah7, bh4)) | 0;
                    lo = (lo + Math.imul(al6, bl5)) | 0;
                    mid = (mid + Math.imul(al6, bh5)) | 0;
                    mid = (mid + Math.imul(ah6, bl5)) | 0;
                    hi = (hi + Math.imul(ah6, bh5)) | 0;
                    lo = (lo + Math.imul(al5, bl6)) | 0;
                    mid = (mid + Math.imul(al5, bh6)) | 0;
                    mid = (mid + Math.imul(ah5, bl6)) | 0;
                    hi = (hi + Math.imul(ah5, bh6)) | 0;
                    lo = (lo + Math.imul(al4, bl7)) | 0;
                    mid = (mid + Math.imul(al4, bh7)) | 0;
                    mid = (mid + Math.imul(ah4, bl7)) | 0;
                    hi = (hi + Math.imul(ah4, bh7)) | 0;
                    lo = (lo + Math.imul(al3, bl8)) | 0;
                    mid = (mid + Math.imul(al3, bh8)) | 0;
                    mid = (mid + Math.imul(ah3, bl8)) | 0;
                    hi = (hi + Math.imul(ah3, bh8)) | 0;
                    lo = (lo + Math.imul(al2, bl9)) | 0;
                    mid = (mid + Math.imul(al2, bh9)) | 0;
                    mid = (mid + Math.imul(ah2, bl9)) | 0;
                    hi = (hi + Math.imul(ah2, bh9)) | 0;
                    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
                    w11 &= 0x3ffffff;
                    /* k = 12 */
                    lo = Math.imul(al9, bl3);
                    mid = Math.imul(al9, bh3);
                    mid = (mid + Math.imul(ah9, bl3)) | 0;
                    hi = Math.imul(ah9, bh3);
                    lo = (lo + Math.imul(al8, bl4)) | 0;
                    mid = (mid + Math.imul(al8, bh4)) | 0;
                    mid = (mid + Math.imul(ah8, bl4)) | 0;
                    hi = (hi + Math.imul(ah8, bh4)) | 0;
                    lo = (lo + Math.imul(al7, bl5)) | 0;
                    mid = (mid + Math.imul(al7, bh5)) | 0;
                    mid = (mid + Math.imul(ah7, bl5)) | 0;
                    hi = (hi + Math.imul(ah7, bh5)) | 0;
                    lo = (lo + Math.imul(al6, bl6)) | 0;
                    mid = (mid + Math.imul(al6, bh6)) | 0;
                    mid = (mid + Math.imul(ah6, bl6)) | 0;
                    hi = (hi + Math.imul(ah6, bh6)) | 0;
                    lo = (lo + Math.imul(al5, bl7)) | 0;
                    mid = (mid + Math.imul(al5, bh7)) | 0;
                    mid = (mid + Math.imul(ah5, bl7)) | 0;
                    hi = (hi + Math.imul(ah5, bh7)) | 0;
                    lo = (lo + Math.imul(al4, bl8)) | 0;
                    mid = (mid + Math.imul(al4, bh8)) | 0;
                    mid = (mid + Math.imul(ah4, bl8)) | 0;
                    hi = (hi + Math.imul(ah4, bh8)) | 0;
                    lo = (lo + Math.imul(al3, bl9)) | 0;
                    mid = (mid + Math.imul(al3, bh9)) | 0;
                    mid = (mid + Math.imul(ah3, bl9)) | 0;
                    hi = (hi + Math.imul(ah3, bh9)) | 0;
                    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
                    w12 &= 0x3ffffff;
                    /* k = 13 */
                    lo = Math.imul(al9, bl4);
                    mid = Math.imul(al9, bh4);
                    mid = (mid + Math.imul(ah9, bl4)) | 0;
                    hi = Math.imul(ah9, bh4);
                    lo = (lo + Math.imul(al8, bl5)) | 0;
                    mid = (mid + Math.imul(al8, bh5)) | 0;
                    mid = (mid + Math.imul(ah8, bl5)) | 0;
                    hi = (hi + Math.imul(ah8, bh5)) | 0;
                    lo = (lo + Math.imul(al7, bl6)) | 0;
                    mid = (mid + Math.imul(al7, bh6)) | 0;
                    mid = (mid + Math.imul(ah7, bl6)) | 0;
                    hi = (hi + Math.imul(ah7, bh6)) | 0;
                    lo = (lo + Math.imul(al6, bl7)) | 0;
                    mid = (mid + Math.imul(al6, bh7)) | 0;
                    mid = (mid + Math.imul(ah6, bl7)) | 0;
                    hi = (hi + Math.imul(ah6, bh7)) | 0;
                    lo = (lo + Math.imul(al5, bl8)) | 0;
                    mid = (mid + Math.imul(al5, bh8)) | 0;
                    mid = (mid + Math.imul(ah5, bl8)) | 0;
                    hi = (hi + Math.imul(ah5, bh8)) | 0;
                    lo = (lo + Math.imul(al4, bl9)) | 0;
                    mid = (mid + Math.imul(al4, bh9)) | 0;
                    mid = (mid + Math.imul(ah4, bl9)) | 0;
                    hi = (hi + Math.imul(ah4, bh9)) | 0;
                    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
                    w13 &= 0x3ffffff;
                    /* k = 14 */
                    lo = Math.imul(al9, bl5);
                    mid = Math.imul(al9, bh5);
                    mid = (mid + Math.imul(ah9, bl5)) | 0;
                    hi = Math.imul(ah9, bh5);
                    lo = (lo + Math.imul(al8, bl6)) | 0;
                    mid = (mid + Math.imul(al8, bh6)) | 0;
                    mid = (mid + Math.imul(ah8, bl6)) | 0;
                    hi = (hi + Math.imul(ah8, bh6)) | 0;
                    lo = (lo + Math.imul(al7, bl7)) | 0;
                    mid = (mid + Math.imul(al7, bh7)) | 0;
                    mid = (mid + Math.imul(ah7, bl7)) | 0;
                    hi = (hi + Math.imul(ah7, bh7)) | 0;
                    lo = (lo + Math.imul(al6, bl8)) | 0;
                    mid = (mid + Math.imul(al6, bh8)) | 0;
                    mid = (mid + Math.imul(ah6, bl8)) | 0;
                    hi = (hi + Math.imul(ah6, bh8)) | 0;
                    lo = (lo + Math.imul(al5, bl9)) | 0;
                    mid = (mid + Math.imul(al5, bh9)) | 0;
                    mid = (mid + Math.imul(ah5, bl9)) | 0;
                    hi = (hi + Math.imul(ah5, bh9)) | 0;
                    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
                    w14 &= 0x3ffffff;
                    /* k = 15 */
                    lo = Math.imul(al9, bl6);
                    mid = Math.imul(al9, bh6);
                    mid = (mid + Math.imul(ah9, bl6)) | 0;
                    hi = Math.imul(ah9, bh6);
                    lo = (lo + Math.imul(al8, bl7)) | 0;
                    mid = (mid + Math.imul(al8, bh7)) | 0;
                    mid = (mid + Math.imul(ah8, bl7)) | 0;
                    hi = (hi + Math.imul(ah8, bh7)) | 0;
                    lo = (lo + Math.imul(al7, bl8)) | 0;
                    mid = (mid + Math.imul(al7, bh8)) | 0;
                    mid = (mid + Math.imul(ah7, bl8)) | 0;
                    hi = (hi + Math.imul(ah7, bh8)) | 0;
                    lo = (lo + Math.imul(al6, bl9)) | 0;
                    mid = (mid + Math.imul(al6, bh9)) | 0;
                    mid = (mid + Math.imul(ah6, bl9)) | 0;
                    hi = (hi + Math.imul(ah6, bh9)) | 0;
                    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
                    w15 &= 0x3ffffff;
                    /* k = 16 */
                    lo = Math.imul(al9, bl7);
                    mid = Math.imul(al9, bh7);
                    mid = (mid + Math.imul(ah9, bl7)) | 0;
                    hi = Math.imul(ah9, bh7);
                    lo = (lo + Math.imul(al8, bl8)) | 0;
                    mid = (mid + Math.imul(al8, bh8)) | 0;
                    mid = (mid + Math.imul(ah8, bl8)) | 0;
                    hi = (hi + Math.imul(ah8, bh8)) | 0;
                    lo = (lo + Math.imul(al7, bl9)) | 0;
                    mid = (mid + Math.imul(al7, bh9)) | 0;
                    mid = (mid + Math.imul(ah7, bl9)) | 0;
                    hi = (hi + Math.imul(ah7, bh9)) | 0;
                    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
                    w16 &= 0x3ffffff;
                    /* k = 17 */
                    lo = Math.imul(al9, bl8);
                    mid = Math.imul(al9, bh8);
                    mid = (mid + Math.imul(ah9, bl8)) | 0;
                    hi = Math.imul(ah9, bh8);
                    lo = (lo + Math.imul(al8, bl9)) | 0;
                    mid = (mid + Math.imul(al8, bh9)) | 0;
                    mid = (mid + Math.imul(ah8, bl9)) | 0;
                    hi = (hi + Math.imul(ah8, bh9)) | 0;
                    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
                    w17 &= 0x3ffffff;
                    /* k = 18 */
                    lo = Math.imul(al9, bl9);
                    mid = Math.imul(al9, bh9);
                    mid = (mid + Math.imul(ah9, bl9)) | 0;
                    hi = Math.imul(ah9, bh9);
                    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
                    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
                    w18 &= 0x3ffffff;
                    o[0] = w0;
                    o[1] = w1;
                    o[2] = w2;
                    o[3] = w3;
                    o[4] = w4;
                    o[5] = w5;
                    o[6] = w6;
                    o[7] = w7;
                    o[8] = w8;
                    o[9] = w9;
                    o[10] = w10;
                    o[11] = w11;
                    o[12] = w12;
                    o[13] = w13;
                    o[14] = w14;
                    o[15] = w15;
                    o[16] = w16;
                    o[17] = w17;
                    o[18] = w18;
                    if (c !== 0) {
                        o[19] = c;
                        out.length++;
                    }
                    return out;
                };

                // Polyfill comb
                if (!Math.imul) {
                    comb10MulTo = smallMulTo;
                }

                function bigMulTo(self, num, out) {
                    out.negative = num.negative ^ self.negative;
                    out.length = self.length + num.length;

                    var carry = 0;
                    var hncarry = 0;
                    for (var k = 0; k < out.length - 1; k++) {
                        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                        // note that ncarry could be >= 0x3ffffff
                        var ncarry = hncarry;
                        hncarry = 0;
                        var rword = carry & 0x3ffffff;
                        var maxJ = Math.min(k, num.length - 1);
                        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                            var i = k - j;
                            var a = self.words[i] | 0;
                            var b = num.words[j] | 0;
                            var r = a * b;

                            var lo = r & 0x3ffffff;
                            ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                            lo = (lo + rword) | 0;
                            rword = lo & 0x3ffffff;
                            ncarry = (ncarry + (lo >>> 26)) | 0;

                            hncarry += ncarry >>> 26;
                            ncarry &= 0x3ffffff;
                        }
                        out.words[k] = rword;
                        carry = ncarry;
                        ncarry = hncarry;
                    }
                    if (carry !== 0) {
                        out.words[k] = carry;
                    } else {
                        out.length--;
                    }

                    return out.strip();
                }

                function jumboMulTo(self, num, out) {
                    var fftm = new FFTM();
                    return fftm.mulp(self, num, out);
                }

                BN.prototype.mulTo = function mulTo(num, out) {
                    var res;
                    var len = this.length + num.length;
                    if (this.length === 10 && num.length === 10) {
                        res = comb10MulTo(this, num, out);
                    } else if (len < 63) {
                        res = smallMulTo(this, num, out);
                    } else if (len < 1024) {
                        res = bigMulTo(this, num, out);
                    } else {
                        res = jumboMulTo(this, num, out);
                    }

                    return res;
                };

                // Cooley-Tukey algorithm for FFT
                // slightly revisited to rely on looping instead of recursion

                function FFTM(x, y) {
                    this.x = x;
                    this.y = y;
                }

                FFTM.prototype.makeRBT = function makeRBT(N) {
                    var t = new Array(N);
                    var l = BN.prototype._countBits(N) - 1;
                    for (var i = 0; i < N; i++) {
                        t[i] = this.revBin(i, l, N);
                    }

                    return t;
                };

                // Returns binary-reversed representation of `x`
                FFTM.prototype.revBin = function revBin(x, l, N) {
                    if (x === 0 || x === N - 1) return x;

                    var rb = 0;
                    for (var i = 0; i < l; i++) {
                        rb |= (x & 1) << (l - i - 1);
                        x >>= 1;
                    }

                    return rb;
                };

                // Performs "tweedling" phase, therefore 'emulating'
                // behaviour of the recursive algorithm
                FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
                    for (var i = 0; i < N; i++) {
                        rtws[i] = rws[rbt[i]];
                        itws[i] = iws[rbt[i]];
                    }
                };

                FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);

                    for (var s = 1; s < N; s <<= 1) {
                        var l = s << 1;

                        var rtwdf = Math.cos(2 * Math.PI / l);
                        var itwdf = Math.sin(2 * Math.PI / l);

                        for (var p = 0; p < N; p += l) {
                            var rtwdf_ = rtwdf;
                            var itwdf_ = itwdf;

                            for (var j = 0; j < s; j++) {
                                var re = rtws[p + j];
                                var ie = itws[p + j];

                                var ro = rtws[p + j + s];
                                var io = itws[p + j + s];

                                var rx = rtwdf_ * ro - itwdf_ * io;

                                io = rtwdf_ * io + itwdf_ * ro;
                                ro = rx;

                                rtws[p + j] = re + ro;
                                itws[p + j] = ie + io;

                                rtws[p + j + s] = re - ro;
                                itws[p + j + s] = ie - io;

                                /* jshint maxdepth : false */
                                if (j !== l) {
                                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;

                                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                                    rtwdf_ = rx;
                                }
                            }
                        }
                    }
                };

                FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
                    var N = Math.max(m, n) | 1;
                    var odd = N & 1;
                    var i = 0;
                    for (N = N / 2 | 0; N; N = N >>> 1) {
                        i++;
                    }

                    return 1 << i + 1 + odd;
                };

                FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
                    if (N <= 1) return;

                    for (var i = 0; i < N / 2; i++) {
                        var t = rws[i];

                        rws[i] = rws[N - i - 1];
                        rws[N - i - 1] = t;

                        t = iws[i];

                        iws[i] = -iws[N - i - 1];
                        iws[N - i - 1] = -t;
                    }
                };

                FFTM.prototype.normalize13b = function normalize13b(ws, N) {
                    var carry = 0;
                    for (var i = 0; i < N / 2; i++) {
                        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
                            Math.round(ws[2 * i] / N) +
                            carry;

                        ws[i] = w & 0x3ffffff;

                        if (w < 0x4000000) {
                            carry = 0;
                        } else {
                            carry = w / 0x4000000 | 0;
                        }
                    }

                    return ws;
                };

                FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
                    var carry = 0;
                    for (var i = 0; i < len; i++) {
                        carry = carry + (ws[i] | 0);

                        rws[2 * i] = carry & 0x1fff;
                        carry = carry >>> 13;
                        rws[2 * i + 1] = carry & 0x1fff;
                        carry = carry >>> 13;
                    }

                    // Pad with zeroes
                    for (i = 2 * len; i < N; ++i) {
                        rws[i] = 0;
                    }

                    assert(carry === 0);
                    assert((carry & ~0x1fff) === 0);
                };

                FFTM.prototype.stub = function stub(N) {
                    var ph = new Array(N);
                    for (var i = 0; i < N; i++) {
                        ph[i] = 0;
                    }

                    return ph;
                };

                FFTM.prototype.mulp = function mulp(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length);

                    var rbt = this.makeRBT(N);

                    var _ = this.stub(N);

                    var rws = new Array(N);
                    var rwst = new Array(N);
                    var iwst = new Array(N);

                    var nrws = new Array(N);
                    var nrwst = new Array(N);
                    var niwst = new Array(N);

                    var rmws = out.words;
                    rmws.length = N;

                    this.convert13b(x.words, x.length, rws, N);
                    this.convert13b(y.words, y.length, nrws, N);

                    this.transform(rws, _, rwst, iwst, N, rbt);
                    this.transform(nrws, _, nrwst, niwst, N, rbt);

                    for (var i = 0; i < N; i++) {
                        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                        rwst[i] = rx;
                    }

                    this.conjugate(rwst, iwst, N);
                    this.transform(rwst, iwst, rmws, _, N, rbt);
                    this.conjugate(rmws, _, N);
                    this.normalize13b(rmws, N);

                    out.negative = x.negative ^ y.negative;
                    out.length = x.length + y.length;
                    return out.strip();
                };

                // Multiply `this` by `num`
                BN.prototype.mul = function mul(num) {
                    var out = new BN(null);
                    out.words = new Array(this.length + num.length);
                    return this.mulTo(num, out);
                };

                // Multiply employing FFT
                BN.prototype.mulf = function mulf(num) {
                    var out = new BN(null);
                    out.words = new Array(this.length + num.length);
                    return jumboMulTo(this, num, out);
                };

                // In-place Multiplication
                BN.prototype.imul = function imul(num) {
                    return this.clone().mulTo(num, this);
                };

                BN.prototype.imuln = function imuln(num) {
                    assert(typeof num === 'number');
                    assert(num < 0x4000000);

                    // Carry
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = (this.words[i] | 0) * num;
                        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
                        carry >>= 26;
                        carry += (w / 0x4000000) | 0;
                        // NOTE: lo is 27bit maximum
                        carry += lo >>> 26;
                        this.words[i] = lo & 0x3ffffff;
                    }

                    if (carry !== 0) {
                        this.words[i] = carry;
                        this.length++;
                    }

                    return this;
                };

                BN.prototype.muln = function muln(num) {
                    return this.clone().imuln(num);
                };

                // `this` * `this`
                BN.prototype.sqr = function sqr() {
                    return this.mul(this);
                };

                // `this` * `this` in-place
                BN.prototype.isqr = function isqr() {
                    return this.imul(this.clone());
                };

                // Math.pow(`this`, `num`)
                BN.prototype.pow = function pow(num) {
                    var w = toBitArray(num);
                    if (w.length === 0) return new BN(1);

                    // Skip leading zeroes
                    var res = this;
                    for (var i = 0; i < w.length; i++, res = res.sqr()) {
                        if (w[i] !== 0) break;
                    }

                    if (++i < w.length) {
                        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                            if (w[i] === 0) continue;

                            res = res.mul(q);
                        }
                    }

                    return res;
                };

                // Shift-left in-place
                BN.prototype.iushln = function iushln(bits) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;
                    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
                    var i;

                    if (r !== 0) {
                        var carry = 0;

                        for (i = 0; i < this.length; i++) {
                            var newCarry = this.words[i] & carryMask;
                            var c = ((this.words[i] | 0) - newCarry) << r;
                            this.words[i] = c | carry;
                            carry = newCarry >>> (26 - r);
                        }

                        if (carry) {
                            this.words[i] = carry;
                            this.length++;
                        }
                    }

                    if (s !== 0) {
                        for (i = this.length - 1; i >= 0; i--) {
                            this.words[i + s] = this.words[i];
                        }

                        for (i = 0; i < s; i++) {
                            this.words[i] = 0;
                        }

                        this.length += s;
                    }

                    return this.strip();
                };

                BN.prototype.ishln = function ishln(bits) {
                    // TODO(indutny): implement me
                    assert(this.negative === 0);
                    return this.iushln(bits);
                };

                // Shift-right in-place
                // NOTE: `hint` is a lowest bit before trailing zeroes
                // NOTE: if `extended` is present - it will be filled with destroyed bits
                BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var h;
                    if (hint) {
                        h = (hint - (hint % 26)) / 26;
                    } else {
                        h = 0;
                    }

                    var r = bits % 26;
                    var s = Math.min((bits - r) / 26, this.length);
                    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                    var maskedWords = extended;

                    h -= s;
                    h = Math.max(0, h);

                    // Extended mode, copy masked part
                    if (maskedWords) {
                        for (var i = 0; i < s; i++) {
                            maskedWords.words[i] = this.words[i];
                        }
                        maskedWords.length = s;
                    }

                    if (s === 0) {
                        // No-op, we should not move anything at all
                    } else if (this.length > s) {
                        this.length -= s;
                        for (i = 0; i < this.length; i++) {
                            this.words[i] = this.words[i + s];
                        }
                    } else {
                        this.words[0] = 0;
                        this.length = 1;
                    }

                    var carry = 0;
                    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                        var word = this.words[i] | 0;
                        this.words[i] = (carry << (26 - r)) | (word >>> r);
                        carry = word & mask;
                    }

                    // Push carried bits as a mask
                    if (maskedWords && carry !== 0) {
                        maskedWords.words[maskedWords.length++] = carry;
                    }

                    if (this.length === 0) {
                        this.words[0] = 0;
                        this.length = 1;
                    }

                    return this.strip();
                };

                BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                    // TODO(indutny): implement me
                    assert(this.negative === 0);
                    return this.iushrn(bits, hint, extended);
                };

                // Shift-left
                BN.prototype.shln = function shln(bits) {
                    return this.clone().ishln(bits);
                };

                BN.prototype.ushln = function ushln(bits) {
                    return this.clone().iushln(bits);
                };

                // Shift-right
                BN.prototype.shrn = function shrn(bits) {
                    return this.clone().ishrn(bits);
                };

                BN.prototype.ushrn = function ushrn(bits) {
                    return this.clone().iushrn(bits);
                };

                // Test if n bit is set
                BN.prototype.testn = function testn(bit) {
                    assert(typeof bit === 'number' && bit >= 0);
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;

                    // Fast case: bit is much higher than all existing words
                    if (this.length <= s) return false;

                    // Check bit and return
                    var w = this.words[s];

                    return !!(w & q);
                };

                // Return only lowers bits of number (in-place)
                BN.prototype.imaskn = function imaskn(bits) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;

                    assert(this.negative === 0, 'imaskn works only with positive numbers');

                    if (this.length <= s) {
                        return this;
                    }

                    if (r !== 0) {
                        s++;
                    }
                    this.length = Math.min(s, this.length);

                    if (r !== 0) {
                        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                        this.words[this.length - 1] &= mask;
                    }

                    return this.strip();
                };

                // Return only lowers bits of number
                BN.prototype.maskn = function maskn(bits) {
                    return this.clone().imaskn(bits);
                };

                // Add plain number `num` to `this`
                BN.prototype.iaddn = function iaddn(num) {
                    assert(typeof num === 'number');
                    assert(num < 0x4000000);
                    if (num < 0) return this.isubn(-num);

                    // Possible sign change
                    if (this.negative !== 0) {
                        if (this.length === 1 && (this.words[0] | 0) < num) {
                            this.words[0] = num - (this.words[0] | 0);
                            this.negative = 0;
                            return this;
                        }

                        this.negative = 0;
                        this.isubn(num);
                        this.negative = 1;
                        return this;
                    }

                    // Add without checks
                    return this._iaddn(num);
                };

                BN.prototype._iaddn = function _iaddn(num) {
                    this.words[0] += num;

                    // Carry
                    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
                        this.words[i] -= 0x4000000;
                        if (i === this.length - 1) {
                            this.words[i + 1] = 1;
                        } else {
                            this.words[i + 1]++;
                        }
                    }
                    this.length = Math.max(this.length, i + 1);

                    return this;
                };

                // Subtract plain number `num` from `this`
                BN.prototype.isubn = function isubn(num) {
                    assert(typeof num === 'number');
                    assert(num < 0x4000000);
                    if (num < 0) return this.iaddn(-num);

                    if (this.negative !== 0) {
                        this.negative = 0;
                        this.iaddn(num);
                        this.negative = 1;
                        return this;
                    }

                    this.words[0] -= num;

                    if (this.length === 1 && this.words[0] < 0) {
                        this.words[0] = -this.words[0];
                        this.negative = 1;
                    } else {
                        // Carry
                        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                            this.words[i] += 0x4000000;
                            this.words[i + 1] -= 1;
                        }
                    }

                    return this.strip();
                };

                BN.prototype.addn = function addn(num) {
                    return this.clone().iaddn(num);
                };

                BN.prototype.subn = function subn(num) {
                    return this.clone().isubn(num);
                };

                BN.prototype.iabs = function iabs() {
                    this.negative = 0;

                    return this;
                };

                BN.prototype.abs = function abs() {
                    return this.clone().iabs();
                };

                BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                    var len = num.length + shift;
                    var i;

                    this._expand(len);

                    var w;
                    var carry = 0;
                    for (i = 0; i < num.length; i++) {
                        w = (this.words[i + shift] | 0) + carry;
                        var right = (num.words[i] | 0) * mul;
                        w -= right & 0x3ffffff;
                        carry = (w >> 26) - ((right / 0x4000000) | 0);
                        this.words[i + shift] = w & 0x3ffffff;
                    }
                    for (; i < this.length - shift; i++) {
                        w = (this.words[i + shift] | 0) + carry;
                        carry = w >> 26;
                        this.words[i + shift] = w & 0x3ffffff;
                    }

                    if (carry === 0) return this.strip();

                    // Subtraction overflow
                    assert(carry === -1);
                    carry = 0;
                    for (i = 0; i < this.length; i++) {
                        w = -(this.words[i] | 0) + carry;
                        carry = w >> 26;
                        this.words[i] = w & 0x3ffffff;
                    }
                    this.negative = 1;

                    return this.strip();
                };

                BN.prototype._wordDiv = function _wordDiv(num, mode) {
                    var shift = this.length - num.length;

                    var a = this.clone();
                    var b = num;

                    // Normalize
                    var bhi = b.words[b.length - 1] | 0;
                    var bhiBits = this._countBits(bhi);
                    shift = 26 - bhiBits;
                    if (shift !== 0) {
                        b = b.ushln(shift);
                        a.iushln(shift);
                        bhi = b.words[b.length - 1] | 0;
                    }

                    // Initialize quotient
                    var m = a.length - b.length;
                    var q;

                    if (mode !== 'mod') {
                        q = new BN(null);
                        q.length = m + 1;
                        q.words = new Array(q.length);
                        for (var i = 0; i < q.length; i++) {
                            q.words[i] = 0;
                        }
                    }

                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    if (diff.negative === 0) {
                        a = diff;
                        if (q) {
                            q.words[m] = 1;
                        }
                    }

                    for (var j = m - 1; j >= 0; j--) {
                        var qj = (a.words[b.length + j] | 0) * 0x4000000 +
                            (a.words[b.length + j - 1] | 0);

                        // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
                        // (0x7ffffff)
                        qj = Math.min((qj / bhi) | 0, 0x3ffffff);

                        a._ishlnsubmul(b, qj, j);
                        while (a.negative !== 0) {
                            qj--;
                            a.negative = 0;
                            a._ishlnsubmul(b, 1, j);
                            if (!a.isZero()) {
                                a.negative ^= 1;
                            }
                        }
                        if (q) {
                            q.words[j] = qj;
                        }
                    }
                    if (q) {
                        q.strip();
                    }
                    a.strip();

                    // Denormalize
                    if (mode !== 'div' && shift !== 0) {
                        a.iushrn(shift);
                    }

                    return {
                        div: q || null,
                        mod: a
                    };
                };

                // NOTE: 1) `mode` can be set to `mod` to request mod only,
                //       to `div` to request div only, or be absent to
                //       request both div & mod
                //       2) `positive` is true if unsigned mod is requested
                BN.prototype.divmod = function divmod(num, mode, positive) {
                    assert(!num.isZero());

                    if (this.isZero()) {
                        return {
                            div: new BN(0),
                            mod: new BN(0)
                        };
                    }

                    var div, mod, res;
                    if (this.negative !== 0 && num.negative === 0) {
                        res = this.neg().divmod(num, mode);

                        if (mode !== 'mod') {
                            div = res.div.neg();
                        }

                        if (mode !== 'div') {
                            mod = res.mod.neg();
                            if (positive && mod.negative !== 0) {
                                mod.iadd(num);
                            }
                        }

                        return {
                            div: div,
                            mod: mod
                        };
                    }

                    if (this.negative === 0 && num.negative !== 0) {
                        res = this.divmod(num.neg(), mode);

                        if (mode !== 'mod') {
                            div = res.div.neg();
                        }

                        return {
                            div: div,
                            mod: res.mod
                        };
                    }

                    if ((this.negative & num.negative) !== 0) {
                        res = this.neg().divmod(num.neg(), mode);

                        if (mode !== 'div') {
                            mod = res.mod.neg();
                            if (positive && mod.negative !== 0) {
                                mod.isub(num);
                            }
                        }

                        return {
                            div: res.div,
                            mod: mod
                        };
                    }

                    // Both numbers are positive at this point

                    // Strip both numbers to approximate shift value
                    if (num.length > this.length || this.cmp(num) < 0) {
                        return {
                            div: new BN(0),
                            mod: this
                        };
                    }

                    // Very short reduction
                    if (num.length === 1) {
                        if (mode === 'div') {
                            return {
                                div: this.divn(num.words[0]),
                                mod: null
                            };
                        }

                        if (mode === 'mod') {
                            return {
                                div: null,
                                mod: new BN(this.modn(num.words[0]))
                            };
                        }

                        return {
                            div: this.divn(num.words[0]),
                            mod: new BN(this.modn(num.words[0]))
                        };
                    }

                    return this._wordDiv(num, mode);
                };

                // Find `this` / `num`
                BN.prototype.div = function div(num) {
                    return this.divmod(num, 'div', false).div;
                };

                // Find `this` % `num`
                BN.prototype.mod = function mod(num) {
                    return this.divmod(num, 'mod', false).mod;
                };

                BN.prototype.umod = function umod(num) {
                    return this.divmod(num, 'mod', true).mod;
                };

                // Find Round(`this` / `num`)
                BN.prototype.divRound = function divRound(num) {
                    var dm = this.divmod(num);

                    // Fast case - exact division
                    if (dm.mod.isZero()) return dm.div;

                    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

                    var half = num.ushrn(1);
                    var r2 = num.andln(1);
                    var cmp = mod.cmp(half);

                    // Round down
                    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

                    // Round up
                    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
                };

                BN.prototype.modn = function modn(num) {
                    assert(num <= 0x3ffffff);
                    var p = (1 << 26) % num;

                    var acc = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                        acc = (p * acc + (this.words[i] | 0)) % num;
                    }

                    return acc;
                };

                // In-place division by number
                BN.prototype.idivn = function idivn(num) {
                    assert(num <= 0x3ffffff);

                    var carry = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                        var w = (this.words[i] | 0) + carry * 0x4000000;
                        this.words[i] = (w / num) | 0;
                        carry = w % num;
                    }

                    return this.strip();
                };

                BN.prototype.divn = function divn(num) {
                    return this.clone().idivn(num);
                };

                BN.prototype.egcd = function egcd(p) {
                    assert(p.negative === 0);
                    assert(!p.isZero());

                    var x = this;
                    var y = p.clone();

                    if (x.negative !== 0) {
                        x = x.umod(p);
                    } else {
                        x = x.clone();
                    }

                    // A * x + B * y = x
                    var A = new BN(1);
                    var B = new BN(0);

                    // C * x + D * y = y
                    var C = new BN(0);
                    var D = new BN(1);

                    var g = 0;

                    while (x.isEven() && y.isEven()) {
                        x.iushrn(1);
                        y.iushrn(1);
                        ++g;
                    }

                    var yp = y.clone();
                    var xp = x.clone();

                    while (!x.isZero()) {
                        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                        if (i > 0) {
                            x.iushrn(i);
                            while (i-- > 0) {
                                if (A.isOdd() || B.isOdd()) {
                                    A.iadd(yp);
                                    B.isub(xp);
                                }

                                A.iushrn(1);
                                B.iushrn(1);
                            }
                        }

                        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                        if (j > 0) {
                            y.iushrn(j);
                            while (j-- > 0) {
                                if (C.isOdd() || D.isOdd()) {
                                    C.iadd(yp);
                                    D.isub(xp);
                                }

                                C.iushrn(1);
                                D.iushrn(1);
                            }
                        }

                        if (x.cmp(y) >= 0) {
                            x.isub(y);
                            A.isub(C);
                            B.isub(D);
                        } else {
                            y.isub(x);
                            C.isub(A);
                            D.isub(B);
                        }
                    }

                    return {
                        a: C,
                        b: D,
                        gcd: y.iushln(g)
                    };
                };

                // This is reduced incarnation of the binary EEA
                // above, designated to invert members of the
                // _prime_ fields F(p) at a maximal speed
                BN.prototype._invmp = function _invmp(p) {
                    assert(p.negative === 0);
                    assert(!p.isZero());

                    var a = this;
                    var b = p.clone();

                    if (a.negative !== 0) {
                        a = a.umod(p);
                    } else {
                        a = a.clone();
                    }

                    var x1 = new BN(1);
                    var x2 = new BN(0);

                    var delta = b.clone();

                    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                        if (i > 0) {
                            a.iushrn(i);
                            while (i-- > 0) {
                                if (x1.isOdd()) {
                                    x1.iadd(delta);
                                }

                                x1.iushrn(1);
                            }
                        }

                        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                        if (j > 0) {
                            b.iushrn(j);
                            while (j-- > 0) {
                                if (x2.isOdd()) {
                                    x2.iadd(delta);
                                }

                                x2.iushrn(1);
                            }
                        }

                        if (a.cmp(b) >= 0) {
                            a.isub(b);
                            x1.isub(x2);
                        } else {
                            b.isub(a);
                            x2.isub(x1);
                        }
                    }

                    var res;
                    if (a.cmpn(1) === 0) {
                        res = x1;
                    } else {
                        res = x2;
                    }

                    if (res.cmpn(0) < 0) {
                        res.iadd(p);
                    }

                    return res;
                };

                BN.prototype.gcd = function gcd(num) {
                    if (this.isZero()) return num.abs();
                    if (num.isZero()) return this.abs();

                    var a = this.clone();
                    var b = num.clone();
                    a.negative = 0;
                    b.negative = 0;

                    // Remove common factor of two
                    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                        a.iushrn(1);
                        b.iushrn(1);
                    }

                    do {
                        while (a.isEven()) {
                            a.iushrn(1);
                        }
                        while (b.isEven()) {
                            b.iushrn(1);
                        }

                        var r = a.cmp(b);
                        if (r < 0) {
                            // Swap `a` and `b` to make `a` always bigger than `b`
                            var t = a;
                            a = b;
                            b = t;
                        } else if (r === 0 || b.cmpn(1) === 0) {
                            break;
                        }

                        a.isub(b);
                    } while (true);

                    return b.iushln(shift);
                };

                // Invert number in the field F(num)
                BN.prototype.invm = function invm(num) {
                    return this.egcd(num).a.umod(num);
                };

                BN.prototype.isEven = function isEven() {
                    return (this.words[0] & 1) === 0;
                };

                BN.prototype.isOdd = function isOdd() {
                    return (this.words[0] & 1) === 1;
                };

                // And first word and num
                BN.prototype.andln = function andln(num) {
                    return this.words[0] & num;
                };

                // Increment at the bit position in-line
                BN.prototype.bincn = function bincn(bit) {
                    assert(typeof bit === 'number');
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;

                    // Fast case: bit is much higher than all existing words
                    if (this.length <= s) {
                        this._expand(s + 1);
                        this.words[s] |= q;
                        return this;
                    }

                    // Add bit and propagate, if needed
                    var carry = q;
                    for (var i = s; carry !== 0 && i < this.length; i++) {
                        var w = this.words[i] | 0;
                        w += carry;
                        carry = w >>> 26;
                        w &= 0x3ffffff;
                        this.words[i] = w;
                    }
                    if (carry !== 0) {
                        this.words[i] = carry;
                        this.length++;
                    }
                    return this;
                };

                BN.prototype.isZero = function isZero() {
                    return this.length === 1 && this.words[0] === 0;
                };

                BN.prototype.cmpn = function cmpn(num) {
                    var negative = num < 0;

                    if (this.negative !== 0 && !negative) return -1;
                    if (this.negative === 0 && negative) return 1;

                    this.strip();

                    var res;
                    if (this.length > 1) {
                        res = 1;
                    } else {
                        if (negative) {
                            num = -num;
                        }

                        assert(num <= 0x3ffffff, 'Number is too big');

                        var w = this.words[0] | 0;
                        res = w === num ? 0 : w < num ? -1 : 1;
                    }
                    if (this.negative !== 0) return -res | 0;
                    return res;
                };

                // Compare two numbers and return:
                // 1 - if `this` > `num`
                // 0 - if `this` == `num`
                // -1 - if `this` < `num`
                BN.prototype.cmp = function cmp(num) {
                    if (this.negative !== 0 && num.negative === 0) return -1;
                    if (this.negative === 0 && num.negative !== 0) return 1;

                    var res = this.ucmp(num);
                    if (this.negative !== 0) return -res | 0;
                    return res;
                };

                // Unsigned comparison
                BN.prototype.ucmp = function ucmp(num) {
                    // At this point both numbers have the same sign
                    if (this.length > num.length) return 1;
                    if (this.length < num.length) return -1;

                    var res = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                        var a = this.words[i] | 0;
                        var b = num.words[i] | 0;

                        if (a === b) continue;
                        if (a < b) {
                            res = -1;
                        } else if (a > b) {
                            res = 1;
                        }
                        break;
                    }
                    return res;
                };

                BN.prototype.gtn = function gtn(num) {
                    return this.cmpn(num) === 1;
                };

                BN.prototype.gt = function gt(num) {
                    return this.cmp(num) === 1;
                };

                BN.prototype.gten = function gten(num) {
                    return this.cmpn(num) >= 0;
                };

                BN.prototype.gte = function gte(num) {
                    return this.cmp(num) >= 0;
                };

                BN.prototype.ltn = function ltn(num) {
                    return this.cmpn(num) === -1;
                };

                BN.prototype.lt = function lt(num) {
                    return this.cmp(num) === -1;
                };

                BN.prototype.lten = function lten(num) {
                    return this.cmpn(num) <= 0;
                };

                BN.prototype.lte = function lte(num) {
                    return this.cmp(num) <= 0;
                };

                BN.prototype.eqn = function eqn(num) {
                    return this.cmpn(num) === 0;
                };

                BN.prototype.eq = function eq(num) {
                    return this.cmp(num) === 0;
                };

                //
                // A reduce context, could be using montgomery or something better, depending
                // on the `m` itself.
                //
                BN.red = function red(num) {
                    return new Red(num);
                };

                BN.prototype.toRed = function toRed(ctx) {
                    assert(!this.red, 'Already a number in reduction context');
                    assert(this.negative === 0, 'red works only with positives');
                    return ctx.convertTo(this)._forceRed(ctx);
                };

                BN.prototype.fromRed = function fromRed() {
                    assert(this.red, 'fromRed works only with numbers in reduction context');
                    return this.red.convertFrom(this);
                };

                BN.prototype._forceRed = function _forceRed(ctx) {
                    this.red = ctx;
                    return this;
                };

                BN.prototype.forceRed = function forceRed(ctx) {
                    assert(!this.red, 'Already a number in reduction context');
                    return this._forceRed(ctx);
                };

                BN.prototype.redAdd = function redAdd(num) {
                    assert(this.red, 'redAdd works only with red numbers');
                    return this.red.add(this, num);
                };

                BN.prototype.redIAdd = function redIAdd(num) {
                    assert(this.red, 'redIAdd works only with red numbers');
                    return this.red.iadd(this, num);
                };

                BN.prototype.redSub = function redSub(num) {
                    assert(this.red, 'redSub works only with red numbers');
                    return this.red.sub(this, num);
                };

                BN.prototype.redISub = function redISub(num) {
                    assert(this.red, 'redISub works only with red numbers');
                    return this.red.isub(this, num);
                };

                BN.prototype.redShl = function redShl(num) {
                    assert(this.red, 'redShl works only with red numbers');
                    return this.red.shl(this, num);
                };

                BN.prototype.redMul = function redMul(num) {
                    assert(this.red, 'redMul works only with red numbers');
                    this.red._verify2(this, num);
                    return this.red.mul(this, num);
                };

                BN.prototype.redIMul = function redIMul(num) {
                    assert(this.red, 'redMul works only with red numbers');
                    this.red._verify2(this, num);
                    return this.red.imul(this, num);
                };

                BN.prototype.redSqr = function redSqr() {
                    assert(this.red, 'redSqr works only with red numbers');
                    this.red._verify1(this);
                    return this.red.sqr(this);
                };

                BN.prototype.redISqr = function redISqr() {
                    assert(this.red, 'redISqr works only with red numbers');
                    this.red._verify1(this);
                    return this.red.isqr(this);
                };

                // Square root over p
                BN.prototype.redSqrt = function redSqrt() {
                    assert(this.red, 'redSqrt works only with red numbers');
                    this.red._verify1(this);
                    return this.red.sqrt(this);
                };

                BN.prototype.redInvm = function redInvm() {
                    assert(this.red, 'redInvm works only with red numbers');
                    this.red._verify1(this);
                    return this.red.invm(this);
                };

                // Return negative clone of `this` % `red modulo`
                BN.prototype.redNeg = function redNeg() {
                    assert(this.red, 'redNeg works only with red numbers');
                    this.red._verify1(this);
                    return this.red.neg(this);
                };

                BN.prototype.redPow = function redPow(num) {
                    assert(this.red && !num.red, 'redPow(normalNum)');
                    this.red._verify1(this);
                    return this.red.pow(this, num);
                };

                // Prime numbers with efficient reduction
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };

                // Pseudo-Mersenne prime
                function MPrime(name, p) {
                    // P = 2 ^ N - K
                    this.name = name;
                    this.p = new BN(p, 16);
                    this.n = this.p.bitLength();
                    this.k = new BN(1).iushln(this.n).isub(this.p);

                    this.tmp = this._tmp();
                }

                MPrime.prototype._tmp = function _tmp() {
                    var tmp = new BN(null);
                    tmp.words = new Array(Math.ceil(this.n / 13));
                    return tmp;
                };

                MPrime.prototype.ireduce = function ireduce(num) {
                    // Assumes that `num` is less than `P^2`
                    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
                    var r = num;
                    var rlen;

                    do {
                        this.split(r, this.tmp);
                        r = this.imulK(r);
                        r = r.iadd(this.tmp);
                        rlen = r.bitLength();
                    } while (rlen > this.n);

                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    if (cmp === 0) {
                        r.words[0] = 0;
                        r.length = 1;
                    } else if (cmp > 0) {
                        r.isub(this.p);
                    } else {
                        r.strip();
                    }

                    return r;
                };

                MPrime.prototype.split = function split(input, out) {
                    input.iushrn(this.n, 0, out);
                };

                MPrime.prototype.imulK = function imulK(num) {
                    return num.imul(this.k);
                };

                function K256() {
                    MPrime.call(
                        this,
                        'k256',
                        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }

                inherits(K256, MPrime);

                K256.prototype.split = function split(input, output) {
                    // 256 = 9 * 26 + 22
                    var mask = 0x3fffff;

                    var outLen = Math.min(input.length, 9);
                    for (var i = 0; i < outLen; i++) {
                        output.words[i] = input.words[i];
                    }
                    output.length = outLen;

                    if (input.length <= 9) {
                        input.words[0] = 0;
                        input.length = 1;
                        return;
                    }

                    // Shift by 9 limbs
                    var prev = input.words[9];
                    output.words[output.length++] = prev & mask;

                    for (i = 10; i < input.length; i++) {
                        var next = input.words[i] | 0;
                        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                        prev = next;
                    }
                    prev >>>= 22;
                    input.words[i - 10] = prev;
                    if (prev === 0 && input.length > 10) {
                        input.length -= 10;
                    } else {
                        input.length -= 9;
                    }
                };

                K256.prototype.imulK = function imulK(num) {
                    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
                    num.words[num.length] = 0;
                    num.words[num.length + 1] = 0;
                    num.length += 2;

                    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
                    var lo = 0;
                    for (var i = 0; i < num.length; i++) {
                        var w = num.words[i] | 0;
                        lo += w * 0x3d1;
                        num.words[i] = lo & 0x3ffffff;
                        lo = w * 0x40 + ((lo / 0x4000000) | 0);
                    }

                    // Fast length reduction
                    if (num.words[num.length - 1] === 0) {
                        num.length--;
                        if (num.words[num.length - 1] === 0) {
                            num.length--;
                        }
                    }
                    return num;
                };

                function P224() {
                    MPrime.call(
                        this,
                        'p224',
                        'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }

                inherits(P224, MPrime);

                function P192() {
                    MPrime.call(
                        this,
                        'p192',
                        'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }

                inherits(P192, MPrime);

                function P25519() {
                    // 2 ^ 255 - 19
                    MPrime.call(
                        this,
                        '25519',
                        '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }

                inherits(P25519, MPrime);

                P25519.prototype.imulK = function imulK(num) {
                    // K = 0x13
                    var carry = 0;
                    for (var i = 0; i < num.length; i++) {
                        var hi = (num.words[i] | 0) * 0x13 + carry;
                        var lo = hi & 0x3ffffff;
                        hi >>>= 26;

                        num.words[i] = lo;
                        carry = hi;
                    }
                    if (carry !== 0) {
                        num.words[num.length++] = carry;
                    }
                    return num;
                };

                // Exported mostly for testing purposes, use plain name instead
                BN._prime = function prime(name) {
                    // Cached version of prime
                    if (primes[name]) return primes[name];

                    var prime;
                    if (name === 'k256') {
                        prime = new K256();
                    } else if (name === 'p224') {
                        prime = new P224();
                    } else if (name === 'p192') {
                        prime = new P192();
                    } else if (name === 'p25519') {
                        prime = new P25519();
                    } else {
                        throw new Error('Unknown prime ' + name);
                    }
                    primes[name] = prime;

                    return prime;
                };

                //
                // Base reduction engine
                //
                function Red(m) {
                    if (typeof m === 'string') {
                        var prime = BN._prime(m);
                        this.m = prime.p;
                        this.prime = prime;
                    } else {
                        assert(m.gtn(1), 'modulus must be greater than 1');
                        this.m = m;
                        this.prime = null;
                    }
                }

                Red.prototype._verify1 = function _verify1(a) {
                    assert(a.negative === 0, 'red works only with positives');
                    assert(a.red, 'red works only with red numbers');
                };

                Red.prototype._verify2 = function _verify2(a, b) {
                    assert((a.negative | b.negative) === 0, 'red works only with positives');
                    assert(a.red && a.red === b.red,
                        'red works only with red numbers');
                };

                Red.prototype.imod = function imod(a) {
                    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                    return a.umod(this.m)._forceRed(this);
                };

                Red.prototype.neg = function neg(a) {
                    if (a.isZero()) {
                        return a.clone();
                    }

                    return this.m.sub(a)._forceRed(this);
                };

                Red.prototype.add = function add(a, b) {
                    this._verify2(a, b);

                    var res = a.add(b);
                    if (res.cmp(this.m) >= 0) {
                        res.isub(this.m);
                    }
                    return res._forceRed(this);
                };

                Red.prototype.iadd = function iadd(a, b) {
                    this._verify2(a, b);

                    var res = a.iadd(b);
                    if (res.cmp(this.m) >= 0) {
                        res.isub(this.m);
                    }
                    return res;
                };

                Red.prototype.sub = function sub(a, b) {
                    this._verify2(a, b);

                    var res = a.sub(b);
                    if (res.cmpn(0) < 0) {
                        res.iadd(this.m);
                    }
                    return res._forceRed(this);
                };

                Red.prototype.isub = function isub(a, b) {
                    this._verify2(a, b);

                    var res = a.isub(b);
                    if (res.cmpn(0) < 0) {
                        res.iadd(this.m);
                    }
                    return res;
                };

                Red.prototype.shl = function shl(a, num) {
                    this._verify1(a);
                    return this.imod(a.ushln(num));
                };

                Red.prototype.imul = function imul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.imul(b));
                };

                Red.prototype.mul = function mul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.mul(b));
                };

                Red.prototype.isqr = function isqr(a) {
                    return this.imul(a, a.clone());
                };

                Red.prototype.sqr = function sqr(a) {
                    return this.mul(a, a);
                };

                Red.prototype.sqrt = function sqrt(a) {
                    if (a.isZero()) return a.clone();

                    var mod3 = this.m.andln(3);
                    assert(mod3 % 2 === 1);

                    // Fast case
                    if (mod3 === 3) {
                        var pow = this.m.add(new BN(1)).iushrn(2);
                        return this.pow(a, pow);
                    }

                    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
                    //
                    // Find Q and S, that Q * 2 ^ S = (P - 1)
                    var q = this.m.subn(1);
                    var s = 0;
                    while (!q.isZero() && q.andln(1) === 0) {
                        s++;
                        q.iushrn(1);
                    }
                    assert(!q.isZero());

                    var one = new BN(1).toRed(this);
                    var nOne = one.redNeg();

                    // Find quadratic non-residue
                    // NOTE: Max is such because of generalized Riemann hypothesis.
                    var lpow = this.m.subn(1).iushrn(1);
                    var z = this.m.bitLength();
                    z = new BN(2 * z * z).toRed(this);

                    while (this.pow(z, lpow).cmp(nOne) !== 0) {
                        z.redIAdd(nOne);
                    }

                    var c = this.pow(z, q);
                    var r = this.pow(a, q.addn(1).iushrn(1));
                    var t = this.pow(a, q);
                    var m = s;
                    while (t.cmp(one) !== 0) {
                        var tmp = t;
                        for (var i = 0; tmp.cmp(one) !== 0; i++) {
                            tmp = tmp.redSqr();
                        }
                        assert(i < m);
                        var b = this.pow(c, new BN(1).iushln(m - i - 1));

                        r = r.redMul(b);
                        c = b.redSqr();
                        t = t.redMul(c);
                        m = i;
                    }

                    return r;
                };

                Red.prototype.invm = function invm(a) {
                    var inv = a._invmp(this.m);
                    if (inv.negative !== 0) {
                        inv.negative = 0;
                        return this.imod(inv).redNeg();
                    } else {
                        return this.imod(inv);
                    }
                };

                Red.prototype.pow = function pow(a, num) {
                    if (num.isZero()) return new BN(1).toRed(this);
                    if (num.cmpn(1) === 0) return a.clone();

                    var windowSize = 4;
                    var wnd = new Array(1 << windowSize);
                    wnd[0] = new BN(1).toRed(this);
                    wnd[1] = a;
                    for (var i = 2; i < wnd.length; i++) {
                        wnd[i] = this.mul(wnd[i - 1], a);
                    }

                    var res = wnd[0];
                    var current = 0;
                    var currentLen = 0;
                    var start = num.bitLength() % 26;
                    if (start === 0) {
                        start = 26;
                    }

                    for (i = num.length - 1; i >= 0; i--) {
                        var word = num.words[i];
                        for (var j = start - 1; j >= 0; j--) {
                            var bit = (word >> j) & 1;
                            if (res !== wnd[0]) {
                                res = this.sqr(res);
                            }

                            if (bit === 0 && current === 0) {
                                currentLen = 0;
                                continue;
                            }

                            current <<= 1;
                            current |= bit;
                            currentLen++;
                            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

                            res = this.mul(res, wnd[current]);
                            currentLen = 0;
                            current = 0;
                        }
                        start = 26;
                    }

                    return res;
                };

                Red.prototype.convertTo = function convertTo(num) {
                    var r = num.umod(this.m);

                    return r === num ? r.clone() : r;
                };

                Red.prototype.convertFrom = function convertFrom(num) {
                    var res = num.clone();
                    res.red = null;
                    return res;
                };

                //
                // Montgomery method engine
                //

                BN.mont = function mont(num) {
                    return new Mont(num);
                };

                function Mont(m) {
                    Red.call(this, m);

                    this.shift = this.m.bitLength();
                    if (this.shift % 26 !== 0) {
                        this.shift += 26 - (this.shift % 26);
                    }

                    this.r = new BN(1).iushln(this.shift);
                    this.r2 = this.imod(this.r.sqr());
                    this.rinv = this.r._invmp(this.m);

                    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                    this.minv = this.minv.umod(this.r);
                    this.minv = this.r.sub(this.minv);
                }

                inherits(Mont, Red);

                Mont.prototype.convertTo = function convertTo(num) {
                    return this.imod(num.ushln(this.shift));
                };

                Mont.prototype.convertFrom = function convertFrom(num) {
                    var r = this.imod(num.mul(this.rinv));
                    r.red = null;
                    return r;
                };

                Mont.prototype.imul = function imul(a, b) {
                    if (a.isZero() || b.isZero()) {
                        a.words[0] = 0;
                        a.length = 1;
                        return a;
                    }

                    var t = a.imul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).iushrn(this.shift);
                    var res = u;

                    if (u.cmp(this.m) >= 0) {
                        res = u.isub(this.m);
                    } else if (u.cmpn(0) < 0) {
                        res = u.iadd(this.m);
                    }

                    return res._forceRed(this);
                };

                Mont.prototype.mul = function mul(a, b) {
                    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

                    var t = a.mul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).iushrn(this.shift);
                    var res = u;
                    if (u.cmp(this.m) >= 0) {
                        res = u.isub(this.m);
                    } else if (u.cmpn(0) < 0) {
                        res = u.iadd(this.m);
                    }

                    return res._forceRed(this);
                };

                Mont.prototype.invm = function invm(a) {
                    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
                    var res = this.imod(a._invmp(this.m).mul(this.r2));
                    return res._forceRed(this);
                };
            })(typeof module === 'undefined' || module, this);

        }, { 'buffer': 29 }],
        28: [function(require, module, exports) {
            var r;

            module.exports = function rand(len) {
                if (!r)
                    r = new Rand(null);

                return r.generate(len);
            };

            function Rand(rand) {
                this.rand = rand;
            }

            module.exports.Rand = Rand;

            Rand.prototype.generate = function generate(len) {
                return this._rand(len);
            };

// Emulate crypto API using randy
            Rand.prototype._rand = function _rand(n) {
                if (this.rand.getBytes)
                    return this.rand.getBytes(n);

                var res = new Uint8Array(n);
                for (var i = 0; i < res.length; i++)
                    res[i] = this.rand.getByte();
                return res;
            };

            if (typeof self === 'object') {
                if (self.crypto && self.crypto.getRandomValues) {
                    // Modern browsers
                    Rand.prototype._rand = function _rand(n) {
                        var arr = new Uint8Array(n);
                        self.crypto.getRandomValues(arr);
                        return arr;
                    };
                } else if (self.msCrypto && self.msCrypto.getRandomValues) {
                    // IE
                    Rand.prototype._rand = function _rand(n) {
                        var arr = new Uint8Array(n);
                        self.msCrypto.getRandomValues(arr);
                        return arr;
                    };

                    // Safari's WebWorkers do not have `crypto`
                } else if (typeof window === 'object') {
                    // Old junk
                    Rand.prototype._rand = function() {
                        throw new Error('Not implemented yet');
                    };
                }
            } else {
                // Node.js or Web worker with no crypto support
                try {
                    var crypto = require('crypto');
                    if (typeof crypto.randomBytes !== 'function')
                        throw new Error('Not supported');

                    Rand.prototype._rand = function _rand(n) {
                        return crypto.randomBytes(n);
                    };
                } catch (e) {
                }
            }

        }, { 'crypto': 29 }],
        29: [function(require, module, exports) {

        }, {}],
        30: [function(require, module, exports) {
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

            var Buffer = require('safe-buffer').Buffer;

            function asUInt32Array(buf) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);

                var len = (buf.length / 4) | 0;
                var out = new Array(len);

                for (var i = 0; i < len; i++) {
                    out[i] = buf.readUInt32BE(i * 4);
                }

                return out;
            }

            function scrubVec(v) {
                for (var i = 0; i < v.length; v++) {
                    v[i] = 0;
                }
            }

            function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
                var SUB_MIX0 = SUB_MIX[0];
                var SUB_MIX1 = SUB_MIX[1];
                var SUB_MIX2 = SUB_MIX[2];
                var SUB_MIX3 = SUB_MIX[3];

                var s0 = M[0] ^ keySchedule[0];
                var s1 = M[1] ^ keySchedule[1];
                var s2 = M[2] ^ keySchedule[2];
                var s3 = M[3] ^ keySchedule[3];
                var t0, t1, t2, t3;
                var ksRow = 4;

                for (var round = 1; round < nRounds; round++) {
                    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
                    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
                    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
                    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
                    s0 = t0;
                    s1 = t1;
                    s2 = t2;
                    s3 = t3;
                }

                t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
                t0 = t0 >>> 0;
                t1 = t1 >>> 0;
                t2 = t2 >>> 0;
                t3 = t3 >>> 0;

                return [t0, t1, t2, t3];
            }

// AES constants
            var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
            var G = (function() {
                // Compute double table
                var d = new Array(256);
                for (var j = 0; j < 256; j++) {
                    if (j < 128) {
                        d[j] = j << 1;
                    } else {
                        d[j] = (j << 1) ^ 0x11b;
                    }
                }

                var SBOX = [];
                var INV_SBOX = [];
                var SUB_MIX = [[], [], [], []];
                var INV_SUB_MIX = [[], [], [], []];

                // Walk GF(2^8)
                var x = 0;
                var xi = 0;
                for (var i = 0; i < 256; ++i) {
                    // Compute sbox
                    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                    SBOX[x] = sx;
                    INV_SBOX[sx] = x;

                    // Compute multiplication
                    var x2 = d[x];
                    var x4 = d[x2];
                    var x8 = d[x4];

                    // Compute sub bytes, mix columns tables
                    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                    SUB_MIX[0][x] = (t << 24) | (t >>> 8);
                    SUB_MIX[1][x] = (t << 16) | (t >>> 16);
                    SUB_MIX[2][x] = (t << 8) | (t >>> 24);
                    SUB_MIX[3][x] = t;

                    // Compute inv sub bytes, inv mix columns tables
                    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
                    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
                    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
                    INV_SUB_MIX[3][sx] = t;

                    if (x === 0) {
                        x = xi = 1;
                    } else {
                        x = x2 ^ d[d[d[x8 ^ x2]]];
                        xi ^= d[d[xi]];
                    }
                }

                return {
                    SBOX: SBOX,
                    INV_SBOX: INV_SBOX,
                    SUB_MIX: SUB_MIX,
                    INV_SUB_MIX: INV_SUB_MIX
                };
            })();

            function AES(key) {
                this._key = asUInt32Array(key);
                this._reset();
            }

            AES.blockSize = 4 * 4;
            AES.keySize = 256 / 8;
            AES.prototype.blockSize = AES.blockSize;
            AES.prototype.keySize = AES.keySize;
            AES.prototype._reset = function() {
                var keyWords = this._key;
                var keySize = keyWords.length;
                var nRounds = keySize + 6;
                var ksRows = (nRounds + 1) * 4;

                var keySchedule = [];
                for (var k = 0; k < keySize; k++) {
                    keySchedule[k] = keyWords[k];
                }

                for (k = keySize; k < ksRows; k++) {
                    var t = keySchedule[k - 1];

                    if (k % keySize === 0) {
                        t = (t << 8) | (t >>> 24);
                        t =
                            (G.SBOX[t >>> 24] << 24) |
                            (G.SBOX[(t >>> 16) & 0xff] << 16) |
                            (G.SBOX[(t >>> 8) & 0xff] << 8) |
                            (G.SBOX[t & 0xff]);

                        t ^= RCON[(k / keySize) | 0] << 24;
                    } else if (keySize > 6 && k % keySize === 4) {
                        t =
                            (G.SBOX[t >>> 24] << 24) |
                            (G.SBOX[(t >>> 16) & 0xff] << 16) |
                            (G.SBOX[(t >>> 8) & 0xff] << 8) |
                            (G.SBOX[t & 0xff]);
                    }

                    keySchedule[k] = keySchedule[k - keySize] ^ t;
                }

                var invKeySchedule = [];
                for (var ik = 0; ik < ksRows; ik++) {
                    var ksR = ksRows - ik;
                    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

                    if (ik < 4 || ksR <= 4) {
                        invKeySchedule[ik] = tt;
                    } else {
                        invKeySchedule[ik] =
                            G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
                            G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
                            G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
                            G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
                    }
                }

                this._nRounds = nRounds;
                this._keySchedule = keySchedule;
                this._invKeySchedule = invKeySchedule;
            };

            AES.prototype.encryptBlockRaw = function(M) {
                M = asUInt32Array(M);
                return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
            };

            AES.prototype.encryptBlock = function(M) {
                var out = this.encryptBlockRaw(M);
                var buf = Buffer.allocUnsafe(16);
                buf.writeUInt32BE(out[0], 0);
                buf.writeUInt32BE(out[1], 4);
                buf.writeUInt32BE(out[2], 8);
                buf.writeUInt32BE(out[3], 12);
                return buf;
            };

            AES.prototype.decryptBlock = function(M) {
                M = asUInt32Array(M);

                // swap
                var m1 = M[1];
                M[1] = M[3];
                M[3] = m1;

                var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
                var buf = Buffer.allocUnsafe(16);
                buf.writeUInt32BE(out[0], 0);
                buf.writeUInt32BE(out[3], 4);
                buf.writeUInt32BE(out[2], 8);
                buf.writeUInt32BE(out[1], 12);
                return buf;
            };

            AES.prototype.scrub = function() {
                scrubVec(this._keySchedule);
                scrubVec(this._invKeySchedule);
                scrubVec(this._key);
            };

            module.exports.AES = AES;

        }, { 'safe-buffer': 169 }],
        31: [function(require, module, exports) {
            var aes = require('./aes');
            var Buffer = require('safe-buffer').Buffer;
            var Transform = require('cipher-base');
            var inherits = require('inherits');
            var GHASH = require('./ghash');
            var xor = require('buffer-xor');
            var incr32 = require('./incr32');

            function xorTest(a, b) {
                var out = 0;
                if (a.length !== b.length) out++;

                var len = Math.min(a.length, b.length);
                for (var i = 0; i < len; ++i) {
                    out += (a[i] ^ b[i]);
                }

                return out;
            }

            function calcIv(self, iv, ck) {
                if (iv.length === 12) {
                    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
                    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
                }
                var ghash = new GHASH(ck);
                var len = iv.length;
                var toPad = len % 16;
                ghash.update(iv);
                if (toPad) {
                    toPad = 16 - toPad;
                    ghash.update(Buffer.alloc(toPad, 0));
                }
                ghash.update(Buffer.alloc(8, 0));
                var ivBits = len * 8;
                var tail = Buffer.alloc(8);
                tail.writeUIntBE(ivBits, 0, 8);
                ghash.update(tail);
                self._finID = ghash.state;
                var out = Buffer.from(self._finID);
                incr32(out);
                return out;
            }

            function StreamCipher(mode, key, iv, decrypt) {
                Transform.call(this);

                var h = Buffer.alloc(4, 0);

                this._cipher = new aes.AES(key);
                var ck = this._cipher.encryptBlock(h);
                this._ghash = new GHASH(ck);
                iv = calcIv(this, iv, ck);

                this._prev = Buffer.from(iv);
                this._cache = Buffer.allocUnsafe(0);
                this._secCache = Buffer.allocUnsafe(0);
                this._decrypt = decrypt;
                this._alen = 0;
                this._len = 0;
                this._mode = mode;

                this._authTag = null;
                this._called = false;
            }

            inherits(StreamCipher, Transform);

            StreamCipher.prototype._update = function(chunk) {
                if (!this._called && this._alen) {
                    var rump = 16 - (this._alen % 16);
                    if (rump < 16) {
                        rump = Buffer.alloc(rump, 0);
                        this._ghash.update(rump);
                    }
                }

                this._called = true;
                var out = this._mode.encrypt(this, chunk);
                if (this._decrypt) {
                    this._ghash.update(chunk);
                } else {
                    this._ghash.update(out);
                }
                this._len += chunk.length;
                return out;
            };

            StreamCipher.prototype._final = function() {
                if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data');

                var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
                if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data');

                this._authTag = tag;
                this._cipher.scrub();
            };

            StreamCipher.prototype.getAuthTag = function getAuthTag() {
                if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state');

                return this._authTag;
            };

            StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
                if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');

                this._authTag = tag;
            };

            StreamCipher.prototype.setAAD = function setAAD(buf) {
                if (this._called) throw new Error('Attempting to set AAD in unsupported state');

                this._ghash.update(buf);
                this._alen += buf.length;
            };

            module.exports = StreamCipher;

        }, {
            './aes': 30,
            './ghash': 35,
            './incr32': 36,
            'buffer-xor': 58,
            'cipher-base': 61,
            'inherits': 116,
            'safe-buffer': 169
        }],
        32: [function(require, module, exports) {
            var ciphers = require('./encrypter');
            var deciphers = require('./decrypter');
            var modes = require('./modes/list.json');

            function getCiphers() {
                return Object.keys(modes);
            }

            exports.createCipher = exports.Cipher = ciphers.createCipher;
            exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
            exports.createDecipher = exports.Decipher = deciphers.createDecipher;
            exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
            exports.listCiphers = exports.getCiphers = getCiphers;

        }, { './decrypter': 33, './encrypter': 34, './modes/list.json': 44 }],
        33: [function(require, module, exports) {
            var AuthCipher = require('./authCipher');
            var Buffer = require('safe-buffer').Buffer;
            var MODES = require('./modes');
            var StreamCipher = require('./streamCipher');
            var Transform = require('cipher-base');
            var aes = require('./aes');
            var ebtk = require('evp_bytestokey');
            var inherits = require('inherits');

            function Decipher(mode, key, iv) {
                Transform.call(this);

                this._cache = new Splitter();
                this._last = void 0;
                this._cipher = new aes.AES(key);
                this._prev = Buffer.from(iv);
                this._mode = mode;
                this._autopadding = true;
            }

            inherits(Decipher, Transform);

            Decipher.prototype._update = function(data) {
                this._cache.add(data);
                var chunk;
                var thing;
                var out = [];
                while ((chunk = this._cache.get(this._autopadding))) {
                    thing = this._mode.decrypt(this, chunk);
                    out.push(thing);
                }
                return Buffer.concat(out);
            };

            Decipher.prototype._final = function() {
                var chunk = this._cache.flush();
                if (this._autopadding) {
                    return unpad(this._mode.decrypt(this, chunk));
                } else if (chunk) {
                    throw new Error('data not multiple of block length');
                }
            };

            Decipher.prototype.setAutoPadding = function(setTo) {
                this._autopadding = !!setTo;
                return this;
            };

            function Splitter() {
                this.cache = Buffer.allocUnsafe(0);
            }

            Splitter.prototype.add = function(data) {
                this.cache = Buffer.concat([this.cache, data]);
            };

            Splitter.prototype.get = function(autoPadding) {
                var out;
                if (autoPadding) {
                    if (this.cache.length > 16) {
                        out = this.cache.slice(0, 16);
                        this.cache = this.cache.slice(16);
                        return out;
                    }
                } else {
                    if (this.cache.length >= 16) {
                        out = this.cache.slice(0, 16);
                        this.cache = this.cache.slice(16);
                        return out;
                    }
                }

                return null;
            };

            Splitter.prototype.flush = function() {
                if (this.cache.length) return this.cache;
            };

            function unpad(last) {
                var padded = last[15];
                if (padded < 1 || padded > 16) {
                    throw new Error('unable to decrypt data');
                }
                var i = -1;
                while (++i < padded) {
                    if (last[(i + (16 - padded))] !== padded) {
                        throw new Error('unable to decrypt data');
                    }
                }
                if (padded === 16) return;

                return last.slice(0, 16 - padded);
            }

            function createDecipheriv(suite, password, iv) {
                var config = MODES[suite.toLowerCase()];
                if (!config) throw new TypeError('invalid suite type');

                if (typeof iv === 'string') iv = Buffer.from(iv);
                if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);

                if (typeof password === 'string') password = Buffer.from(password);
                if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);

                if (config.type === 'stream') {
                    return new StreamCipher(config.module, password, iv, true);
                } else if (config.type === 'auth') {
                    return new AuthCipher(config.module, password, iv, true);
                }

                return new Decipher(config.module, password, iv);
            }

            function createDecipher(suite, password) {
                var config = MODES[suite.toLowerCase()];
                if (!config) throw new TypeError('invalid suite type');

                var keys = ebtk(password, false, config.key, config.iv);
                return createDecipheriv(suite, keys.key, keys.iv);
            }

            exports.createDecipher = createDecipher;
            exports.createDecipheriv = createDecipheriv;

        }, {
            './aes': 30,
            './authCipher': 31,
            './modes': 43,
            './streamCipher': 46,
            'cipher-base': 61,
            'evp_bytestokey': 98,
            'inherits': 116,
            'safe-buffer': 169
        }],
        34: [function(require, module, exports) {
            var MODES = require('./modes');
            var AuthCipher = require('./authCipher');
            var Buffer = require('safe-buffer').Buffer;
            var StreamCipher = require('./streamCipher');
            var Transform = require('cipher-base');
            var aes = require('./aes');
            var ebtk = require('evp_bytestokey');
            var inherits = require('inherits');

            function Cipher(mode, key, iv) {
                Transform.call(this);

                this._cache = new Splitter();
                this._cipher = new aes.AES(key);
                this._prev = Buffer.from(iv);
                this._mode = mode;
                this._autopadding = true;
            }

            inherits(Cipher, Transform);

            Cipher.prototype._update = function(data) {
                this._cache.add(data);
                var chunk;
                var thing;
                var out = [];

                while ((chunk = this._cache.get())) {
                    thing = this._mode.encrypt(this, chunk);
                    out.push(thing);
                }

                return Buffer.concat(out);
            };

            var PADDING = Buffer.alloc(16, 0x10);

            Cipher.prototype._final = function() {
                var chunk = this._cache.flush();
                if (this._autopadding) {
                    chunk = this._mode.encrypt(this, chunk);
                    this._cipher.scrub();
                    return chunk;
                }

                if (!chunk.equals(PADDING)) {
                    this._cipher.scrub();
                    throw new Error('data not multiple of block length');
                }
            };

            Cipher.prototype.setAutoPadding = function(setTo) {
                this._autopadding = !!setTo;
                return this;
            };

            function Splitter() {
                this.cache = Buffer.allocUnsafe(0);
            }

            Splitter.prototype.add = function(data) {
                this.cache = Buffer.concat([this.cache, data]);
            };

            Splitter.prototype.get = function() {
                if (this.cache.length > 15) {
                    var out = this.cache.slice(0, 16);
                    this.cache = this.cache.slice(16);
                    return out;
                }
                return null;
            };

            Splitter.prototype.flush = function() {
                var len = 16 - this.cache.length;
                var padBuff = Buffer.allocUnsafe(len);

                var i = -1;
                while (++i < len) {
                    padBuff.writeUInt8(len, i);
                }

                return Buffer.concat([this.cache, padBuff]);
            };

            function createCipheriv(suite, password, iv) {
                var config = MODES[suite.toLowerCase()];
                if (!config) throw new TypeError('invalid suite type');

                if (typeof password === 'string') password = Buffer.from(password);
                if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);

                if (typeof iv === 'string') iv = Buffer.from(iv);
                if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);

                if (config.type === 'stream') {
                    return new StreamCipher(config.module, password, iv);
                } else if (config.type === 'auth') {
                    return new AuthCipher(config.module, password, iv);
                }

                return new Cipher(config.module, password, iv);
            }

            function createCipher(suite, password) {
                var config = MODES[suite.toLowerCase()];
                if (!config) throw new TypeError('invalid suite type');

                var keys = ebtk(password, false, config.key, config.iv);
                return createCipheriv(suite, keys.key, keys.iv);
            }

            exports.createCipheriv = createCipheriv;
            exports.createCipher = createCipher;

        }, {
            './aes': 30,
            './authCipher': 31,
            './modes': 43,
            './streamCipher': 46,
            'cipher-base': 61,
            'evp_bytestokey': 98,
            'inherits': 116,
            'safe-buffer': 169
        }],
        35: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;
            var ZEROES = Buffer.alloc(16, 0);

            function toArray(buf) {
                return [
                    buf.readUInt32BE(0),
                    buf.readUInt32BE(4),
                    buf.readUInt32BE(8),
                    buf.readUInt32BE(12)
                ];
            }

            function fromArray(out) {
                var buf = Buffer.allocUnsafe(16);
                buf.writeUInt32BE(out[0] >>> 0, 0);
                buf.writeUInt32BE(out[1] >>> 0, 4);
                buf.writeUInt32BE(out[2] >>> 0, 8);
                buf.writeUInt32BE(out[3] >>> 0, 12);
                return buf;
            }

            function GHASH(key) {
                this.h = key;
                this.state = Buffer.alloc(16, 0);
                this.cache = Buffer.allocUnsafe(0);
            }

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
            GHASH.prototype.ghash = function(block) {
                var i = -1;
                while (++i < block.length) {
                    this.state[i] ^= block[i];
                }
                this._multiply();
            };

            GHASH.prototype._multiply = function() {
                var Vi = toArray(this.h);
                var Zi = [0, 0, 0, 0];
                var j, xi, lsbVi;
                var i = -1;
                while (++i < 128) {
                    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0;
                    if (xi) {
                        // Z_i+1 = Z_i ^ V_i
                        Zi[0] ^= Vi[0];
                        Zi[1] ^= Vi[1];
                        Zi[2] ^= Vi[2];
                        Zi[3] ^= Vi[3];
                    }

                    // Store the value of LSB(V_i)
                    lsbVi = (Vi[3] & 1) !== 0;

                    // V_i+1 = V_i >> 1
                    for (j = 3; j > 0; j--) {
                        Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
                    }
                    Vi[0] = Vi[0] >>> 1;

                    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
                    if (lsbVi) {
                        Vi[0] = Vi[0] ^ (0xe1 << 24);
                    }
                }
                this.state = fromArray(Zi);
            };

            GHASH.prototype.update = function(buf) {
                this.cache = Buffer.concat([this.cache, buf]);
                var chunk;
                while (this.cache.length >= 16) {
                    chunk = this.cache.slice(0, 16);
                    this.cache = this.cache.slice(16);
                    this.ghash(chunk);
                }
            };

            GHASH.prototype.final = function(abl, bl) {
                if (this.cache.length) {
                    this.ghash(Buffer.concat([this.cache, ZEROES], 16));
                }

                this.ghash(fromArray([0, abl, 0, bl]));
                return this.state;
            };

            module.exports = GHASH;

        }, { 'safe-buffer': 169 }],
        36: [function(require, module, exports) {
            function incr32(iv) {
                var len = iv.length;
                var item;
                while (len--) {
                    item = iv.readUInt8(len);
                    if (item === 255) {
                        iv.writeUInt8(0, len);
                    } else {
                        item++;
                        iv.writeUInt8(item, len);
                        break;
                    }
                }
            }

            module.exports = incr32;

        }, {}],
        37: [function(require, module, exports) {
            var xor = require('buffer-xor');

            exports.encrypt = function(self, block) {
                var data = xor(block, self._prev);

                self._prev = self._cipher.encryptBlock(data);
                return self._prev;
            };

            exports.decrypt = function(self, block) {
                var pad = self._prev;

                self._prev = block;
                var out = self._cipher.decryptBlock(block);

                return xor(out, pad);
            };

        }, { 'buffer-xor': 58 }],
        38: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;
            var xor = require('buffer-xor');

            function encryptStart(self, data, decrypt) {
                var len = data.length;
                var out = xor(data, self._cache);
                self._cache = self._cache.slice(len);
                self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
                return out;
            }

            exports.encrypt = function(self, data, decrypt) {
                var out = Buffer.allocUnsafe(0);
                var len;

                while (data.length) {
                    if (self._cache.length === 0) {
                        self._cache = self._cipher.encryptBlock(self._prev);
                        self._prev = Buffer.allocUnsafe(0);
                    }

                    if (self._cache.length <= data.length) {
                        len = self._cache.length;
                        out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
                        data = data.slice(len);
                    } else {
                        out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
                        break;
                    }
                }

                return out;
            };

        }, { 'buffer-xor': 58, 'safe-buffer': 169 }],
        39: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;

            function encryptByte(self, byteParam, decrypt) {
                var pad;
                var i = -1;
                var len = 8;
                var out = 0;
                var bit, value;
                while (++i < len) {
                    pad = self._cipher.encryptBlock(self._prev);
                    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
                    value = pad[0] ^ bit;
                    out += ((value & 0x80) >> (i % 8));
                    self._prev = shiftIn(self._prev, decrypt ? bit : value);
                }
                return out;
            }

            function shiftIn(buffer, value) {
                var len = buffer.length;
                var i = -1;
                var out = Buffer.allocUnsafe(buffer.length);
                buffer = Buffer.concat([buffer, Buffer.from([value])]);

                while (++i < len) {
                    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
                }

                return out;
            }

            exports.encrypt = function(self, chunk, decrypt) {
                var len = chunk.length;
                var out = Buffer.allocUnsafe(len);
                var i = -1;

                while (++i < len) {
                    out[i] = encryptByte(self, chunk[i], decrypt);
                }

                return out;
            };

        }, { 'safe-buffer': 169 }],
        40: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;

            function encryptByte(self, byteParam, decrypt) {
                var pad = self._cipher.encryptBlock(self._prev);
                var out = pad[0] ^ byteParam;

                self._prev = Buffer.concat([
                    self._prev.slice(1),
                    Buffer.from([decrypt ? byteParam : out])
                ]);

                return out;
            }

            exports.encrypt = function(self, chunk, decrypt) {
                var len = chunk.length;
                var out = Buffer.allocUnsafe(len);
                var i = -1;

                while (++i < len) {
                    out[i] = encryptByte(self, chunk[i], decrypt);
                }

                return out;
            };

        }, { 'safe-buffer': 169 }],
        41: [function(require, module, exports) {
            var xor = require('buffer-xor');
            var Buffer = require('safe-buffer').Buffer;
            var incr32 = require('../incr32');

            function getBlock(self) {
                var out = self._cipher.encryptBlockRaw(self._prev);
                incr32(self._prev);
                return out;
            }

            var blockSize = 16;
            exports.encrypt = function(self, chunk) {
                var chunkNum = Math.ceil(chunk.length / blockSize);
                var start = self._cache.length;
                self._cache = Buffer.concat([
                    self._cache,
                    Buffer.allocUnsafe(chunkNum * blockSize)
                ]);
                for (var i = 0; i < chunkNum; i++) {
                    var out = getBlock(self);
                    var offset = start + i * blockSize;
                    self._cache.writeUInt32BE(out[0], offset + 0);
                    self._cache.writeUInt32BE(out[1], offset + 4);
                    self._cache.writeUInt32BE(out[2], offset + 8);
                    self._cache.writeUInt32BE(out[3], offset + 12);
                }
                var pad = self._cache.slice(0, chunk.length);
                self._cache = self._cache.slice(chunk.length);
                return xor(chunk, pad);
            };

        }, { '../incr32': 36, 'buffer-xor': 58, 'safe-buffer': 169 }],
        42: [function(require, module, exports) {
            exports.encrypt = function(self, block) {
                return self._cipher.encryptBlock(block);
            };

            exports.decrypt = function(self, block) {
                return self._cipher.decryptBlock(block);
            };

        }, {}],
        43: [function(require, module, exports) {
            var modeModules = {
                ECB: require('./ecb'),
                CBC: require('./cbc'),
                CFB: require('./cfb'),
                CFB8: require('./cfb8'),
                CFB1: require('./cfb1'),
                OFB: require('./ofb'),
                CTR: require('./ctr'),
                GCM: require('./ctr')
            };

            var modes = require('./list.json');

            for (var key in modes) {
                modes[key].module = modeModules[modes[key].mode];
            }

            module.exports = modes;

        }, {
            './cbc': 37,
            './cfb': 38,
            './cfb1': 39,
            './cfb8': 40,
            './ctr': 41,
            './ecb': 42,
            './list.json': 44,
            './ofb': 45
        }],
        44: [function(require, module, exports) {
            module.exports = {
                'aes-128-ecb': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 0,
                    'mode': 'ECB',
                    'type': 'block'
                },
                'aes-192-ecb': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 0,
                    'mode': 'ECB',
                    'type': 'block'
                },
                'aes-256-ecb': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 0,
                    'mode': 'ECB',
                    'type': 'block'
                },
                'aes-128-cbc': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes-192-cbc': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes-256-cbc': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes128': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes192': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes256': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CBC',
                    'type': 'block'
                },
                'aes-128-cfb': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CFB',
                    'type': 'stream'
                },
                'aes-192-cfb': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CFB',
                    'type': 'stream'
                },
                'aes-256-cfb': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CFB',
                    'type': 'stream'
                },
                'aes-128-cfb8': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CFB8',
                    'type': 'stream'
                },
                'aes-192-cfb8': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CFB8',
                    'type': 'stream'
                },
                'aes-256-cfb8': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CFB8',
                    'type': 'stream'
                },
                'aes-128-cfb1': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CFB1',
                    'type': 'stream'
                },
                'aes-192-cfb1': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CFB1',
                    'type': 'stream'
                },
                'aes-256-cfb1': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CFB1',
                    'type': 'stream'
                },
                'aes-128-ofb': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'OFB',
                    'type': 'stream'
                },
                'aes-192-ofb': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'OFB',
                    'type': 'stream'
                },
                'aes-256-ofb': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'OFB',
                    'type': 'stream'
                },
                'aes-128-ctr': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 16,
                    'mode': 'CTR',
                    'type': 'stream'
                },
                'aes-192-ctr': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 16,
                    'mode': 'CTR',
                    'type': 'stream'
                },
                'aes-256-ctr': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 16,
                    'mode': 'CTR',
                    'type': 'stream'
                },
                'aes-128-gcm': {
                    'cipher': 'AES',
                    'key': 128,
                    'iv': 12,
                    'mode': 'GCM',
                    'type': 'auth'
                },
                'aes-192-gcm': {
                    'cipher': 'AES',
                    'key': 192,
                    'iv': 12,
                    'mode': 'GCM',
                    'type': 'auth'
                },
                'aes-256-gcm': {
                    'cipher': 'AES',
                    'key': 256,
                    'iv': 12,
                    'mode': 'GCM',
                    'type': 'auth'
                }
            };

        }, {}],
        45: [function(require, module, exports) {
            (function(Buffer) {
                var xor = require('buffer-xor');

                function getBlock(self) {
                    self._prev = self._cipher.encryptBlock(self._prev);
                    return self._prev;
                }

                exports.encrypt = function(self, chunk) {
                    while (self._cache.length < chunk.length) {
                        self._cache = Buffer.concat([self._cache, getBlock(self)]);
                    }

                    var pad = self._cache.slice(0, chunk.length);
                    self._cache = self._cache.slice(chunk.length);
                    return xor(chunk, pad);
                };

            }).call(this, require('buffer').Buffer);
        }, { 'buffer': 59, 'buffer-xor': 58 }],
        46: [function(require, module, exports) {
            var aes = require('./aes');
            var Buffer = require('safe-buffer').Buffer;
            var Transform = require('cipher-base');
            var inherits = require('inherits');

            function StreamCipher(mode, key, iv, decrypt) {
                Transform.call(this);

                this._cipher = new aes.AES(key);
                this._prev = Buffer.from(iv);
                this._cache = Buffer.allocUnsafe(0);
                this._secCache = Buffer.allocUnsafe(0);
                this._decrypt = decrypt;
                this._mode = mode;
            }

            inherits(StreamCipher, Transform);

            StreamCipher.prototype._update = function(chunk) {
                return this._mode.encrypt(this, chunk, this._decrypt);
            };

            StreamCipher.prototype._final = function() {
                this._cipher.scrub();
            };

            module.exports = StreamCipher;

        }, { './aes': 30, 'cipher-base': 61, 'inherits': 116, 'safe-buffer': 169 }],
        47: [function(require, module, exports) {
            var DES = require('browserify-des');
            var aes = require('browserify-aes/browser');
            var aesModes = require('browserify-aes/modes');
            var desModes = require('browserify-des/modes');
            var ebtk = require('evp_bytestokey');

            function createCipher(suite, password) {
                suite = suite.toLowerCase();

                var keyLen, ivLen;
                if (aesModes[suite]) {
                    keyLen = aesModes[suite].key;
                    ivLen = aesModes[suite].iv;
                } else if (desModes[suite]) {
                    keyLen = desModes[suite].key * 8;
                    ivLen = desModes[suite].iv;
                } else {
                    throw new TypeError('invalid suite type');
                }

                var keys = ebtk(password, false, keyLen, ivLen);
                return createCipheriv(suite, keys.key, keys.iv);
            }

            function createDecipher(suite, password) {
                suite = suite.toLowerCase();

                var keyLen, ivLen;
                if (aesModes[suite]) {
                    keyLen = aesModes[suite].key;
                    ivLen = aesModes[suite].iv;
                } else if (desModes[suite]) {
                    keyLen = desModes[suite].key * 8;
                    ivLen = desModes[suite].iv;
                } else {
                    throw new TypeError('invalid suite type');
                }

                var keys = ebtk(password, false, keyLen, ivLen);
                return createDecipheriv(suite, keys.key, keys.iv);
            }

            function createCipheriv(suite, key, iv) {
                suite = suite.toLowerCase();
                if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
                if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite });

                throw new TypeError('invalid suite type');
            }

            function createDecipheriv(suite, key, iv) {
                suite = suite.toLowerCase();
                if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
                if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true });

                throw new TypeError('invalid suite type');
            }

            function getCiphers() {
                return Object.keys(desModes).concat(aes.getCiphers());
            }

            exports.createCipher = exports.Cipher = createCipher;
            exports.createCipheriv = exports.Cipheriv = createCipheriv;
            exports.createDecipher = exports.Decipher = createDecipher;
            exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
            exports.listCiphers = exports.getCiphers = getCiphers;

        }, {
            'browserify-aes/browser': 32,
            'browserify-aes/modes': 43,
            'browserify-des': 48,
            'browserify-des/modes': 49,
            'evp_bytestokey': 98
        }],
        48: [function(require, module, exports) {
            var CipherBase = require('cipher-base');
            var des = require('des.js');
            var inherits = require('inherits');
            var Buffer = require('safe-buffer').Buffer;

            var modes = {
                'des-ede3-cbc': des.CBC.instantiate(des.EDE),
                'des-ede3': des.EDE,
                'des-ede-cbc': des.CBC.instantiate(des.EDE),
                'des-ede': des.EDE,
                'des-cbc': des.CBC.instantiate(des.DES),
                'des-ecb': des.DES
            };
            modes.des = modes['des-cbc'];
            modes.des3 = modes['des-ede3-cbc'];
            module.exports = DES;
            inherits(DES, CipherBase);

            function DES(opts) {
                CipherBase.call(this);
                var modeName = opts.mode.toLowerCase();
                var mode = modes[modeName];
                var type;
                if (opts.decrypt) {
                    type = 'decrypt';
                } else {
                    type = 'encrypt';
                }
                var key = opts.key;
                if (!Buffer.isBuffer(key)) {
                    key = Buffer.from(key);
                }
                if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
                    key = Buffer.concat([key, key.slice(0, 8)]);
                }
                var iv = opts.iv;
                if (!Buffer.isBuffer(iv)) {
                    iv = Buffer.from(iv);
                }
                this._des = mode.create({
                    key: key,
                    iv: iv,
                    type: type
                });
            }

            DES.prototype._update = function(data) {
                return Buffer.from(this._des.update(data));
            };
            DES.prototype._final = function() {
                return Buffer.from(this._des.final());
            };

        }, { 'cipher-base': 61, 'des.js': 70, 'inherits': 116, 'safe-buffer': 169 }],
        49: [function(require, module, exports) {
            exports['des-ecb'] = {
                key: 8,
                iv: 0
            };
            exports['des-cbc'] = exports.des = {
                key: 8,
                iv: 8
            };
            exports['des-ede3-cbc'] = exports.des3 = {
                key: 24,
                iv: 8
            };
            exports['des-ede3'] = {
                key: 24,
                iv: 0
            };
            exports['des-ede-cbc'] = {
                key: 16,
                iv: 8
            };
            exports['des-ede'] = {
                key: 16,
                iv: 0
            };

        }, {}],
        50: [function(require, module, exports) {
            (function(Buffer) {
                var bn = require('bn.js');
                var randomBytes = require('randombytes');
                module.exports = crt;

                function blind(priv) {
                    var r = getr(priv);
                    var blinder = r.toRed(bn.mont(priv.modulus))
                        .redPow(new bn(priv.publicExponent)).fromRed();
                    return {
                        blinder: blinder,
                        unblinder: r.invm(priv.modulus)
                    };
                }

                function crt(msg, priv) {
                    var blinds = blind(priv);
                    var len = priv.modulus.byteLength();
                    var mod = bn.mont(priv.modulus);
                    var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
                    var c1 = blinded.toRed(bn.mont(priv.prime1));
                    var c2 = blinded.toRed(bn.mont(priv.prime2));
                    var qinv = priv.coefficient;
                    var p = priv.prime1;
                    var q = priv.prime2;
                    var m1 = c1.redPow(priv.exponent1);
                    var m2 = c2.redPow(priv.exponent2);
                    m1 = m1.fromRed();
                    m2 = m2.fromRed();
                    var h = m1.isub(m2).imul(qinv).umod(p);
                    h.imul(q);
                    m2.iadd(h);
                    return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
                }

                crt.getr = getr;

                function getr(priv) {
                    var len = priv.modulus.byteLength();
                    var r = new bn(randomBytes(len));
                    while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
                        r = new bn(randomBytes(len));
                    }
                    return r;
                }

            }).call(this, require('buffer').Buffer);
        }, { 'bn.js': 27, 'buffer': 59, 'randombytes': 152 }],
        51: [function(require, module, exports) {
            module.exports = require('./browser/algorithms.json');

        }, { './browser/algorithms.json': 52 }],
        52: [function(require, module, exports) {
            module.exports = {
                'sha224WithRSAEncryption': {
                    'sign': 'rsa',
                    'hash': 'sha224',
                    'id': '302d300d06096086480165030402040500041c'
                },
                'RSA-SHA224': {
                    'sign': 'ecdsa/rsa',
                    'hash': 'sha224',
                    'id': '302d300d06096086480165030402040500041c'
                },
                'sha256WithRSAEncryption': {
                    'sign': 'rsa',
                    'hash': 'sha256',
                    'id': '3031300d060960864801650304020105000420'
                },
                'RSA-SHA256': {
                    'sign': 'ecdsa/rsa',
                    'hash': 'sha256',
                    'id': '3031300d060960864801650304020105000420'
                },
                'sha384WithRSAEncryption': {
                    'sign': 'rsa',
                    'hash': 'sha384',
                    'id': '3041300d060960864801650304020205000430'
                },
                'RSA-SHA384': {
                    'sign': 'ecdsa/rsa',
                    'hash': 'sha384',
                    'id': '3041300d060960864801650304020205000430'
                },
                'sha512WithRSAEncryption': {
                    'sign': 'rsa',
                    'hash': 'sha512',
                    'id': '3051300d060960864801650304020305000440'
                },
                'RSA-SHA512': {
                    'sign': 'ecdsa/rsa',
                    'hash': 'sha512',
                    'id': '3051300d060960864801650304020305000440'
                },
                'RSA-SHA1': {
                    'sign': 'rsa',
                    'hash': 'sha1',
                    'id': '3021300906052b0e03021a05000414'
                },
                'ecdsa-with-SHA1': {
                    'sign': 'ecdsa',
                    'hash': 'sha1',
                    'id': ''
                },
                'sha256': {
                    'sign': 'ecdsa',
                    'hash': 'sha256',
                    'id': ''
                },
                'sha224': {
                    'sign': 'ecdsa',
                    'hash': 'sha224',
                    'id': ''
                },
                'sha384': {
                    'sign': 'ecdsa',
                    'hash': 'sha384',
                    'id': ''
                },
                'sha512': {
                    'sign': 'ecdsa',
                    'hash': 'sha512',
                    'id': ''
                },
                'DSA-SHA': {
                    'sign': 'dsa',
                    'hash': 'sha1',
                    'id': ''
                },
                'DSA-SHA1': {
                    'sign': 'dsa',
                    'hash': 'sha1',
                    'id': ''
                },
                'DSA': {
                    'sign': 'dsa',
                    'hash': 'sha1',
                    'id': ''
                },
                'DSA-WITH-SHA224': {
                    'sign': 'dsa',
                    'hash': 'sha224',
                    'id': ''
                },
                'DSA-SHA224': {
                    'sign': 'dsa',
                    'hash': 'sha224',
                    'id': ''
                },
                'DSA-WITH-SHA256': {
                    'sign': 'dsa',
                    'hash': 'sha256',
                    'id': ''
                },
                'DSA-SHA256': {
                    'sign': 'dsa',
                    'hash': 'sha256',
                    'id': ''
                },
                'DSA-WITH-SHA384': {
                    'sign': 'dsa',
                    'hash': 'sha384',
                    'id': ''
                },
                'DSA-SHA384': {
                    'sign': 'dsa',
                    'hash': 'sha384',
                    'id': ''
                },
                'DSA-WITH-SHA512': {
                    'sign': 'dsa',
                    'hash': 'sha512',
                    'id': ''
                },
                'DSA-SHA512': {
                    'sign': 'dsa',
                    'hash': 'sha512',
                    'id': ''
                },
                'DSA-RIPEMD160': {
                    'sign': 'dsa',
                    'hash': 'rmd160',
                    'id': ''
                },
                'ripemd160WithRSA': {
                    'sign': 'rsa',
                    'hash': 'rmd160',
                    'id': '3021300906052b2403020105000414'
                },
                'RSA-RIPEMD160': {
                    'sign': 'rsa',
                    'hash': 'rmd160',
                    'id': '3021300906052b2403020105000414'
                },
                'md5WithRSAEncryption': {
                    'sign': 'rsa',
                    'hash': 'md5',
                    'id': '3020300c06082a864886f70d020505000410'
                },
                'RSA-MD5': {
                    'sign': 'rsa',
                    'hash': 'md5',
                    'id': '3020300c06082a864886f70d020505000410'
                }
            };

        }, {}],
        53: [function(require, module, exports) {
            module.exports = {
                '1.3.132.0.10': 'secp256k1',
                '1.3.132.0.33': 'p224',
                '1.2.840.10045.3.1.1': 'p192',
                '1.2.840.10045.3.1.7': 'p256',
                '1.3.132.0.34': 'p384',
                '1.3.132.0.35': 'p521'
            };

        }, {}],
        54: [function(require, module, exports) {
            (function(Buffer) {
                var createHash = require('create-hash');
                var stream = require('stream');
                var inherits = require('inherits');
                var sign = require('./sign');
                var verify = require('./verify');

                var algorithms = require('./algorithms.json');
                Object.keys(algorithms).forEach(function(key) {
                    algorithms[key].id = new Buffer(algorithms[key].id, 'hex');
                    algorithms[key.toLowerCase()] = algorithms[key];
                });

                function Sign(algorithm) {
                    stream.Writable.call(this);

                    var data = algorithms[algorithm];
                    if (!data) throw new Error('Unknown message digest');

                    this._hashType = data.hash;
                    this._hash = createHash(data.hash);
                    this._tag = data.id;
                    this._signType = data.sign;
                }

                inherits(Sign, stream.Writable);

                Sign.prototype._write = function _write(data, _, done) {
                    this._hash.update(data);
                    done();
                };

                Sign.prototype.update = function update(data, enc) {
                    if (typeof data === 'string') data = new Buffer(data, enc);

                    this._hash.update(data);
                    return this;
                };

                Sign.prototype.sign = function signMethod(key, enc) {
                    this.end();
                    var hash = this._hash.digest();
                    var sig = sign(hash, key, this._hashType, this._signType, this._tag);

                    return enc ? sig.toString(enc) : sig;
                };

                function Verify(algorithm) {
                    stream.Writable.call(this);

                    var data = algorithms[algorithm];
                    if (!data) throw new Error('Unknown message digest');

                    this._hash = createHash(data.hash);
                    this._tag = data.id;
                    this._signType = data.sign;
                }

                inherits(Verify, stream.Writable);

                Verify.prototype._write = function _write(data, _, done) {
                    this._hash.update(data);
                    done();
                };

                Verify.prototype.update = function update(data, enc) {
                    if (typeof data === 'string') data = new Buffer(data, enc);

                    this._hash.update(data);
                    return this;
                };

                Verify.prototype.verify = function verifyMethod(key, sig, enc) {
                    if (typeof sig === 'string') sig = new Buffer(sig, enc);

                    this.end();
                    var hash = this._hash.digest();
                    return verify(sig, hash, key, this._signType, this._tag);
                };

                function createSign(algorithm) {
                    return new Sign(algorithm);
                }

                function createVerify(algorithm) {
                    return new Verify(algorithm);
                }

                module.exports = {
                    Sign: createSign,
                    Verify: createVerify,
                    createSign: createSign,
                    createVerify: createVerify
                };

            }).call(this, require('buffer').Buffer);
        }, {
            './algorithms.json': 52,
            './sign': 55,
            './verify': 56,
            'buffer': 59,
            'create-hash': 64,
            'inherits': 116,
            'stream': 179
        }],
        55: [function(require, module, exports) {
            (function(Buffer) {
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
                var createHmac = require('create-hmac');
                var crt = require('browserify-rsa');
                var EC = require('elliptic').ec;
                var BN = require('bn.js');
                var parseKeys = require('parse-asn1');
                var curves = require('./curves.json');

                function sign(hash, key, hashType, signType, tag) {
                    var priv = parseKeys(key);
                    if (priv.curve) {
                        // rsa keys can be interpreted as ecdsa ones in openssl
                        if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
                        return ecSign(hash, priv);
                    } else if (priv.type === 'dsa') {
                        if (signType !== 'dsa') throw new Error('wrong private key type');
                        return dsaSign(hash, priv, hashType);
                    } else {
                        if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
                    }
                    hash = Buffer.concat([tag, hash]);
                    var len = priv.modulus.byteLength();
                    var pad = [0, 1];
                    while (hash.length + pad.length + 1 < len) pad.push(0xff);
                    pad.push(0x00);
                    var i = -1;
                    while (++i < hash.length) pad.push(hash[i]);

                    var out = crt(pad, priv);
                    return out;
                }

                function ecSign(hash, priv) {
                    var curveId = curves[priv.curve.join('.')];
                    if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'));

                    var curve = new EC(curveId);
                    var key = curve.keyFromPrivate(priv.privateKey);
                    var out = key.sign(hash);

                    return new Buffer(out.toDER());
                }

                function dsaSign(hash, priv, algo) {
                    var x = priv.params.priv_key;
                    var p = priv.params.p;
                    var q = priv.params.q;
                    var g = priv.params.g;
                    var r = new BN(0);
                    var k;
                    var H = bits2int(hash, q).mod(q);
                    var s = false;
                    var kv = getKey(x, q, hash, algo);
                    while (s === false) {
                        k = makeKey(q, kv, algo);
                        r = makeR(g, k, p, q);
                        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
                        if (s.cmpn(0) === 0) {
                            s = false;
                            r = new BN(0);
                        }
                    }
                    return toDER(r, s);
                }

                function toDER(r, s) {
                    r = r.toArray();
                    s = s.toArray();

                    // Pad values
                    if (r[0] & 0x80) r = [0].concat(r);
                    if (s[0] & 0x80) s = [0].concat(s);

                    var total = r.length + s.length + 4;
                    var res = [0x30, total, 0x02, r.length];
                    res = res.concat(r, [0x02, s.length], s);
                    return new Buffer(res);
                }

                function getKey(x, q, hash, algo) {
                    x = new Buffer(x.toArray());
                    if (x.length < q.byteLength()) {
                        var zeros = new Buffer(q.byteLength() - x.length);
                        zeros.fill(0);
                        x = Buffer.concat([zeros, x]);
                    }
                    var hlen = hash.length;
                    var hbits = bits2octets(hash, q);
                    var v = new Buffer(hlen);
                    v.fill(1);
                    var k = new Buffer(hlen);
                    k.fill(0);
                    k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest();
                    v = createHmac(algo, k).update(v).digest();
                    k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest();
                    v = createHmac(algo, k).update(v).digest();
                    return { k: k, v: v };
                }

                function bits2int(obits, q) {
                    var bits = new BN(obits);
                    var shift = (obits.length << 3) - q.bitLength();
                    if (shift > 0) bits.ishrn(shift);
                    return bits;
                }

                function bits2octets(bits, q) {
                    bits = bits2int(bits, q);
                    bits = bits.mod(q);
                    var out = new Buffer(bits.toArray());
                    if (out.length < q.byteLength()) {
                        var zeros = new Buffer(q.byteLength() - out.length);
                        zeros.fill(0);
                        out = Buffer.concat([zeros, out]);
                    }
                    return out;
                }

                function makeKey(q, kv, algo) {
                    var t;
                    var k;

                    do {
                        t = new Buffer(0);

                        while (t.length * 8 < q.bitLength()) {
                            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
                            t = Buffer.concat([t, kv.v]);
                        }

                        k = bits2int(t, q);
                        kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
                        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
                    } while (k.cmp(q) !== -1);

                    return k;
                }

                function makeR(g, k, p, q) {
                    return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
                }

                module.exports = sign;
                module.exports.getKey = getKey;
                module.exports.makeKey = makeKey;

            }).call(this, require('buffer').Buffer);
        }, {
            './curves.json': 53,
            'bn.js': 27,
            'browserify-rsa': 50,
            'buffer': 59,
            'create-hmac': 66,
            'elliptic': 80,
            'parse-asn1': 133
        }],
        56: [function(require, module, exports) {
            (function(Buffer) {
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
                var BN = require('bn.js');
                var EC = require('elliptic').ec;
                var parseKeys = require('parse-asn1');
                var curves = require('./curves.json');

                function verify(sig, hash, key, signType, tag) {
                    var pub = parseKeys(key);
                    if (pub.type === 'ec') {
                        // rsa keys can be interpreted as ecdsa ones in openssl
                        if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
                        return ecVerify(sig, hash, pub);
                    } else if (pub.type === 'dsa') {
                        if (signType !== 'dsa') throw new Error('wrong public key type');
                        return dsaVerify(sig, hash, pub);
                    } else {
                        if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
                    }
                    hash = Buffer.concat([tag, hash]);
                    var len = pub.modulus.byteLength();
                    var pad = [1];
                    var padNum = 0;
                    while (hash.length + pad.length + 2 < len) {
                        pad.push(0xff);
                        padNum++;
                    }
                    pad.push(0x00);
                    var i = -1;
                    while (++i < hash.length) {
                        pad.push(hash[i]);
                    }
                    pad = new Buffer(pad);
                    var red = BN.mont(pub.modulus);
                    sig = new BN(sig).toRed(red);

                    sig = sig.redPow(new BN(pub.publicExponent));
                    sig = new Buffer(sig.fromRed().toArray());
                    var out = padNum < 8 ? 1 : 0;
                    len = Math.min(sig.length, pad.length);
                    if (sig.length !== pad.length) out = 1;

                    i = -1;
                    while (++i < len) out |= sig[i] ^ pad[i];
                    return out === 0;
                }

                function ecVerify(sig, hash, pub) {
                    var curveId = curves[pub.data.algorithm.curve.join('.')];
                    if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));

                    var curve = new EC(curveId);
                    var pubkey = pub.data.subjectPrivateKey.data;

                    return curve.verify(hash, sig, pubkey);
                }

                function dsaVerify(sig, hash, pub) {
                    var p = pub.data.p;
                    var q = pub.data.q;
                    var g = pub.data.g;
                    var y = pub.data.pub_key;
                    var unpacked = parseKeys.signature.decode(sig, 'der');
                    var s = unpacked.s;
                    var r = unpacked.r;
                    checkValue(s, q);
                    checkValue(r, q);
                    var montp = BN.mont(p);
                    var w = s.invm(q);
                    var v = g.toRed(montp)
                        .redPow(new BN(hash).mul(w).mod(q))
                        .fromRed()
                        .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
                        .mod(p)
                        .mod(q);
                    return v.cmp(r) === 0;
                }

                function checkValue(b, q) {
                    if (b.cmpn(0) <= 0) throw new Error('invalid sig');
                    if (b.cmp(q) >= q) throw new Error('invalid sig');
                }

                module.exports = verify;

            }).call(this, require('buffer').Buffer);
        }, { './curves.json': 53, 'bn.js': 27, 'buffer': 59, 'elliptic': 80, 'parse-asn1': 133 }],
        57: [function(require, module, exports) {
            arguments[4][29][0].apply(exports, arguments);
        }, { 'dup': 29 }],
        58: [function(require, module, exports) {
            (function(Buffer) {
                module.exports = function xor(a, b) {
                    var length = Math.min(a.length, b.length);
                    var buffer = new Buffer(length);

                    for (var i = 0; i < length; ++i) {
                        buffer[i] = a[i] ^ b[i];
                    }

                    return buffer;
                };

            }).call(this, require('buffer').Buffer);
        }, { 'buffer': 59 }],
        59: [function(require, module, exports) {
            (function(global) {
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                /* eslint-disable no-proto */

                'use strict';

                var base64 = require('base64-js');
                var ieee754 = require('ieee754');
                var isArray = require('isarray');

                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;
                Buffer.poolSize = 8192; // not used by this implementation

                var rootParent = {};

                /**
                 * If `Buffer.TYPED_ARRAY_SUPPORT`:
                 *   === true    Use Uint8Array implementation (fastest)
                 *   === false   Use Object implementation (most compatible, even IE6)
                 *
                 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                 * Opera 11.6+, iOS 4.2+.
                 *
                 * Due to various browser bugs, sometimes the Object implementation will be used even
                 * when the browser supports typed arrays.
                 *
                 * Note:
                 *
                 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
                 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
                 *
                 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
                 *     on objects.
                 *
                 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
                 *
                 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
                 *     incorrect length in some situations.

                 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
                 * get the Object implementation, which is slower but behaves correctly.
                 */
                Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
                    ? global.TYPED_ARRAY_SUPPORT
                    : typedArraySupport();

                function typedArraySupport() {
                    function Bar() {
                    }

                    try {
                        var arr = new Uint8Array(1);
                        arr.foo = function() {
                            return 42;
                        };
                        arr.constructor = Bar;
                        return arr.foo() === 42 && // typed array instances can be augmented
                            arr.constructor === Bar && // constructor can be set
                            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
                    } catch (e) {
                        return false;
                    }
                }

                function kMaxLength() {
                    return Buffer.TYPED_ARRAY_SUPPORT
                        ? 0x7fffffff
                        : 0x3fffffff;
                }

                /**
                 * Class: Buffer
                 * =============
                 *
                 * The Buffer constructor returns instances of `Uint8Array` that are augmented
                 * with function properties for all the node `Buffer` API functions. We use
                 * `Uint8Array` so that square bracket notation works as expected -- it returns
                 * a single octet.
                 *
                 * By augmenting the instances, we can avoid modifying the `Uint8Array`
                 * prototype.
                 */
                function Buffer(arg) {
                    if (!(this instanceof Buffer)) {
                        // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
                        if (arguments.length > 1) return new Buffer(arg, arguments[1]);
                        return new Buffer(arg);
                    }

                    if (!Buffer.TYPED_ARRAY_SUPPORT) {
                        this.length = 0;
                        this.parent = undefined;
                    }

                    // Common case.
                    if (typeof arg === 'number') {
                        return fromNumber(this, arg);
                    }

                    // Slightly less common case.
                    if (typeof arg === 'string') {
                        return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
                    }

                    // Unusual.
                    return fromObject(this, arg);
                }

                function fromNumber(that, length) {
                    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) {
                        for (var i = 0; i < length; i++) {
                            that[i] = 0;
                        }
                    }
                    return that;
                }

                function fromString(that, string, encoding) {
                    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

                    // Assumption: byteLength() return value is always < kMaxLength.
                    var length = byteLength(string, encoding) | 0;
                    that = allocate(that, length);

                    that.write(string, encoding);
                    return that;
                }

                function fromObject(that, object) {
                    if (Buffer.isBuffer(object)) return fromBuffer(that, object);

                    if (isArray(object)) return fromArray(that, object);

                    if (object == null) {
                        throw new TypeError('must start with number, buffer, array or string');
                    }

                    if (typeof ArrayBuffer !== 'undefined') {
                        if (object.buffer instanceof ArrayBuffer) {
                            return fromTypedArray(that, object);
                        }
                        if (object instanceof ArrayBuffer) {
                            return fromArrayBuffer(that, object);
                        }
                    }

                    if (object.length) return fromArrayLike(that, object);

                    return fromJsonObject(that, object);
                }

                function fromBuffer(that, buffer) {
                    var length = checked(buffer.length) | 0;
                    that = allocate(that, length);
                    buffer.copy(that, 0, 0, length);
                    return that;
                }

                function fromArray(that, array) {
                    var length = checked(array.length) | 0;
                    that = allocate(that, length);
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

// Duplicate of fromArray() to keep fromArray() monomorphic.
                function fromTypedArray(that, array) {
                    var length = checked(array.length) | 0;
                    that = allocate(that, length);
                    // Truncating the elements is probably not what people expect from typed
                    // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
                    // of the old Buffer constructor.
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

                function fromArrayBuffer(that, array) {
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        array.byteLength;
                        that = Buffer._augment(new Uint8Array(array));
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        that = fromTypedArray(that, new Uint8Array(array));
                    }
                    return that;
                }

                function fromArrayLike(that, array) {
                    var length = checked(array.length) | 0;
                    that = allocate(that, length);
                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
                function fromJsonObject(that, object) {
                    var array;
                    var length = 0;

                    if (object.type === 'Buffer' && isArray(object.data)) {
                        array = object.data;
                        length = checked(array.length) | 0;
                    }
                    that = allocate(that, length);

                    for (var i = 0; i < length; i += 1) {
                        that[i] = array[i] & 255;
                    }
                    return that;
                }

                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    Buffer.prototype.__proto__ = Uint8Array.prototype;
                    Buffer.__proto__ = Uint8Array;
                } else {
                    // pre-set for values that may exist in the future
                    Buffer.prototype.length = undefined;
                    Buffer.prototype.parent = undefined;
                }

                function allocate(that, length) {
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        // Return an augmented `Uint8Array` instance, for best performance
                        that = Buffer._augment(new Uint8Array(length));
                        that.__proto__ = Buffer.prototype;
                    } else {
                        // Fallback: Return an object instance of the Buffer class
                        that.length = length;
                        that._isBuffer = true;
                    }

                    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
                    if (fromPool) that.parent = rootParent;

                    return that;
                }

                function checked(length) {
                    // Note: cannot use `length < kMaxLength` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= kMaxLength()) {
                        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                            'size: 0x' + kMaxLength().toString(16) + ' bytes');
                    }
                    return length | 0;
                }

                function SlowBuffer(subject, encoding) {
                    if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

                    var buf = new Buffer(subject, encoding);
                    delete buf.parent;
                    return buf;
                }

                Buffer.isBuffer = function isBuffer(b) {
                    return !!(b != null && b._isBuffer);
                };

                Buffer.compare = function compare(a, b) {
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError('Arguments must be Buffers');
                    }

                    if (a === b) return 0;

                    var x = a.length;
                    var y = b.length;

                    var i = 0;
                    var len = Math.min(x, y);
                    while (i < len) {
                        if (a[i] !== b[i]) break;

                        ++i;
                    }

                    if (i !== len) {
                        x = a[i];
                        y = b[i];
                    }

                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };

                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                        case 'hex':
                        case 'utf8':
                        case 'utf-8':
                        case 'ascii':
                        case 'binary':
                        case 'base64':
                        case 'raw':
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return true;
                        default:
                            return false;
                    }
                };

                Buffer.concat = function concat(list, length) {
                    if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

                    if (list.length === 0) {
                        return new Buffer(0);
                    }

                    var i;
                    if (length === undefined) {
                        length = 0;
                        for (i = 0; i < list.length; i++) {
                            length += list[i].length;
                        }
                    }

                    var buf = new Buffer(length);
                    var pos = 0;
                    for (i = 0; i < list.length; i++) {
                        var item = list[i];
                        item.copy(buf, pos);
                        pos += item.length;
                    }
                    return buf;
                };

                function byteLength(string, encoding) {
                    if (typeof string !== 'string') string = '' + string;

                    var len = string.length;
                    if (len === 0) return 0;

                    // Use a for loop to avoid recursion
                    var loweredCase = false;
                    for (; ;) {
                        switch (encoding) {
                            case 'ascii':
                            case 'binary':
                            // Deprecated
                            case 'raw':
                            case 'raws':
                                return len;
                            case 'utf8':
                            case 'utf-8':
                                return utf8ToBytes(string).length;
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return len * 2;
                            case 'hex':
                                return len >>> 1;
                            case 'base64':
                                return base64ToBytes(string).length;
                            default:
                                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                }

                Buffer.byteLength = byteLength;

                function slowToString(encoding, start, end) {
                    var loweredCase = false;

                    start = start | 0;
                    end = end === undefined || end === Infinity ? this.length : end | 0;

                    if (!encoding) encoding = 'utf8';
                    if (start < 0) start = 0;
                    if (end > this.length) end = this.length;
                    if (end <= start) return '';

                    while (true) {
                        switch (encoding) {
                            case 'hex':
                                return hexSlice(this, start, end);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Slice(this, start, end);

                            case 'ascii':
                                return asciiSlice(this, start, end);

                            case 'binary':
                                return binarySlice(this, start, end);

                            case 'base64':
                                return base64Slice(this, start, end);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return utf16leSlice(this, start, end);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = (encoding + '').toLowerCase();
                                loweredCase = true;
                        }
                    }
                }

                Buffer.prototype.toString = function toString() {
                    var length = this.length | 0;
                    if (length === 0) return '';
                    if (arguments.length === 0) return utf8Slice(this, 0, length);
                    return slowToString.apply(this, arguments);
                };

                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
                    if (this === b) return true;
                    return Buffer.compare(this, b) === 0;
                };

                Buffer.prototype.inspect = function inspect() {
                    var str = '';
                    var max = exports.INSPECT_MAX_BYTES;
                    if (this.length > 0) {
                        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                        if (this.length > max) str += ' ... ';
                    }
                    return '<Buffer ' + str + '>';
                };

                Buffer.prototype.compare = function compare(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
                    if (this === b) return 0;
                    return Buffer.compare(this, b);
                };

                Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
                    if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
                    else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
                    byteOffset >>= 0;

                    if (this.length === 0) return -1;
                    if (byteOffset >= this.length) return -1;

                    // Negative offsets start from the end of the buffer
                    if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

                    if (typeof val === 'string') {
                        if (val.length === 0) return -1; // special case: looking for empty string always fails
                        return String.prototype.indexOf.call(this, val, byteOffset);
                    }
                    if (Buffer.isBuffer(val)) {
                        return arrayIndexOf(this, val, byteOffset);
                    }
                    if (typeof val === 'number') {
                        if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                            return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
                        }
                        return arrayIndexOf(this, [val], byteOffset);
                    }

                    function arrayIndexOf(arr, val, byteOffset) {
                        var foundIndex = -1;
                        for (var i = 0; byteOffset + i < arr.length; i++) {
                            if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                                if (foundIndex === -1) foundIndex = i;
                                if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
                            } else {
                                foundIndex = -1;
                            }
                        }
                        return -1;
                    }

                    throw new TypeError('val must be string, number or Buffer');
                };

// `get` is deprecated
                Buffer.prototype.get = function get(offset) {
                    console.log('.get() is deprecated. Access using array indexes instead.');
                    return this.readUInt8(offset);
                };

// `set` is deprecated
                Buffer.prototype.set = function set(v, offset) {
                    console.log('.set() is deprecated. Access using array indexes instead.');
                    return this.writeUInt8(v, offset);
                };

                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    var remaining = buf.length - offset;
                    if (!length) {
                        length = remaining;
                    } else {
                        length = Number(length);
                        if (length > remaining) {
                            length = remaining;
                        }
                    }

                    // must be an even number of digits
                    var strLen = string.length;
                    if (strLen % 2 !== 0) throw new Error('Invalid hex string');

                    if (length > strLen / 2) {
                        length = strLen / 2;
                    }
                    for (var i = 0; i < length; i++) {
                        var parsed = parseInt(string.substr(i * 2, 2), 16);
                        if (isNaN(parsed)) throw new Error('Invalid hex string');
                        buf[offset + i] = parsed;
                    }
                    return i;
                }

                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }

                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }

                function binaryWrite(buf, string, offset, length) {
                    return asciiWrite(buf, string, offset, length);
                }

                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }

                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }

                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = 'utf8';
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === 'string') {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset = offset | 0;
                        if (isFinite(length)) {
                            length = length | 0;
                            if (encoding === undefined) encoding = 'utf8';
                        } else {
                            encoding = length;
                            length = undefined;
                        }
                        // legacy write(string, encoding, offset, length) - remove in v0.13
                    } else {
                        var swap = encoding;
                        encoding = offset;
                        offset = length | 0;
                        length = swap;
                    }

                    var remaining = this.length - offset;
                    if (length === undefined || length > remaining) length = remaining;

                    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                        throw new RangeError('attempt to write outside buffer bounds');
                    }

                    if (!encoding) encoding = 'utf8';

                    var loweredCase = false;
                    for (; ;) {
                        switch (encoding) {
                            case 'hex':
                                return hexWrite(this, string, offset, length);

                            case 'utf8':
                            case 'utf-8':
                                return utf8Write(this, string, offset, length);

                            case 'ascii':
                                return asciiWrite(this, string, offset, length);

                            case 'binary':
                                return binaryWrite(this, string, offset, length);

                            case 'base64':
                                // Warning: maxLength not taken into account in base64Write
                                return base64Write(this, string, offset, length);

                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return ucs2Write(this, string, offset, length);

                            default:
                                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                                encoding = ('' + encoding).toLowerCase();
                                loweredCase = true;
                        }
                    }
                };

                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: 'Buffer',
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };

                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf);
                    } else {
                        return base64.fromByteArray(buf.slice(start, end));
                    }
                }

                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    var res = [];

                    var i = start;
                    while (i < end) {
                        var firstByte = buf[i];
                        var codePoint = null;
                        var bytesPerSequence = (firstByte > 0xEF) ? 4
                            : (firstByte > 0xDF) ? 3
                                : (firstByte > 0xBF) ? 2
                                    : 1;

                        if (i + bytesPerSequence <= end) {
                            var secondByte, thirdByte, fourthByte, tempCodePoint;

                            switch (bytesPerSequence) {
                                case 1:
                                    if (firstByte < 0x80) {
                                        codePoint = firstByte;
                                    }
                                    break;
                                case 2:
                                    secondByte = buf[i + 1];
                                    if ((secondByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                                        if (tempCodePoint > 0x7F) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 3:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                                    break;
                                case 4:
                                    secondByte = buf[i + 1];
                                    thirdByte = buf[i + 2];
                                    fourthByte = buf[i + 3];
                                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                            codePoint = tempCodePoint;
                                        }
                                    }
                            }
                        }

                        if (codePoint === null) {
                            // we did not generate a valid codePoint so insert a
                            // replacement char (U+FFFD) and advance only 1 byte
                            codePoint = 0xFFFD;
                            bytesPerSequence = 1;
                        } else if (codePoint > 0xFFFF) {
                            // encode to utf16 (surrogate pair dance)
                            codePoint -= 0x10000;
                            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                            codePoint = 0xDC00 | codePoint & 0x3FF;
                        }

                        res.push(codePoint);
                        i += bytesPerSequence;
                    }

                    return decodeCodePointsArray(res);
                }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
                var MAX_ARGUMENTS_LENGTH = 0x1000;

                function decodeCodePointsArray(codePoints) {
                    var len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH) {
                        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
                    }

                    // Decode in chunks to avoid "call stack size exceeded".
                    var res = '';
                    var i = 0;
                    while (i < len) {
                        res += String.fromCharCode.apply(
                            String,
                            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                        );
                    }
                    return res;
                }

                function asciiSlice(buf, start, end) {
                    var ret = '';
                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; i++) {
                        ret += String.fromCharCode(buf[i] & 0x7F);
                    }
                    return ret;
                }

                function binarySlice(buf, start, end) {
                    var ret = '';
                    end = Math.min(buf.length, end);

                    for (var i = start; i < end; i++) {
                        ret += String.fromCharCode(buf[i]);
                    }
                    return ret;
                }

                function hexSlice(buf, start, end) {
                    var len = buf.length;

                    if (!start || start < 0) start = 0;
                    if (!end || end < 0 || end > len) end = len;

                    var out = '';
                    for (var i = start; i < end; i++) {
                        out += toHex(buf[i]);
                    }
                    return out;
                }

                function utf16leSlice(buf, start, end) {
                    var bytes = buf.slice(start, end);
                    var res = '';
                    for (var i = 0; i < bytes.length; i += 2) {
                        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                    }
                    return res;
                }

                Buffer.prototype.slice = function slice(start, end) {
                    var len = this.length;
                    start = ~~start;
                    end = end === undefined ? len : ~~end;

                    if (start < 0) {
                        start += len;
                        if (start < 0) start = 0;
                    } else if (start > len) {
                        start = len;
                    }

                    if (end < 0) {
                        end += len;
                        if (end < 0) end = 0;
                    } else if (end > len) {
                        end = len;
                    }

                    if (end < start) end = start;

                    var newBuf;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        newBuf = Buffer._augment(this.subarray(start, end));
                    } else {
                        var sliceLen = end - start;
                        newBuf = new Buffer(sliceLen, undefined);
                        for (var i = 0; i < sliceLen; i++) {
                            newBuf[i] = this[i + start];
                        }
                    }

                    if (newBuf.length) newBuf.parent = this.parent || this;

                    return newBuf;
                };

                /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
                function checkOffset(offset, ext, length) {
                    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint');
                    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
                }

                Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) {
                        checkOffset(offset, byteLength, this.length);
                    }

                    var val = this[offset + --byteLength];
                    var mul = 1;
                    while (byteLength > 0 && (mul *= 0x100)) {
                        val += this[offset + --byteLength] * mul;
                    }

                    return val;
                };

                Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    return this[offset];
                };

                Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] | (this[offset + 1] << 8);
                };

                Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return (this[offset] << 8) | this[offset + 1];
                };

                Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return ((this[offset]) |
                            (this[offset + 1] << 8) |
                            (this[offset + 2] << 16)) +
                        (this[offset + 3] * 0x1000000);
                };

                Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return (this[offset] * 0x1000000) +
                        ((this[offset + 1] << 16) |
                            (this[offset + 2] << 8) |
                            this[offset + 3]);
                };

                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var val = this[offset];
                    var mul = 1;
                    var i = 0;
                    while (++i < byteLength && (mul *= 0x100)) {
                        val += this[offset + i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);

                    var i = byteLength;
                    var mul = 1;
                    var val = this[offset + --i];
                    while (i > 0 && (mul *= 0x100)) {
                        val += this[offset + --i] * mul;
                    }
                    mul *= 0x80;

                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                    return val;
                };

                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    if (!(this[offset] & 0x80)) return (this[offset]);
                    return ((0xff - this[offset] + 1) * -1);
                };

                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset] | (this[offset + 1] << 8);
                    return (val & 0x8000) ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    var val = this[offset + 1] | (this[offset] << 8);
                    return (val & 0x8000) ? val | 0xFFFF0000 : val;
                };

                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return (this[offset]) |
                        (this[offset + 1] << 8) |
                        (this[offset + 2] << 16) |
                        (this[offset + 3] << 24);
                };

                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);

                    return (this[offset] << 24) |
                        (this[offset + 1] << 16) |
                        (this[offset + 2] << 8) |
                        (this[offset + 3]);
                };

                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, true, 23, 4);
                };

                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, false, 23, 4);
                };

                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, true, 52, 8);
                };

                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, false, 52, 8);
                };

                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');
                    if (value > max || value < min) throw new RangeError('value is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError('index out of range');
                }

                Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

                    var mul = 1;
                    var i = 0;
                    this[offset] = value & 0xFF;
                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = (value / mul) & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    byteLength = byteLength | 0;
                    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

                    var i = byteLength - 1;
                    var mul = 1;
                    this[offset + i] = value & 0xFF;
                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = (value / mul) & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                    this[offset] = (value & 0xff);
                    return offset + 1;
                };

                function objectWriteUInt16(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                            (littleEndian ? i : 1 - i) * 8;
                    }
                }

                Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value >>> 8);
                        this[offset + 1] = (value & 0xff);
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                };

                function objectWriteUInt32(buf, value, offset, littleEndian) {
                    if (value < 0) value = 0xffffffff + value + 1;
                    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
                    }
                }

                Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset + 3] = (value >>> 24);
                        this[offset + 2] = (value >>> 16);
                        this[offset + 1] = (value >>> 8);
                        this[offset] = (value & 0xff);
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value >>> 24);
                        this[offset + 1] = (value >>> 16);
                        this[offset + 2] = (value >>> 8);
                        this[offset + 3] = (value & 0xff);
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = 0;
                    var mul = 1;
                    var sub = value < 0 ? 1 : 0;
                    this[offset] = value & 0xFF;
                    while (++i < byteLength && (mul *= 0x100)) {
                        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);

                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }

                    var i = byteLength - 1;
                    var mul = 1;
                    var sub = value < 0 ? 1 : 0;
                    this[offset + i] = value & 0xFF;
                    while (--i >= 0 && (mul *= 0x100)) {
                        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                    }

                    return offset + byteLength;
                };

                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
                    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                    if (value < 0) value = 0xff + value + 1;
                    this[offset] = (value & 0xff);
                    return offset + 1;
                };

                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                    } else {
                        objectWriteUInt16(this, value, offset, true);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value >>> 8);
                        this[offset + 1] = (value & 0xff);
                    } else {
                        objectWriteUInt16(this, value, offset, false);
                    }
                    return offset + 2;
                };

                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                        this[offset + 2] = (value >>> 16);
                        this[offset + 3] = (value >>> 24);
                    } else {
                        objectWriteUInt32(this, value, offset, true);
                    }
                    return offset + 4;
                };

                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset | 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                    if (value < 0) value = 0xffffffff + value + 1;
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        this[offset] = (value >>> 24);
                        this[offset + 1] = (value >>> 16);
                        this[offset + 2] = (value >>> 8);
                        this[offset + 3] = (value & 0xff);
                    } else {
                        objectWriteUInt32(this, value, offset, false);
                    }
                    return offset + 4;
                };

                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (value > max || value < min) throw new RangeError('value is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError('index out of range');
                    if (offset < 0) throw new RangeError('index out of range');
                }

                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);
                    return offset + 4;
                }

                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                };

                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);
                    return offset + 8;
                }

                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                };

                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                };

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!start) start = 0;
                    if (!end && end !== 0) end = this.length;
                    if (targetStart >= target.length) targetStart = target.length;
                    if (!targetStart) targetStart = 0;
                    if (end > 0 && end < start) end = start;

                    // Copy 0 bytes; we're done
                    if (end === start) return 0;
                    if (target.length === 0 || this.length === 0) return 0;

                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError('targetStart out of bounds');
                    }
                    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
                    if (end < 0) throw new RangeError('sourceEnd out of bounds');

                    // Are we oob?
                    if (end > this.length) end = this.length;
                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start;
                    }

                    var len = end - start;
                    var i;

                    if (this === target && start < targetStart && targetStart < end) {
                        // descending copy from end
                        for (i = len - 1; i >= 0; i--) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                        // ascending copy from start
                        for (i = 0; i < len; i++) {
                            target[i + targetStart] = this[i + start];
                        }
                    } else {
                        target._set(this.subarray(start, start + len), targetStart);
                    }

                    return len;
                };

// fill(value, start=0, end=buffer.length)
                Buffer.prototype.fill = function fill(value, start, end) {
                    if (!value) value = 0;
                    if (!start) start = 0;
                    if (!end) end = this.length;

                    if (end < start) throw new RangeError('end < start');

                    // Fill 0 bytes; we're done
                    if (end === start) return;
                    if (this.length === 0) return;

                    if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');
                    if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

                    var i;
                    if (typeof value === 'number') {
                        for (i = start; i < end; i++) {
                            this[i] = value;
                        }
                    } else {
                        var bytes = utf8ToBytes(value.toString());
                        var len = bytes.length;
                        for (i = start; i < end; i++) {
                            this[i] = bytes[i % len];
                        }
                    }

                    return this;
                };

                /**
                 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
                 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
                 */
                Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
                    if (typeof Uint8Array !== 'undefined') {
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            return (new Buffer(this)).buffer;
                        } else {
                            var buf = new Uint8Array(this.length);
                            for (var i = 0, len = buf.length; i < len; i += 1) {
                                buf[i] = this[i];
                            }
                            return buf.buffer;
                        }
                    } else {
                        throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
                    }
                };

// HELPER FUNCTIONS
// ================

                var BP = Buffer.prototype;

                /**
                 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
                 */
                Buffer._augment = function _augment(arr) {
                    arr.constructor = Buffer;
                    arr._isBuffer = true;

                    // save reference to original Uint8Array set method before overwriting
                    arr._set = arr.set;

                    // deprecated
                    arr.get = BP.get;
                    arr.set = BP.set;

                    arr.write = BP.write;
                    arr.toString = BP.toString;
                    arr.toLocaleString = BP.toString;
                    arr.toJSON = BP.toJSON;
                    arr.equals = BP.equals;
                    arr.compare = BP.compare;
                    arr.indexOf = BP.indexOf;
                    arr.copy = BP.copy;
                    arr.slice = BP.slice;
                    arr.readUIntLE = BP.readUIntLE;
                    arr.readUIntBE = BP.readUIntBE;
                    arr.readUInt8 = BP.readUInt8;
                    arr.readUInt16LE = BP.readUInt16LE;
                    arr.readUInt16BE = BP.readUInt16BE;
                    arr.readUInt32LE = BP.readUInt32LE;
                    arr.readUInt32BE = BP.readUInt32BE;
                    arr.readIntLE = BP.readIntLE;
                    arr.readIntBE = BP.readIntBE;
                    arr.readInt8 = BP.readInt8;
                    arr.readInt16LE = BP.readInt16LE;
                    arr.readInt16BE = BP.readInt16BE;
                    arr.readInt32LE = BP.readInt32LE;
                    arr.readInt32BE = BP.readInt32BE;
                    arr.readFloatLE = BP.readFloatLE;
                    arr.readFloatBE = BP.readFloatBE;
                    arr.readDoubleLE = BP.readDoubleLE;
                    arr.readDoubleBE = BP.readDoubleBE;
                    arr.writeUInt8 = BP.writeUInt8;
                    arr.writeUIntLE = BP.writeUIntLE;
                    arr.writeUIntBE = BP.writeUIntBE;
                    arr.writeUInt16LE = BP.writeUInt16LE;
                    arr.writeUInt16BE = BP.writeUInt16BE;
                    arr.writeUInt32LE = BP.writeUInt32LE;
                    arr.writeUInt32BE = BP.writeUInt32BE;
                    arr.writeIntLE = BP.writeIntLE;
                    arr.writeIntBE = BP.writeIntBE;
                    arr.writeInt8 = BP.writeInt8;
                    arr.writeInt16LE = BP.writeInt16LE;
                    arr.writeInt16BE = BP.writeInt16BE;
                    arr.writeInt32LE = BP.writeInt32LE;
                    arr.writeInt32BE = BP.writeInt32BE;
                    arr.writeFloatLE = BP.writeFloatLE;
                    arr.writeFloatBE = BP.writeFloatBE;
                    arr.writeDoubleLE = BP.writeDoubleLE;
                    arr.writeDoubleBE = BP.writeDoubleBE;
                    arr.fill = BP.fill;
                    arr.inspect = BP.inspect;
                    arr.toArrayBuffer = BP.toArrayBuffer;

                    return arr;
                };

                var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

                function base64clean(str) {
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2) return '';
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str = str + '=';
                    }
                    return str;
                }

                function stringtrim(str) {
                    if (str.trim) return str.trim();
                    return str.replace(/^\s+|\s+$/g, '');
                }

                function toHex(n) {
                    if (n < 16) return '0' + n.toString(16);
                    return n.toString(16);
                }

                function utf8ToBytes(string, units) {
                    units = units || Infinity;
                    var codePoint;
                    var length = string.length;
                    var leadSurrogate = null;
                    var bytes = [];

                    for (var i = 0; i < length; i++) {
                        codePoint = string.charCodeAt(i);

                        // is surrogate component
                        if (codePoint > 0xD7FF && codePoint < 0xE000) {
                            // last char was a lead
                            if (!leadSurrogate) {
                                // no lead yet
                                if (codePoint > 0xDBFF) {
                                    // unexpected trail
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                }

                                // valid lead
                                leadSurrogate = codePoint;

                                continue;
                            }

                            // 2 leads in a row
                            if (codePoint < 0xDC00) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                leadSurrogate = codePoint;
                                continue;
                            }

                            // valid surrogate pair
                            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                        }

                        leadSurrogate = null;

                        // encode utf8
                        if (codePoint < 0x80) {
                            if ((units -= 1) < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0) break;
                            bytes.push(
                                codePoint >> 0x6 | 0xC0,
                                codePoint & 0x3F | 0x80
                            );
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0) break;
                            bytes.push(
                                codePoint >> 0xC | 0xE0,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            );
                        } else if (codePoint < 0x110000) {
                            if ((units -= 4) < 0) break;
                            bytes.push(
                                codePoint >> 0x12 | 0xF0,
                                codePoint >> 0xC & 0x3F | 0x80,
                                codePoint >> 0x6 & 0x3F | 0x80,
                                codePoint & 0x3F | 0x80
                            );
                        } else {
                            throw new Error('Invalid code point');
                        }
                    }

                    return bytes;
                }

                function asciiToBytes(str) {
                    var byteArray = [];
                    for (var i = 0; i < str.length; i++) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 0xFF);
                    }
                    return byteArray;
                }

                function utf16leToBytes(str, units) {
                    var c, hi, lo;
                    var byteArray = [];
                    for (var i = 0; i < str.length; i++) {
                        if ((units -= 2) < 0) break;

                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }

                    return byteArray;
                }

                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }

                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length; i++) {
                        if ((i + offset >= dst.length) || (i >= src.length)) break;
                        dst[i + offset] = src[i];
                    }
                    return i;
                }

            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { 'base64-js': 25, 'ieee754': 114, 'isarray': 118 }],
        60: [function(require, module, exports) {
            module.exports = {
                '100': 'Continue',
                '101': 'Switching Protocols',
                '102': 'Processing',
                '200': 'OK',
                '201': 'Created',
                '202': 'Accepted',
                '203': 'Non-Authoritative Information',
                '204': 'No Content',
                '205': 'Reset Content',
                '206': 'Partial Content',
                '207': 'Multi-Status',
                '208': 'Already Reported',
                '226': 'IM Used',
                '300': 'Multiple Choices',
                '301': 'Moved Permanently',
                '302': 'Found',
                '303': 'See Other',
                '304': 'Not Modified',
                '305': 'Use Proxy',
                '307': 'Temporary Redirect',
                '308': 'Permanent Redirect',
                '400': 'Bad Request',
                '401': 'Unauthorized',
                '402': 'Payment Required',
                '403': 'Forbidden',
                '404': 'Not Found',
                '405': 'Method Not Allowed',
                '406': 'Not Acceptable',
                '407': 'Proxy Authentication Required',
                '408': 'Request Timeout',
                '409': 'Conflict',
                '410': 'Gone',
                '411': 'Length Required',
                '412': 'Precondition Failed',
                '413': 'Payload Too Large',
                '414': 'URI Too Long',
                '415': 'Unsupported Media Type',
                '416': 'Range Not Satisfiable',
                '417': 'Expectation Failed',
                '418': 'I\'m a teapot',
                '421': 'Misdirected Request',
                '422': 'Unprocessable Entity',
                '423': 'Locked',
                '424': 'Failed Dependency',
                '425': 'Unordered Collection',
                '426': 'Upgrade Required',
                '428': 'Precondition Required',
                '429': 'Too Many Requests',
                '431': 'Request Header Fields Too Large',
                '451': 'Unavailable For Legal Reasons',
                '500': 'Internal Server Error',
                '501': 'Not Implemented',
                '502': 'Bad Gateway',
                '503': 'Service Unavailable',
                '504': 'Gateway Timeout',
                '505': 'HTTP Version Not Supported',
                '506': 'Variant Also Negotiates',
                '507': 'Insufficient Storage',
                '508': 'Loop Detected',
                '509': 'Bandwidth Limit Exceeded',
                '510': 'Not Extended',
                '511': 'Network Authentication Required'
            };

        }, {}],
        61: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;
            var Transform = require('stream').Transform;
            var StringDecoder = require('string_decoder').StringDecoder;
            var inherits = require('inherits');

            function CipherBase(hashMode) {
                Transform.call(this);
                this.hashMode = typeof hashMode === 'string';
                if (this.hashMode) {
                    this[hashMode] = this._finalOrDigest;
                } else {
                    this.final = this._finalOrDigest;
                }
                if (this._final) {
                    this.__final = this._final;
                    this._final = null;
                }
                this._decoder = null;
                this._encoding = null;
            }

            inherits(CipherBase, Transform);

            CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
                if (typeof data === 'string') {
                    data = Buffer.from(data, inputEnc);
                }

                var outData = this._update(data);
                if (this.hashMode) return this;

                if (outputEnc) {
                    outData = this._toString(outData, outputEnc);
                }

                return outData;
            };

            CipherBase.prototype.setAutoPadding = function() {
            };
            CipherBase.prototype.getAuthTag = function() {
                throw new Error('trying to get auth tag in unsupported state');
            };

            CipherBase.prototype.setAuthTag = function() {
                throw new Error('trying to set auth tag in unsupported state');
            };

            CipherBase.prototype.setAAD = function() {
                throw new Error('trying to set aad in unsupported state');
            };

            CipherBase.prototype._transform = function(data, _, next) {
                var err;
                try {
                    if (this.hashMode) {
                        this._update(data);
                    } else {
                        this.push(this._update(data));
                    }
                } catch (e) {
                    err = e;
                } finally {
                    next(err);
                }
            };
            CipherBase.prototype._flush = function(done) {
                var err;
                try {
                    this.push(this.__final());
                } catch (e) {
                    err = e;
                }

                done(err);
            };
            CipherBase.prototype._finalOrDigest = function(outputEnc) {
                var outData = this.__final() || Buffer.alloc(0);
                if (outputEnc) {
                    outData = this._toString(outData, outputEnc, true);
                }
                return outData;
            };

            CipherBase.prototype._toString = function(value, enc, fin) {
                if (!this._decoder) {
                    this._decoder = new StringDecoder(enc);
                    this._encoding = enc;
                }

                if (this._encoding !== enc) throw new Error('can\'t switch encodings');

                var out = this._decoder.write(value);
                if (fin) {
                    out += this._decoder.end();
                }

                return out;
            };

            module.exports = CipherBase;

        }, { 'inherits': 116, 'safe-buffer': 169, 'stream': 179, 'string_decoder': 184 }],
        62: [function(require, module, exports) {
            (function(Buffer) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

                function isArray(arg) {
                    if (Array.isArray) {
                        return Array.isArray(arg);
                    }
                    return objectToString(arg) === '[object Array]';
                }

                exports.isArray = isArray;

                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }

                exports.isBoolean = isBoolean;

                function isNull(arg) {
                    return arg === null;
                }

                exports.isNull = isNull;

                function isNullOrUndefined(arg) {
                    return arg == null;
                }

                exports.isNullOrUndefined = isNullOrUndefined;

                function isNumber(arg) {
                    return typeof arg === 'number';
                }

                exports.isNumber = isNumber;

                function isString(arg) {
                    return typeof arg === 'string';
                }

                exports.isString = isString;

                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }

                exports.isSymbol = isSymbol;

                function isUndefined(arg) {
                    return arg === void 0;
                }

                exports.isUndefined = isUndefined;

                function isRegExp(re) {
                    return objectToString(re) === '[object RegExp]';
                }

                exports.isRegExp = isRegExp;

                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }

                exports.isObject = isObject;

                function isDate(d) {
                    return objectToString(d) === '[object Date]';
                }

                exports.isDate = isDate;

                function isError(e) {
                    return (objectToString(e) === '[object Error]' || e instanceof Error);
                }

                exports.isError = isError;

                function isFunction(arg) {
                    return typeof arg === 'function';
                }

                exports.isFunction = isFunction;

                function isPrimitive(arg) {
                    return arg === null ||
                        typeof arg === 'boolean' ||
                        typeof arg === 'number' ||
                        typeof arg === 'string' ||
                        typeof arg === 'symbol' ||  // ES6 symbol
                        typeof arg === 'undefined';
                }

                exports.isPrimitive = isPrimitive;

                exports.isBuffer = Buffer.isBuffer;

                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }

            }).call(this, { 'isBuffer': require('../../is-buffer/index.js') });
        }, { '../../is-buffer/index.js': 117 }],
        63: [function(require, module, exports) {
            (function(Buffer) {
                var elliptic = require('elliptic');
                var BN = require('bn.js');

                module.exports = function createECDH(curve) {
                    return new ECDH(curve);
                };

                var aliases = {
                    secp256k1: {
                        name: 'secp256k1',
                        byteLength: 32
                    },
                    secp224r1: {
                        name: 'p224',
                        byteLength: 28
                    },
                    prime256v1: {
                        name: 'p256',
                        byteLength: 32
                    },
                    prime192v1: {
                        name: 'p192',
                        byteLength: 24
                    },
                    ed25519: {
                        name: 'ed25519',
                        byteLength: 32
                    },
                    secp384r1: {
                        name: 'p384',
                        byteLength: 48
                    },
                    secp521r1: {
                        name: 'p521',
                        byteLength: 66
                    }
                };

                aliases.p224 = aliases.secp224r1;
                aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
                aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
                aliases.p384 = aliases.secp384r1;
                aliases.p521 = aliases.secp521r1;

                function ECDH(curve) {
                    this.curveType = aliases[curve];
                    if (!this.curveType) {
                        this.curveType = {
                            name: curve
                        };
                    }
                    this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap
                    this.keys = void 0;
                }

                ECDH.prototype.generateKeys = function(enc, format) {
                    this.keys = this.curve.genKeyPair();
                    return this.getPublicKey(enc, format);
                };

                ECDH.prototype.computeSecret = function(other, inenc, enc) {
                    inenc = inenc || 'utf8';
                    if (!Buffer.isBuffer(other)) {
                        other = new Buffer(other, inenc);
                    }
                    var otherPub = this.curve.keyFromPublic(other).getPublic();
                    var out = otherPub.mul(this.keys.getPrivate()).getX();
                    return formatReturnValue(out, enc, this.curveType.byteLength);
                };

                ECDH.prototype.getPublicKey = function(enc, format) {
                    var key = this.keys.getPublic(format === 'compressed', true);
                    if (format === 'hybrid') {
                        if (key[key.length - 1] % 2) {
                            key[0] = 7;
                        } else {
                            key[0] = 6;
                        }
                    }
                    return formatReturnValue(key, enc);
                };

                ECDH.prototype.getPrivateKey = function(enc) {
                    return formatReturnValue(this.keys.getPrivate(), enc);
                };

                ECDH.prototype.setPublicKey = function(pub, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(pub)) {
                        pub = new Buffer(pub, enc);
                    }
                    this.keys._importPublic(pub);
                    return this;
                };

                ECDH.prototype.setPrivateKey = function(priv, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(priv)) {
                        priv = new Buffer(priv, enc);
                    }

                    var _priv = new BN(priv);
                    _priv = _priv.toString(16);
                    this.keys = this.curve.genKeyPair();
                    this.keys._importPrivate(_priv);
                    return this;
                };

                function formatReturnValue(bn, enc, len) {
                    if (!Array.isArray(bn)) {
                        bn = bn.toArray();
                    }
                    var buf = new Buffer(bn);
                    if (len && buf.length < len) {
                        var zeros = new Buffer(len - buf.length);
                        zeros.fill(0);
                        buf = Buffer.concat([zeros, buf]);
                    }
                    if (!enc) {
                        return buf;
                    } else {
                        return buf.toString(enc);
                    }
                }

            }).call(this, require('buffer').Buffer);
        }, { 'bn.js': 27, 'buffer': 59, 'elliptic': 80 }],
        64: [function(require, module, exports) {
            'use strict';
            var inherits = require('inherits');
            var MD5 = require('md5.js');
            var RIPEMD160 = require('ripemd160');
            var sha = require('sha.js');
            var Base = require('cipher-base');

            function Hash(hash) {
                Base.call(this, 'digest');

                this._hash = hash;
            }

            inherits(Hash, Base);

            Hash.prototype._update = function(data) {
                this._hash.update(data);
            };

            Hash.prototype._final = function() {
                return this._hash.digest();
            };

            module.exports = function createHash(alg) {
                alg = alg.toLowerCase();
                if (alg === 'md5') return new MD5();
                if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();

                return new Hash(sha(alg));
            };

        }, { 'cipher-base': 61, 'inherits': 116, 'md5.js': 121, 'ripemd160': 168, 'sha.js': 172 }],
        65: [function(require, module, exports) {
            var MD5 = require('md5.js');

            module.exports = function(buffer) {
                return new MD5().update(buffer).digest();
            };

        }, { 'md5.js': 121 }],
        66: [function(require, module, exports) {
            'use strict';
            var inherits = require('inherits');
            var Legacy = require('./legacy');
            var Base = require('cipher-base');
            var Buffer = require('safe-buffer').Buffer;
            var md5 = require('create-hash/md5');
            var RIPEMD160 = require('ripemd160');

            var sha = require('sha.js');

            var ZEROS = Buffer.alloc(128);

            function Hmac(alg, key) {
                Base.call(this, 'digest');
                if (typeof key === 'string') {
                    key = Buffer.from(key);
                }

                var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

                this._alg = alg;
                this._key = key;
                if (key.length > blocksize) {
                    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
                    key = hash.update(key).digest();
                } else if (key.length < blocksize) {
                    key = Buffer.concat([key, ZEROS], blocksize);
                }

                var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
                var opad = this._opad = Buffer.allocUnsafe(blocksize);

                for (var i = 0; i < blocksize; i++) {
                    ipad[i] = key[i] ^ 0x36;
                    opad[i] = key[i] ^ 0x5C;
                }
                this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
                this._hash.update(ipad);
            }

            inherits(Hmac, Base);

            Hmac.prototype._update = function(data) {
                this._hash.update(data);
            };

            Hmac.prototype._final = function() {
                var h = this._hash.digest();
                var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
                return hash.update(this._opad).update(h).digest();
            };

            module.exports = function createHmac(alg, key) {
                alg = alg.toLowerCase();
                if (alg === 'rmd160' || alg === 'ripemd160') {
                    return new Hmac('rmd160', key);
                }
                if (alg === 'md5') {
                    return new Legacy(md5, key);
                }
                return new Hmac(alg, key);
            };

        }, {
            './legacy': 67,
            'cipher-base': 61,
            'create-hash/md5': 65,
            'inherits': 116,
            'ripemd160': 168,
            'safe-buffer': 169,
            'sha.js': 172
        }],
        67: [function(require, module, exports) {
            'use strict';
            var inherits = require('inherits');
            var Buffer = require('safe-buffer').Buffer;

            var Base = require('cipher-base');

            var ZEROS = Buffer.alloc(128);
            var blocksize = 64;

            function Hmac(alg, key) {
                Base.call(this, 'digest');
                if (typeof key === 'string') {
                    key = Buffer.from(key);
                }

                this._alg = alg;
                this._key = key;

                if (key.length > blocksize) {
                    key = alg(key);
                } else if (key.length < blocksize) {
                    key = Buffer.concat([key, ZEROS], blocksize);
                }

                var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
                var opad = this._opad = Buffer.allocUnsafe(blocksize);

                for (var i = 0; i < blocksize; i++) {
                    ipad[i] = key[i] ^ 0x36;
                    opad[i] = key[i] ^ 0x5C;
                }

                this._hash = [ipad];
            }

            inherits(Hmac, Base);

            Hmac.prototype._update = function(data) {
                this._hash.push(data);
            };

            Hmac.prototype._final = function() {
                var h = this._alg(Buffer.concat(this._hash));
                return this._alg(Buffer.concat([this._opad, h]));
            };
            module.exports = Hmac;

        }, { 'cipher-base': 61, 'inherits': 116, 'safe-buffer': 169 }],
        68: [function(require, module, exports) {
            'use strict';

            exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');
            exports.createHash = exports.Hash = require('create-hash');
            exports.createHmac = exports.Hmac = require('create-hmac');

            var algos = require('browserify-sign/algos');
            var algoKeys = Object.keys(algos);
            var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);
            exports.getHashes = function() {
                return hashes;
            };

            var p = require('pbkdf2');
            exports.pbkdf2 = p.pbkdf2;
            exports.pbkdf2Sync = p.pbkdf2Sync;

            var aes = require('browserify-cipher');

            exports.Cipher = aes.Cipher;
            exports.createCipher = aes.createCipher;
            exports.Cipheriv = aes.Cipheriv;
            exports.createCipheriv = aes.createCipheriv;
            exports.Decipher = aes.Decipher;
            exports.createDecipher = aes.createDecipher;
            exports.Decipheriv = aes.Decipheriv;
            exports.createDecipheriv = aes.createDecipheriv;
            exports.getCiphers = aes.getCiphers;
            exports.listCiphers = aes.listCiphers;

            var dh = require('diffie-hellman');

            exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
            exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
            exports.getDiffieHellman = dh.getDiffieHellman;
            exports.createDiffieHellman = dh.createDiffieHellman;
            exports.DiffieHellman = dh.DiffieHellman;

            var sign = require('browserify-sign');

            exports.createSign = sign.createSign;
            exports.Sign = sign.Sign;
            exports.createVerify = sign.createVerify;
            exports.Verify = sign.Verify;

            exports.createECDH = require('create-ecdh');

            var publicEncrypt = require('public-encrypt');

            exports.publicEncrypt = publicEncrypt.publicEncrypt;
            exports.privateEncrypt = publicEncrypt.privateEncrypt;
            exports.publicDecrypt = publicEncrypt.publicDecrypt;
            exports.privateDecrypt = publicEncrypt.privateDecrypt;

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

            var rf = require('randomfill');

            exports.randomFill = rf.randomFill;
            exports.randomFillSync = rf.randomFillSync;

            exports.createCredentials = function() {
                throw new Error([
                    'sorry, createCredentials is not implemented yet',
                    'we accept pull requests',
                    'https://github.com/crypto-browserify/crypto-browserify'
                ].join('\n'));
            };

            exports.constants = {
                'DH_CHECK_P_NOT_SAFE_PRIME': 2,
                'DH_CHECK_P_NOT_PRIME': 1,
                'DH_UNABLE_TO_CHECK_GENERATOR': 4,
                'DH_NOT_SUITABLE_GENERATOR': 8,
                'NPN_ENABLED': 1,
                'ALPN_ENABLED': 1,
                'RSA_PKCS1_PADDING': 1,
                'RSA_SSLV23_PADDING': 2,
                'RSA_NO_PADDING': 3,
                'RSA_PKCS1_OAEP_PADDING': 4,
                'RSA_X931_PADDING': 5,
                'RSA_PKCS1_PSS_PADDING': 6,
                'POINT_CONVERSION_COMPRESSED': 2,
                'POINT_CONVERSION_UNCOMPRESSED': 4,
                'POINT_CONVERSION_HYBRID': 6
            };

        }, {
            'browserify-cipher': 47,
            'browserify-sign': 54,
            'browserify-sign/algos': 51,
            'create-ecdh': 63,
            'create-hash': 64,
            'create-hmac': 66,
            'diffie-hellman': 76,
            'pbkdf2': 135,
            'public-encrypt': 142,
            'randombytes': 152,
            'randomfill': 153
        }],
        69: [function(require, module, exports) {
            module.exports = function() {
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined) return arguments[i];
                }
            };

        }, {}],
        70: [function(require, module, exports) {
            'use strict';

            exports.utils = require('./des/utils');
            exports.Cipher = require('./des/cipher');
            exports.DES = require('./des/des');
            exports.CBC = require('./des/cbc');
            exports.EDE = require('./des/ede');

        }, { './des/cbc': 71, './des/cipher': 72, './des/des': 73, './des/ede': 74, './des/utils': 75 }],
        71: [function(require, module, exports) {
            'use strict';

            var assert = require('minimalistic-assert');
            var inherits = require('inherits');

            var proto = {};

            function CBCState(iv) {
                assert.equal(iv.length, 8, 'Invalid IV length');

                this.iv = new Array(8);
                for (var i = 0; i < this.iv.length; i++)
                    this.iv[i] = iv[i];
            }

            function instantiate(Base) {
                function CBC(options) {
                    Base.call(this, options);
                    this._cbcInit();
                }

                inherits(CBC, Base);

                var keys = Object.keys(proto);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    CBC.prototype[key] = proto[key];
                }

                CBC.create = function create(options) {
                    return new CBC(options);
                };

                return CBC;
            }

            exports.instantiate = instantiate;

            proto._cbcInit = function _cbcInit() {
                var state = new CBCState(this.options.iv);
                this._cbcState = state;
            };

            proto._update = function _update(inp, inOff, out, outOff) {
                var state = this._cbcState;
                var superProto = this.constructor.super_.prototype;

                var iv = state.iv;
                if (this.type === 'encrypt') {
                    for (var i = 0; i < this.blockSize; i++)
                        iv[i] ^= inp[inOff + i];

                    superProto._update.call(this, iv, 0, out, outOff);

                    for (var i = 0; i < this.blockSize; i++)
                        iv[i] = out[outOff + i];
                } else {
                    superProto._update.call(this, inp, inOff, out, outOff);

                    for (var i = 0; i < this.blockSize; i++)
                        out[outOff + i] ^= iv[i];

                    for (var i = 0; i < this.blockSize; i++)
                        iv[i] = inp[inOff + i];
                }
            };

        }, { 'inherits': 116, 'minimalistic-assert': 126 }],
        72: [function(require, module, exports) {
            'use strict';

            var assert = require('minimalistic-assert');

            function Cipher(options) {
                this.options = options;

                this.type = this.options.type;
                this.blockSize = 8;
                this._init();

                this.buffer = new Array(this.blockSize);
                this.bufferOff = 0;
            }

            module.exports = Cipher;

            Cipher.prototype._init = function _init() {
                // Might be overrided
            };

            Cipher.prototype.update = function update(data) {
                if (data.length === 0)
                    return [];

                if (this.type === 'decrypt')
                    return this._updateDecrypt(data);
                else
                    return this._updateEncrypt(data);
            };

            Cipher.prototype._buffer = function _buffer(data, off) {
                // Append data to buffer
                var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
                for (var i = 0; i < min; i++)
                    this.buffer[this.bufferOff + i] = data[off + i];
                this.bufferOff += min;

                // Shift next
                return min;
            };

            Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
                this._update(this.buffer, 0, out, off);
                this.bufferOff = 0;
                return this.blockSize;
            };

            Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
                var inputOff = 0;
                var outputOff = 0;

                var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
                var out = new Array(count * this.blockSize);

                if (this.bufferOff !== 0) {
                    inputOff += this._buffer(data, inputOff);

                    if (this.bufferOff === this.buffer.length)
                        outputOff += this._flushBuffer(out, outputOff);
                }

                // Write blocks
                var max = data.length - ((data.length - inputOff) % this.blockSize);
                for (; inputOff < max; inputOff += this.blockSize) {
                    this._update(data, inputOff, out, outputOff);
                    outputOff += this.blockSize;
                }

                // Queue rest
                for (; inputOff < data.length; inputOff++, this.bufferOff++)
                    this.buffer[this.bufferOff] = data[inputOff];

                return out;
            };

            Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
                var inputOff = 0;
                var outputOff = 0;

                var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
                var out = new Array(count * this.blockSize);

                // TODO(indutny): optimize it, this is far from optimal
                for (; count > 0; count--) {
                    inputOff += this._buffer(data, inputOff);
                    outputOff += this._flushBuffer(out, outputOff);
                }

                // Buffer rest of the input
                inputOff += this._buffer(data, inputOff);

                return out;
            };

            Cipher.prototype.final = function final(buffer) {
                var first;
                if (buffer)
                    first = this.update(buffer);

                var last;
                if (this.type === 'encrypt')
                    last = this._finalEncrypt();
                else
                    last = this._finalDecrypt();

                if (first)
                    return first.concat(last);
                else
                    return last;
            };

            Cipher.prototype._pad = function _pad(buffer, off) {
                if (off === 0)
                    return false;

                while (off < buffer.length)
                    buffer[off++] = 0;

                return true;
            };

            Cipher.prototype._finalEncrypt = function _finalEncrypt() {
                if (!this._pad(this.buffer, this.bufferOff))
                    return [];

                var out = new Array(this.blockSize);
                this._update(this.buffer, 0, out, 0);
                return out;
            };

            Cipher.prototype._unpad = function _unpad(buffer) {
                return buffer;
            };

            Cipher.prototype._finalDecrypt = function _finalDecrypt() {
                assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
                var out = new Array(this.blockSize);
                this._flushBuffer(out, 0);

                return this._unpad(out);
            };

        }, { 'minimalistic-assert': 126 }],
        73: [function(require, module, exports) {
            'use strict';

            var assert = require('minimalistic-assert');
            var inherits = require('inherits');

            var des = require('../des');
            var utils = des.utils;
            var Cipher = des.Cipher;

            function DESState() {
                this.tmp = new Array(2);
                this.keys = null;
            }

            function DES(options) {
                Cipher.call(this, options);

                var state = new DESState();
                this._desState = state;

                this.deriveKeys(state, options.key);
            }

            inherits(DES, Cipher);
            module.exports = DES;

            DES.create = function create(options) {
                return new DES(options);
            };

            var shiftTable = [
                1, 1, 2, 2, 2, 2, 2, 2,
                1, 2, 2, 2, 2, 2, 2, 1
            ];

            DES.prototype.deriveKeys = function deriveKeys(state, key) {
                state.keys = new Array(16 * 2);

                assert.equal(key.length, this.blockSize, 'Invalid key length');

                var kL = utils.readUInt32BE(key, 0);
                var kR = utils.readUInt32BE(key, 4);

                utils.pc1(kL, kR, state.tmp, 0);
                kL = state.tmp[0];
                kR = state.tmp[1];
                for (var i = 0; i < state.keys.length; i += 2) {
                    var shift = shiftTable[i >>> 1];
                    kL = utils.r28shl(kL, shift);
                    kR = utils.r28shl(kR, shift);
                    utils.pc2(kL, kR, state.keys, i);
                }
            };

            DES.prototype._update = function _update(inp, inOff, out, outOff) {
                var state = this._desState;

                var l = utils.readUInt32BE(inp, inOff);
                var r = utils.readUInt32BE(inp, inOff + 4);

                // Initial Permutation
                utils.ip(l, r, state.tmp, 0);
                l = state.tmp[0];
                r = state.tmp[1];

                if (this.type === 'encrypt')
                    this._encrypt(state, l, r, state.tmp, 0);
                else
                    this._decrypt(state, l, r, state.tmp, 0);

                l = state.tmp[0];
                r = state.tmp[1];

                utils.writeUInt32BE(out, l, outOff);
                utils.writeUInt32BE(out, r, outOff + 4);
            };

            DES.prototype._pad = function _pad(buffer, off) {
                var value = buffer.length - off;
                for (var i = off; i < buffer.length; i++)
                    buffer[i] = value;

                return true;
            };

            DES.prototype._unpad = function _unpad(buffer) {
                var pad = buffer[buffer.length - 1];
                for (var i = buffer.length - pad; i < buffer.length; i++)
                    assert.equal(buffer[i], pad);

                return buffer.slice(0, buffer.length - pad);
            };

            DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
                var l = lStart;
                var r = rStart;

                // Apply f() x16 times
                for (var i = 0; i < state.keys.length; i += 2) {
                    var keyL = state.keys[i];
                    var keyR = state.keys[i + 1];

                    // f(r, k)
                    utils.expand(r, state.tmp, 0);

                    keyL ^= state.tmp[0];
                    keyR ^= state.tmp[1];
                    var s = utils.substitute(keyL, keyR);
                    var f = utils.permute(s);

                    var t = r;
                    r = (l ^ f) >>> 0;
                    l = t;
                }

                // Reverse Initial Permutation
                utils.rip(r, l, out, off);
            };

            DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
                var l = rStart;
                var r = lStart;

                // Apply f() x16 times
                for (var i = state.keys.length - 2; i >= 0; i -= 2) {
                    var keyL = state.keys[i];
                    var keyR = state.keys[i + 1];

                    // f(r, k)
                    utils.expand(l, state.tmp, 0);

                    keyL ^= state.tmp[0];
                    keyR ^= state.tmp[1];
                    var s = utils.substitute(keyL, keyR);
                    var f = utils.permute(s);

                    var t = l;
                    l = (r ^ f) >>> 0;
                    r = t;
                }

                // Reverse Initial Permutation
                utils.rip(l, r, out, off);
            };

        }, { '../des': 70, 'inherits': 116, 'minimalistic-assert': 126 }],
        74: [function(require, module, exports) {
            'use strict';

            var assert = require('minimalistic-assert');
            var inherits = require('inherits');

            var des = require('../des');
            var Cipher = des.Cipher;
            var DES = des.DES;

            function EDEState(type, key) {
                assert.equal(key.length, 24, 'Invalid key length');

                var k1 = key.slice(0, 8);
                var k2 = key.slice(8, 16);
                var k3 = key.slice(16, 24);

                if (type === 'encrypt') {
                    this.ciphers = [
                        DES.create({ type: 'encrypt', key: k1 }),
                        DES.create({ type: 'decrypt', key: k2 }),
                        DES.create({ type: 'encrypt', key: k3 })
                    ];
                } else {
                    this.ciphers = [
                        DES.create({ type: 'decrypt', key: k3 }),
                        DES.create({ type: 'encrypt', key: k2 }),
                        DES.create({ type: 'decrypt', key: k1 })
                    ];
                }
            }

            function EDE(options) {
                Cipher.call(this, options);

                var state = new EDEState(this.type, this.options.key);
                this._edeState = state;
            }

            inherits(EDE, Cipher);

            module.exports = EDE;

            EDE.create = function create(options) {
                return new EDE(options);
            };

            EDE.prototype._update = function _update(inp, inOff, out, outOff) {
                var state = this._edeState;

                state.ciphers[0]._update(inp, inOff, out, outOff);
                state.ciphers[1]._update(out, outOff, out, outOff);
                state.ciphers[2]._update(out, outOff, out, outOff);
            };

            EDE.prototype._pad = DES.prototype._pad;
            EDE.prototype._unpad = DES.prototype._unpad;

        }, { '../des': 70, 'inherits': 116, 'minimalistic-assert': 126 }],
        75: [function(require, module, exports) {
            'use strict';

            exports.readUInt32BE = function readUInt32BE(bytes, off) {
                var res = (bytes[0 + off] << 24) |
                    (bytes[1 + off] << 16) |
                    (bytes[2 + off] << 8) |
                    bytes[3 + off];
                return res >>> 0;
            };

            exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
                bytes[0 + off] = value >>> 24;
                bytes[1 + off] = (value >>> 16) & 0xff;
                bytes[2 + off] = (value >>> 8) & 0xff;
                bytes[3 + off] = value & 0xff;
            };

            exports.ip = function ip(inL, inR, out, off) {
                var outL = 0;
                var outR = 0;

                for (var i = 6; i >= 0; i -= 2) {
                    for (var j = 0; j <= 24; j += 8) {
                        outL <<= 1;
                        outL |= (inR >>> (j + i)) & 1;
                    }
                    for (var j = 0; j <= 24; j += 8) {
                        outL <<= 1;
                        outL |= (inL >>> (j + i)) & 1;
                    }
                }

                for (var i = 6; i >= 0; i -= 2) {
                    for (var j = 1; j <= 25; j += 8) {
                        outR <<= 1;
                        outR |= (inR >>> (j + i)) & 1;
                    }
                    for (var j = 1; j <= 25; j += 8) {
                        outR <<= 1;
                        outR |= (inL >>> (j + i)) & 1;
                    }
                }

                out[off + 0] = outL >>> 0;
                out[off + 1] = outR >>> 0;
            };

            exports.rip = function rip(inL, inR, out, off) {
                var outL = 0;
                var outR = 0;

                for (var i = 0; i < 4; i++) {
                    for (var j = 24; j >= 0; j -= 8) {
                        outL <<= 1;
                        outL |= (inR >>> (j + i)) & 1;
                        outL <<= 1;
                        outL |= (inL >>> (j + i)) & 1;
                    }
                }
                for (var i = 4; i < 8; i++) {
                    for (var j = 24; j >= 0; j -= 8) {
                        outR <<= 1;
                        outR |= (inR >>> (j + i)) & 1;
                        outR <<= 1;
                        outR |= (inL >>> (j + i)) & 1;
                    }
                }

                out[off + 0] = outL >>> 0;
                out[off + 1] = outR >>> 0;
            };

            exports.pc1 = function pc1(inL, inR, out, off) {
                var outL = 0;
                var outR = 0;

                // 7, 15, 23, 31, 39, 47, 55, 63
                // 6, 14, 22, 30, 39, 47, 55, 63
                // 5, 13, 21, 29, 39, 47, 55, 63
                // 4, 12, 20, 28
                for (var i = 7; i >= 5; i--) {
                    for (var j = 0; j <= 24; j += 8) {
                        outL <<= 1;
                        outL |= (inR >> (j + i)) & 1;
                    }
                    for (var j = 0; j <= 24; j += 8) {
                        outL <<= 1;
                        outL |= (inL >> (j + i)) & 1;
                    }
                }
                for (var j = 0; j <= 24; j += 8) {
                    outL <<= 1;
                    outL |= (inR >> (j + i)) & 1;
                }

                // 1, 9, 17, 25, 33, 41, 49, 57
                // 2, 10, 18, 26, 34, 42, 50, 58
                // 3, 11, 19, 27, 35, 43, 51, 59
                // 36, 44, 52, 60
                for (var i = 1; i <= 3; i++) {
                    for (var j = 0; j <= 24; j += 8) {
                        outR <<= 1;
                        outR |= (inR >> (j + i)) & 1;
                    }
                    for (var j = 0; j <= 24; j += 8) {
                        outR <<= 1;
                        outR |= (inL >> (j + i)) & 1;
                    }
                }
                for (var j = 0; j <= 24; j += 8) {
                    outR <<= 1;
                    outR |= (inL >> (j + i)) & 1;
                }

                out[off + 0] = outL >>> 0;
                out[off + 1] = outR >>> 0;
            };

            exports.r28shl = function r28shl(num, shift) {
                return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
            };

            var pc2table = [
                // inL => outL
                14, 11, 17, 4, 27, 23, 25, 0,
                13, 22, 7, 18, 5, 9, 16, 24,
                2, 20, 12, 21, 1, 8, 15, 26,

                // inR => outR
                15, 4, 25, 19, 9, 1, 26, 16,
                5, 11, 23, 8, 12, 7, 17, 0,
                22, 3, 10, 14, 6, 20, 27, 24
            ];

            exports.pc2 = function pc2(inL, inR, out, off) {
                var outL = 0;
                var outR = 0;

                var len = pc2table.length >>> 1;
                for (var i = 0; i < len; i++) {
                    outL <<= 1;
                    outL |= (inL >>> pc2table[i]) & 0x1;
                }
                for (var i = len; i < pc2table.length; i++) {
                    outR <<= 1;
                    outR |= (inR >>> pc2table[i]) & 0x1;
                }

                out[off + 0] = outL >>> 0;
                out[off + 1] = outR >>> 0;
            };

            exports.expand = function expand(r, out, off) {
                var outL = 0;
                var outR = 0;

                outL = ((r & 1) << 5) | (r >>> 27);
                for (var i = 23; i >= 15; i -= 4) {
                    outL <<= 6;
                    outL |= (r >>> i) & 0x3f;
                }
                for (var i = 11; i >= 3; i -= 4) {
                    outR |= (r >>> i) & 0x3f;
                    outR <<= 6;
                }
                outR |= ((r & 0x1f) << 1) | (r >>> 31);

                out[off + 0] = outL >>> 0;
                out[off + 1] = outR >>> 0;
            };

            var sTable = [
                14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
                3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
                4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
                15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

                15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
                9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
                0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
                5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

                10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
                1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
                13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
                11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

                7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
                1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
                10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
                15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

                2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
                8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
                4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
                15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

                12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
                0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
                9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
                7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

                4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
                3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
                1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
                10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

                13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
                10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
                7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
                0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
            ];

            exports.substitute = function substitute(inL, inR) {
                var out = 0;
                for (var i = 0; i < 4; i++) {
                    var b = (inL >>> (18 - i * 6)) & 0x3f;
                    var sb = sTable[i * 0x40 + b];

                    out <<= 4;
                    out |= sb;
                }
                for (var i = 0; i < 4; i++) {
                    var b = (inR >>> (18 - i * 6)) & 0x3f;
                    var sb = sTable[4 * 0x40 + i * 0x40 + b];

                    out <<= 4;
                    out |= sb;
                }
                return out >>> 0;
            };

            var permuteTable = [
                16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
                30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
            ];

            exports.permute = function permute(num) {
                var out = 0;
                for (var i = 0; i < permuteTable.length; i++) {
                    out <<= 1;
                    out |= (num >>> permuteTable[i]) & 0x1;
                }
                return out >>> 0;
            };

            exports.padSplit = function padSplit(num, size, group) {
                var str = num.toString(2);
                while (str.length < size)
                    str = '0' + str;

                var out = [];
                for (var i = 0; i < size; i += group)
                    out.push(str.slice(i, i + group));
                return out.join(' ');
            };

        }, {}],
        76: [function(require, module, exports) {
            (function(Buffer) {
                var generatePrime = require('./lib/generatePrime');
                var primes = require('./lib/primes.json');

                var DH = require('./lib/dh');

                function getDiffieHellman(mod) {
                    var prime = new Buffer(primes[mod].prime, 'hex');
                    var gen = new Buffer(primes[mod].gen, 'hex');

                    return new DH(prime, gen);
                }

                var ENCODINGS = {
                    'binary': true, 'hex': true, 'base64': true
                };

                function createDiffieHellman(prime, enc, generator, genc) {
                    if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
                        return createDiffieHellman(prime, 'binary', enc, generator);
                    }

                    enc = enc || 'binary';
                    genc = genc || 'binary';
                    generator = generator || new Buffer([2]);

                    if (!Buffer.isBuffer(generator)) {
                        generator = new Buffer(generator, genc);
                    }

                    if (typeof prime === 'number') {
                        return new DH(generatePrime(prime, generator), generator, true);
                    }

                    if (!Buffer.isBuffer(prime)) {
                        prime = new Buffer(prime, enc);
                    }

                    return new DH(prime, generator, true);
                }

                exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
                exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

            }).call(this, require('buffer').Buffer);
        }, { './lib/dh': 77, './lib/generatePrime': 78, './lib/primes.json': 79, 'buffer': 59 }],
        77: [function(require, module, exports) {
            (function(Buffer) {
                var BN = require('bn.js');
                var MillerRabin = require('miller-rabin');
                var millerRabin = new MillerRabin();
                var TWENTYFOUR = new BN(24);
                var ELEVEN = new BN(11);
                var TEN = new BN(10);
                var THREE = new BN(3);
                var SEVEN = new BN(7);
                var primes = require('./generatePrime');
                var randomBytes = require('randombytes');
                module.exports = DH;

                function setPublicKey(pub, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(pub)) {
                        pub = new Buffer(pub, enc);
                    }
                    this._pub = new BN(pub);
                    return this;
                }

                function setPrivateKey(priv, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(priv)) {
                        priv = new Buffer(priv, enc);
                    }
                    this._priv = new BN(priv);
                    return this;
                }

                var primeCache = {};

                function checkPrime(prime, generator) {
                    var gen = generator.toString('hex');
                    var hex = [gen, prime.toString(16)].join('_');
                    if (hex in primeCache) {
                        return primeCache[hex];
                    }
                    var error = 0;

                    if (prime.isEven() ||
                        !primes.simpleSieve ||
                        !primes.fermatTest(prime) ||
                        !millerRabin.test(prime)) {
                        //not a prime so +1
                        error += 1;

                        if (gen === '02' || gen === '05') {
                            // we'd be able to check the generator
                            // it would fail so +8
                            error += 8;
                        } else {
                            //we wouldn't be able to test the generator
                            // so +4
                            error += 4;
                        }
                        primeCache[hex] = error;
                        return error;
                    }
                    if (!millerRabin.test(prime.shrn(1))) {
                        //not a safe prime
                        error += 2;
                    }
                    var rem;
                    switch (gen) {
                        case '02':
                            if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                                // unsuidable generator
                                error += 8;
                            }
                            break;
                        case '05':
                            rem = prime.mod(TEN);
                            if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                                // prime mod 10 needs to equal 3 or 7
                                error += 8;
                            }
                            break;
                        default:
                            error += 4;
                    }
                    primeCache[hex] = error;
                    return error;
                }

                function DH(prime, generator, malleable) {
                    this.setGenerator(generator);
                    this.__prime = new BN(prime);
                    this._prime = BN.mont(this.__prime);
                    this._primeLen = prime.length;
                    this._pub = undefined;
                    this._priv = undefined;
                    this._primeCode = undefined;
                    if (malleable) {
                        this.setPublicKey = setPublicKey;
                        this.setPrivateKey = setPrivateKey;
                    } else {
                        this._primeCode = 8;
                    }
                }

                Object.defineProperty(DH.prototype, 'verifyError', {
                    enumerable: true,
                    get: function() {
                        if (typeof this._primeCode !== 'number') {
                            this._primeCode = checkPrime(this.__prime, this.__gen);
                        }
                        return this._primeCode;
                    }
                });
                DH.prototype.generateKeys = function() {
                    if (!this._priv) {
                        this._priv = new BN(randomBytes(this._primeLen));
                    }
                    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
                    return this.getPublicKey();
                };

                DH.prototype.computeSecret = function(other) {
                    other = new BN(other);
                    other = other.toRed(this._prime);
                    var secret = other.redPow(this._priv).fromRed();
                    var out = new Buffer(secret.toArray());
                    var prime = this.getPrime();
                    if (out.length < prime.length) {
                        var front = new Buffer(prime.length - out.length);
                        front.fill(0);
                        out = Buffer.concat([front, out]);
                    }
                    return out;
                };

                DH.prototype.getPublicKey = function getPublicKey(enc) {
                    return formatReturnValue(this._pub, enc);
                };

                DH.prototype.getPrivateKey = function getPrivateKey(enc) {
                    return formatReturnValue(this._priv, enc);
                };

                DH.prototype.getPrime = function(enc) {
                    return formatReturnValue(this.__prime, enc);
                };

                DH.prototype.getGenerator = function(enc) {
                    return formatReturnValue(this._gen, enc);
                };

                DH.prototype.setGenerator = function(gen, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(gen)) {
                        gen = new Buffer(gen, enc);
                    }
                    this.__gen = gen;
                    this._gen = new BN(gen);
                    return this;
                };

                function formatReturnValue(bn, enc) {
                    var buf = new Buffer(bn.toArray());
                    if (!enc) {
                        return buf;
                    } else {
                        return buf.toString(enc);
                    }
                }

            }).call(this, require('buffer').Buffer);
        }, { './generatePrime': 78, 'bn.js': 27, 'buffer': 59, 'miller-rabin': 122, 'randombytes': 152 }],
        78: [function(require, module, exports) {
            var randomBytes = require('randombytes');
            module.exports = findPrime;
            findPrime.simpleSieve = simpleSieve;
            findPrime.fermatTest = fermatTest;
            var BN = require('bn.js');
            var TWENTYFOUR = new BN(24);
            var MillerRabin = require('miller-rabin');
            var millerRabin = new MillerRabin();
            var ONE = new BN(1);
            var TWO = new BN(2);
            var FIVE = new BN(5);
            var SIXTEEN = new BN(16);
            var EIGHT = new BN(8);
            var TEN = new BN(10);
            var THREE = new BN(3);
            var SEVEN = new BN(7);
            var ELEVEN = new BN(11);
            var FOUR = new BN(4);
            var TWELVE = new BN(12);
            var primes = null;

            function _getPrimes() {
                if (primes !== null)
                    return primes;

                var limit = 0x100000;
                var res = [];
                res[0] = 2;
                for (var i = 1, k = 3; k < limit; k += 2) {
                    var sqrt = Math.ceil(Math.sqrt(k));
                    for (var j = 0; j < i && res[j] <= sqrt; j++)
                        if (k % res[j] === 0)
                            break;

                    if (i !== j && res[j] <= sqrt)
                        continue;

                    res[i++] = k;
                }
                primes = res;
                return res;
            }

            function simpleSieve(p) {
                var primes = _getPrimes();

                for (var i = 0; i < primes.length; i++)
                    if (p.modn(primes[i]) === 0) {
                        if (p.cmpn(primes[i]) === 0) {
                            return true;
                        } else {
                            return false;
                        }
                    }

                return true;
            }

            function fermatTest(p) {
                var red = BN.mont(p);
                return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
            }

            function findPrime(bits, gen) {
                if (bits < 16) {
                    // this is what openssl does
                    if (gen === 2 || gen === 5) {
                        return new BN([0x8c, 0x7b]);
                    } else {
                        return new BN([0x8c, 0x27]);
                    }
                }
                gen = new BN(gen);

                var num, n2;

                while (true) {
                    num = new BN(randomBytes(Math.ceil(bits / 8)));
                    while (num.bitLength() > bits) {
                        num.ishrn(1);
                    }
                    if (num.isEven()) {
                        num.iadd(ONE);
                    }
                    if (!num.testn(1)) {
                        num.iadd(TWO);
                    }
                    if (!gen.cmp(TWO)) {
                        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
                            num.iadd(FOUR);
                        }
                    } else if (!gen.cmp(FIVE)) {
                        while (num.mod(TEN).cmp(THREE)) {
                            num.iadd(FOUR);
                        }
                    }
                    n2 = num.shrn(1);
                    if (simpleSieve(n2) && simpleSieve(num) &&
                        fermatTest(n2) && fermatTest(num) &&
                        millerRabin.test(n2) && millerRabin.test(num)) {
                        return num;
                    }
                }

            }

        }, { 'bn.js': 27, 'miller-rabin': 122, 'randombytes': 152 }],
        79: [function(require, module, exports) {
            module.exports = {
                'modp1': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff'
                },
                'modp2': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff'
                },
                'modp5': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff'
                },
                'modp14': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff'
                },
                'modp15': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff'
                },
                'modp16': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff'
                },
                'modp17': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff'
                },
                'modp18': {
                    'gen': '02',
                    'prime': 'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff'
                }
            };
        }, {}],
        80: [function(require, module, exports) {
            'use strict';

            var elliptic = exports;

            elliptic.version = require('../package.json').version;
            elliptic.utils = require('./elliptic/utils');
            elliptic.rand = require('brorand');
            elliptic.curve = require('./elliptic/curve');
            elliptic.curves = require('./elliptic/curves');

// Protocols
            elliptic.ec = require('./elliptic/ec');
            elliptic.eddsa = require('./elliptic/eddsa');

        }, {
            '../package.json': 95,
            './elliptic/curve': 83,
            './elliptic/curves': 86,
            './elliptic/ec': 87,
            './elliptic/eddsa': 90,
            './elliptic/utils': 94,
            'brorand': 28
        }],
        81: [function(require, module, exports) {
            'use strict';

            var BN = require('bn.js');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var getNAF = utils.getNAF;
            var getJSF = utils.getJSF;
            var assert = utils.assert;

            function BaseCurve(type, conf) {
                this.type = type;
                this.p = new BN(conf.p, 16);

                // Use Montgomery, when there is no fast reduction for the prime
                this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

                // Useful for many curves
                this.zero = new BN(0).toRed(this.red);
                this.one = new BN(1).toRed(this.red);
                this.two = new BN(2).toRed(this.red);

                // Curve configuration, optional
                this.n = conf.n && new BN(conf.n, 16);
                this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

                // Temporary arrays
                this._wnafT1 = new Array(4);
                this._wnafT2 = new Array(4);
                this._wnafT3 = new Array(4);
                this._wnafT4 = new Array(4);

                // Generalized Greg Maxwell's trick
                var adjustCount = this.n && this.p.div(this.n);
                if (!adjustCount || adjustCount.cmpn(100) > 0) {
                    this.redN = null;
                } else {
                    this._maxwellTrick = true;
                    this.redN = this.n.toRed(this.red);
                }
            }

            module.exports = BaseCurve;

            BaseCurve.prototype.point = function point() {
                throw new Error('Not implemented');
            };

            BaseCurve.prototype.validate = function validate() {
                throw new Error('Not implemented');
            };

            BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
                assert(p.precomputed);
                var doubles = p._getDoubles();

                var naf = getNAF(k, 1);
                var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
                I /= 3;

                // Translate into more windowed form
                var repr = [];
                for (var j = 0; j < naf.length; j += doubles.step) {
                    var nafW = 0;
                    for (var k = j + doubles.step - 1; k >= j; k--)
                        nafW = (nafW << 1) + naf[k];
                    repr.push(nafW);
                }

                var a = this.jpoint(null, null, null);
                var b = this.jpoint(null, null, null);
                for (var i = I; i > 0; i--) {
                    for (var j = 0; j < repr.length; j++) {
                        var nafW = repr[j];
                        if (nafW === i)
                            b = b.mixedAdd(doubles.points[j]);
                        else if (nafW === -i)
                            b = b.mixedAdd(doubles.points[j].neg());
                    }
                    a = a.add(b);
                }
                return a.toP();
            };

            BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
                var w = 4;

                // Precompute window
                var nafPoints = p._getNAFPoints(w);
                w = nafPoints.wnd;
                var wnd = nafPoints.points;

                // Get NAF form
                var naf = getNAF(k, w);

                // Add `this`*(N+1) for every w-NAF index
                var acc = this.jpoint(null, null, null);
                for (var i = naf.length - 1; i >= 0; i--) {
                    // Count zeroes
                    for (var k = 0; i >= 0 && naf[i] === 0; i--)
                        k++;
                    if (i >= 0)
                        k++;
                    acc = acc.dblp(k);

                    if (i < 0)
                        break;
                    var z = naf[i];
                    assert(z !== 0);
                    if (p.type === 'affine') {
                        // J +- P
                        if (z > 0)
                            acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                        else
                            acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
                    } else {
                        // J +- J
                        if (z > 0)
                            acc = acc.add(wnd[(z - 1) >> 1]);
                        else
                            acc = acc.add(wnd[(-z - 1) >> 1].neg());
                    }
                }
                return p.type === 'affine' ? acc.toP() : acc;
            };

            BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                                   points,
                                                                   coeffs,
                                                                   len,
                                                                   jacobianResult) {
                var wndWidth = this._wnafT1;
                var wnd = this._wnafT2;
                var naf = this._wnafT3;

                // Fill all arrays
                var max = 0;
                for (var i = 0; i < len; i++) {
                    var p = points[i];
                    var nafPoints = p._getNAFPoints(defW);
                    wndWidth[i] = nafPoints.wnd;
                    wnd[i] = nafPoints.points;
                }

                // Comb small window NAFs
                for (var i = len - 1; i >= 1; i -= 2) {
                    var a = i - 1;
                    var b = i;
                    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                        naf[a] = getNAF(coeffs[a], wndWidth[a]);
                        naf[b] = getNAF(coeffs[b], wndWidth[b]);
                        max = Math.max(naf[a].length, max);
                        max = Math.max(naf[b].length, max);
                        continue;
                    }

                    var comb = [
                        points[a], /* 1 */
                        null, /* 3 */
                        null, /* 5 */
                        points[b] /* 7 */
                    ];

                    // Try to avoid Projective points, if possible
                    if (points[a].y.cmp(points[b].y) === 0) {
                        comb[1] = points[a].add(points[b]);
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                        comb[1] = points[a].toJ().mixedAdd(points[b]);
                        comb[2] = points[a].add(points[b].neg());
                    } else {
                        comb[1] = points[a].toJ().mixedAdd(points[b]);
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                    }

                    var index = [
                        -3, /* -1 -1 */
                        -1, /* -1 0 */
                        -5, /* -1 1 */
                        -7, /* 0 -1 */
                        0, /* 0 0 */
                        7, /* 0 1 */
                        5, /* 1 -1 */
                        1, /* 1 0 */
                        3  /* 1 1 */
                    ];

                    var jsf = getJSF(coeffs[a], coeffs[b]);
                    max = Math.max(jsf[0].length, max);
                    naf[a] = new Array(max);
                    naf[b] = new Array(max);
                    for (var j = 0; j < max; j++) {
                        var ja = jsf[0][j] | 0;
                        var jb = jsf[1][j] | 0;

                        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                        naf[b][j] = 0;
                        wnd[a] = comb;
                    }
                }

                var acc = this.jpoint(null, null, null);
                var tmp = this._wnafT4;
                for (var i = max; i >= 0; i--) {
                    var k = 0;

                    while (i >= 0) {
                        var zero = true;
                        for (var j = 0; j < len; j++) {
                            tmp[j] = naf[j][i] | 0;
                            if (tmp[j] !== 0)
                                zero = false;
                        }
                        if (!zero)
                            break;
                        k++;
                        i--;
                    }
                    if (i >= 0)
                        k++;
                    acc = acc.dblp(k);
                    if (i < 0)
                        break;

                    for (var j = 0; j < len; j++) {
                        var z = tmp[j];
                        var p;
                        if (z === 0)
                            continue;
                        else if (z > 0)
                            p = wnd[j][(z - 1) >> 1];
                        else if (z < 0)
                            p = wnd[j][(-z - 1) >> 1].neg();

                        if (p.type === 'affine')
                            acc = acc.mixedAdd(p);
                        else
                            acc = acc.add(p);
                    }
                }
                // Zeroify references
                for (var i = 0; i < len; i++)
                    wnd[i] = null;

                if (jacobianResult)
                    return acc;
                else
                    return acc.toP();
            };

            function BasePoint(curve, type) {
                this.curve = curve;
                this.type = type;
                this.precomputed = null;
            }

            BaseCurve.BasePoint = BasePoint;

            BasePoint.prototype.eq = function eq(/*other*/) {
                throw new Error('Not implemented');
            };

            BasePoint.prototype.validate = function validate() {
                return this.curve.validate(this);
            };

            BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
                bytes = utils.toArray(bytes, enc);

                var len = this.p.byteLength();

                // uncompressed, hybrid-odd, hybrid-even
                if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
                    bytes.length - 1 === 2 * len) {
                    if (bytes[0] === 0x06)
                        assert(bytes[bytes.length - 1] % 2 === 0);
                    else if (bytes[0] === 0x07)
                        assert(bytes[bytes.length - 1] % 2 === 1);

                    var res = this.point(bytes.slice(1, 1 + len),
                        bytes.slice(1 + len, 1 + 2 * len));

                    return res;
                } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
                    bytes.length - 1 === len) {
                    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
                }
                throw new Error('Unknown point format');
            };

            BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
                return this.encode(enc, true);
            };

            BasePoint.prototype._encode = function _encode(compact) {
                var len = this.curve.p.byteLength();
                var x = this.getX().toArray('be', len);

                if (compact)
                    return [this.getY().isEven() ? 0x02 : 0x03].concat(x);

                return [0x04].concat(x, this.getY().toArray('be', len));
            };

            BasePoint.prototype.encode = function encode(enc, compact) {
                return utils.encode(this._encode(compact), enc);
            };

            BasePoint.prototype.precompute = function precompute(power) {
                if (this.precomputed)
                    return this;

                var precomputed = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                precomputed.naf = this._getNAFPoints(8);
                precomputed.doubles = this._getDoubles(4, power);
                precomputed.beta = this._getBeta();
                this.precomputed = precomputed;

                return this;
            };

            BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
                if (!this.precomputed)
                    return false;

                var doubles = this.precomputed.doubles;
                if (!doubles)
                    return false;

                return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
            };

            BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
                if (this.precomputed && this.precomputed.doubles)
                    return this.precomputed.doubles;

                var doubles = [this];
                var acc = this;
                for (var i = 0; i < power; i += step) {
                    for (var j = 0; j < step; j++)
                        acc = acc.dbl();
                    doubles.push(acc);
                }
                return {
                    step: step,
                    points: doubles
                };
            };

            BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
                if (this.precomputed && this.precomputed.naf)
                    return this.precomputed.naf;

                var res = [this];
                var max = (1 << wnd) - 1;
                var dbl = max === 1 ? null : this.dbl();
                for (var i = 1; i < max; i++)
                    res[i] = res[i - 1].add(dbl);
                return {
                    wnd: wnd,
                    points: res
                };
            };

            BasePoint.prototype._getBeta = function _getBeta() {
                return null;
            };

            BasePoint.prototype.dblp = function dblp(k) {
                var r = this;
                for (var i = 0; i < k; i++)
                    r = r.dbl();
                return r;
            };

        }, { '../../elliptic': 80, 'bn.js': 27 }],
        82: [function(require, module, exports) {
            'use strict';

            var curve = require('../curve');
            var elliptic = require('../../elliptic');
            var BN = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;

            var assert = elliptic.utils.assert;

            function EdwardsCurve(conf) {
                // NOTE: Important as we are creating point in Base.call()
                this.twisted = (conf.a | 0) !== 1;
                this.mOneA = this.twisted && (conf.a | 0) === -1;
                this.extended = this.mOneA;

                Base.call(this, 'edwards', conf);

                this.a = new BN(conf.a, 16).umod(this.red.m);
                this.a = this.a.toRed(this.red);
                this.c = new BN(conf.c, 16).toRed(this.red);
                this.c2 = this.c.redSqr();
                this.d = new BN(conf.d, 16).toRed(this.red);
                this.dd = this.d.redAdd(this.d);

                assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
                this.oneC = (conf.c | 0) === 1;
            }

            inherits(EdwardsCurve, Base);
            module.exports = EdwardsCurve;

            EdwardsCurve.prototype._mulA = function _mulA(num) {
                if (this.mOneA)
                    return num.redNeg();
                else
                    return this.a.redMul(num);
            };

            EdwardsCurve.prototype._mulC = function _mulC(num) {
                if (this.oneC)
                    return num;
                else
                    return this.c.redMul(num);
            };

// Just for compatibility with Short curve
            EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
                return this.point(x, y, z, t);
            };

            EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
                x = new BN(x, 16);
                if (!x.red)
                    x = x.toRed(this.red);

                var x2 = x.redSqr();
                var rhs = this.c2.redSub(this.a.redMul(x2));
                var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

                var y2 = rhs.redMul(lhs.redInvm());
                var y = y2.redSqrt();
                if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
                    throw new Error('invalid point');

                var isOdd = y.fromRed().isOdd();
                if (odd && !isOdd || !odd && isOdd)
                    y = y.redNeg();

                return this.point(x, y);
            };

            EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
                y = new BN(y, 16);
                if (!y.red)
                    y = y.toRed(this.red);

                // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
                var y2 = y.redSqr();
                var lhs = y2.redSub(this.c2);
                var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
                var x2 = lhs.redMul(rhs.redInvm());

                if (x2.cmp(this.zero) === 0) {
                    if (odd)
                        throw new Error('invalid point');
                    else
                        return this.point(this.zero, y);
                }

                var x = x2.redSqrt();
                if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
                    throw new Error('invalid point');

                if (x.fromRed().isOdd() !== odd)
                    x = x.redNeg();

                return this.point(x, y);
            };

            EdwardsCurve.prototype.validate = function validate(point) {
                if (point.isInfinity())
                    return true;

                // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
                point.normalize();

                var x2 = point.x.redSqr();
                var y2 = point.y.redSqr();
                var lhs = x2.redMul(this.a).redAdd(y2);
                var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

                return lhs.cmp(rhs) === 0;
            };

            function Point(curve, x, y, z, t) {
                Base.BasePoint.call(this, curve, 'projective');
                if (x === null && y === null && z === null) {
                    this.x = this.curve.zero;
                    this.y = this.curve.one;
                    this.z = this.curve.one;
                    this.t = this.curve.zero;
                    this.zOne = true;
                } else {
                    this.x = new BN(x, 16);
                    this.y = new BN(y, 16);
                    this.z = z ? new BN(z, 16) : this.curve.one;
                    this.t = t && new BN(t, 16);
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.y.red)
                        this.y = this.y.toRed(this.curve.red);
                    if (!this.z.red)
                        this.z = this.z.toRed(this.curve.red);
                    if (this.t && !this.t.red)
                        this.t = this.t.toRed(this.curve.red);
                    this.zOne = this.z === this.curve.one;

                    // Use extended coordinates
                    if (this.curve.extended && !this.t) {
                        this.t = this.x.redMul(this.y);
                        if (!this.zOne)
                            this.t = this.t.redMul(this.z.redInvm());
                    }
                }
            }

            inherits(Point, Base.BasePoint);

            EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
                return Point.fromJSON(this, obj);
            };

            EdwardsCurve.prototype.point = function point(x, y, z, t) {
                return new Point(this, x, y, z, t);
            };

            Point.fromJSON = function fromJSON(curve, obj) {
                return new Point(curve, obj[0], obj[1], obj[2]);
            };

            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                    ' y: ' + this.y.fromRed().toString(16, 2) +
                    ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            };

            Point.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.x.cmpn(0) === 0 &&
                    (this.y.cmp(this.z) === 0 ||
                        (this.zOne && this.y.cmp(this.curve.c) === 0));
            };

            Point.prototype._extDbl = function _extDbl() {
                // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
                //     #doubling-dbl-2008-hwcd
                // 4M + 4S

                // A = X1^2
                var a = this.x.redSqr();
                // B = Y1^2
                var b = this.y.redSqr();
                // C = 2 * Z1^2
                var c = this.z.redSqr();
                c = c.redIAdd(c);
                // D = a * A
                var d = this.curve._mulA(a);
                // E = (X1 + Y1)^2 - A - B
                var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
                // G = D + B
                var g = d.redAdd(b);
                // F = G - C
                var f = g.redSub(c);
                // H = D - B
                var h = d.redSub(b);
                // X3 = E * F
                var nx = e.redMul(f);
                // Y3 = G * H
                var ny = g.redMul(h);
                // T3 = E * H
                var nt = e.redMul(h);
                // Z3 = F * G
                var nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            };

            Point.prototype._projDbl = function _projDbl() {
                // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
                //     #doubling-dbl-2008-bbjlp
                //     #doubling-dbl-2007-bl
                // and others
                // Generally 3M + 4S or 2M + 4S

                // B = (X1 + Y1)^2
                var b = this.x.redAdd(this.y).redSqr();
                // C = X1^2
                var c = this.x.redSqr();
                // D = Y1^2
                var d = this.y.redSqr();

                var nx;
                var ny;
                var nz;
                if (this.curve.twisted) {
                    // E = a * C
                    var e = this.curve._mulA(c);
                    // F = E + D
                    var f = e.redAdd(d);
                    if (this.zOne) {
                        // X3 = (B - C - D) * (F - 2)
                        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                        // Y3 = F * (E - D)
                        ny = f.redMul(e.redSub(d));
                        // Z3 = F^2 - 2 * F
                        nz = f.redSqr().redSub(f).redSub(f);
                    } else {
                        // H = Z1^2
                        var h = this.z.redSqr();
                        // J = F - 2 * H
                        var j = f.redSub(h).redISub(h);
                        // X3 = (B-C-D)*J
                        nx = b.redSub(c).redISub(d).redMul(j);
                        // Y3 = F * (E - D)
                        ny = f.redMul(e.redSub(d));
                        // Z3 = F * J
                        nz = f.redMul(j);
                    }
                } else {
                    // E = C + D
                    var e = c.redAdd(d);
                    // H = (c * Z1)^2
                    var h = this.curve._mulC(this.z).redSqr();
                    // J = E - 2 * H
                    var j = e.redSub(h).redSub(h);
                    // X3 = c * (B - E) * J
                    nx = this.curve._mulC(b.redISub(e)).redMul(j);
                    // Y3 = c * E * (C - D)
                    ny = this.curve._mulC(e).redMul(c.redISub(d));
                    // Z3 = E * J
                    nz = e.redMul(j);
                }
                return this.curve.point(nx, ny, nz);
            };

            Point.prototype.dbl = function dbl() {
                if (this.isInfinity())
                    return this;

                // Double in extended coordinates
                if (this.curve.extended)
                    return this._extDbl();
                else
                    return this._projDbl();
            };

            Point.prototype._extAdd = function _extAdd(p) {
                // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
                //     #addition-add-2008-hwcd-3
                // 8M

                // A = (Y1 - X1) * (Y2 - X2)
                var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
                // B = (Y1 + X1) * (Y2 + X2)
                var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
                // C = T1 * k * T2
                var c = this.t.redMul(this.curve.dd).redMul(p.t);
                // D = Z1 * 2 * Z2
                var d = this.z.redMul(p.z.redAdd(p.z));
                // E = B - A
                var e = b.redSub(a);
                // F = D - C
                var f = d.redSub(c);
                // G = D + C
                var g = d.redAdd(c);
                // H = B + A
                var h = b.redAdd(a);
                // X3 = E * F
                var nx = e.redMul(f);
                // Y3 = G * H
                var ny = g.redMul(h);
                // T3 = E * H
                var nt = e.redMul(h);
                // Z3 = F * G
                var nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            };

            Point.prototype._projAdd = function _projAdd(p) {
                // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
                //     #addition-add-2008-bbjlp
                //     #addition-add-2007-bl
                // 10M + 1S

                // A = Z1 * Z2
                var a = this.z.redMul(p.z);
                // B = A^2
                var b = a.redSqr();
                // C = X1 * X2
                var c = this.x.redMul(p.x);
                // D = Y1 * Y2
                var d = this.y.redMul(p.y);
                // E = d * C * D
                var e = this.curve.d.redMul(c).redMul(d);
                // F = B - E
                var f = b.redSub(e);
                // G = B + E
                var g = b.redAdd(e);
                // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
                var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
                var nx = a.redMul(f).redMul(tmp);
                var ny;
                var nz;
                if (this.curve.twisted) {
                    // Y3 = A * G * (D - a * C)
                    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
                    // Z3 = F * G
                    nz = f.redMul(g);
                } else {
                    // Y3 = A * G * (D - C)
                    ny = a.redMul(g).redMul(d.redSub(c));
                    // Z3 = c * F * G
                    nz = this.curve._mulC(f).redMul(g);
                }
                return this.curve.point(nx, ny, nz);
            };

            Point.prototype.add = function add(p) {
                if (this.isInfinity())
                    return p;
                if (p.isInfinity())
                    return this;

                if (this.curve.extended)
                    return this._extAdd(p);
                else
                    return this._projAdd(p);
            };

            Point.prototype.mul = function mul(k) {
                if (this._hasDoubles(k))
                    return this.curve._fixedNafMul(this, k);
                else
                    return this.curve._wnafMul(this, k);
            };

            Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
            };

            Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
            };

            Point.prototype.normalize = function normalize() {
                if (this.zOne)
                    return this;

                // Normalize coordinates
                var zi = this.z.redInvm();
                this.x = this.x.redMul(zi);
                this.y = this.y.redMul(zi);
                if (this.t)
                    this.t = this.t.redMul(zi);
                this.z = this.curve.one;
                this.zOne = true;
                return this;
            };

            Point.prototype.neg = function neg() {
                return this.curve.point(this.x.redNeg(),
                    this.y,
                    this.z,
                    this.t && this.t.redNeg());
            };

            Point.prototype.getX = function getX() {
                this.normalize();
                return this.x.fromRed();
            };

            Point.prototype.getY = function getY() {
                this.normalize();
                return this.y.fromRed();
            };

            Point.prototype.eq = function eq(other) {
                return this === other ||
                    this.getX().cmp(other.getX()) === 0 &&
                    this.getY().cmp(other.getY()) === 0;
            };

            Point.prototype.eqXToP = function eqXToP(x) {
                var rx = x.toRed(this.curve.red).redMul(this.z);
                if (this.x.cmp(rx) === 0)
                    return true;

                var xc = x.clone();
                var t = this.curve.redN.redMul(this.z);
                for (; ;) {
                    xc.iadd(this.curve.n);
                    if (xc.cmp(this.curve.p) >= 0)
                        return false;

                    rx.redIAdd(t);
                    if (this.x.cmp(rx) === 0)
                        return true;
                }
            };

// Compatibility with BaseCurve
            Point.prototype.toP = Point.prototype.normalize;
            Point.prototype.mixedAdd = Point.prototype.add;

        }, { '../../elliptic': 80, '../curve': 83, 'bn.js': 27, 'inherits': 116 }],
        83: [function(require, module, exports) {
            'use strict';

            var curve = exports;

            curve.base = require('./base');
            curve.short = require('./short');
            curve.mont = require('./mont');
            curve.edwards = require('./edwards');

        }, { './base': 81, './edwards': 82, './mont': 84, './short': 85 }],
        84: [function(require, module, exports) {
            'use strict';

            var curve = require('../curve');
            var BN = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;

            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;

            function MontCurve(conf) {
                Base.call(this, 'mont', conf);

                this.a = new BN(conf.a, 16).toRed(this.red);
                this.b = new BN(conf.b, 16).toRed(this.red);
                this.i4 = new BN(4).toRed(this.red).redInvm();
                this.two = new BN(2).toRed(this.red);
                this.a24 = this.i4.redMul(this.a.redAdd(this.two));
            }

            inherits(MontCurve, Base);
            module.exports = MontCurve;

            MontCurve.prototype.validate = function validate(point) {
                var x = point.normalize().x;
                var x2 = x.redSqr();
                var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
                var y = rhs.redSqrt();

                return y.redSqr().cmp(rhs) === 0;
            };

            function Point(curve, x, z) {
                Base.BasePoint.call(this, curve, 'projective');
                if (x === null && z === null) {
                    this.x = this.curve.one;
                    this.z = this.curve.zero;
                } else {
                    this.x = new BN(x, 16);
                    this.z = new BN(z, 16);
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.z.red)
                        this.z = this.z.toRed(this.curve.red);
                }
            }

            inherits(Point, Base.BasePoint);

            MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
                return this.point(utils.toArray(bytes, enc), 1);
            };

            MontCurve.prototype.point = function point(x, z) {
                return new Point(this, x, z);
            };

            MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
                return Point.fromJSON(this, obj);
            };

            Point.prototype.precompute = function precompute() {
                // No-op
            };

            Point.prototype._encode = function _encode() {
                return this.getX().toArray('be', this.curve.p.byteLength());
            };

            Point.fromJSON = function fromJSON(curve, obj) {
                return new Point(curve, obj[0], obj[1] || curve.one);
            };

            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                    ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            };

            Point.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.z.cmpn(0) === 0;
            };

            Point.prototype.dbl = function dbl() {
                // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
                // 2M + 2S + 4A

                // A = X1 + Z1
                var a = this.x.redAdd(this.z);
                // AA = A^2
                var aa = a.redSqr();
                // B = X1 - Z1
                var b = this.x.redSub(this.z);
                // BB = B^2
                var bb = b.redSqr();
                // C = AA - BB
                var c = aa.redSub(bb);
                // X3 = AA * BB
                var nx = aa.redMul(bb);
                // Z3 = C * (BB + A24 * C)
                var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
                return this.curve.point(nx, nz);
            };

            Point.prototype.add = function add() {
                throw new Error('Not supported on Montgomery curve');
            };

            Point.prototype.diffAdd = function diffAdd(p, diff) {
                // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
                // 4M + 2S + 6A

                // A = X2 + Z2
                var a = this.x.redAdd(this.z);
                // B = X2 - Z2
                var b = this.x.redSub(this.z);
                // C = X3 + Z3
                var c = p.x.redAdd(p.z);
                // D = X3 - Z3
                var d = p.x.redSub(p.z);
                // DA = D * A
                var da = d.redMul(a);
                // CB = C * B
                var cb = c.redMul(b);
                // X5 = Z1 * (DA + CB)^2
                var nx = diff.z.redMul(da.redAdd(cb).redSqr());
                // Z5 = X1 * (DA - CB)^2
                var nz = diff.x.redMul(da.redISub(cb).redSqr());
                return this.curve.point(nx, nz);
            };

            Point.prototype.mul = function mul(k) {
                var t = k.clone();
                var a = this; // (N / 2) * Q + Q
                var b = this.curve.point(null, null); // (N / 2) * Q
                var c = this; // Q

                for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
                    bits.push(t.andln(1));

                for (var i = bits.length - 1; i >= 0; i--) {
                    if (bits[i] === 0) {
                        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
                        a = a.diffAdd(b, c);
                        // N * Q = 2 * ((N / 2) * Q + Q))
                        b = b.dbl();
                    } else {
                        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
                        b = a.diffAdd(b, c);
                        // N * Q + Q = 2 * ((N / 2) * Q + Q)
                        a = a.dbl();
                    }
                }
                return b;
            };

            Point.prototype.mulAdd = function mulAdd() {
                throw new Error('Not supported on Montgomery curve');
            };

            Point.prototype.jumlAdd = function jumlAdd() {
                throw new Error('Not supported on Montgomery curve');
            };

            Point.prototype.eq = function eq(other) {
                return this.getX().cmp(other.getX()) === 0;
            };

            Point.prototype.normalize = function normalize() {
                this.x = this.x.redMul(this.z.redInvm());
                this.z = this.curve.one;
                return this;
            };

            Point.prototype.getX = function getX() {
                // Normalize coordinates
                this.normalize();

                return this.x.fromRed();
            };

        }, { '../../elliptic': 80, '../curve': 83, 'bn.js': 27, 'inherits': 116 }],
        85: [function(require, module, exports) {
            'use strict';

            var curve = require('../curve');
            var elliptic = require('../../elliptic');
            var BN = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;

            var assert = elliptic.utils.assert;

            function ShortCurve(conf) {
                Base.call(this, 'short', conf);

                this.a = new BN(conf.a, 16).toRed(this.red);
                this.b = new BN(conf.b, 16).toRed(this.red);
                this.tinv = this.two.redInvm();

                this.zeroA = this.a.fromRed().cmpn(0) === 0;
                this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

                // If the curve is endomorphic, precalculate beta and lambda
                this.endo = this._getEndomorphism(conf);
                this._endoWnafT1 = new Array(4);
                this._endoWnafT2 = new Array(4);
            }

            inherits(ShortCurve, Base);
            module.exports = ShortCurve;

            ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
                // No efficient endomorphism
                if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
                    return;

                // Compute beta and lambda, that lambda * P = (beta * Px; Py)
                var beta;
                var lambda;
                if (conf.beta) {
                    beta = new BN(conf.beta, 16).toRed(this.red);
                } else {
                    var betas = this._getEndoRoots(this.p);
                    // Choose the smallest beta
                    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
                    beta = beta.toRed(this.red);
                }
                if (conf.lambda) {
                    lambda = new BN(conf.lambda, 16);
                } else {
                    // Choose the lambda that is matching selected beta
                    var lambdas = this._getEndoRoots(this.n);
                    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                        lambda = lambdas[0];
                    } else {
                        lambda = lambdas[1];
                        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
                    }
                }

                // Get basis vectors, used for balanced length-two representation
                var basis;
                if (conf.basis) {
                    basis = conf.basis.map(function(vec) {
                        return {
                            a: new BN(vec.a, 16),
                            b: new BN(vec.b, 16)
                        };
                    });
                } else {
                    basis = this._getEndoBasis(lambda);
                }

                return {
                    beta: beta,
                    lambda: lambda,
                    basis: basis
                };
            };

            ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
                // Find roots of for x^2 + x + 1 in F
                // Root = (-1 +- Sqrt(-3)) / 2
                //
                var red = num === this.p ? this.red : BN.mont(num);
                var tinv = new BN(2).toRed(red).redInvm();
                var ntinv = tinv.redNeg();

                var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

                var l1 = ntinv.redAdd(s).fromRed();
                var l2 = ntinv.redSub(s).fromRed();
                return [l1, l2];
            };

            ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
                // aprxSqrt >= sqrt(this.n)
                var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

                // 3.74
                // Run EGCD, until r(L + 1) < aprxSqrt
                var u = lambda;
                var v = this.n.clone();
                var x1 = new BN(1);
                var y1 = new BN(0);
                var x2 = new BN(0);
                var y2 = new BN(1);

                // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
                var a0;
                var b0;
                // First vector
                var a1;
                var b1;
                // Second vector
                var a2;
                var b2;

                var prevR;
                var i = 0;
                var r;
                var x;
                while (u.cmpn(0) !== 0) {
                    var q = v.div(u);
                    r = v.sub(q.mul(u));
                    x = x2.sub(q.mul(x1));
                    var y = y2.sub(q.mul(y1));

                    if (!a1 && r.cmp(aprxSqrt) < 0) {
                        a0 = prevR.neg();
                        b0 = x1;
                        a1 = r.neg();
                        b1 = x;
                    } else if (a1 && ++i === 2) {
                        break;
                    }
                    prevR = r;

                    v = u;
                    u = r;
                    x2 = x1;
                    x1 = x;
                    y2 = y1;
                    y1 = y;
                }
                a2 = r.neg();
                b2 = x;

                var len1 = a1.sqr().add(b1.sqr());
                var len2 = a2.sqr().add(b2.sqr());
                if (len2.cmp(len1) >= 0) {
                    a2 = a0;
                    b2 = b0;
                }

                // Normalize signs
                if (a1.negative) {
                    a1 = a1.neg();
                    b1 = b1.neg();
                }
                if (a2.negative) {
                    a2 = a2.neg();
                    b2 = b2.neg();
                }

                return [
                    { a: a1, b: b1 },
                    { a: a2, b: b2 }
                ];
            };

            ShortCurve.prototype._endoSplit = function _endoSplit(k) {
                var basis = this.endo.basis;
                var v1 = basis[0];
                var v2 = basis[1];

                var c1 = v2.b.mul(k).divRound(this.n);
                var c2 = v1.b.neg().mul(k).divRound(this.n);

                var p1 = c1.mul(v1.a);
                var p2 = c2.mul(v2.a);
                var q1 = c1.mul(v1.b);
                var q2 = c2.mul(v2.b);

                // Calculate answer
                var k1 = k.sub(p1).sub(p2);
                var k2 = q1.add(q2).neg();
                return { k1: k1, k2: k2 };
            };

            ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
                x = new BN(x, 16);
                if (!x.red)
                    x = x.toRed(this.red);

                var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
                var y = y2.redSqrt();
                if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
                    throw new Error('invalid point');

                // XXX Is there any way to tell if the number is odd without converting it
                // to non-red form?
                var isOdd = y.fromRed().isOdd();
                if (odd && !isOdd || !odd && isOdd)
                    y = y.redNeg();

                return this.point(x, y);
            };

            ShortCurve.prototype.validate = function validate(point) {
                if (point.inf)
                    return true;

                var x = point.x;
                var y = point.y;

                var ax = this.a.redMul(x);
                var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
                return y.redSqr().redISub(rhs).cmpn(0) === 0;
            };

            ShortCurve.prototype._endoWnafMulAdd =
                function _endoWnafMulAdd(points, coeffs, jacobianResult) {
                    var npoints = this._endoWnafT1;
                    var ncoeffs = this._endoWnafT2;
                    for (var i = 0; i < points.length; i++) {
                        var split = this._endoSplit(coeffs[i]);
                        var p = points[i];
                        var beta = p._getBeta();

                        if (split.k1.negative) {
                            split.k1.ineg();
                            p = p.neg(true);
                        }
                        if (split.k2.negative) {
                            split.k2.ineg();
                            beta = beta.neg(true);
                        }

                        npoints[i * 2] = p;
                        npoints[i * 2 + 1] = beta;
                        ncoeffs[i * 2] = split.k1;
                        ncoeffs[i * 2 + 1] = split.k2;
                    }
                    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

                    // Clean-up references to points and coefficients
                    for (var j = 0; j < i * 2; j++) {
                        npoints[j] = null;
                        ncoeffs[j] = null;
                    }
                    return res;
                };

            function Point(curve, x, y, isRed) {
                Base.BasePoint.call(this, curve, 'affine');
                if (x === null && y === null) {
                    this.x = null;
                    this.y = null;
                    this.inf = true;
                } else {
                    this.x = new BN(x, 16);
                    this.y = new BN(y, 16);
                    // Force redgomery representation when loading from JSON
                    if (isRed) {
                        this.x.forceRed(this.curve.red);
                        this.y.forceRed(this.curve.red);
                    }
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.y.red)
                        this.y = this.y.toRed(this.curve.red);
                    this.inf = false;
                }
            }

            inherits(Point, Base.BasePoint);

            ShortCurve.prototype.point = function point(x, y, isRed) {
                return new Point(this, x, y, isRed);
            };

            ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
                return Point.fromJSON(this, obj, red);
            };

            Point.prototype._getBeta = function _getBeta() {
                if (!this.curve.endo)
                    return;

                var pre = this.precomputed;
                if (pre && pre.beta)
                    return pre.beta;

                var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (pre) {
                    var curve = this.curve;
                    var endoMul = function(p) {
                        return curve.point(p.x.redMul(curve.endo.beta), p.y);
                    };
                    pre.beta = beta;
                    beta.precomputed = {
                        beta: null,
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(endoMul)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(endoMul)
                        }
                    };
                }
                return beta;
            };

            Point.prototype.toJSON = function toJSON() {
                if (!this.precomputed)
                    return [this.x, this.y];

                return [this.x, this.y, this.precomputed && {
                    doubles: this.precomputed.doubles && {
                        step: this.precomputed.doubles.step,
                        points: this.precomputed.doubles.points.slice(1)
                    },
                    naf: this.precomputed.naf && {
                        wnd: this.precomputed.naf.wnd,
                        points: this.precomputed.naf.points.slice(1)
                    }
                }];
            };

            Point.fromJSON = function fromJSON(curve, obj, red) {
                if (typeof obj === 'string')
                    obj = JSON.parse(obj);
                var res = curve.point(obj[0], obj[1], red);
                if (!obj[2])
                    return res;

                function obj2point(obj) {
                    return curve.point(obj[0], obj[1], red);
                }

                var pre = obj[2];
                res.precomputed = {
                    beta: null,
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: [res].concat(pre.doubles.points.map(obj2point))
                    },
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: [res].concat(pre.naf.points.map(obj2point))
                    }
                };
                return res;
            };

            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
                    ' y: ' + this.y.fromRed().toString(16, 2) + '>';
            };

            Point.prototype.isInfinity = function isInfinity() {
                return this.inf;
            };

            Point.prototype.add = function add(p) {
                // O + P = P
                if (this.inf)
                    return p;

                // P + O = P
                if (p.inf)
                    return this;

                // P + P = 2P
                if (this.eq(p))
                    return this.dbl();

                // P + (-P) = O
                if (this.neg().eq(p))
                    return this.curve.point(null, null);

                // P + Q = O
                if (this.x.cmp(p.x) === 0)
                    return this.curve.point(null, null);

                var c = this.y.redSub(p.y);
                if (c.cmpn(0) !== 0)
                    c = c.redMul(this.x.redSub(p.x).redInvm());
                var nx = c.redSqr().redISub(this.x).redISub(p.x);
                var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            };

            Point.prototype.dbl = function dbl() {
                if (this.inf)
                    return this;

                // 2P = O
                var ys1 = this.y.redAdd(this.y);
                if (ys1.cmpn(0) === 0)
                    return this.curve.point(null, null);

                var a = this.curve.a;

                var x2 = this.x.redSqr();
                var dyinv = ys1.redInvm();
                var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

                var nx = c.redSqr().redISub(this.x.redAdd(this.x));
                var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            };

            Point.prototype.getX = function getX() {
                return this.x.fromRed();
            };

            Point.prototype.getY = function getY() {
                return this.y.fromRed();
            };

            Point.prototype.mul = function mul(k) {
                k = new BN(k, 16);

                if (this._hasDoubles(k))
                    return this.curve._fixedNafMul(this, k);
                else if (this.curve.endo)
                    return this.curve._endoWnafMulAdd([this], [k]);
                else
                    return this.curve._wnafMul(this, k);
            };

            Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
                var points = [this, p2];
                var coeffs = [k1, k2];
                if (this.curve.endo)
                    return this.curve._endoWnafMulAdd(points, coeffs);
                else
                    return this.curve._wnafMulAdd(1, points, coeffs, 2);
            };

            Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
                var points = [this, p2];
                var coeffs = [k1, k2];
                if (this.curve.endo)
                    return this.curve._endoWnafMulAdd(points, coeffs, true);
                else
                    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
            };

            Point.prototype.eq = function eq(p) {
                return this === p ||
                    this.inf === p.inf &&
                    (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
            };

            Point.prototype.neg = function neg(_precompute) {
                if (this.inf)
                    return this;

                var res = this.curve.point(this.x, this.y.redNeg());
                if (_precompute && this.precomputed) {
                    var pre = this.precomputed;
                    var negate = function(p) {
                        return p.neg();
                    };
                    res.precomputed = {
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(negate)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(negate)
                        }
                    };
                }
                return res;
            };

            Point.prototype.toJ = function toJ() {
                if (this.inf)
                    return this.curve.jpoint(null, null, null);

                var res = this.curve.jpoint(this.x, this.y, this.curve.one);
                return res;
            };

            function JPoint(curve, x, y, z) {
                Base.BasePoint.call(this, curve, 'jacobian');
                if (x === null && y === null && z === null) {
                    this.x = this.curve.one;
                    this.y = this.curve.one;
                    this.z = new BN(0);
                } else {
                    this.x = new BN(x, 16);
                    this.y = new BN(y, 16);
                    this.z = new BN(z, 16);
                }
                if (!this.x.red)
                    this.x = this.x.toRed(this.curve.red);
                if (!this.y.red)
                    this.y = this.y.toRed(this.curve.red);
                if (!this.z.red)
                    this.z = this.z.toRed(this.curve.red);

                this.zOne = this.z === this.curve.one;
            }

            inherits(JPoint, Base.BasePoint);

            ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
                return new JPoint(this, x, y, z);
            };

            JPoint.prototype.toP = function toP() {
                if (this.isInfinity())
                    return this.curve.point(null, null);

                var zinv = this.z.redInvm();
                var zinv2 = zinv.redSqr();
                var ax = this.x.redMul(zinv2);
                var ay = this.y.redMul(zinv2).redMul(zinv);

                return this.curve.point(ax, ay);
            };

            JPoint.prototype.neg = function neg() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
            };

            JPoint.prototype.add = function add(p) {
                // O + P = P
                if (this.isInfinity())
                    return p;

                // P + O = P
                if (p.isInfinity())
                    return this;

                // 12M + 4S + 7A
                var pz2 = p.z.redSqr();
                var z2 = this.z.redSqr();
                var u1 = this.x.redMul(pz2);
                var u2 = p.x.redMul(z2);
                var s1 = this.y.redMul(pz2.redMul(p.z));
                var s2 = p.y.redMul(z2.redMul(this.z));

                var h = u1.redSub(u2);
                var r = s1.redSub(s2);
                if (h.cmpn(0) === 0) {
                    if (r.cmpn(0) !== 0)
                        return this.curve.jpoint(null, null, null);
                    else
                        return this.dbl();
                }

                var h2 = h.redSqr();
                var h3 = h2.redMul(h);
                var v = u1.redMul(h2);

                var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
                var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
                var nz = this.z.redMul(p.z).redMul(h);

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype.mixedAdd = function mixedAdd(p) {
                // O + P = P
                if (this.isInfinity())
                    return p.toJ();

                // P + O = P
                if (p.isInfinity())
                    return this;

                // 8M + 3S + 7A
                var z2 = this.z.redSqr();
                var u1 = this.x;
                var u2 = p.x.redMul(z2);
                var s1 = this.y;
                var s2 = p.y.redMul(z2).redMul(this.z);

                var h = u1.redSub(u2);
                var r = s1.redSub(s2);
                if (h.cmpn(0) === 0) {
                    if (r.cmpn(0) !== 0)
                        return this.curve.jpoint(null, null, null);
                    else
                        return this.dbl();
                }

                var h2 = h.redSqr();
                var h3 = h2.redMul(h);
                var v = u1.redMul(h2);

                var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
                var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
                var nz = this.z.redMul(h);

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype.dblp = function dblp(pow) {
                if (pow === 0)
                    return this;
                if (this.isInfinity())
                    return this;
                if (!pow)
                    return this.dbl();

                if (this.curve.zeroA || this.curve.threeA) {
                    var r = this;
                    for (var i = 0; i < pow; i++)
                        r = r.dbl();
                    return r;
                }

                // 1M + 2S + 1A + N * (4S + 5M + 8A)
                // N = 1 => 6M + 6S + 9A
                var a = this.curve.a;
                var tinv = this.curve.tinv;

                var jx = this.x;
                var jy = this.y;
                var jz = this.z;
                var jz4 = jz.redSqr().redSqr();

                // Reuse results
                var jyd = jy.redAdd(jy);
                for (var i = 0; i < pow; i++) {
                    var jx2 = jx.redSqr();
                    var jyd2 = jyd.redSqr();
                    var jyd4 = jyd2.redSqr();
                    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

                    var t1 = jx.redMul(jyd2);
                    var nx = c.redSqr().redISub(t1.redAdd(t1));
                    var t2 = t1.redISub(nx);
                    var dny = c.redMul(t2);
                    dny = dny.redIAdd(dny).redISub(jyd4);
                    var nz = jyd.redMul(jz);
                    if (i + 1 < pow)
                        jz4 = jz4.redMul(jyd4);

                    jx = nx;
                    jz = nz;
                    jyd = dny;
                }

                return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
            };

            JPoint.prototype.dbl = function dbl() {
                if (this.isInfinity())
                    return this;

                if (this.curve.zeroA)
                    return this._zeroDbl();
                else if (this.curve.threeA)
                    return this._threeDbl();
                else
                    return this._dbl();
            };

            JPoint.prototype._zeroDbl = function _zeroDbl() {
                var nx;
                var ny;
                var nz;
                // Z = 1
                if (this.zOne) {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                    //     #doubling-mdbl-2007-bl
                    // 1M + 5S + 14A

                    // XX = X1^2
                    var xx = this.x.redSqr();
                    // YY = Y1^2
                    var yy = this.y.redSqr();
                    // YYYY = YY^2
                    var yyyy = yy.redSqr();
                    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    // M = 3 * XX + a; a = 0
                    var m = xx.redAdd(xx).redIAdd(xx);
                    // T = M ^ 2 - 2*S
                    var t = m.redSqr().redISub(s).redISub(s);

                    // 8 * YYYY
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    yyyy8 = yyyy8.redIAdd(yyyy8);

                    // X3 = T
                    nx = t;
                    // Y3 = M * (S - T) - 8 * YYYY
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                    // Z3 = 2*Y1
                    nz = this.y.redAdd(this.y);
                } else {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                    //     #doubling-dbl-2009-l
                    // 2M + 5S + 13A

                    // A = X1^2
                    var a = this.x.redSqr();
                    // B = Y1^2
                    var b = this.y.redSqr();
                    // C = B^2
                    var c = b.redSqr();
                    // D = 2 * ((X1 + B)^2 - A - C)
                    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
                    d = d.redIAdd(d);
                    // E = 3 * A
                    var e = a.redAdd(a).redIAdd(a);
                    // F = E^2
                    var f = e.redSqr();

                    // 8 * C
                    var c8 = c.redIAdd(c);
                    c8 = c8.redIAdd(c8);
                    c8 = c8.redIAdd(c8);

                    // X3 = F - 2 * D
                    nx = f.redISub(d).redISub(d);
                    // Y3 = E * (D - X3) - 8 * C
                    ny = e.redMul(d.redISub(nx)).redISub(c8);
                    // Z3 = 2 * Y1 * Z1
                    nz = this.y.redMul(this.z);
                    nz = nz.redIAdd(nz);
                }

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype._threeDbl = function _threeDbl() {
                var nx;
                var ny;
                var nz;
                // Z = 1
                if (this.zOne) {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
                    //     #doubling-mdbl-2007-bl
                    // 1M + 5S + 15A

                    // XX = X1^2
                    var xx = this.x.redSqr();
                    // YY = Y1^2
                    var yy = this.y.redSqr();
                    // YYYY = YY^2
                    var yyyy = yy.redSqr();
                    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    // M = 3 * XX + a
                    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
                    // T = M^2 - 2 * S
                    var t = m.redSqr().redISub(s).redISub(s);
                    // X3 = T
                    nx = t;
                    // Y3 = M * (S - T) - 8 * YYYY
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                    // Z3 = 2 * Y1
                    nz = this.y.redAdd(this.y);
                } else {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
                    // 3M + 5S

                    // delta = Z1^2
                    var delta = this.z.redSqr();
                    // gamma = Y1^2
                    var gamma = this.y.redSqr();
                    // beta = X1 * gamma
                    var beta = this.x.redMul(gamma);
                    // alpha = 3 * (X1 - delta) * (X1 + delta)
                    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
                    alpha = alpha.redAdd(alpha).redIAdd(alpha);
                    // X3 = alpha^2 - 8 * beta
                    var beta4 = beta.redIAdd(beta);
                    beta4 = beta4.redIAdd(beta4);
                    var beta8 = beta4.redAdd(beta4);
                    nx = alpha.redSqr().redISub(beta8);
                    // Z3 = (Y1 + Z1)^2 - gamma - delta
                    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
                    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
                    var ggamma8 = gamma.redSqr();
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
                }

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype._dbl = function _dbl() {
                var a = this.curve.a;

                // 4M + 6S + 10A
                var jx = this.x;
                var jy = this.y;
                var jz = this.z;
                var jz4 = jz.redSqr().redSqr();

                var jx2 = jx.redSqr();
                var jy2 = jy.redSqr();

                var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

                var jxd4 = jx.redAdd(jx);
                jxd4 = jxd4.redIAdd(jxd4);
                var t1 = jxd4.redMul(jy2);
                var nx = c.redSqr().redISub(t1.redAdd(t1));
                var t2 = t1.redISub(nx);

                var jyd8 = jy2.redSqr();
                jyd8 = jyd8.redIAdd(jyd8);
                jyd8 = jyd8.redIAdd(jyd8);
                jyd8 = jyd8.redIAdd(jyd8);
                var ny = c.redMul(t2).redISub(jyd8);
                var nz = jy.redAdd(jy).redMul(jz);

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype.trpl = function trpl() {
                if (!this.curve.zeroA)
                    return this.dbl().add(this);

                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
                // 5M + 10S + ...

                // XX = X1^2
                var xx = this.x.redSqr();
                // YY = Y1^2
                var yy = this.y.redSqr();
                // ZZ = Z1^2
                var zz = this.z.redSqr();
                // YYYY = YY^2
                var yyyy = yy.redSqr();
                // M = 3 * XX + a * ZZ2; a = 0
                var m = xx.redAdd(xx).redIAdd(xx);
                // MM = M^2
                var mm = m.redSqr();
                // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
                var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                e = e.redIAdd(e);
                e = e.redAdd(e).redIAdd(e);
                e = e.redISub(mm);
                // EE = E^2
                var ee = e.redSqr();
                // T = 16*YYYY
                var t = yyyy.redIAdd(yyyy);
                t = t.redIAdd(t);
                t = t.redIAdd(t);
                t = t.redIAdd(t);
                // U = (M + E)^2 - MM - EE - T
                var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
                // X3 = 4 * (X1 * EE - 4 * YY * U)
                var yyu4 = yy.redMul(u);
                yyu4 = yyu4.redIAdd(yyu4);
                yyu4 = yyu4.redIAdd(yyu4);
                var nx = this.x.redMul(ee).redISub(yyu4);
                nx = nx.redIAdd(nx);
                nx = nx.redIAdd(nx);
                // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
                var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
                ny = ny.redIAdd(ny);
                ny = ny.redIAdd(ny);
                ny = ny.redIAdd(ny);
                // Z3 = (Z1 + E)^2 - ZZ - EE
                var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

                return this.curve.jpoint(nx, ny, nz);
            };

            JPoint.prototype.mul = function mul(k, kbase) {
                k = new BN(k, kbase);

                return this.curve._wnafMul(this, k);
            };

            JPoint.prototype.eq = function eq(p) {
                if (p.type === 'affine')
                    return this.eq(p.toJ());

                if (this === p)
                    return true;

                // x1 * z2^2 == x2 * z1^2
                var z2 = this.z.redSqr();
                var pz2 = p.z.redSqr();
                if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
                    return false;

                // y1 * z2^3 == y2 * z1^3
                var z3 = z2.redMul(this.z);
                var pz3 = pz2.redMul(p.z);
                return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
            };

            JPoint.prototype.eqXToP = function eqXToP(x) {
                var zs = this.z.redSqr();
                var rx = x.toRed(this.curve.red).redMul(zs);
                if (this.x.cmp(rx) === 0)
                    return true;

                var xc = x.clone();
                var t = this.curve.redN.redMul(zs);
                for (; ;) {
                    xc.iadd(this.curve.n);
                    if (xc.cmp(this.curve.p) >= 0)
                        return false;

                    rx.redIAdd(t);
                    if (this.x.cmp(rx) === 0)
                        return true;
                }
            };

            JPoint.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC JPoint Infinity>';
                return '<EC JPoint x: ' + this.x.toString(16, 2) +
                    ' y: ' + this.y.toString(16, 2) +
                    ' z: ' + this.z.toString(16, 2) + '>';
            };

            JPoint.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.z.cmpn(0) === 0;
            };

        }, { '../../elliptic': 80, '../curve': 83, 'bn.js': 27, 'inherits': 116 }],
        86: [function(require, module, exports) {
            'use strict';

            var curves = exports;

            var hash = require('hash.js');
            var elliptic = require('../elliptic');

            var assert = elliptic.utils.assert;

            function PresetCurve(options) {
                if (options.type === 'short')
                    this.curve = new elliptic.curve.short(options);
                else if (options.type === 'edwards')
                    this.curve = new elliptic.curve.edwards(options);
                else
                    this.curve = new elliptic.curve.mont(options);
                this.g = this.curve.g;
                this.n = this.curve.n;
                this.hash = options.hash;

                assert(this.g.validate(), 'Invalid curve');
                assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
            }

            curves.PresetCurve = PresetCurve;

            function defineCurve(name, options) {
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        var curve = new PresetCurve(options);
                        Object.defineProperty(curves, name, {
                            configurable: true,
                            enumerable: true,
                            value: curve
                        });
                        return curve;
                    }
                });
            }

            defineCurve('p192', {
                type: 'short',
                prime: 'p192',
                p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
                b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
                n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
                ]
            });

            defineCurve('p224', {
                type: 'short',
                prime: 'p224',
                p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
                b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
                n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
                hash: hash.sha256,
                gRed: false,
                g: [
                    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
                ]
            });

            defineCurve('p256', {
                type: 'short',
                prime: null,
                p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
                a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
                b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
                n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
                ]
            });

            defineCurve('p384', {
                type: 'short',
                prime: null,
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'fffffffe ffffffff 00000000 00000000 ffffffff',
                a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'fffffffe ffffffff 00000000 00000000 fffffffc',
                b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
                    '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
                n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
                    'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
                hash: hash.sha384,
                gRed: false,
                g: [
                    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
                    '5502f25d bf55296c 3a545e38 72760ab7',
                    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
                    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
                ]
            });

            defineCurve('p521', {
                type: 'short',
                prime: null,
                p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'ffffffff ffffffff ffffffff ffffffff ffffffff',
                a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'ffffffff ffffffff ffffffff ffffffff fffffffc',
                b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
                    '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
                    '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
                n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
                    'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
                    'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
                hash: hash.sha512,
                gRed: false,
                g: [
                    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
                    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
                    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
                    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
                    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
                    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
                ]
            });

            defineCurve('curve25519', {
                type: 'mont',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '76d06',
                b: '1',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '9'
                ]
            });

            defineCurve('ed25519', {
                type: 'edwards',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '-1',
                c: '1',
                // -121665 * (121666^(-1)) (mod P)
                d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

                    // 4/5
                    '6666666666666666666666666666666666666666666666666666666666666658'
                ]
            });

            var pre;
            try {
                pre = require('./precomputed/secp256k1');
            } catch (e) {
                pre = undefined;
            }

            defineCurve('secp256k1', {
                type: 'short',
                prime: 'k256',
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                a: '0',
                b: '7',
                n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
                h: '1',
                hash: hash.sha256,

                // Precomputed endomorphism
                beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
                lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
                basis: [
                    {
                        a: '3086d221a7d46bcde86c90e49284eb15',
                        b: '-e4437ed6010e88286f547fa90abfe4c3'
                    },
                    {
                        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                        b: '3086d221a7d46bcde86c90e49284eb15'
                    }
                ],

                gRed: false,
                g: [
                    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                    pre
                ]
            });

        }, { '../elliptic': 80, './precomputed/secp256k1': 93, 'hash.js': 100 }],
        87: [function(require, module, exports) {
            'use strict';

            var BN = require('bn.js');
            var HmacDRBG = require('hmac-drbg');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;

            var KeyPair = require('./key');
            var Signature = require('./signature');

            function EC(options) {
                if (!(this instanceof EC))
                    return new EC(options);

                // Shortcut `elliptic.ec(curve-name)`
                if (typeof options === 'string') {
                    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

                    options = elliptic.curves[options];
                }

                // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
                if (options instanceof elliptic.curves.PresetCurve)
                    options = { curve: options };

                this.curve = options.curve.curve;
                this.n = this.curve.n;
                this.nh = this.n.ushrn(1);
                this.g = this.curve.g;

                // Point on curve
                this.g = options.curve.g;
                this.g.precompute(options.curve.n.bitLength() + 1);

                // Hash for function for DRBG
                this.hash = options.hash || options.curve.hash;
            }

            module.exports = EC;

            EC.prototype.keyPair = function keyPair(options) {
                return new KeyPair(this, options);
            };

            EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
                return KeyPair.fromPrivate(this, priv, enc);
            };

            EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
                return KeyPair.fromPublic(this, pub, enc);
            };

            EC.prototype.genKeyPair = function genKeyPair(options) {
                if (!options)
                    options = {};

                // Instantiate Hmac_DRBG
                var drbg = new HmacDRBG({
                    hash: this.hash,
                    pers: options.pers,
                    persEnc: options.persEnc || 'utf8',
                    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
                    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
                    nonce: this.n.toArray()
                });

                var bytes = this.n.byteLength();
                var ns2 = this.n.sub(new BN(2));
                do {
                    var priv = new BN(drbg.generate(bytes));
                    if (priv.cmp(ns2) > 0)
                        continue;

                    priv.iaddn(1);
                    return this.keyFromPrivate(priv);
                } while (true);
            };

            EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
                var delta = msg.byteLength() * 8 - this.n.bitLength();
                if (delta > 0)
                    msg = msg.ushrn(delta);
                if (!truncOnly && msg.cmp(this.n) >= 0)
                    return msg.sub(this.n);
                else
                    return msg;
            };

            EC.prototype.sign = function sign(msg, key, enc, options) {
                if (typeof enc === 'object') {
                    options = enc;
                    enc = null;
                }
                if (!options)
                    options = {};

                key = this.keyFromPrivate(key, enc);
                msg = this._truncateToN(new BN(msg, 16));

                // Zero-extend key to provide enough entropy
                var bytes = this.n.byteLength();
                var bkey = key.getPrivate().toArray('be', bytes);

                // Zero-extend nonce to have the same byte size as N
                var nonce = msg.toArray('be', bytes);

                // Instantiate Hmac_DRBG
                var drbg = new HmacDRBG({
                    hash: this.hash,
                    entropy: bkey,
                    nonce: nonce,
                    pers: options.pers,
                    persEnc: options.persEnc || 'utf8'
                });

                // Number of bytes to generate
                var ns1 = this.n.sub(new BN(1));

                for (var iter = 0; true; iter++) {
                    var k = options.k ?
                        options.k(iter) :
                        new BN(drbg.generate(this.n.byteLength()));
                    k = this._truncateToN(k, true);
                    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
                        continue;

                    var kp = this.g.mul(k);
                    if (kp.isInfinity())
                        continue;

                    var kpX = kp.getX();
                    var r = kpX.umod(this.n);
                    if (r.cmpn(0) === 0)
                        continue;

                    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
                    s = s.umod(this.n);
                    if (s.cmpn(0) === 0)
                        continue;

                    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

                    // Use complement of `s`, if it is > `n / 2`
                    if (options.canonical && s.cmp(this.nh) > 0) {
                        s = this.n.sub(s);
                        recoveryParam ^= 1;
                    }

                    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
                }
            };

            EC.prototype.verify = function verify(msg, signature, key, enc) {
                msg = this._truncateToN(new BN(msg, 16));
                key = this.keyFromPublic(key, enc);
                signature = new Signature(signature, 'hex');

                // Perform primitive values validation
                var r = signature.r;
                var s = signature.s;
                if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
                    return false;
                if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
                    return false;

                // Validate signature
                var sinv = s.invm(this.n);
                var u1 = sinv.mul(msg).umod(this.n);
                var u2 = sinv.mul(r).umod(this.n);

                if (!this.curve._maxwellTrick) {
                    var p = this.g.mulAdd(u1, key.getPublic(), u2);
                    if (p.isInfinity())
                        return false;

                    return p.getX().umod(this.n).cmp(r) === 0;
                }

                // NOTE: Greg Maxwell's trick, inspired by:
                // https://git.io/vad3K

                var p = this.g.jmulAdd(u1, key.getPublic(), u2);
                if (p.isInfinity())
                    return false;

                // Compare `p.x` of Jacobian point with `r`,
                // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
                // inverse of `p.z^2`
                return p.eqXToP(r);
            };

            EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
                assert((3 & j) === j, 'The recovery param is more than two bits');
                signature = new Signature(signature, enc);

                var n = this.n;
                var e = new BN(msg);
                var r = signature.r;
                var s = signature.s;

                // A set LSB signifies that the y-coordinate is odd
                var isYOdd = j & 1;
                var isSecondKey = j >> 1;
                if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
                    throw new Error('Unable to find sencond key candinate');

                // 1.1. Let x = r + jn.
                if (isSecondKey)
                    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
                else
                    r = this.curve.pointFromX(r, isYOdd);

                var rInv = signature.r.invm(n);
                var s1 = n.sub(e).mul(rInv).umod(n);
                var s2 = s.mul(rInv).umod(n);

                // 1.6.1 Compute Q = r^-1 (sR -  eG)
                //               Q = r^-1 (sR + -eG)
                return this.g.mulAdd(s1, r, s2);
            };

            EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
                signature = new Signature(signature, enc);
                if (signature.recoveryParam !== null)
                    return signature.recoveryParam;

                for (var i = 0; i < 4; i++) {
                    var Qprime;
                    try {
                        Qprime = this.recoverPubKey(e, signature, i);
                    } catch (e) {
                        continue;
                    }

                    if (Qprime.eq(Q))
                        return i;
                }
                throw new Error('Unable to find valid recovery factor');
            };

        }, { '../../elliptic': 80, './key': 88, './signature': 89, 'bn.js': 27, 'hmac-drbg': 112 }],
        88: [function(require, module, exports) {
            'use strict';

            var BN = require('bn.js');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;

            function KeyPair(ec, options) {
                this.ec = ec;
                this.priv = null;
                this.pub = null;

                // KeyPair(ec, { priv: ..., pub: ... })
                if (options.priv)
                    this._importPrivate(options.priv, options.privEnc);
                if (options.pub)
                    this._importPublic(options.pub, options.pubEnc);
            }

            module.exports = KeyPair;

            KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
                if (pub instanceof KeyPair)
                    return pub;

                return new KeyPair(ec, {
                    pub: pub,
                    pubEnc: enc
                });
            };

            KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
                if (priv instanceof KeyPair)
                    return priv;

                return new KeyPair(ec, {
                    priv: priv,
                    privEnc: enc
                });
            };

            KeyPair.prototype.validate = function validate() {
                var pub = this.getPublic();

                if (pub.isInfinity())
                    return { result: false, reason: 'Invalid public key' };
                if (!pub.validate())
                    return { result: false, reason: 'Public key is not a point' };
                if (!pub.mul(this.ec.curve.n).isInfinity())
                    return { result: false, reason: 'Public key * N != O' };

                return { result: true, reason: null };
            };

            KeyPair.prototype.getPublic = function getPublic(compact, enc) {
                // compact is optional argument
                if (typeof compact === 'string') {
                    enc = compact;
                    compact = null;
                }

                if (!this.pub)
                    this.pub = this.ec.g.mul(this.priv);

                if (!enc)
                    return this.pub;

                return this.pub.encode(enc, compact);
            };

            KeyPair.prototype.getPrivate = function getPrivate(enc) {
                if (enc === 'hex')
                    return this.priv.toString(16, 2);
                else
                    return this.priv;
            };

            KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
                this.priv = new BN(key, enc || 16);

                // Ensure that the priv won't be bigger than n, otherwise we may fail
                // in fixed multiplication method
                this.priv = this.priv.umod(this.ec.curve.n);
            };

            KeyPair.prototype._importPublic = function _importPublic(key, enc) {
                if (key.x || key.y) {
                    // Montgomery points only have an `x` coordinate.
                    // Weierstrass/Edwards points on the other hand have both `x` and
                    // `y` coordinates.
                    if (this.ec.curve.type === 'mont') {
                        assert(key.x, 'Need x coordinate');
                    } else if (this.ec.curve.type === 'short' ||
                        this.ec.curve.type === 'edwards') {
                        assert(key.x && key.y, 'Need both x and y coordinate');
                    }
                    this.pub = this.ec.curve.point(key.x, key.y);
                    return;
                }
                this.pub = this.ec.curve.decodePoint(key, enc);
            };

// ECDH
            KeyPair.prototype.derive = function derive(pub) {
                return pub.mul(this.priv).getX();
            };

// ECDSA
            KeyPair.prototype.sign = function sign(msg, enc, options) {
                return this.ec.sign(msg, this, enc, options);
            };

            KeyPair.prototype.verify = function verify(msg, signature) {
                return this.ec.verify(msg, signature, this);
            };

            KeyPair.prototype.inspect = function inspect() {
                return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
                    ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
            };

        }, { '../../elliptic': 80, 'bn.js': 27 }],
        89: [function(require, module, exports) {
            'use strict';

            var BN = require('bn.js');

            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;

            function Signature(options, enc) {
                if (options instanceof Signature)
                    return options;

                if (this._importDER(options, enc))
                    return;

                assert(options.r && options.s, 'Signature without r or s');
                this.r = new BN(options.r, 16);
                this.s = new BN(options.s, 16);
                if (options.recoveryParam === undefined)
                    this.recoveryParam = null;
                else
                    this.recoveryParam = options.recoveryParam;
            }

            module.exports = Signature;

            function Position() {
                this.place = 0;
            }

            function getLength(buf, p) {
                var initial = buf[p.place++];
                if (!(initial & 0x80)) {
                    return initial;
                }
                var octetLen = initial & 0xf;
                var val = 0;
                for (var i = 0, off = p.place; i < octetLen; i++, off++) {
                    val <<= 8;
                    val |= buf[off];
                }
                p.place = off;
                return val;
            }

            function rmPadding(buf) {
                var i = 0;
                var len = buf.length - 1;
                while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
                    i++;
                }
                if (i === 0) {
                    return buf;
                }
                return buf.slice(i);
            }

            Signature.prototype._importDER = function _importDER(data, enc) {
                data = utils.toArray(data, enc);
                var p = new Position();
                if (data[p.place++] !== 0x30) {
                    return false;
                }
                var len = getLength(data, p);
                if ((len + p.place) !== data.length) {
                    return false;
                }
                if (data[p.place++] !== 0x02) {
                    return false;
                }
                var rlen = getLength(data, p);
                var r = data.slice(p.place, rlen + p.place);
                p.place += rlen;
                if (data[p.place++] !== 0x02) {
                    return false;
                }
                var slen = getLength(data, p);
                if (data.length !== slen + p.place) {
                    return false;
                }
                var s = data.slice(p.place, slen + p.place);
                if (r[0] === 0 && (r[1] & 0x80)) {
                    r = r.slice(1);
                }
                if (s[0] === 0 && (s[1] & 0x80)) {
                    s = s.slice(1);
                }

                this.r = new BN(r);
                this.s = new BN(s);
                this.recoveryParam = null;

                return true;
            };

            function constructLength(arr, len) {
                if (len < 0x80) {
                    arr.push(len);
                    return;
                }
                var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
                arr.push(octets | 0x80);
                while (--octets) {
                    arr.push((len >>> (octets << 3)) & 0xff);
                }
                arr.push(len);
            }

            Signature.prototype.toDER = function toDER(enc) {
                var r = this.r.toArray();
                var s = this.s.toArray();

                // Pad values
                if (r[0] & 0x80)
                    r = [0].concat(r);
                // Pad values
                if (s[0] & 0x80)
                    s = [0].concat(s);

                r = rmPadding(r);
                s = rmPadding(s);

                while (!s[0] && !(s[1] & 0x80)) {
                    s = s.slice(1);
                }
                var arr = [0x02];
                constructLength(arr, r.length);
                arr = arr.concat(r);
                arr.push(0x02);
                constructLength(arr, s.length);
                var backHalf = arr.concat(s);
                var res = [0x30];
                constructLength(res, backHalf.length);
                res = res.concat(backHalf);
                return utils.encode(res, enc);
            };

        }, { '../../elliptic': 80, 'bn.js': 27 }],
        90: [function(require, module, exports) {
            'use strict';

            var hash = require('hash.js');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            var parseBytes = utils.parseBytes;
            var KeyPair = require('./key');
            var Signature = require('./signature');

            function EDDSA(curve) {
                assert(curve === 'ed25519', 'only tested with ed25519 so far');

                if (!(this instanceof EDDSA))
                    return new EDDSA(curve);

                var curve = elliptic.curves[curve].curve;
                this.curve = curve;
                this.g = curve.g;
                this.g.precompute(curve.n.bitLength() + 1);

                this.pointClass = curve.point().constructor;
                this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
                this.hash = hash.sha512;
            }

            module.exports = EDDSA;

            /**
             * @param {Array|String} message - message bytes
             * @param {Array|String|KeyPair} secret - secret bytes or a keypair
             * @returns {Signature} - signature
             */
            EDDSA.prototype.sign = function sign(message, secret) {
                message = parseBytes(message);
                var key = this.keyFromSecret(secret);
                var r = this.hashInt(key.messagePrefix(), message);
                var R = this.g.mul(r);
                var Rencoded = this.encodePoint(R);
                var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
                    .mul(key.priv());
                var S = r.add(s_).umod(this.curve.n);
                return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
            };

            /**
             * @param {Array} message - message bytes
             * @param {Array|String|Signature} sig - sig bytes
             * @param {Array|String|Point|KeyPair} pub - public key
             * @returns {Boolean} - true if public key matches sig of message
             */
            EDDSA.prototype.verify = function verify(message, sig, pub) {
                message = parseBytes(message);
                sig = this.makeSignature(sig);
                var key = this.keyFromPublic(pub);
                var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
                var SG = this.g.mul(sig.S());
                var RplusAh = sig.R().add(key.pub().mul(h));
                return RplusAh.eq(SG);
            };

            EDDSA.prototype.hashInt = function hashInt() {
                var hash = this.hash();
                for (var i = 0; i < arguments.length; i++)
                    hash.update(arguments[i]);
                return utils.intFromLE(hash.digest()).umod(this.curve.n);
            };

            EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
                return KeyPair.fromPublic(this, pub);
            };

            EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
                return KeyPair.fromSecret(this, secret);
            };

            EDDSA.prototype.makeSignature = function makeSignature(sig) {
                if (sig instanceof Signature)
                    return sig;
                return new Signature(this, sig);
            };

            /**
             * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
             *
             * EDDSA defines methods for encoding and decoding points and integers. These are
             * helper convenience methods, that pass along to utility functions implied
             * parameters.
             *
             */
            EDDSA.prototype.encodePoint = function encodePoint(point) {
                var enc = point.getY().toArray('le', this.encodingLength);
                enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
                return enc;
            };

            EDDSA.prototype.decodePoint = function decodePoint(bytes) {
                bytes = utils.parseBytes(bytes);

                var lastIx = bytes.length - 1;
                var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
                var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

                var y = utils.intFromLE(normed);
                return this.curve.pointFromY(y, xIsOdd);
            };

            EDDSA.prototype.encodeInt = function encodeInt(num) {
                return num.toArray('le', this.encodingLength);
            };

            EDDSA.prototype.decodeInt = function decodeInt(bytes) {
                return utils.intFromLE(bytes);
            };

            EDDSA.prototype.isPoint = function isPoint(val) {
                return val instanceof this.pointClass;
            };

        }, { '../../elliptic': 80, './key': 91, './signature': 92, 'hash.js': 100 }],
        91: [function(require, module, exports) {
            'use strict';

            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            var parseBytes = utils.parseBytes;
            var cachedProperty = utils.cachedProperty;

            /**
             * @param {EDDSA} eddsa - instance
             * @param {Object} params - public/private key parameters
             *
             * @param {Array<Byte>} [params.secret] - secret seed bytes
             * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
             * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
             *
             */
            function KeyPair(eddsa, params) {
                this.eddsa = eddsa;
                this._secret = parseBytes(params.secret);
                if (eddsa.isPoint(params.pub))
                    this._pub = params.pub;
                else
                    this._pubBytes = parseBytes(params.pub);
            }

            KeyPair.fromPublic = function fromPublic(eddsa, pub) {
                if (pub instanceof KeyPair)
                    return pub;
                return new KeyPair(eddsa, { pub: pub });
            };

            KeyPair.fromSecret = function fromSecret(eddsa, secret) {
                if (secret instanceof KeyPair)
                    return secret;
                return new KeyPair(eddsa, { secret: secret });
            };

            KeyPair.prototype.secret = function secret() {
                return this._secret;
            };

            cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
                return this.eddsa.encodePoint(this.pub());
            });

            cachedProperty(KeyPair, 'pub', function pub() {
                if (this._pubBytes)
                    return this.eddsa.decodePoint(this._pubBytes);
                return this.eddsa.g.mul(this.priv());
            });

            cachedProperty(KeyPair, 'privBytes', function privBytes() {
                var eddsa = this.eddsa;
                var hash = this.hash();
                var lastIx = eddsa.encodingLength - 1;

                var a = hash.slice(0, eddsa.encodingLength);
                a[0] &= 248;
                a[lastIx] &= 127;
                a[lastIx] |= 64;

                return a;
            });

            cachedProperty(KeyPair, 'priv', function priv() {
                return this.eddsa.decodeInt(this.privBytes());
            });

            cachedProperty(KeyPair, 'hash', function hash() {
                return this.eddsa.hash().update(this.secret()).digest();
            });

            cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
                return this.hash().slice(this.eddsa.encodingLength);
            });

            KeyPair.prototype.sign = function sign(message) {
                assert(this._secret, 'KeyPair can only verify');
                return this.eddsa.sign(message, this);
            };

            KeyPair.prototype.verify = function verify(message, sig) {
                return this.eddsa.verify(message, sig, this);
            };

            KeyPair.prototype.getSecret = function getSecret(enc) {
                assert(this._secret, 'KeyPair is public only');
                return utils.encode(this.secret(), enc);
            };

            KeyPair.prototype.getPublic = function getPublic(enc) {
                return utils.encode(this.pubBytes(), enc);
            };

            module.exports = KeyPair;

        }, { '../../elliptic': 80 }],
        92: [function(require, module, exports) {
            'use strict';

            var BN = require('bn.js');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            var cachedProperty = utils.cachedProperty;
            var parseBytes = utils.parseBytes;

            /**
             * @param {EDDSA} eddsa - eddsa instance
             * @param {Array<Bytes>|Object} sig -
             * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
             * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
             * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
             * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
             */
            function Signature(eddsa, sig) {
                this.eddsa = eddsa;

                if (typeof sig !== 'object')
                    sig = parseBytes(sig);

                if (Array.isArray(sig)) {
                    sig = {
                        R: sig.slice(0, eddsa.encodingLength),
                        S: sig.slice(eddsa.encodingLength)
                    };
                }

                assert(sig.R && sig.S, 'Signature without R or S');

                if (eddsa.isPoint(sig.R))
                    this._R = sig.R;
                if (sig.S instanceof BN)
                    this._S = sig.S;

                this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
                this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
            }

            cachedProperty(Signature, 'S', function S() {
                return this.eddsa.decodeInt(this.Sencoded());
            });

            cachedProperty(Signature, 'R', function R() {
                return this.eddsa.decodePoint(this.Rencoded());
            });

            cachedProperty(Signature, 'Rencoded', function Rencoded() {
                return this.eddsa.encodePoint(this.R());
            });

            cachedProperty(Signature, 'Sencoded', function Sencoded() {
                return this.eddsa.encodeInt(this.S());
            });

            Signature.prototype.toBytes = function toBytes() {
                return this.Rencoded().concat(this.Sencoded());
            };

            Signature.prototype.toHex = function toHex() {
                return utils.encode(this.toBytes(), 'hex').toUpperCase();
            };

            module.exports = Signature;

        }, { '../../elliptic': 80, 'bn.js': 27 }],
        93: [function(require, module, exports) {
            module.exports = {
                doubles: {
                    step: 4,
                    points: [
                        [
                            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                        ],
                        [
                            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                        ],
                        [
                            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                        ],
                        [
                            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                        ],
                        [
                            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                        ],
                        [
                            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                        ],
                        [
                            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                        ],
                        [
                            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                        ],
                        [
                            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                        ],
                        [
                            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                        ],
                        [
                            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                        ],
                        [
                            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                        ],
                        [
                            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                        ],
                        [
                            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                        ],
                        [
                            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                        ],
                        [
                            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                        ],
                        [
                            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                        ],
                        [
                            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                        ],
                        [
                            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                        ],
                        [
                            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                        ],
                        [
                            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                        ],
                        [
                            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                        ],
                        [
                            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                        ],
                        [
                            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                        ],
                        [
                            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                        ],
                        [
                            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                        ],
                        [
                            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                        ],
                        [
                            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                        ],
                        [
                            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                        ],
                        [
                            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                        ],
                        [
                            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                        ],
                        [
                            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                        ],
                        [
                            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                        ],
                        [
                            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                        ],
                        [
                            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                        ],
                        [
                            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                        ],
                        [
                            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                        ],
                        [
                            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                        ],
                        [
                            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                        ],
                        [
                            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                        ],
                        [
                            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                        ],
                        [
                            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                        ],
                        [
                            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                        ],
                        [
                            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                        ],
                        [
                            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                        ],
                        [
                            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                        ],
                        [
                            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                        ],
                        [
                            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                        ],
                        [
                            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                        ],
                        [
                            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                        ],
                        [
                            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                        ],
                        [
                            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                        ],
                        [
                            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                        ],
                        [
                            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                        ],
                        [
                            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                        ],
                        [
                            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                        ],
                        [
                            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                        ],
                        [
                            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                        ],
                        [
                            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                        ],
                        [
                            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                        ],
                        [
                            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                        ],
                        [
                            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                        ],
                        [
                            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                        ],
                        [
                            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                        ],
                        [
                            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                        ]
                    ]
                },
                naf: {
                    wnd: 7,
                    points: [
                        [
                            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                        ],
                        [
                            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                        ],
                        [
                            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                        ],
                        [
                            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                        ],
                        [
                            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                        ],
                        [
                            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                        ],
                        [
                            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                        ],
                        [
                            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                        ],
                        [
                            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                        ],
                        [
                            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                        ],
                        [
                            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                        ],
                        [
                            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                        ],
                        [
                            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                        ],
                        [
                            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                        ],
                        [
                            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                        ],
                        [
                            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                        ],
                        [
                            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                        ],
                        [
                            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                        ],
                        [
                            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                        ],
                        [
                            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                        ],
                        [
                            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                        ],
                        [
                            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                        ],
                        [
                            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                        ],
                        [
                            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                        ],
                        [
                            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                        ],
                        [
                            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                        ],
                        [
                            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                        ],
                        [
                            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                        ],
                        [
                            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                        ],
                        [
                            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                        ],
                        [
                            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                        ],
                        [
                            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                        ],
                        [
                            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                        ],
                        [
                            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                        ],
                        [
                            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                        ],
                        [
                            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                        ],
                        [
                            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                        ],
                        [
                            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                        ],
                        [
                            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                        ],
                        [
                            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                        ],
                        [
                            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                        ],
                        [
                            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                        ],
                        [
                            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                        ],
                        [
                            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                        ],
                        [
                            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                        ],
                        [
                            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                        ],
                        [
                            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                        ],
                        [
                            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                        ],
                        [
                            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                        ],
                        [
                            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                        ],
                        [
                            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                        ],
                        [
                            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                        ],
                        [
                            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                        ],
                        [
                            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                        ],
                        [
                            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                        ],
                        [
                            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                        ],
                        [
                            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                        ],
                        [
                            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                        ],
                        [
                            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                        ],
                        [
                            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                        ],
                        [
                            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                        ],
                        [
                            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                        ],
                        [
                            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                        ],
                        [
                            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                        ],
                        [
                            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                        ],
                        [
                            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                        ],
                        [
                            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                        ],
                        [
                            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                        ],
                        [
                            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                        ],
                        [
                            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                        ],
                        [
                            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                        ],
                        [
                            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                        ],
                        [
                            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                        ],
                        [
                            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                        ],
                        [
                            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                        ],
                        [
                            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                        ],
                        [
                            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                        ],
                        [
                            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                        ],
                        [
                            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                        ],
                        [
                            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                        ],
                        [
                            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                        ],
                        [
                            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                        ],
                        [
                            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                        ],
                        [
                            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                        ],
                        [
                            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                        ],
                        [
                            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                        ],
                        [
                            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                        ],
                        [
                            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                        ],
                        [
                            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                        ],
                        [
                            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                        ],
                        [
                            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                        ],
                        [
                            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                        ],
                        [
                            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                        ],
                        [
                            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                        ],
                        [
                            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                        ],
                        [
                            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                        ],
                        [
                            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                        ],
                        [
                            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                        ],
                        [
                            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                        ],
                        [
                            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                        ],
                        [
                            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                        ],
                        [
                            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                        ],
                        [
                            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                        ],
                        [
                            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                        ],
                        [
                            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                        ],
                        [
                            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                        ],
                        [
                            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                        ],
                        [
                            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                        ],
                        [
                            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                        ],
                        [
                            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                        ],
                        [
                            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                        ],
                        [
                            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                        ],
                        [
                            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                        ],
                        [
                            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                        ],
                        [
                            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                        ],
                        [
                            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                        ],
                        [
                            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                        ],
                        [
                            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                        ],
                        [
                            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                        ],
                        [
                            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                        ],
                        [
                            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                        ],
                        [
                            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                        ],
                        [
                            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                        ],
                        [
                            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                        ],
                        [
                            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                        ],
                        [
                            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                        ],
                        [
                            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                        ]
                    ]
                }
            };

        }, {}],
        94: [function(require, module, exports) {
            'use strict';

            var utils = exports;
            var BN = require('bn.js');
            var minAssert = require('minimalistic-assert');
            var minUtils = require('minimalistic-crypto-utils');

            utils.assert = minAssert;
            utils.toArray = minUtils.toArray;
            utils.zero2 = minUtils.zero2;
            utils.toHex = minUtils.toHex;
            utils.encode = minUtils.encode;

// Represent num in a w-NAF form
            function getNAF(num, w) {
                var naf = [];
                var ws = 1 << (w + 1);
                var k = num.clone();
                while (k.cmpn(1) >= 0) {
                    var z;
                    if (k.isOdd()) {
                        var mod = k.andln(ws - 1);
                        if (mod > (ws >> 1) - 1)
                            z = (ws >> 1) - mod;
                        else
                            z = mod;
                        k.isubn(z);
                    } else {
                        z = 0;
                    }
                    naf.push(z);

                    // Optimization, shift by word if possible
                    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
                    for (var i = 1; i < shift; i++)
                        naf.push(0);
                    k.iushrn(shift);
                }

                return naf;
            }

            utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
            function getJSF(k1, k2) {
                var jsf = [
                    [],
                    []
                ];

                k1 = k1.clone();
                k2 = k2.clone();
                var d1 = 0;
                var d2 = 0;
                while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

                    // First phase
                    var m14 = (k1.andln(3) + d1) & 3;
                    var m24 = (k2.andln(3) + d2) & 3;
                    if (m14 === 3)
                        m14 = -1;
                    if (m24 === 3)
                        m24 = -1;
                    var u1;
                    if ((m14 & 1) === 0) {
                        u1 = 0;
                    } else {
                        var m8 = (k1.andln(7) + d1) & 7;
                        if ((m8 === 3 || m8 === 5) && m24 === 2)
                            u1 = -m14;
                        else
                            u1 = m14;
                    }
                    jsf[0].push(u1);

                    var u2;
                    if ((m24 & 1) === 0) {
                        u2 = 0;
                    } else {
                        var m8 = (k2.andln(7) + d2) & 7;
                        if ((m8 === 3 || m8 === 5) && m14 === 2)
                            u2 = -m24;
                        else
                            u2 = m24;
                    }
                    jsf[1].push(u2);

                    // Second phase
                    if (2 * d1 === u1 + 1)
                        d1 = 1 - d1;
                    if (2 * d2 === u2 + 1)
                        d2 = 1 - d2;
                    k1.iushrn(1);
                    k2.iushrn(1);
                }

                return jsf;
            }

            utils.getJSF = getJSF;

            function cachedProperty(obj, name, computer) {
                var key = '_' + name;
                obj.prototype[name] = function cachedProperty() {
                    return this[key] !== undefined ? this[key] :
                        this[key] = computer.call(this);
                };
            }

            utils.cachedProperty = cachedProperty;

            function parseBytes(bytes) {
                return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                    bytes;
            }

            utils.parseBytes = parseBytes;

            function intFromLE(bytes) {
                return new BN(bytes, 'hex', 'le');
            }

            utils.intFromLE = intFromLE;


        }, { 'bn.js': 27, 'minimalistic-assert': 126, 'minimalistic-crypto-utils': 127 }],
        95: [function(require, module, exports) {
            module.exports = {
                'name': 'elliptic',
                'version': '6.4.1',
                'description': 'EC cryptography',
                'main': 'lib/elliptic.js',
                'files': [
                    'lib'
                ],
                'scripts': {
                    'jscs': 'jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js',
                    'jshint': 'jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js',
                    'lint': 'npm run jscs && npm run jshint',
                    'unit': 'istanbul test _mocha --reporter=spec test/index.js',
                    'test': 'npm run lint && npm run unit',
                    'version': 'grunt dist && git add dist/'
                },
                'repository': {
                    'type': 'git',
                    'url': 'git@github.com:indutny/elliptic'
                },
                'keywords': [
                    'EC',
                    'Elliptic',
                    'curve',
                    'Cryptography'
                ],
                'author': 'Fedor Indutny <fedor@indutny.com>',
                'license': 'MIT',
                'bugs': {
                    'url': 'https://github.com/indutny/elliptic/issues'
                },
                'homepage': 'https://github.com/indutny/elliptic',
                'devDependencies': {
                    'brfs': '^1.4.3',
                    'coveralls': '^2.11.3',
                    'grunt': '^0.4.5',
                    'grunt-browserify': '^5.0.0',
                    'grunt-cli': '^1.2.0',
                    'grunt-contrib-connect': '^1.0.0',
                    'grunt-contrib-copy': '^1.0.0',
                    'grunt-contrib-uglify': '^1.0.1',
                    'grunt-mocha-istanbul': '^3.0.1',
                    'grunt-saucelabs': '^8.6.2',
                    'istanbul': '^0.4.2',
                    'jscs': '^2.9.0',
                    'jshint': '^2.6.0',
                    'mocha': '^2.1.0'
                },
                'dependencies': {
                    'bn.js': '^4.4.0',
                    'brorand': '^1.0.1',
                    'hash.js': '^1.0.0',
                    'hmac-drbg': '^1.0.0',
                    'inherits': '^2.0.1',
                    'minimalistic-assert': '^1.0.0',
                    'minimalistic-crypto-utils': '^1.0.0'
                }
            };

        }, {}],
        96: [function(require, module, exports) {
            'use strict';

            Object.defineProperty(exports, '__esModule', {
                value: true
            });

            var _get = function get(_x2, _x3, _x4) {
                var _again = true;
                _function: while (_again) {
                    var object = _x2, property = _x3, receiver = _x4;
                    _again = false;
                    if (object === null) object = Function.prototype;
                    var desc = Object.getOwnPropertyDescriptor(object, property);
                    if (desc === undefined) {
                        var parent = Object.getPrototypeOf(object);
                        if (parent === null) {
                            return undefined;
                        } else {
                            _x2 = parent;
                            _x3 = property;
                            _x4 = receiver;
                            _again = true;
                            desc = parent = undefined;

                        }
                    } else if ('value' in desc) {
                        return desc.value;
                    } else {
                        var getter = desc.get;
                        if (getter === undefined) {
                            return undefined;
                        }
                        return getter.call(receiver);
                    }
                }
            };

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError('Cannot call a class as a function');
                }
            }

            function _inherits(subClass, superClass) {
                if (typeof superClass !== 'function' && superClass !== null) {
                    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }

            var ExtendableError = (function(_Error) {
                _inherits(ExtendableError, _Error);

                function ExtendableError() {
                    var message = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

                    _classCallCheck(this, ExtendableError);

                    _get(Object.getPrototypeOf(ExtendableError.prototype), 'constructor', this).call(this, message);

                    // extending Error is weird and does not propagate `message`
                    Object.defineProperty(this, 'message', {
                        enumerable: false,
                        value: message,
                        writable: true
                    });

                    Object.defineProperty(this, 'name', {
                        enumerable: false,
                        value: this.constructor.name,
                        writable: true
                    });

                    if (Error.hasOwnProperty('captureStackTrace')) {
                        Error.captureStackTrace(this, this.constructor);
                        return;
                    }

                    Object.defineProperty(this, 'stack', {
                        enumerable: false,
                        value: new Error(message).stack,
                        writable: true
                    });
                }

                return ExtendableError;
            })(Error);

            exports['default'] = ExtendableError;
            module.exports = exports['default'];
        }, {}],
        97: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            function EventEmitter() {
                this._events = this._events || {};
                this._maxListeners = this._maxListeners || undefined;
            }

            module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
            EventEmitter.EventEmitter = EventEmitter;

            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
            EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
            EventEmitter.prototype.setMaxListeners = function(n) {
                if (!isNumber(n) || n < 0 || isNaN(n))
                    throw TypeError('n must be a positive number');
                this._maxListeners = n;
                return this;
            };

            EventEmitter.prototype.emit = function(type) {
                var er, handler, len, args, i, listeners;

                if (!this._events)
                    this._events = {};

                // If there is no 'error' event listener then throw.
                if (type === 'error') {
                    if (!this._events.error ||
                        (isObject(this._events.error) && !this._events.error.length)) {
                        er = arguments[1];
                        if (er instanceof Error) {
                            throw er; // Unhandled 'error' event
                        } else {
                            // At least give some kind of context to the user
                            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                            err.context = er;
                            throw err;
                        }
                    }
                }

                handler = this._events[type];

                if (isUndefined(handler))
                    return false;

                if (isFunction(handler)) {
                    switch (arguments.length) {
                        // fast cases
                        case 1:
                            handler.call(this);
                            break;
                        case 2:
                            handler.call(this, arguments[1]);
                            break;
                        case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;
                        // slower
                        default:
                            args = Array.prototype.slice.call(arguments, 1);
                            handler.apply(this, args);
                    }
                } else if (isObject(handler)) {
                    args = Array.prototype.slice.call(arguments, 1);
                    listeners = handler.slice();
                    len = listeners.length;
                    for (i = 0; i < len; i++)
                        listeners[i].apply(this, args);
                }

                return true;
            };

            EventEmitter.prototype.addListener = function(type, listener) {
                var m;

                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                if (!this._events)
                    this._events = {};

                // To avoid recursion in the case that type === "newListener"! Before
                // adding it to the listeners, first emit "newListener".
                if (this._events.newListener)
                    this.emit('newListener', type,
                        isFunction(listener.listener) ?
                            listener.listener : listener);

                if (!this._events[type])
                    // Optimize the case of one listener. Don't need the extra array object.
                    this._events[type] = listener;
                else if (isObject(this._events[type]))
                    // If we've already got an array, just append.
                    this._events[type].push(listener);
                else
                    // Adding the second element, need to change to array.
                    this._events[type] = [this._events[type], listener];

                // Check for listener leak
                if (isObject(this._events[type]) && !this._events[type].warned) {
                    if (!isUndefined(this._maxListeners)) {
                        m = this._maxListeners;
                    } else {
                        m = EventEmitter.defaultMaxListeners;
                    }

                    if (m && m > 0 && this._events[type].length > m) {
                        this._events[type].warned = true;
                        console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            this._events[type].length);
                        if (typeof console.trace === 'function') {
                            // not supported in IE 10
                            console.trace();
                        }
                    }
                }

                return this;
            };

            EventEmitter.prototype.on = EventEmitter.prototype.addListener;

            EventEmitter.prototype.once = function(type, listener) {
                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                var fired = false;

                function g() {
                    this.removeListener(type, g);

                    if (!fired) {
                        fired = true;
                        listener.apply(this, arguments);
                    }
                }

                g.listener = listener;
                this.on(type, g);

                return this;
            };

// emits a 'removeListener' event iff the listener was removed
            EventEmitter.prototype.removeListener = function(type, listener) {
                var list, position, length, i;

                if (!isFunction(listener))
                    throw TypeError('listener must be a function');

                if (!this._events || !this._events[type])
                    return this;

                list = this._events[type];
                length = list.length;
                position = -1;

                if (list === listener ||
                    (isFunction(list.listener) && list.listener === listener)) {
                    delete this._events[type];
                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);

                } else if (isObject(list)) {
                    for (i = length; i-- > 0;) {
                        if (list[i] === listener ||
                            (list[i].listener && list[i].listener === listener)) {
                            position = i;
                            break;
                        }
                    }

                    if (position < 0)
                        return this;

                    if (list.length === 1) {
                        list.length = 0;
                        delete this._events[type];
                    } else {
                        list.splice(position, 1);
                    }

                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);
                }

                return this;
            };

            EventEmitter.prototype.removeAllListeners = function(type) {
                var key, listeners;

                if (!this._events)
                    return this;

                // not listening for removeListener, no need to emit
                if (!this._events.removeListener) {
                    if (arguments.length === 0)
                        this._events = {};
                    else if (this._events[type])
                        delete this._events[type];
                    return this;
                }

                // emit removeListener for all listeners on all events
                if (arguments.length === 0) {
                    for (key in this._events) {
                        if (key === 'removeListener') continue;
                        this.removeAllListeners(key);
                    }
                    this.removeAllListeners('removeListener');
                    this._events = {};
                    return this;
                }

                listeners = this._events[type];

                if (isFunction(listeners)) {
                    this.removeListener(type, listeners);
                } else if (listeners) {
                    // LIFO order
                    while (listeners.length)
                        this.removeListener(type, listeners[listeners.length - 1]);
                }
                delete this._events[type];

                return this;
            };

            EventEmitter.prototype.listeners = function(type) {
                var ret;
                if (!this._events || !this._events[type])
                    ret = [];
                else if (isFunction(this._events[type]))
                    ret = [this._events[type]];
                else
                    ret = this._events[type].slice();
                return ret;
            };

            EventEmitter.prototype.listenerCount = function(type) {
                if (this._events) {
                    var evlistener = this._events[type];

                    if (isFunction(evlistener))
                        return 1;
                    else if (evlistener)
                        return evlistener.length;
                }
                return 0;
            };

            EventEmitter.listenerCount = function(emitter, type) {
                return emitter.listenerCount(type);
            };

            function isFunction(arg) {
                return typeof arg === 'function';
            }

            function isNumber(arg) {
                return typeof arg === 'number';
            }

            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }

            function isUndefined(arg) {
                return arg === void 0;
            }

        }, {}],
        98: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;
            var MD5 = require('md5.js');

            /* eslint-disable camelcase */
            function EVP_BytesToKey(password, salt, keyBits, ivLen) {
                if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary');
                if (salt) {
                    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
                    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length');
                }

                var keyLen = keyBits / 8;
                var key = Buffer.alloc(keyLen);
                var iv = Buffer.alloc(ivLen || 0);
                var tmp = Buffer.alloc(0);

                while (keyLen > 0 || ivLen > 0) {
                    var hash = new MD5();
                    hash.update(tmp);
                    hash.update(password);
                    if (salt) hash.update(salt);
                    tmp = hash.digest();

                    var used = 0;

                    if (keyLen > 0) {
                        var keyStart = key.length - keyLen;
                        used = Math.min(keyLen, tmp.length);
                        tmp.copy(key, keyStart, 0, used);
                        keyLen -= used;
                    }

                    if (used < tmp.length && ivLen > 0) {
                        var ivStart = iv.length - ivLen;
                        var length = Math.min(ivLen, tmp.length - used);
                        tmp.copy(iv, ivStart, used, used + length);
                        ivLen -= length;
                    }
                }

                tmp.fill(0);
                return { key: key, iv: iv };
            }

            module.exports = EVP_BytesToKey;

        }, { 'md5.js': 121, 'safe-buffer': 169 }],
        99: [function(require, module, exports) {
            'use strict';
            var Buffer = require('safe-buffer').Buffer;
            var Transform = require('stream').Transform;
            var inherits = require('inherits');

            function throwIfNotStringOrBuffer(val, prefix) {
                if (!Buffer.isBuffer(val) && typeof val !== 'string') {
                    throw new TypeError(prefix + ' must be a string or a buffer');
                }
            }

            function HashBase(blockSize) {
                Transform.call(this);

                this._block = Buffer.allocUnsafe(blockSize);
                this._blockSize = blockSize;
                this._blockOffset = 0;
                this._length = [0, 0, 0, 0];

                this._finalized = false;
            }

            inherits(HashBase, Transform);

            HashBase.prototype._transform = function(chunk, encoding, callback) {
                var error = null;
                try {
                    this.update(chunk, encoding);
                } catch (err) {
                    error = err;
                }

                callback(error);
            };

            HashBase.prototype._flush = function(callback) {
                var error = null;
                try {
                    this.push(this.digest());
                } catch (err) {
                    error = err;
                }

                callback(error);
            };

            HashBase.prototype.update = function(data, encoding) {
                throwIfNotStringOrBuffer(data, 'Data');
                if (this._finalized) throw new Error('Digest already called');
                if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);

                // consume data
                var block = this._block;
                var offset = 0;
                while (this._blockOffset + data.length - offset >= this._blockSize) {
                    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
                    this._update();
                    this._blockOffset = 0;
                }
                while (offset < data.length) block[this._blockOffset++] = data[offset++];

                // update length
                for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
                    this._length[j] += carry;
                    carry = (this._length[j] / 0x0100000000) | 0;
                    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
                }

                return this;
            };

            HashBase.prototype._update = function() {
                throw new Error('_update is not implemented');
            };

            HashBase.prototype.digest = function(encoding) {
                if (this._finalized) throw new Error('Digest already called');
                this._finalized = true;

                var digest = this._digest();
                if (encoding !== undefined) digest = digest.toString(encoding);

                // reset state
                this._block.fill(0);
                this._blockOffset = 0;
                for (var i = 0; i < 4; ++i) this._length[i] = 0;

                return digest;
            };

            HashBase.prototype._digest = function() {
                throw new Error('_digest is not implemented');
            };

            module.exports = HashBase;

        }, { 'inherits': 116, 'safe-buffer': 169, 'stream': 179 }],
        100: [function(require, module, exports) {
            var hash = exports;

            hash.utils = require('./hash/utils');
            hash.common = require('./hash/common');
            hash.sha = require('./hash/sha');
            hash.ripemd = require('./hash/ripemd');
            hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
            hash.sha1 = hash.sha.sha1;
            hash.sha256 = hash.sha.sha256;
            hash.sha224 = hash.sha.sha224;
            hash.sha384 = hash.sha.sha384;
            hash.sha512 = hash.sha.sha512;
            hash.ripemd160 = hash.ripemd.ripemd160;

        }, { './hash/common': 101, './hash/hmac': 102, './hash/ripemd': 103, './hash/sha': 104, './hash/utils': 111 }],
        101: [function(require, module, exports) {
            'use strict';

            var utils = require('./utils');
            var assert = require('minimalistic-assert');

            function BlockHash() {
                this.pending = null;
                this.pendingTotal = 0;
                this.blockSize = this.constructor.blockSize;
                this.outSize = this.constructor.outSize;
                this.hmacStrength = this.constructor.hmacStrength;
                this.padLength = this.constructor.padLength / 8;
                this.endian = 'big';

                this._delta8 = this.blockSize / 8;
                this._delta32 = this.blockSize / 32;
            }

            exports.BlockHash = BlockHash;

            BlockHash.prototype.update = function update(msg, enc) {
                // Convert message to array, pad it, and join into 32bit blocks
                msg = utils.toArray(msg, enc);
                if (!this.pending)
                    this.pending = msg;
                else
                    this.pending = this.pending.concat(msg);
                this.pendingTotal += msg.length;

                // Enough data, try updating
                if (this.pending.length >= this._delta8) {
                    msg = this.pending;

                    // Process pending data in blocks
                    var r = msg.length % this._delta8;
                    this.pending = msg.slice(msg.length - r, msg.length);
                    if (this.pending.length === 0)
                        this.pending = null;

                    msg = utils.join32(msg, 0, msg.length - r, this.endian);
                    for (var i = 0; i < msg.length; i += this._delta32)
                        this._update(msg, i, i + this._delta32);
                }

                return this;
            };

            BlockHash.prototype.digest = function digest(enc) {
                this.update(this._pad());
                assert(this.pending === null);

                return this._digest(enc);
            };

            BlockHash.prototype._pad = function pad() {
                var len = this.pendingTotal;
                var bytes = this._delta8;
                var k = bytes - ((len + this.padLength) % bytes);
                var res = new Array(k + this.padLength);
                res[0] = 0x80;
                for (var i = 1; i < k; i++)
                    res[i] = 0;

                // Append length
                len <<= 3;
                if (this.endian === 'big') {
                    for (var t = 8; t < this.padLength; t++)
                        res[i++] = 0;

                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = (len >>> 24) & 0xff;
                    res[i++] = (len >>> 16) & 0xff;
                    res[i++] = (len >>> 8) & 0xff;
                    res[i++] = len & 0xff;
                } else {
                    res[i++] = len & 0xff;
                    res[i++] = (len >>> 8) & 0xff;
                    res[i++] = (len >>> 16) & 0xff;
                    res[i++] = (len >>> 24) & 0xff;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;

                    for (t = 8; t < this.padLength; t++)
                        res[i++] = 0;
                }

                return res;
            };

        }, { './utils': 111, 'minimalistic-assert': 126 }],
        102: [function(require, module, exports) {
            'use strict';

            var utils = require('./utils');
            var assert = require('minimalistic-assert');

            function Hmac(hash, key, enc) {
                if (!(this instanceof Hmac))
                    return new Hmac(hash, key, enc);
                this.Hash = hash;
                this.blockSize = hash.blockSize / 8;
                this.outSize = hash.outSize / 8;
                this.inner = null;
                this.outer = null;

                this._init(utils.toArray(key, enc));
            }

            module.exports = Hmac;

            Hmac.prototype._init = function init(key) {
                // Shorten key, if needed
                if (key.length > this.blockSize)
                    key = new this.Hash().update(key).digest();
                assert(key.length <= this.blockSize);

                // Add padding to key
                for (var i = key.length; i < this.blockSize; i++)
                    key.push(0);

                for (i = 0; i < key.length; i++)
                    key[i] ^= 0x36;
                this.inner = new this.Hash().update(key);

                // 0x36 ^ 0x5c = 0x6a
                for (i = 0; i < key.length; i++)
                    key[i] ^= 0x6a;
                this.outer = new this.Hash().update(key);
            };

            Hmac.prototype.update = function update(msg, enc) {
                this.inner.update(msg, enc);
                return this;
            };

            Hmac.prototype.digest = function digest(enc) {
                this.outer.update(this.inner.digest());
                return this.outer.digest(enc);
            };

        }, { './utils': 111, 'minimalistic-assert': 126 }],
        103: [function(require, module, exports) {
            'use strict';

            var utils = require('./utils');
            var common = require('./common');

            var rotl32 = utils.rotl32;
            var sum32 = utils.sum32;
            var sum32_3 = utils.sum32_3;
            var sum32_4 = utils.sum32_4;
            var BlockHash = common.BlockHash;

            function RIPEMD160() {
                if (!(this instanceof RIPEMD160))
                    return new RIPEMD160();

                BlockHash.call(this);

                this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
                this.endian = 'little';
            }

            utils.inherits(RIPEMD160, BlockHash);
            exports.ripemd160 = RIPEMD160;

            RIPEMD160.blockSize = 512;
            RIPEMD160.outSize = 160;
            RIPEMD160.hmacStrength = 192;
            RIPEMD160.padLength = 64;

            RIPEMD160.prototype._update = function update(msg, start) {
                var A = this.h[0];
                var B = this.h[1];
                var C = this.h[2];
                var D = this.h[3];
                var E = this.h[4];
                var Ah = A;
                var Bh = B;
                var Ch = C;
                var Dh = D;
                var Eh = E;
                for (var j = 0; j < 80; j++) {
                    var T = sum32(
                        rotl32(
                            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
                            s[j]),
                        E);
                    A = E;
                    E = D;
                    D = rotl32(C, 10);
                    C = B;
                    B = T;
                    T = sum32(
                        rotl32(
                            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
                            sh[j]),
                        Eh);
                    Ah = Eh;
                    Eh = Dh;
                    Dh = rotl32(Ch, 10);
                    Ch = Bh;
                    Bh = T;
                }
                T = sum32_3(this.h[1], C, Dh);
                this.h[1] = sum32_3(this.h[2], D, Eh);
                this.h[2] = sum32_3(this.h[3], E, Ah);
                this.h[3] = sum32_3(this.h[4], A, Bh);
                this.h[4] = sum32_3(this.h[0], B, Ch);
                this.h[0] = T;
            };

            RIPEMD160.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'little');
                else
                    return utils.split32(this.h, 'little');
            };

            function f(j, x, y, z) {
                if (j <= 15)
                    return x ^ y ^ z;
                else if (j <= 31)
                    return (x & y) | ((~x) & z);
                else if (j <= 47)
                    return (x | (~y)) ^ z;
                else if (j <= 63)
                    return (x & z) | (y & (~z));
                else
                    return x ^ (y | (~z));
            }

            function K(j) {
                if (j <= 15)
                    return 0x00000000;
                else if (j <= 31)
                    return 0x5a827999;
                else if (j <= 47)
                    return 0x6ed9eba1;
                else if (j <= 63)
                    return 0x8f1bbcdc;
                else
                    return 0xa953fd4e;
            }

            function Kh(j) {
                if (j <= 15)
                    return 0x50a28be6;
                else if (j <= 31)
                    return 0x5c4dd124;
                else if (j <= 47)
                    return 0x6d703ef3;
                else if (j <= 63)
                    return 0x7a6d76e9;
                else
                    return 0x00000000;
            }

            var r = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
            ];

            var rh = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
            ];

            var s = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
            ];

            var sh = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
            ];

        }, { './common': 101, './utils': 111 }],
        104: [function(require, module, exports) {
            'use strict';

            exports.sha1 = require('./sha/1');
            exports.sha224 = require('./sha/224');
            exports.sha256 = require('./sha/256');
            exports.sha384 = require('./sha/384');
            exports.sha512 = require('./sha/512');

        }, { './sha/1': 105, './sha/224': 106, './sha/256': 107, './sha/384': 108, './sha/512': 109 }],
        105: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var common = require('../common');
            var shaCommon = require('./common');

            var rotl32 = utils.rotl32;
            var sum32 = utils.sum32;
            var sum32_5 = utils.sum32_5;
            var ft_1 = shaCommon.ft_1;
            var BlockHash = common.BlockHash;

            var sha1_K = [
                0x5A827999, 0x6ED9EBA1,
                0x8F1BBCDC, 0xCA62C1D6
            ];

            function SHA1() {
                if (!(this instanceof SHA1))
                    return new SHA1();

                BlockHash.call(this);
                this.h = [
                    0x67452301, 0xefcdab89, 0x98badcfe,
                    0x10325476, 0xc3d2e1f0];
                this.W = new Array(80);
            }

            utils.inherits(SHA1, BlockHash);
            module.exports = SHA1;

            SHA1.blockSize = 512;
            SHA1.outSize = 160;
            SHA1.hmacStrength = 80;
            SHA1.padLength = 64;

            SHA1.prototype._update = function _update(msg, start) {
                var W = this.W;

                for (var i = 0; i < 16; i++)
                    W[i] = msg[start + i];

                for (; i < W.length; i++)
                    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

                var a = this.h[0];
                var b = this.h[1];
                var c = this.h[2];
                var d = this.h[3];
                var e = this.h[4];

                for (i = 0; i < W.length; i++) {
                    var s = ~~(i / 20);
                    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
                    e = d;
                    d = c;
                    c = rotl32(b, 30);
                    b = a;
                    a = t;
                }

                this.h[0] = sum32(this.h[0], a);
                this.h[1] = sum32(this.h[1], b);
                this.h[2] = sum32(this.h[2], c);
                this.h[3] = sum32(this.h[3], d);
                this.h[4] = sum32(this.h[4], e);
            };

            SHA1.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };

        }, { '../common': 101, '../utils': 111, './common': 110 }],
        106: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var SHA256 = require('./256');

            function SHA224() {
                if (!(this instanceof SHA224))
                    return new SHA224();

                SHA256.call(this);
                this.h = [
                    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
            }

            utils.inherits(SHA224, SHA256);
            module.exports = SHA224;

            SHA224.blockSize = 512;
            SHA224.outSize = 224;
            SHA224.hmacStrength = 192;
            SHA224.padLength = 64;

            SHA224.prototype._digest = function digest(enc) {
                // Just truncate output
                if (enc === 'hex')
                    return utils.toHex32(this.h.slice(0, 7), 'big');
                else
                    return utils.split32(this.h.slice(0, 7), 'big');
            };


        }, { '../utils': 111, './256': 107 }],
        107: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var common = require('../common');
            var shaCommon = require('./common');
            var assert = require('minimalistic-assert');

            var sum32 = utils.sum32;
            var sum32_4 = utils.sum32_4;
            var sum32_5 = utils.sum32_5;
            var ch32 = shaCommon.ch32;
            var maj32 = shaCommon.maj32;
            var s0_256 = shaCommon.s0_256;
            var s1_256 = shaCommon.s1_256;
            var g0_256 = shaCommon.g0_256;
            var g1_256 = shaCommon.g1_256;

            var BlockHash = common.BlockHash;

            var sha256_K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            ];

            function SHA256() {
                if (!(this instanceof SHA256))
                    return new SHA256();

                BlockHash.call(this);
                this.h = [
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                ];
                this.k = sha256_K;
                this.W = new Array(64);
            }

            utils.inherits(SHA256, BlockHash);
            module.exports = SHA256;

            SHA256.blockSize = 512;
            SHA256.outSize = 256;
            SHA256.hmacStrength = 192;
            SHA256.padLength = 64;

            SHA256.prototype._update = function _update(msg, start) {
                var W = this.W;

                for (var i = 0; i < 16; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i++)
                    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

                var a = this.h[0];
                var b = this.h[1];
                var c = this.h[2];
                var d = this.h[3];
                var e = this.h[4];
                var f = this.h[5];
                var g = this.h[6];
                var h = this.h[7];

                assert(this.k.length === W.length);
                for (i = 0; i < W.length; i++) {
                    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
                    var T2 = sum32(s0_256(a), maj32(a, b, c));
                    h = g;
                    g = f;
                    f = e;
                    e = sum32(d, T1);
                    d = c;
                    c = b;
                    b = a;
                    a = sum32(T1, T2);
                }

                this.h[0] = sum32(this.h[0], a);
                this.h[1] = sum32(this.h[1], b);
                this.h[2] = sum32(this.h[2], c);
                this.h[3] = sum32(this.h[3], d);
                this.h[4] = sum32(this.h[4], e);
                this.h[5] = sum32(this.h[5], f);
                this.h[6] = sum32(this.h[6], g);
                this.h[7] = sum32(this.h[7], h);
            };

            SHA256.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };

        }, { '../common': 101, '../utils': 111, './common': 110, 'minimalistic-assert': 126 }],
        108: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');

            var SHA512 = require('./512');

            function SHA384() {
                if (!(this instanceof SHA384))
                    return new SHA384();

                SHA512.call(this);
                this.h = [
                    0xcbbb9d5d, 0xc1059ed8,
                    0x629a292a, 0x367cd507,
                    0x9159015a, 0x3070dd17,
                    0x152fecd8, 0xf70e5939,
                    0x67332667, 0xffc00b31,
                    0x8eb44a87, 0x68581511,
                    0xdb0c2e0d, 0x64f98fa7,
                    0x47b5481d, 0xbefa4fa4];
            }

            utils.inherits(SHA384, SHA512);
            module.exports = SHA384;

            SHA384.blockSize = 1024;
            SHA384.outSize = 384;
            SHA384.hmacStrength = 192;
            SHA384.padLength = 128;

            SHA384.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h.slice(0, 12), 'big');
                else
                    return utils.split32(this.h.slice(0, 12), 'big');
            };

        }, { '../utils': 111, './512': 109 }],
        109: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var common = require('../common');
            var assert = require('minimalistic-assert');

            var rotr64_hi = utils.rotr64_hi;
            var rotr64_lo = utils.rotr64_lo;
            var shr64_hi = utils.shr64_hi;
            var shr64_lo = utils.shr64_lo;
            var sum64 = utils.sum64;
            var sum64_hi = utils.sum64_hi;
            var sum64_lo = utils.sum64_lo;
            var sum64_4_hi = utils.sum64_4_hi;
            var sum64_4_lo = utils.sum64_4_lo;
            var sum64_5_hi = utils.sum64_5_hi;
            var sum64_5_lo = utils.sum64_5_lo;

            var BlockHash = common.BlockHash;

            var sha512_K = [
                0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
                0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
                0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
                0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
                0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
                0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
                0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
                0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
                0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
                0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
                0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
                0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
                0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
                0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
                0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
                0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
                0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
                0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
                0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
                0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
                0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
                0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
                0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
                0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
                0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
                0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
                0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
                0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
                0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
                0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
                0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
                0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
                0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
                0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
                0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
                0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
            ];

            function SHA512() {
                if (!(this instanceof SHA512))
                    return new SHA512();

                BlockHash.call(this);
                this.h = [
                    0x6a09e667, 0xf3bcc908,
                    0xbb67ae85, 0x84caa73b,
                    0x3c6ef372, 0xfe94f82b,
                    0xa54ff53a, 0x5f1d36f1,
                    0x510e527f, 0xade682d1,
                    0x9b05688c, 0x2b3e6c1f,
                    0x1f83d9ab, 0xfb41bd6b,
                    0x5be0cd19, 0x137e2179];
                this.k = sha512_K;
                this.W = new Array(160);
            }

            utils.inherits(SHA512, BlockHash);
            module.exports = SHA512;

            SHA512.blockSize = 1024;
            SHA512.outSize = 512;
            SHA512.hmacStrength = 192;
            SHA512.padLength = 128;

            SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
                var W = this.W;

                // 32 x 32bit words
                for (var i = 0; i < 32; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i += 2) {
                    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
                    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
                    var c1_hi = W[i - 14];  // i - 7
                    var c1_lo = W[i - 13];
                    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
                    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
                    var c3_hi = W[i - 32];  // i - 16
                    var c3_lo = W[i - 31];

                    W[i] = sum64_4_hi(
                        c0_hi, c0_lo,
                        c1_hi, c1_lo,
                        c2_hi, c2_lo,
                        c3_hi, c3_lo);
                    W[i + 1] = sum64_4_lo(
                        c0_hi, c0_lo,
                        c1_hi, c1_lo,
                        c2_hi, c2_lo,
                        c3_hi, c3_lo);
                }
            };

            SHA512.prototype._update = function _update(msg, start) {
                this._prepareBlock(msg, start);

                var W = this.W;

                var ah = this.h[0];
                var al = this.h[1];
                var bh = this.h[2];
                var bl = this.h[3];
                var ch = this.h[4];
                var cl = this.h[5];
                var dh = this.h[6];
                var dl = this.h[7];
                var eh = this.h[8];
                var el = this.h[9];
                var fh = this.h[10];
                var fl = this.h[11];
                var gh = this.h[12];
                var gl = this.h[13];
                var hh = this.h[14];
                var hl = this.h[15];

                assert(this.k.length === W.length);
                for (var i = 0; i < W.length; i += 2) {
                    var c0_hi = hh;
                    var c0_lo = hl;
                    var c1_hi = s1_512_hi(eh, el);
                    var c1_lo = s1_512_lo(eh, el);
                    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
                    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
                    var c3_hi = this.k[i];
                    var c3_lo = this.k[i + 1];
                    var c4_hi = W[i];
                    var c4_lo = W[i + 1];

                    var T1_hi = sum64_5_hi(
                        c0_hi, c0_lo,
                        c1_hi, c1_lo,
                        c2_hi, c2_lo,
                        c3_hi, c3_lo,
                        c4_hi, c4_lo);
                    var T1_lo = sum64_5_lo(
                        c0_hi, c0_lo,
                        c1_hi, c1_lo,
                        c2_hi, c2_lo,
                        c3_hi, c3_lo,
                        c4_hi, c4_lo);

                    c0_hi = s0_512_hi(ah, al);
                    c0_lo = s0_512_lo(ah, al);
                    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
                    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

                    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
                    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

                    hh = gh;
                    hl = gl;

                    gh = fh;
                    gl = fl;

                    fh = eh;
                    fl = el;

                    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
                    el = sum64_lo(dl, dl, T1_hi, T1_lo);

                    dh = ch;
                    dl = cl;

                    ch = bh;
                    cl = bl;

                    bh = ah;
                    bl = al;

                    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
                    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
                }

                sum64(this.h, 0, ah, al);
                sum64(this.h, 2, bh, bl);
                sum64(this.h, 4, ch, cl);
                sum64(this.h, 6, dh, dl);
                sum64(this.h, 8, eh, el);
                sum64(this.h, 10, fh, fl);
                sum64(this.h, 12, gh, gl);
                sum64(this.h, 14, hh, hl);
            };

            SHA512.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };

            function ch64_hi(xh, xl, yh, yl, zh) {
                var r = (xh & yh) ^ ((~xh) & zh);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function ch64_lo(xh, xl, yh, yl, zh, zl) {
                var r = (xl & yl) ^ ((~xl) & zl);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function maj64_hi(xh, xl, yh, yl, zh) {
                var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function maj64_lo(xh, xl, yh, yl, zh, zl) {
                var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function s0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 28);
                var c1_hi = rotr64_hi(xl, xh, 2);  // 34
                var c2_hi = rotr64_hi(xl, xh, 7);  // 39

                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function s0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 28);
                var c1_lo = rotr64_lo(xl, xh, 2);  // 34
                var c2_lo = rotr64_lo(xl, xh, 7);  // 39

                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function s1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 14);
                var c1_hi = rotr64_hi(xh, xl, 18);
                var c2_hi = rotr64_hi(xl, xh, 9);  // 41

                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function s1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 14);
                var c1_lo = rotr64_lo(xh, xl, 18);
                var c2_lo = rotr64_lo(xl, xh, 9);  // 41

                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function g0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 1);
                var c1_hi = rotr64_hi(xh, xl, 8);
                var c2_hi = shr64_hi(xh, xl, 7);

                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function g0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 1);
                var c1_lo = rotr64_lo(xh, xl, 8);
                var c2_lo = shr64_lo(xh, xl, 7);

                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function g1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 19);
                var c1_hi = rotr64_hi(xl, xh, 29);  // 61
                var c2_hi = shr64_hi(xh, xl, 6);

                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

            function g1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 19);
                var c1_lo = rotr64_lo(xl, xh, 29);  // 61
                var c2_lo = shr64_lo(xh, xl, 6);

                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

        }, { '../common': 101, '../utils': 111, 'minimalistic-assert': 126 }],
        110: [function(require, module, exports) {
            'use strict';

            var utils = require('../utils');
            var rotr32 = utils.rotr32;

            function ft_1(s, x, y, z) {
                if (s === 0)
                    return ch32(x, y, z);
                if (s === 1 || s === 3)
                    return p32(x, y, z);
                if (s === 2)
                    return maj32(x, y, z);
            }

            exports.ft_1 = ft_1;

            function ch32(x, y, z) {
                return (x & y) ^ ((~x) & z);
            }

            exports.ch32 = ch32;

            function maj32(x, y, z) {
                return (x & y) ^ (x & z) ^ (y & z);
            }

            exports.maj32 = maj32;

            function p32(x, y, z) {
                return x ^ y ^ z;
            }

            exports.p32 = p32;

            function s0_256(x) {
                return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
            }

            exports.s0_256 = s0_256;

            function s1_256(x) {
                return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
            }

            exports.s1_256 = s1_256;

            function g0_256(x) {
                return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
            }

            exports.g0_256 = g0_256;

            function g1_256(x) {
                return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
            }

            exports.g1_256 = g1_256;

        }, { '../utils': 111 }],
        111: [function(require, module, exports) {
            'use strict';

            var assert = require('minimalistic-assert');
            var inherits = require('inherits');

            exports.inherits = inherits;

            function toArray(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if (typeof msg === 'string') {
                    if (!enc) {
                        for (var i = 0; i < msg.length; i++) {
                            var c = msg.charCodeAt(i);
                            var hi = c >> 8;
                            var lo = c & 0xff;
                            if (hi)
                                res.push(hi, lo);
                            else
                                res.push(lo);
                        }
                    } else if (enc === 'hex') {
                        msg = msg.replace(/[^a-z0-9]+/ig, '');
                        if (msg.length % 2 !== 0)
                            msg = '0' + msg;
                        for (i = 0; i < msg.length; i += 2)
                            res.push(parseInt(msg[i] + msg[i + 1], 16));
                    }
                } else {
                    for (i = 0; i < msg.length; i++)
                        res[i] = msg[i] | 0;
                }
                return res;
            }

            exports.toArray = toArray;

            function toHex(msg) {
                var res = '';
                for (var i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res;
            }

            exports.toHex = toHex;

            function htonl(w) {
                var res = (w >>> 24) |
                    ((w >>> 8) & 0xff00) |
                    ((w << 8) & 0xff0000) |
                    ((w & 0xff) << 24);
                return res >>> 0;
            }

            exports.htonl = htonl;

            function toHex32(msg, endian) {
                var res = '';
                for (var i = 0; i < msg.length; i++) {
                    var w = msg[i];
                    if (endian === 'little')
                        w = htonl(w);
                    res += zero8(w.toString(16));
                }
                return res;
            }

            exports.toHex32 = toHex32;

            function zero2(word) {
                if (word.length === 1)
                    return '0' + word;
                else
                    return word;
            }

            exports.zero2 = zero2;

            function zero8(word) {
                if (word.length === 7)
                    return '0' + word;
                else if (word.length === 6)
                    return '00' + word;
                else if (word.length === 5)
                    return '000' + word;
                else if (word.length === 4)
                    return '0000' + word;
                else if (word.length === 3)
                    return '00000' + word;
                else if (word.length === 2)
                    return '000000' + word;
                else if (word.length === 1)
                    return '0000000' + word;
                else
                    return word;
            }

            exports.zero8 = zero8;

            function join32(msg, start, end, endian) {
                var len = end - start;
                assert(len % 4 === 0);
                var res = new Array(len / 4);
                for (var i = 0, k = start; i < res.length; i++, k += 4) {
                    var w;
                    if (endian === 'big')
                        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
                    else
                        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
                    res[i] = w >>> 0;
                }
                return res;
            }

            exports.join32 = join32;

            function split32(msg, endian) {
                var res = new Array(msg.length * 4);
                for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
                    var m = msg[i];
                    if (endian === 'big') {
                        res[k] = m >>> 24;
                        res[k + 1] = (m >>> 16) & 0xff;
                        res[k + 2] = (m >>> 8) & 0xff;
                        res[k + 3] = m & 0xff;
                    } else {
                        res[k + 3] = m >>> 24;
                        res[k + 2] = (m >>> 16) & 0xff;
                        res[k + 1] = (m >>> 8) & 0xff;
                        res[k] = m & 0xff;
                    }
                }
                return res;
            }

            exports.split32 = split32;

            function rotr32(w, b) {
                return (w >>> b) | (w << (32 - b));
            }

            exports.rotr32 = rotr32;

            function rotl32(w, b) {
                return (w << b) | (w >>> (32 - b));
            }

            exports.rotl32 = rotl32;

            function sum32(a, b) {
                return (a + b) >>> 0;
            }

            exports.sum32 = sum32;

            function sum32_3(a, b, c) {
                return (a + b + c) >>> 0;
            }

            exports.sum32_3 = sum32_3;

            function sum32_4(a, b, c, d) {
                return (a + b + c + d) >>> 0;
            }

            exports.sum32_4 = sum32_4;

            function sum32_5(a, b, c, d, e) {
                return (a + b + c + d + e) >>> 0;
            }

            exports.sum32_5 = sum32_5;

            function sum64(buf, pos, ah, al) {
                var bh = buf[pos];
                var bl = buf[pos + 1];

                var lo = (al + bl) >>> 0;
                var hi = (lo < al ? 1 : 0) + ah + bh;
                buf[pos] = hi >>> 0;
                buf[pos + 1] = lo;
            }

            exports.sum64 = sum64;

            function sum64_hi(ah, al, bh, bl) {
                var lo = (al + bl) >>> 0;
                var hi = (lo < al ? 1 : 0) + ah + bh;
                return hi >>> 0;
            }

            exports.sum64_hi = sum64_hi;

            function sum64_lo(ah, al, bh, bl) {
                var lo = al + bl;
                return lo >>> 0;
            }

            exports.sum64_lo = sum64_lo;

            function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
                var carry = 0;
                var lo = al;
                lo = (lo + bl) >>> 0;
                carry += lo < al ? 1 : 0;
                lo = (lo + cl) >>> 0;
                carry += lo < cl ? 1 : 0;
                lo = (lo + dl) >>> 0;
                carry += lo < dl ? 1 : 0;

                var hi = ah + bh + ch + dh + carry;
                return hi >>> 0;
            }

            exports.sum64_4_hi = sum64_4_hi;

            function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
                var lo = al + bl + cl + dl;
                return lo >>> 0;
            }

            exports.sum64_4_lo = sum64_4_lo;

            function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var carry = 0;
                var lo = al;
                lo = (lo + bl) >>> 0;
                carry += lo < al ? 1 : 0;
                lo = (lo + cl) >>> 0;
                carry += lo < cl ? 1 : 0;
                lo = (lo + dl) >>> 0;
                carry += lo < dl ? 1 : 0;
                lo = (lo + el) >>> 0;
                carry += lo < el ? 1 : 0;

                var hi = ah + bh + ch + dh + eh + carry;
                return hi >>> 0;
            }

            exports.sum64_5_hi = sum64_5_hi;

            function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var lo = al + bl + cl + dl + el;

                return lo >>> 0;
            }

            exports.sum64_5_lo = sum64_5_lo;

            function rotr64_hi(ah, al, num) {
                var r = (al << (32 - num)) | (ah >>> num);
                return r >>> 0;
            }

            exports.rotr64_hi = rotr64_hi;

            function rotr64_lo(ah, al, num) {
                var r = (ah << (32 - num)) | (al >>> num);
                return r >>> 0;
            }

            exports.rotr64_lo = rotr64_lo;

            function shr64_hi(ah, al, num) {
                return ah >>> num;
            }

            exports.shr64_hi = shr64_hi;

            function shr64_lo(ah, al, num) {
                var r = (ah << (32 - num)) | (al >>> num);
                return r >>> 0;
            }

            exports.shr64_lo = shr64_lo;

        }, { 'inherits': 116, 'minimalistic-assert': 126 }],
        112: [function(require, module, exports) {
            'use strict';

            var hash = require('hash.js');
            var utils = require('minimalistic-crypto-utils');
            var assert = require('minimalistic-assert');

            function HmacDRBG(options) {
                if (!(this instanceof HmacDRBG))
                    return new HmacDRBG(options);
                this.hash = options.hash;
                this.predResist = !!options.predResist;

                this.outLen = this.hash.outSize;
                this.minEntropy = options.minEntropy || this.hash.hmacStrength;

                this._reseed = null;
                this.reseedInterval = null;
                this.K = null;
                this.V = null;

                var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
                var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
                var pers = utils.toArray(options.pers, options.persEnc || 'hex');
                assert(entropy.length >= (this.minEntropy / 8),
                    'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
                this._init(entropy, nonce, pers);
            }

            module.exports = HmacDRBG;

            HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
                var seed = entropy.concat(nonce).concat(pers);

                this.K = new Array(this.outLen / 8);
                this.V = new Array(this.outLen / 8);
                for (var i = 0; i < this.V.length; i++) {
                    this.K[i] = 0x00;
                    this.V[i] = 0x01;
                }

                this._update(seed);
                this._reseed = 1;
                this.reseedInterval = 0x1000000000000;  // 2^48
            };

            HmacDRBG.prototype._hmac = function hmac() {
                return new hash.hmac(this.hash, this.K);
            };

            HmacDRBG.prototype._update = function update(seed) {
                var kmac = this._hmac()
                    .update(this.V)
                    .update([0x00]);
                if (seed)
                    kmac = kmac.update(seed);
                this.K = kmac.digest();
                this.V = this._hmac().update(this.V).digest();
                if (!seed)
                    return;

                this.K = this._hmac()
                    .update(this.V)
                    .update([0x01])
                    .update(seed)
                    .digest();
                this.V = this._hmac().update(this.V).digest();
            };

            HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
                // Optional entropy enc
                if (typeof entropyEnc !== 'string') {
                    addEnc = add;
                    add = entropyEnc;
                    entropyEnc = null;
                }

                entropy = utils.toArray(entropy, entropyEnc);
                add = utils.toArray(add, addEnc);

                assert(entropy.length >= (this.minEntropy / 8),
                    'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

                this._update(entropy.concat(add || []));
                this._reseed = 1;
            };

            HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
                if (this._reseed > this.reseedInterval)
                    throw new Error('Reseed is required');

                // Optional encoding
                if (typeof enc !== 'string') {
                    addEnc = add;
                    add = enc;
                    enc = null;
                }

                // Optional additional data
                if (add) {
                    add = utils.toArray(add, addEnc || 'hex');
                    this._update(add);
                }

                var temp = [];
                while (temp.length < len) {
                    this.V = this._hmac().update(this.V).digest();
                    temp = temp.concat(this.V);
                }

                var res = temp.slice(0, len);
                this._update(add);
                this._reseed++;
                return utils.encode(res, enc);
            };

        }, { 'hash.js': 100, 'minimalistic-assert': 126, 'minimalistic-crypto-utils': 127 }],
        113: [function(require, module, exports) {
            var http = require('http');

            var https = module.exports;

            for (var key in http) {
                if (http.hasOwnProperty(key)) https[key] = http[key];
            }


            https.request = function(params, cb) {
                if (!params) params = {};
                params.scheme = 'https';
                params.protocol = 'https:';
                return http.request.call(this, params, cb);
            };

        }, { 'http': 180 }],
        114: [function(require, module, exports) {
            exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = (nBytes * 8) - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? (nBytes - 1) : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];

                i += d;

                e = s & ((1 << (-nBits)) - 1);
                s >>= (-nBits);
                nBits += eLen;
                for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {
                }

                m = e & ((1 << (-nBits)) - 1);
                e >>= (-nBits);
                nBits += mLen;
                for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {
                }

                if (e === 0) {
                    e = 1 - eBias;
                } else if (e === eMax) {
                    return m ? NaN : ((s ? -1 : 1) * Infinity);
                } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };

            exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = (nBytes * 8) - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
                var i = isLE ? 0 : (nBytes - 1);
                var d = isLE ? 1 : -1;
                var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

                value = Math.abs(value);

                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }
                    if (e + eBias >= 1) {
                        value += rt / c;
                    } else {
                        value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }

                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    } else if (e + eBias >= 1) {
                        m = ((value * c) - 1) * Math.pow(2, mLen);
                        e = e + eBias;
                    } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                        e = 0;
                    }
                }

                for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {
                }

                e = (e << mLen) | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {
                }

                buffer[offset + i - d] |= s * 128;
            };

        }, {}],
        115: [function(require, module, exports) {

            var indexOf = [].indexOf;

            module.exports = function(arr, obj) {
                if (indexOf) return arr.indexOf(obj);
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i] === obj) return i;
                }
                return -1;
            };
        }, {}],
        116: [function(require, module, exports) {
            if (typeof Object.create === 'function') {
                // implementation from standard node.js 'util' module
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                };
            } else {
                // old school shim for old browsers
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {
                    };
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor();
                    ctor.prototype.constructor = ctor;
                };
            }

        }, {}],
        117: [function(require, module, exports) {
            /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
            module.exports = function(obj) {
                return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
            };

            function isBuffer(obj) {
                return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
            }

// For Node v0.10 support. Remove this eventually.
            function isSlowBuffer(obj) {
                return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
            }

        }, {}],
        118: [function(require, module, exports) {
            var toString = {}.toString;

            module.exports = Array.isArray || function(arr) {
                return toString.call(arr) == '[object Array]';
            };

        }, {}],
        119: [function(require, module, exports) {
            (function(Buffer, setImmediate) {
                var util = require('util'),
                    TransformStream = require('stream').Transform;

                module.exports = function(options) {
                    return new JSONStream(options);
                };

                var JSONStream = module.exports.JSONStream = function(options) {
                    options = options || {};
                    TransformStream.call(this, options);
                    this._writableState.objectMode = false;
                    this._readableState.objectMode = true;
                    this._async = options.async || false;
                };
                util.inherits(JSONStream, TransformStream);

                JSONStream.prototype._transform = function(data, encoding, callback) {
                    if (!Buffer.isBuffer(data)) data = new Buffer(data);
                    if (this._buffer) {
                        data = Buffer.concat([this._buffer, data]);
                    }

                    var ptr = 0, start = 0;
                    while (++ptr <= data.length) {
                        if (data[ptr] === 10 || ptr === data.length) {
                            var line;
                            try {
                                line = JSON.parse(data.slice(start, ptr));
                            } catch (ex) {
                            }
                            if (line) {
                                this.push(line);
                                line = null;
                            }
                            if (data[ptr] === 10) start = ++ptr;
                        }
                    }

                    this._buffer = data.slice(start);
                    return this._async
                        ? void setImmediate(callback)
                        : void callback();
                };

            }).call(this, require('buffer').Buffer, require('timers').setImmediate);
        }, { 'buffer': 59, 'stream': 179, 'timers': 192, 'util': 198 }],
        120: [function(require, module, exports) {
            (function(global) {
                /**
                 * @license
                 * Lodash <https://lodash.com/>
                 * Copyright JS Foundation and other contributors <https://js.foundation/>
                 * Released under MIT license <https://lodash.com/license>
                 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                 */
                ;(function() {

                    /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                    var undefined;

                    /** Used as the semantic version number. */
                    var VERSION = '4.17.11';

                    /** Used as the size to enable large array optimizations. */
                    var LARGE_ARRAY_SIZE = 200;

                    /** Error message constants. */
                    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
                        FUNC_ERROR_TEXT = 'Expected a function';

                    /** Used to stand-in for `undefined` hash values. */
                    var HASH_UNDEFINED = '__lodash_hash_undefined__';

                    /** Used as the maximum memoize cache size. */
                    var MAX_MEMOIZE_SIZE = 500;

                    /** Used as the internal argument placeholder. */
                    var PLACEHOLDER = '__lodash_placeholder__';

                    /** Used to compose bitmasks for cloning. */
                    var CLONE_DEEP_FLAG = 1,
                        CLONE_FLAT_FLAG = 2,
                        CLONE_SYMBOLS_FLAG = 4;

                    /** Used to compose bitmasks for value comparisons. */
                    var COMPARE_PARTIAL_FLAG = 1,
                        COMPARE_UNORDERED_FLAG = 2;

                    /** Used to compose bitmasks for function metadata. */
                    var WRAP_BIND_FLAG = 1,
                        WRAP_BIND_KEY_FLAG = 2,
                        WRAP_CURRY_BOUND_FLAG = 4,
                        WRAP_CURRY_FLAG = 8,
                        WRAP_CURRY_RIGHT_FLAG = 16,
                        WRAP_PARTIAL_FLAG = 32,
                        WRAP_PARTIAL_RIGHT_FLAG = 64,
                        WRAP_ARY_FLAG = 128,
                        WRAP_REARG_FLAG = 256,
                        WRAP_FLIP_FLAG = 512;

                    /** Used as default options for `_.truncate`. */
                    var DEFAULT_TRUNC_LENGTH = 30,
                        DEFAULT_TRUNC_OMISSION = '...';

                    /** Used to detect hot functions by number of calls within a span of milliseconds. */
                    var HOT_COUNT = 800,
                        HOT_SPAN = 16;

                    /** Used to indicate the type of lazy iteratees. */
                    var LAZY_FILTER_FLAG = 1,
                        LAZY_MAP_FLAG = 2,
                        LAZY_WHILE_FLAG = 3;

                    /** Used as references for various `Number` constants. */
                    var INFINITY = 1 / 0,
                        MAX_SAFE_INTEGER = 9007199254740991,
                        MAX_INTEGER = 1.7976931348623157e+308,
                        NAN = 0 / 0;

                    /** Used as references for the maximum length and index of an array. */
                    var MAX_ARRAY_LENGTH = 4294967295,
                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                    /** Used to associate wrap methods with their bit flags. */
                    var wrapFlags = [
                        ['ary', WRAP_ARY_FLAG],
                        ['bind', WRAP_BIND_FLAG],
                        ['bindKey', WRAP_BIND_KEY_FLAG],
                        ['curry', WRAP_CURRY_FLAG],
                        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
                        ['flip', WRAP_FLIP_FLAG],
                        ['partial', WRAP_PARTIAL_FLAG],
                        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
                        ['rearg', WRAP_REARG_FLAG]
                    ];

                    /** `Object#toString` result references. */
                    var argsTag = '[object Arguments]',
                        arrayTag = '[object Array]',
                        asyncTag = '[object AsyncFunction]',
                        boolTag = '[object Boolean]',
                        dateTag = '[object Date]',
                        domExcTag = '[object DOMException]',
                        errorTag = '[object Error]',
                        funcTag = '[object Function]',
                        genTag = '[object GeneratorFunction]',
                        mapTag = '[object Map]',
                        numberTag = '[object Number]',
                        nullTag = '[object Null]',
                        objectTag = '[object Object]',
                        promiseTag = '[object Promise]',
                        proxyTag = '[object Proxy]',
                        regexpTag = '[object RegExp]',
                        setTag = '[object Set]',
                        stringTag = '[object String]',
                        symbolTag = '[object Symbol]',
                        undefinedTag = '[object Undefined]',
                        weakMapTag = '[object WeakMap]',
                        weakSetTag = '[object WeakSet]';

                    var arrayBufferTag = '[object ArrayBuffer]',
                        dataViewTag = '[object DataView]',
                        float32Tag = '[object Float32Array]',
                        float64Tag = '[object Float64Array]',
                        int8Tag = '[object Int8Array]',
                        int16Tag = '[object Int16Array]',
                        int32Tag = '[object Int32Array]',
                        uint8Tag = '[object Uint8Array]',
                        uint8ClampedTag = '[object Uint8ClampedArray]',
                        uint16Tag = '[object Uint16Array]',
                        uint32Tag = '[object Uint32Array]';

                    /** Used to match empty string literals in compiled template source. */
                    var reEmptyStringLeading = /\b__p \+= '';/g,
                        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                    /** Used to match HTML entities and HTML characters. */
                    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
                        reUnescapedHtml = /[&<>"']/g,
                        reHasEscapedHtml = RegExp(reEscapedHtml.source),
                        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

                    /** Used to match template delimiters. */
                    var reEscape = /<%-([\s\S]+?)%>/g,
                        reEvaluate = /<%([\s\S]+?)%>/g,
                        reInterpolate = /<%=([\s\S]+?)%>/g;

                    /** Used to match property names within property paths. */
                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                        reIsPlainProp = /^\w*$/,
                        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

                    /**
                     * Used to match `RegExp`
                     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                     */
                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                        reHasRegExpChar = RegExp(reRegExpChar.source);

                    /** Used to match leading and trailing whitespace. */
                    var reTrim = /^\s+|\s+$/g,
                        reTrimStart = /^\s+/,
                        reTrimEnd = /\s+$/;

                    /** Used to match wrap detail comments. */
                    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
                        reSplitDetails = /,? & /;

                    /** Used to match words composed of alphanumeric characters. */
                    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

                    /** Used to match backslashes in property paths. */
                    var reEscapeChar = /\\(\\)?/g;

                    /**
                     * Used to match
                     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
                     */
                    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                    /** Used to match `RegExp` flags from their coerced string values. */
                    var reFlags = /\w*$/;

                    /** Used to detect bad signed hexadecimal string values. */
                    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

                    /** Used to detect binary string values. */
                    var reIsBinary = /^0b[01]+$/i;

                    /** Used to detect host constructors (Safari). */
                    var reIsHostCtor = /^\[object .+?Constructor\]$/;

                    /** Used to detect octal string values. */
                    var reIsOctal = /^0o[0-7]+$/i;

                    /** Used to detect unsigned integer values. */
                    var reIsUint = /^(?:0|[1-9]\d*)$/;

                    /** Used to match Latin Unicode letters (excluding mathematical operators). */
                    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

                    /** Used to ensure capturing order of template delimiters. */
                    var reNoMatch = /($^)/;

                    /** Used to match unescaped characters in compiled string literals. */
                    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

                    /** Used to compose unicode character classes. */
                    var rsAstralRange = '\\ud800-\\udfff',
                        rsComboMarksRange = '\\u0300-\\u036f',
                        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
                        rsComboSymbolsRange = '\\u20d0-\\u20ff',
                        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                        rsDingbatRange = '\\u2700-\\u27bf',
                        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
                        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
                        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
                        rsPunctuationRange = '\\u2000-\\u206f',
                        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
                        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
                        rsVarRange = '\\ufe0e\\ufe0f',
                        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

                    /** Used to compose unicode capture groups. */
                    var rsApos = '[\'\u2019]',
                        rsAstral = '[' + rsAstralRange + ']',
                        rsBreak = '[' + rsBreakRange + ']',
                        rsCombo = '[' + rsComboRange + ']',
                        rsDigits = '\\d+',
                        rsDingbat = '[' + rsDingbatRange + ']',
                        rsLower = '[' + rsLowerRange + ']',
                        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
                        rsFitz = '\\ud83c[\\udffb-\\udfff]',
                        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
                        rsNonAstral = '[^' + rsAstralRange + ']',
                        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
                        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
                        rsUpper = '[' + rsUpperRange + ']',
                        rsZWJ = '\\u200d';

                    /** Used to compose unicode regexes. */
                    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
                        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
                        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
                        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
                        reOptMod = rsModifier + '?',
                        rsOptVar = '[' + rsVarRange + ']?',
                        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
                        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
                        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
                        rsSeq = rsOptVar + reOptMod + rsOptJoin,
                        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
                        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

                    /** Used to match apostrophes. */
                    var reApos = RegExp(rsApos, 'g');

                    /**
                     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
                     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
                     */
                    var reComboMark = RegExp(rsCombo, 'g');

                    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
                    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

                    /** Used to match complex or compound words. */
                    var reUnicodeWord = RegExp([
                        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
                        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
                        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
                        rsUpper + '+' + rsOptContrUpper,
                        rsOrdUpper,
                        rsOrdLower,
                        rsDigits,
                        rsEmoji
                    ].join('|'), 'g');

                    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
                    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

                    /** Used to detect strings that need a more robust regexp to match words. */
                    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

                    /** Used to assign default `context` object properties. */
                    var contextProps = [
                        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
                        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
                        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
                        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
                        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
                    ];

                    /** Used to make template sourceURLs easier to identify. */
                    var templateCounter = -1;

                    /** Used to identify `toStringTag` values of typed arrays. */
                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                                    typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                                typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                                            typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                                typedArrayTags[weakMapTag] = false;

                    /** Used to identify `toStringTag` values supported by `_.clone`. */
                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[arrayTag] =
                        cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                            cloneableTags[boolTag] = cloneableTags[dateTag] =
                                cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                                    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                                        cloneableTags[int32Tag] = cloneableTags[mapTag] =
                                            cloneableTags[numberTag] = cloneableTags[objectTag] =
                                                cloneableTags[regexpTag] = cloneableTags[setTag] =
                                                    cloneableTags[stringTag] = cloneableTags[symbolTag] =
                                                        cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                    cloneableTags[errorTag] = cloneableTags[funcTag] =
                        cloneableTags[weakMapTag] = false;

                    /** Used to map Latin Unicode letters to basic Latin letters. */
                    var deburredLetters = {
                        // Latin-1 Supplement block.
                        '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                        '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                        '\xc7': 'C', '\xe7': 'c',
                        '\xd0': 'D', '\xf0': 'd',
                        '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                        '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                        '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                        '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
                        '\xd1': 'N', '\xf1': 'n',
                        '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                        '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                        '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                        '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                        '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
                        '\xc6': 'Ae', '\xe6': 'ae',
                        '\xde': 'Th', '\xfe': 'th',
                        '\xdf': 'ss',
                        // Latin Extended-A block.
                        '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
                        '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
                        '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
                        '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
                        '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
                        '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
                        '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
                        '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
                        '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
                        '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
                        '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
                        '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
                        '\u0134': 'J', '\u0135': 'j',
                        '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
                        '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
                        '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
                        '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
                        '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
                        '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
                        '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
                        '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
                        '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
                        '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
                        '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
                        '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
                        '\u0163': 't', '\u0165': 't', '\u0167': 't',
                        '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
                        '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
                        '\u0174': 'W', '\u0175': 'w',
                        '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
                        '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
                        '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
                        '\u0132': 'IJ', '\u0133': 'ij',
                        '\u0152': 'Oe', '\u0153': 'oe',
                        '\u0149': '\'n', '\u017f': 's'
                    };

                    /** Used to map characters to HTML entities. */
                    var htmlEscapes = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        '\'': '&#39;'
                    };

                    /** Used to map HTML entities to characters. */
                    var htmlUnescapes = {
                        '&amp;': '&',
                        '&lt;': '<',
                        '&gt;': '>',
                        '&quot;': '"',
                        '&#39;': '\''
                    };

                    /** Used to escape characters for inclusion in compiled string literals. */
                    var stringEscapes = {
                        '\\': '\\',
                        '\'': '\'',
                        '\n': 'n',
                        '\r': 'r',
                        '\u2028': 'u2028',
                        '\u2029': 'u2029'
                    };

                    /** Built-in method references without a dependency on `root`. */
                    var freeParseFloat = parseFloat,
                        freeParseInt = parseInt;

                    /** Detect free variable `global` from Node.js. */
                    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

                    /** Detect free variable `self`. */
                    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

                    /** Used as a reference to the global object. */
                    var root = freeGlobal || freeSelf || Function('return this')();

                    /** Detect free variable `exports`. */
                    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

                    /** Detect free variable `module`. */
                    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

                    /** Detect the popular CommonJS extension `module.exports`. */
                    var moduleExports = freeModule && freeModule.exports === freeExports;

                    /** Detect free variable `process` from Node.js. */
                    var freeProcess = moduleExports && freeGlobal.process;

                    /** Used to access faster Node.js helpers. */
                    var nodeUtil = (function() {
                        try {
                            // Use `util.types` for Node.js 10+.
                            var types = freeModule && freeModule.require && freeModule.require('util').types;

                            if (types) {
                                return types;
                            }

                            // Legacy `process.binding('util')` for Node.js < 10.
                            return freeProcess && freeProcess.binding && freeProcess.binding('util');
                        } catch (e) {
                        }
                    }());

                    /* Node.js helper references. */
                    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
                        nodeIsDate = nodeUtil && nodeUtil.isDate,
                        nodeIsMap = nodeUtil && nodeUtil.isMap,
                        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
                        nodeIsSet = nodeUtil && nodeUtil.isSet,
                        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * A faster alternative to `Function#apply`, this function invokes `func`
                     * with the `this` binding of `thisArg` and the arguments of `args`.
                     *
                     * @private
                     * @param {Function} func The function to invoke.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} args The arguments to invoke `func` with.
                     * @returns {*} Returns the result of `func`.
                     */
                    function apply(func, thisArg, args) {
                        switch (args.length) {
                            case 0:
                                return func.call(thisArg);
                            case 1:
                                return func.call(thisArg, args[0]);
                            case 2:
                                return func.call(thisArg, args[0], args[1]);
                            case 3:
                                return func.call(thisArg, args[0], args[1], args[2]);
                        }
                        return func.apply(thisArg, args);
                    }

                    /**
                     * A specialized version of `baseAggregator` for arrays.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} setter The function to set `accumulator` values.
                     * @param {Function} iteratee The iteratee to transform keys.
                     * @param {Object} accumulator The initial aggregated object.
                     * @returns {Function} Returns `accumulator`.
                     */
                    function arrayAggregator(array, setter, iteratee, accumulator) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            var value = array[index];
                            setter(accumulator, value, iteratee(value), array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.forEach` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEachRight` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEachRight(array, iteratee) {
                        var length = array == null ? 0 : array.length;

                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.every` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     */
                    function arrayEvery(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `_.filter` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            resIndex = 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[resIndex++] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.includes` for arrays without support for
                     * specifying an index to search from.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */
                    function arrayIncludes(array, value) {
                        var length = array == null ? 0 : array.length;
                        return !!length && baseIndexOf(array, value, 0) > -1;
                    }

                    /**
                     * This function is like `arrayIncludes` except that it accepts a comparator.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @param {Function} comparator The comparator invoked per element.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */
                    function arrayIncludesWith(array, value, comparator) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (comparator(value, array[index])) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `_.map` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }

                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.reduce` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initAccum] Specify using the first element of `array` as
                     *  the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduce(array, iteratee, accumulator, initAccum) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        if (initAccum && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.reduceRight` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initAccum] Specify using the last element of `array` as
                     *  the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                        var length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.some` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function arraySome(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * Gets the size of an ASCII `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */
                    var asciiSize = baseProperty('length');

                    /**
                     * Converts an ASCII `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function asciiToArray(string) {
                        return string.split('');
                    }

                    /**
                     * Splits an ASCII `string` into an array of its words.
                     *
                     * @private
                     * @param {string} The string to inspect.
                     * @returns {Array} Returns the words of `string`.
                     */
                    function asciiWords(string) {
                        return string.match(reAsciiWord) || [];
                    }

                    /**
                     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
                     * without support for iteratee shorthands, which iterates over `collection`
                     * using `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to inspect.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the found element or its key, else `undefined`.
                     */
                    function baseFindKey(collection, predicate, eachFunc) {
                        var result;
                        eachFunc(collection, function(value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.findIndex` and `_.findLastIndex` without
                     * support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {number} fromIndex The index to search from.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseFindIndex(array, predicate, fromIndex, fromRight) {
                        var length = array.length,
                            index = fromIndex + (fromRight ? 1 : -1);

                        while ((fromRight ? index-- : ++index < length)) {
                            if (predicate(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseIndexOf(array, value, fromIndex) {
                        return value === value
                            ? strictIndexOf(array, value, fromIndex)
                            : baseFindIndex(array, baseIsNaN, fromIndex);
                    }

                    /**
                     * This function is like `baseIndexOf` except that it accepts a comparator.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @param {Function} comparator The comparator invoked per element.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseIndexOfWith(array, value, fromIndex, comparator) {
                        var index = fromIndex - 1,
                            length = array.length;

                        while (++index < length) {
                            if (comparator(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * The base implementation of `_.isNaN` without support for number objects.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     */
                    function baseIsNaN(value) {
                        return value !== value;
                    }

                    /**
                     * The base implementation of `_.mean` and `_.meanBy` without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the mean.
                     */
                    function baseMean(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        return length ? (baseSum(array, iteratee) / length) : NAN;
                    }

                    /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new accessor function.
                     */
                    function baseProperty(key) {
                        return function(object) {
                            return object == null ? undefined : object[key];
                        };
                    }

                    /**
                     * The base implementation of `_.propertyOf` without support for deep paths.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Function} Returns the new accessor function.
                     */
                    function basePropertyOf(object) {
                        return function(key) {
                            return object == null ? undefined : object[key];
                        };
                    }

                    /**
                     * The base implementation of `_.reduce` and `_.reduceRight`, without support
                     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initAccum Specify using the first or last element of
                     *  `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */
                    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                        eachFunc(collection, function(value, index, collection) {
                            accumulator = initAccum
                                ? (initAccum = false, value)
                                : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define the
                     * sort order of `array` and replaces criteria objects with their corresponding
                     * values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */
                    function baseSortBy(array, comparer) {
                        var length = array.length;

                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.sum` and `_.sumBy` without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function baseSum(array, iteratee) {
                        var result,
                            index = -1,
                            length = array.length;

                        while (++index < length) {
                            var current = iteratee(array[index]);
                            if (current !== undefined) {
                                result = result === undefined ? current : (result + current);
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.times` without support for iteratee shorthands
                     * or max array length checks.
                     *
                     * @private
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the array of results.
                     */
                    function baseTimes(n, iteratee) {
                        var index = -1,
                            result = Array(n);

                        while (++index < n) {
                            result[index] = iteratee(index);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
                     * of key-value pairs for `object` corresponding to the property names of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the key-value pairs.
                     */
                    function baseToPairs(object, props) {
                        return arrayMap(props, function(key) {
                            return [key, object[key]];
                        });
                    }

                    /**
                     * The base implementation of `_.unary` without support for storing metadata.
                     *
                     * @private
                     * @param {Function} func The function to cap arguments for.
                     * @returns {Function} Returns the new capped function.
                     */
                    function baseUnary(func) {
                        return function(value) {
                            return func(value);
                        };
                    }

                    /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */
                    function baseValues(object, props) {
                        return arrayMap(props, function(key) {
                            return object[key];
                        });
                    }

                    /**
                     * Checks if a `cache` value for `key` exists.
                     *
                     * @private
                     * @param {Object} cache The cache to query.
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function cacheHas(cache, key) {
                        return cache.has(key);
                    }

                    /**
                     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
                     * that is not found in the character symbols.
                     *
                     * @private
                     * @param {Array} strSymbols The string symbols to inspect.
                     * @param {Array} chrSymbols The character symbols to find.
                     * @returns {number} Returns the index of the first unmatched string symbol.
                     */
                    function charsStartIndex(strSymbols, chrSymbols) {
                        var index = -1,
                            length = strSymbols.length;

                        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                        }
                        return index;
                    }

                    /**
                     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
                     * that is not found in the character symbols.
                     *
                     * @private
                     * @param {Array} strSymbols The string symbols to inspect.
                     * @param {Array} chrSymbols The character symbols to find.
                     * @returns {number} Returns the index of the last unmatched string symbol.
                     */
                    function charsEndIndex(strSymbols, chrSymbols) {
                        var index = strSymbols.length;

                        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                        }
                        return index;
                    }

                    /**
                     * Gets the number of `placeholder` occurrences in `array`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} placeholder The placeholder to search for.
                     * @returns {number} Returns the placeholder count.
                     */
                    function countHolders(array, placeholder) {
                        var length = array.length,
                            result = 0;

                        while (length--) {
                            if (array[length] === placeholder) {
                                ++result;
                            }
                        }
                        return result;
                    }

                    /**
                     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
                     * letters to basic Latin letters.
                     *
                     * @private
                     * @param {string} letter The matched letter to deburr.
                     * @returns {string} Returns the deburred letter.
                     */
                    var deburrLetter = basePropertyOf(deburredLetters);

                    /**
                     * Used by `_.escape` to convert characters to HTML entities.
                     *
                     * @private
                     * @param {string} chr The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    var escapeHtmlChar = basePropertyOf(htmlEscapes);

                    /**
                     * Used by `_.template` to escape characters for inclusion in compiled string literals.
                     *
                     * @private
                     * @param {string} chr The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    function escapeStringChar(chr) {
                        return '\\' + stringEscapes[chr];
                    }

                    /**
                     * Gets the value at `key` of `object`.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {string} key The key of the property to get.
                     * @returns {*} Returns the property value.
                     */
                    function getValue(object, key) {
                        return object == null ? undefined : object[key];
                    }

                    /**
                     * Checks if `string` contains Unicode symbols.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
                     */
                    function hasUnicode(string) {
                        return reHasUnicode.test(string);
                    }

                    /**
                     * Checks if `string` contains a word composed of Unicode symbols.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {boolean} Returns `true` if a word is found, else `false`.
                     */
                    function hasUnicodeWord(string) {
                        return reHasUnicodeWord.test(string);
                    }

                    /**
                     * Converts `iterator` to an array.
                     *
                     * @private
                     * @param {Object} iterator The iterator to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function iteratorToArray(iterator) {
                        var data,
                            result = [];

                        while (!(data = iterator.next()).done) {
                            result.push(data.value);
                        }
                        return result;
                    }

                    /**
                     * Converts `map` to its key-value pairs.
                     *
                     * @private
                     * @param {Object} map The map to convert.
                     * @returns {Array} Returns the key-value pairs.
                     */
                    function mapToArray(map) {
                        var index = -1,
                            result = Array(map.size);

                        map.forEach(function(value, key) {
                            result[++index] = [key, value];
                        });
                        return result;
                    }

                    /**
                     * Creates a unary function that invokes `func` with its argument transformed.
                     *
                     * @private
                     * @param {Function} func The function to wrap.
                     * @param {Function} transform The argument transform.
                     * @returns {Function} Returns the new function.
                     */
                    function overArg(func, transform) {
                        return function(arg) {
                            return func(transform(arg));
                        };
                    }

                    /**
                     * Replaces all `placeholder` elements in `array` with an internal placeholder
                     * and returns an array of their indexes.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {*} placeholder The placeholder to replace.
                     * @returns {Array} Returns the new array of placeholder indexes.
                     */
                    function replaceHolders(array, placeholder) {
                        var index = -1,
                            length = array.length,
                            resIndex = 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value === placeholder || value === PLACEHOLDER) {
                                array[index] = PLACEHOLDER;
                                result[resIndex++] = index;
                            }
                        }
                        return result;
                    }

                    /**
                     * Converts `set` to an array of its values.
                     *
                     * @private
                     * @param {Object} set The set to convert.
                     * @returns {Array} Returns the values.
                     */
                    function setToArray(set) {
                        var index = -1,
                            result = Array(set.size);

                        set.forEach(function(value) {
                            result[++index] = value;
                        });
                        return result;
                    }

                    /**
                     * Converts `set` to its value-value pairs.
                     *
                     * @private
                     * @param {Object} set The set to convert.
                     * @returns {Array} Returns the value-value pairs.
                     */
                    function setToPairs(set) {
                        var index = -1,
                            result = Array(set.size);

                        set.forEach(function(value) {
                            result[++index] = [value, value];
                        });
                        return result;
                    }

                    /**
                     * A specialized version of `_.indexOf` which performs strict equality
                     * comparisons of values, i.e. `===`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function strictIndexOf(array, value, fromIndex) {
                        var index = fromIndex - 1,
                            length = array.length;

                        while (++index < length) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * A specialized version of `_.lastIndexOf` which performs strict equality
                     * comparisons of values, i.e. `===`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function strictLastIndexOf(array, value, fromIndex) {
                        var index = fromIndex + 1;
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return index;
                    }

                    /**
                     * Gets the number of symbols in `string`.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {number} Returns the string size.
                     */
                    function stringSize(string) {
                        return hasUnicode(string)
                            ? unicodeSize(string)
                            : asciiSize(string);
                    }

                    /**
                     * Converts `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function stringToArray(string) {
                        return hasUnicode(string)
                            ? unicodeToArray(string)
                            : asciiToArray(string);
                    }

                    /**
                     * Used by `_.unescape` to convert HTML entities to characters.
                     *
                     * @private
                     * @param {string} chr The matched character to unescape.
                     * @returns {string} Returns the unescaped character.
                     */
                    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

                    /**
                     * Gets the size of a Unicode `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */
                    function unicodeSize(string) {
                        var result = reUnicode.lastIndex = 0;
                        while (reUnicode.test(string)) {
                            ++result;
                        }
                        return result;
                    }

                    /**
                     * Converts a Unicode `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function unicodeToArray(string) {
                        return string.match(reUnicode) || [];
                    }

                    /**
                     * Splits a Unicode `string` into an array of its words.
                     *
                     * @private
                     * @param {string} The string to inspect.
                     * @returns {Array} Returns the words of `string`.
                     */
                    function unicodeWords(string) {
                        return string.match(reUnicodeWord) || [];
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Create a new pristine `lodash` function using the `context` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 1.1.0
                     * @category Util
                     * @param {Object} [context=root] The context object.
                     * @returns {Function} Returns a new `lodash` function.
                     * @example
                     *
                     * _.mixin({ 'foo': _.constant('foo') });
                     *
                     * var lodash = _.runInContext();
                     * lodash.mixin({ 'bar': lodash.constant('bar') });
                     *
                     * _.isFunction(_.foo);
                     * // => true
                     * _.isFunction(_.bar);
                     * // => false
                     *
                     * lodash.isFunction(lodash.foo);
                     * // => false
                     * lodash.isFunction(lodash.bar);
                     * // => true
                     *
                     * // Create a suped-up `defer` in Node.js.
                     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                     */
                    var runInContext = (function runInContext(context) {
                        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

                        /** Built-in constructor references. */
                        var Array = context.Array,
                            Date = context.Date,
                            Error = context.Error,
                            Function = context.Function,
                            Math = context.Math,
                            Object = context.Object,
                            RegExp = context.RegExp,
                            String = context.String,
                            TypeError = context.TypeError;

                        /** Used for built-in method references. */
                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;

                        /** Used to detect overreaching core-js shims. */
                        var coreJsData = context['__core-js_shared__'];

                        /** Used to resolve the decompiled source of functions. */
                        var funcToString = funcProto.toString;

                        /** Used to check objects for own properties. */
                        var hasOwnProperty = objectProto.hasOwnProperty;

                        /** Used to generate unique IDs. */
                        var idCounter = 0;

                        /** Used to detect methods masquerading as native. */
                        var maskSrcKey = (function() {
                            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                            return uid ? ('Symbol(src)_1.' + uid) : '';
                        }());

                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */
                        var nativeObjectToString = objectProto.toString;

                        /** Used to infer the `Object` constructor. */
                        var objectCtorString = funcToString.call(Object);

                        /** Used to restore the original `_` reference in `_.noConflict`. */
                        var oldDash = root._;

                        /** Used to detect if a method is native. */
                        var reIsNative = RegExp('^' +
                            funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                        );

                        /** Built-in value references. */
                        var Buffer = moduleExports ? context.Buffer : undefined,
                            Symbol = context.Symbol,
                            Uint8Array = context.Uint8Array,
                            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                            getPrototype = overArg(Object.getPrototypeOf, Object),
                            objectCreate = Object.create,
                            propertyIsEnumerable = objectProto.propertyIsEnumerable,
                            splice = arrayProto.splice,
                            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
                            symIterator = Symbol ? Symbol.iterator : undefined,
                            symToStringTag = Symbol ? Symbol.toStringTag : undefined;

                        var defineProperty = (function() {
                            try {
                                var func = getNative(Object, 'defineProperty');
                                func({}, '', {});
                                return func;
                            } catch (e) {
                            }
                        }());

                        /** Mocked built-ins. */
                        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
                            ctxNow = Date && Date.now !== root.Date.now && Date.now,
                            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

                        /* Built-in method references for those with the same name as other `lodash` methods. */
                        var nativeCeil = Math.ceil,
                            nativeFloor = Math.floor,
                            nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                            nativeIsFinite = context.isFinite,
                            nativeJoin = arrayProto.join,
                            nativeKeys = overArg(Object.keys, Object),
                            nativeMax = Math.max,
                            nativeMin = Math.min,
                            nativeNow = Date.now,
                            nativeParseInt = context.parseInt,
                            nativeRandom = Math.random,
                            nativeReverse = arrayProto.reverse;

                        /* Built-in method references that are verified to be native. */
                        var DataView = getNative(context, 'DataView'),
                            Map = getNative(context, 'Map'),
                            Promise = getNative(context, 'Promise'),
                            Set = getNative(context, 'Set'),
                            WeakMap = getNative(context, 'WeakMap'),
                            nativeCreate = getNative(Object, 'create');

                        /** Used to store function metadata. */
                        var metaMap = WeakMap && new WeakMap;

                        /** Used to lookup unminified function names. */
                        var realNames = {};

                        /** Used to detect maps, sets, and weakmaps. */
                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);

                        /** Used to convert symbols to primitives and strings. */
                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                            symbolToString = symbolProto ? symbolProto.toString : undefined;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a `lodash` object which wraps `value` to enable implicit method
                         * chain sequences. Methods that operate on and return arrays, collections,
                         * and functions can be chained together. Methods that retrieve a single value
                         * or may return a primitive value will automatically end the chain sequence
                         * and return the unwrapped value. Otherwise, the value must be unwrapped
                         * with `_#value`.
                         *
                         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
                         * enabled using `_.chain`.
                         *
                         * The execution of chained methods is lazy, that is, it's deferred until
                         * `_#value` is implicitly or explicitly called.
                         *
                         * Lazy evaluation allows several methods to support shortcut fusion.
                         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
                         * the creation of intermediate arrays and can greatly reduce the number of
                         * iteratee executions. Sections of a chain sequence qualify for shortcut
                         * fusion if the section is applied to an array and iteratees accept only
                         * one argument. The heuristic for whether a section qualifies for shortcut
                         * fusion is subject to change.
                         *
                         * Chaining is supported in custom builds as long as the `_#value` method is
                         * directly or indirectly included in the build.
                         *
                         * In addition to lodash methods, wrappers have `Array` and `String` methods.
                         *
                         * The wrapper `Array` methods are:
                         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
                         *
                         * The wrapper `String` methods are:
                         * `replace` and `split`
                         *
                         * The wrapper methods that support shortcut fusion are:
                         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
                         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
                         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
                         *
                         * The chainable wrapper methods are:
                         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
                         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
                         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
                         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
                         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
                         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
                         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
                         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
                         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
                         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
                         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
                         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
                         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
                         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
                         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
                         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
                         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
                         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
                         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
                         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
                         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
                         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
                         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
                         * `zipObject`, `zipObjectDeep`, and `zipWith`
                         *
                         * The wrapper methods that are **not** chainable by default are:
                         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
                         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
                         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
                         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
                         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
                         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
                         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
                         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
                         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
                         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
                         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
                         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
                         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
                         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
                         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
                         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
                         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
                         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
                         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
                         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
                         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
                         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
                         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
                         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
                         * `upperFirst`, `value`, and `words`
                         *
                         * @name _
                         * @constructor
                         * @category Seq
                         * @param {*} value The value to wrap in a `lodash` instance.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var wrapped = _([1, 2, 3]);
                         *
                         * // Returns an unwrapped value.
                         * wrapped.reduce(_.add);
                         * // => 6
                         *
                         * // Returns a wrapped value.
                         * var squares = wrapped.map(square);
                         *
                         * _.isArray(squares);
                         * // => false
                         *
                         * _.isArray(squares.value());
                         * // => true
                         */
                        function lodash(value) {
                            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                                if (value instanceof LodashWrapper) {
                                    return value;
                                }
                                if (hasOwnProperty.call(value, '__wrapped__')) {
                                    return wrapperClone(value);
                                }
                            }
                            return new LodashWrapper(value);
                        }

                        /**
                         * The base implementation of `_.create` without support for assigning
                         * properties to the created object.
                         *
                         * @private
                         * @param {Object} proto The object to inherit from.
                         * @returns {Object} Returns the new object.
                         */
                        var baseCreate = (function() {
                            function object() {
                            }

                            return function(proto) {
                                if (!isObject(proto)) {
                                    return {};
                                }
                                if (objectCreate) {
                                    return objectCreate(proto);
                                }
                                object.prototype = proto;
                                var result = new object;
                                object.prototype = undefined;
                                return result;
                            };
                        }());

                        /**
                         * The function whose prototype chain sequence wrappers inherit from.
                         *
                         * @private
                         */
                        function baseLodash() {
                            // No operation performed.
                        }

                        /**
                         * The base constructor for creating `lodash` wrapper objects.
                         *
                         * @private
                         * @param {*} value The value to wrap.
                         * @param {boolean} [chainAll] Enable explicit method chain sequences.
                         */
                        function LodashWrapper(value, chainAll) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__chain__ = !!chainAll;
                            this.__index__ = 0;
                            this.__values__ = undefined;
                        }

                        /**
                         * By default, the template delimiters used by lodash are like those in
                         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
                         * following template settings to use alternative delimiters.
                         *
                         * @static
                         * @memberOf _
                         * @type {Object}
                         */
                        lodash.templateSettings = {

                            /**
                             * Used to detect `data` property values to be HTML-escaped.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'escape': reEscape,

                            /**
                             * Used to detect code to be evaluated.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'evaluate': reEvaluate,

                            /**
                             * Used to detect `data` property values to inject.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'interpolate': reInterpolate,

                            /**
                             * Used to reference the data object in the template text.
                             *
                             * @memberOf _.templateSettings
                             * @type {string}
                             */
                            'variable': '',

                            /**
                             * Used to import variables into the compiled template.
                             *
                             * @memberOf _.templateSettings
                             * @type {Object}
                             */
                            'imports': {

                                /**
                                 * A reference to the `lodash` function.
                                 *
                                 * @memberOf _.templateSettings.imports
                                 * @type {Function}
                                 */
                                '_': lodash
                            }
                        };

                        // Ensure wrappers are instances of `baseLodash`.
                        lodash.prototype = baseLodash.prototype;
                        lodash.prototype.constructor = lodash;

                        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                        LodashWrapper.prototype.constructor = LodashWrapper;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                         *
                         * @private
                         * @constructor
                         * @param {*} value The value to wrap.
                         */
                        function LazyWrapper(value) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__dir__ = 1;
                            this.__filtered__ = false;
                            this.__iteratees__ = [];
                            this.__takeCount__ = MAX_ARRAY_LENGTH;
                            this.__views__ = [];
                        }

                        /**
                         * Creates a clone of the lazy wrapper object.
                         *
                         * @private
                         * @name clone
                         * @memberOf LazyWrapper
                         * @returns {Object} Returns the cloned `LazyWrapper` object.
                         */
                        function lazyClone() {
                            var result = new LazyWrapper(this.__wrapped__);
                            result.__actions__ = copyArray(this.__actions__);
                            result.__dir__ = this.__dir__;
                            result.__filtered__ = this.__filtered__;
                            result.__iteratees__ = copyArray(this.__iteratees__);
                            result.__takeCount__ = this.__takeCount__;
                            result.__views__ = copyArray(this.__views__);
                            return result;
                        }

                        /**
                         * Reverses the direction of lazy iteration.
                         *
                         * @private
                         * @name reverse
                         * @memberOf LazyWrapper
                         * @returns {Object} Returns the new reversed `LazyWrapper` object.
                         */
                        function lazyReverse() {
                            if (this.__filtered__) {
                                var result = new LazyWrapper(this);
                                result.__dir__ = -1;
                                result.__filtered__ = true;
                            } else {
                                result = this.clone();
                                result.__dir__ *= -1;
                            }
                            return result;
                        }

                        /**
                         * Extracts the unwrapped value from its lazy wrapper.
                         *
                         * @private
                         * @name value
                         * @memberOf LazyWrapper
                         * @returns {*} Returns the unwrapped value.
                         */
                        function lazyValue() {
                            var array = this.__wrapped__.value(),
                                dir = this.__dir__,
                                isArr = isArray(array),
                                isRight = dir < 0,
                                arrLength = isArr ? array.length : 0,
                                view = getView(0, arrLength, this.__views__),
                                start = view.start,
                                end = view.end,
                                length = end - start,
                                index = isRight ? end : (start - 1),
                                iteratees = this.__iteratees__,
                                iterLength = iteratees.length,
                                resIndex = 0,
                                takeCount = nativeMin(length, this.__takeCount__);

                            if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
                                return baseWrapperValue(array, this.__actions__);
                            }
                            var result = [];

                            outer:
                                while (length-- && resIndex < takeCount) {
                                    index += dir;

                                    var iterIndex = -1,
                                        value = array[index];

                                    while (++iterIndex < iterLength) {
                                        var data = iteratees[iterIndex],
                                            iteratee = data.iteratee,
                                            type = data.type,
                                            computed = iteratee(value);

                                        if (type == LAZY_MAP_FLAG) {
                                            value = computed;
                                        } else if (!computed) {
                                            if (type == LAZY_FILTER_FLAG) {
                                                continue outer;
                                            } else {
                                                break outer;
                                            }
                                        }
                                    }
                                    result[resIndex++] = value;
                                }
                            return result;
                        }

                        // Ensure `LazyWrapper` is an instance of `baseLodash`.
                        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                        LazyWrapper.prototype.constructor = LazyWrapper;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function Hash(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }

                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */
                        function hashClear() {
                            this.__data__ = nativeCreate ? nativeCreate(null) : {};
                            this.size = 0;
                        }

                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function hashDelete(key) {
                            var result = this.has(key) && delete this.__data__[key];
                            this.size -= result ? 1 : 0;
                            return result;
                        }

                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function hashGet(key) {
                            var data = this.__data__;
                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED ? undefined : result;
                            }
                            return hasOwnProperty.call(data, key) ? data[key] : undefined;
                        }

                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
                        }

                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */
                        function hashSet(key, value) {
                            var data = this.__data__;
                            this.size += this.has(key) ? 0 : 1;
                            data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
                            return this;
                        }

                        // Add methods to `Hash`.
                        Hash.prototype.clear = hashClear;
                        Hash.prototype['delete'] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function ListCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }

                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */
                        function listCacheClear() {
                            this.__data__ = [];
                            this.size = 0;
                        }

                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }
                            var lastIndex = data.length - 1;
                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }
                            --this.size;
                            return true;
                        }

                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            return index < 0 ? undefined : data[index][1];
                        }

                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }

                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */
                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                ++this.size;
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }
                            return this;
                        }

                        // Add methods to `ListCache`.
                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype['delete'] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function MapCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;

                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }

                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */
                        function mapCacheClear() {
                            this.size = 0;
                            this.__data__ = {
                                'hash': new Hash,
                                'map': new (Map || ListCache),
                                'string': new Hash
                            };
                        }

                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function mapCacheDelete(key) {
                            var result = getMapData(this, key)['delete'](key);
                            this.size -= result ? 1 : 0;
                            return result;
                        }

                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }

                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }

                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */
                        function mapCacheSet(key, value) {
                            var data = getMapData(this, key),
                                size = data.size;

                            data.set(key, value);
                            this.size += data.size == size ? 0 : 1;
                            return this;
                        }

                        // Add methods to `MapCache`.
                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype['delete'] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;

                        /*------------------------------------------------------------------------*/

                        /**
                         *
                         * Creates an array cache object to store unique values.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [values] The values to cache.
                         */
                        function SetCache(values) {
                            var index = -1,
                                length = values == null ? 0 : values.length;

                            this.__data__ = new MapCache;
                            while (++index < length) {
                                this.add(values[index]);
                            }
                        }

                        /**
                         * Adds `value` to the array cache.
                         *
                         * @private
                         * @name add
                         * @memberOf SetCache
                         * @alias push
                         * @param {*} value The value to cache.
                         * @returns {Object} Returns the cache instance.
                         */
                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);
                            return this;
                        }

                        /**
                         * Checks if `value` is in the array cache.
                         *
                         * @private
                         * @name has
                         * @memberOf SetCache
                         * @param {*} value The value to search for.
                         * @returns {number} Returns `true` if `value` is found, else `false`.
                         */
                        function setCacheHas(value) {
                            return this.__data__.has(value);
                        }

                        // Add methods to `SetCache`.
                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a stack cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function Stack(entries) {
                            var data = this.__data__ = new ListCache(entries);
                            this.size = data.size;
                        }

                        /**
                         * Removes all key-value entries from the stack.
                         *
                         * @private
                         * @name clear
                         * @memberOf Stack
                         */
                        function stackClear() {
                            this.__data__ = new ListCache;
                            this.size = 0;
                        }

                        /**
                         * Removes `key` and its value from the stack.
                         *
                         * @private
                         * @name delete
                         * @memberOf Stack
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function stackDelete(key) {
                            var data = this.__data__,
                                result = data['delete'](key);

                            this.size = data.size;
                            return result;
                        }

                        /**
                         * Gets the stack value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Stack
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function stackGet(key) {
                            return this.__data__.get(key);
                        }

                        /**
                         * Checks if a stack value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Stack
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function stackHas(key) {
                            return this.__data__.has(key);
                        }

                        /**
                         * Sets the stack `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Stack
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the stack cache instance.
                         */
                        function stackSet(key, value) {
                            var data = this.__data__;
                            if (data instanceof ListCache) {
                                var pairs = data.__data__;
                                if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                                    pairs.push([key, value]);
                                    this.size = ++data.size;
                                    return this;
                                }
                                data = this.__data__ = new MapCache(pairs);
                            }
                            data.set(key, value);
                            this.size = data.size;
                            return this;
                        }

                        // Add methods to `Stack`.
                        Stack.prototype.clear = stackClear;
                        Stack.prototype['delete'] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates an array of the enumerable property names of the array-like `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @param {boolean} inherited Specify returning inherited property names.
                         * @returns {Array} Returns the array of property names.
                         */
                        function arrayLikeKeys(value, inherited) {
                            var isArr = isArray(value),
                                isArg = !isArr && isArguments(value),
                                isBuff = !isArr && !isArg && isBuffer(value),
                                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                                skipIndexes = isArr || isArg || isBuff || isType,
                                result = skipIndexes ? baseTimes(value.length, String) : [],
                                length = result.length;

                            for (var key in value) {
                                if ((inherited || hasOwnProperty.call(value, key)) &&
                                    !(skipIndexes && (
                                        // Safari 9 has enumerable `arguments.length` in strict mode.
                                        key == 'length' ||
                                        // Node.js 0.10 has enumerable non-index properties on buffers.
                                        (isBuff && (key == 'offset' || key == 'parent')) ||
                                        // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                        (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                                        // Skip index properties.
                                        isIndex(key, length)
                                    ))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }

                        /**
                         * A specialized version of `_.sample` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to sample.
                         * @returns {*} Returns the random element.
                         */
                        function arraySample(array) {
                            var length = array.length;
                            return length ? array[baseRandom(0, length - 1)] : undefined;
                        }

                        /**
                         * A specialized version of `_.sampleSize` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to sample.
                         * @param {number} n The number of elements to sample.
                         * @returns {Array} Returns the random elements.
                         */
                        function arraySampleSize(array, n) {
                            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                        }

                        /**
                         * A specialized version of `_.shuffle` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         */
                        function arrayShuffle(array) {
                            return shuffleSelf(copyArray(array));
                        }

                        /**
                         * This function is like `assignValue` except that it doesn't assign
                         * `undefined` values.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function assignMergeValue(object, key, value) {
                            if ((value !== undefined && !eq(object[key], value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }

                        /**
                         * Assigns `value` to `key` of `object` if the existing value is not equivalent
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function assignValue(object, key, value) {
                            var objValue = object[key];
                            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }

                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */
                        function assocIndexOf(array, key) {
                            var length = array.length;
                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }
                            return -1;
                        }

                        /**
                         * Aggregates elements of `collection` on `accumulator` with keys transformed
                         * by `iteratee` and values set by `setter`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} setter The function to set `accumulator` values.
                         * @param {Function} iteratee The iteratee to transform keys.
                         * @param {Object} accumulator The initial aggregated object.
                         * @returns {Function} Returns `accumulator`.
                         */
                        function baseAggregator(collection, setter, iteratee, accumulator) {
                            baseEach(collection, function(value, key, collection) {
                                setter(accumulator, value, iteratee(value), collection);
                            });
                            return accumulator;
                        }

                        /**
                         * The base implementation of `_.assign` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */
                        function baseAssign(object, source) {
                            return object && copyObject(source, keys(source), object);
                        }

                        /**
                         * The base implementation of `_.assignIn` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */
                        function baseAssignIn(object, source) {
                            return object && copyObject(source, keysIn(source), object);
                        }

                        /**
                         * The base implementation of `assignValue` and `assignMergeValue` without
                         * value checks.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function baseAssignValue(object, key, value) {
                            if (key == '__proto__' && defineProperty) {
                                defineProperty(object, key, {
                                    'configurable': true,
                                    'enumerable': true,
                                    'value': value,
                                    'writable': true
                                });
                            } else {
                                object[key] = value;
                            }
                        }

                        /**
                         * The base implementation of `_.at` without support for individual paths.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {string[]} paths The property paths to pick.
                         * @returns {Array} Returns the picked elements.
                         */
                        function baseAt(object, paths) {
                            var index = -1,
                                length = paths.length,
                                result = Array(length),
                                skip = object == null;

                            while (++index < length) {
                                result[index] = skip ? undefined : get(object, paths[index]);
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.clamp` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {number} number The number to clamp.
                         * @param {number} [lower] The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the clamped number.
                         */
                        function baseClamp(number, lower, upper) {
                            if (number === number) {
                                if (upper !== undefined) {
                                    number = number <= upper ? number : upper;
                                }
                                if (lower !== undefined) {
                                    number = number >= lower ? number : lower;
                                }
                            }
                            return number;
                        }

                        /**
                         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                         * traversed objects.
                         *
                         * @private
                         * @param {*} value The value to clone.
                         * @param {boolean} bitmask The bitmask flags.
                         *  1 - Deep clone
                         *  2 - Flatten inherited properties
                         *  4 - Clone symbols
                         * @param {Function} [customizer] The function to customize cloning.
                         * @param {string} [key] The key of `value`.
                         * @param {Object} [object] The parent object of `value`.
                         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                         * @returns {*} Returns the cloned value.
                         */
                        function baseClone(value, bitmask, customizer, key, object, stack) {
                            var result,
                                isDeep = bitmask & CLONE_DEEP_FLAG,
                                isFlat = bitmask & CLONE_FLAT_FLAG,
                                isFull = bitmask & CLONE_SYMBOLS_FLAG;

                            if (customizer) {
                                result = object ? customizer(value, key, object, stack) : customizer(value);
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            if (!isObject(value)) {
                                return value;
                            }
                            var isArr = isArray(value);
                            if (isArr) {
                                result = initCloneArray(value);
                                if (!isDeep) {
                                    return copyArray(value, result);
                                }
                            } else {
                                var tag = getTag(value),
                                    isFunc = tag == funcTag || tag == genTag;

                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep);
                                }
                                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                    result = (isFlat || isFunc) ? {} : initCloneObject(value);
                                    if (!isDeep) {
                                        return isFlat
                                            ? copySymbolsIn(value, baseAssignIn(result, value))
                                            : copySymbols(value, baseAssign(result, value));
                                    }
                                } else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {};
                                    }
                                    result = initCloneByTag(value, tag, isDeep);
                                }
                            }
                            // Check for circular references and return its corresponding clone.
                            stack || (stack = new Stack);
                            var stacked = stack.get(value);
                            if (stacked) {
                                return stacked;
                            }
                            stack.set(value, result);

                            if (isSet(value)) {
                                value.forEach(function(subValue) {
                                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                                });

                                return result;
                            }

                            if (isMap(value)) {
                                value.forEach(function(subValue, key) {
                                    result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                                });

                                return result;
                            }

                            var keysFunc = isFull
                                ? (isFlat ? getAllKeysIn : getAllKeys)
                                : (isFlat ? keysIn : keys);

                            var props = isArr ? undefined : keysFunc(value);
                            arrayEach(props || value, function(subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key];
                                }
                                // Recursively populate clone (susceptible to call stack limits).
                                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                            });
                            return result;
                        }

                        /**
                         * The base implementation of `_.conforms` which doesn't clone `source`.
                         *
                         * @private
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseConforms(source) {
                            var props = keys(source);
                            return function(object) {
                                return baseConformsTo(object, source, props);
                            };
                        }

                        /**
                         * The base implementation of `_.conformsTo` which accepts `props` to check.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                         */
                        function baseConformsTo(object, source, props) {
                            var length = props.length;
                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (length--) {
                                var key = props[length],
                                    predicate = source[key],
                                    value = object[key];

                                if ((value === undefined && !(key in object)) || !predicate(value)) {
                                    return false;
                                }
                            }
                            return true;
                        }

                        /**
                         * The base implementation of `_.delay` and `_.defer` which accepts `args`
                         * to provide to `func`.
                         *
                         * @private
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @param {Array} args The arguments to provide to `func`.
                         * @returns {number|Object} Returns the timer id or timeout object.
                         */
                        function baseDelay(func, wait, args) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return setTimeout(function() {
                                func.apply(undefined, args);
                            }, wait);
                        }

                        /**
                         * The base implementation of methods like `_.difference` without support
                         * for excluding multiple arrays or iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Array} values The values to exclude.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         */
                        function baseDifference(array, values, iteratee, comparator) {
                            var index = -1,
                                includes = arrayIncludes,
                                isCommon = true,
                                length = array.length,
                                result = [],
                                valuesLength = values.length;

                            if (!length) {
                                return result;
                            }
                            if (iteratee) {
                                values = arrayMap(values, baseUnary(iteratee));
                            }
                            if (comparator) {
                                includes = arrayIncludesWith;
                                isCommon = false;
                            } else if (values.length >= LARGE_ARRAY_SIZE) {
                                includes = cacheHas;
                                isCommon = false;
                                values = new SetCache(values);
                            }
                            outer:
                                while (++index < length) {
                                    var value = array[index],
                                        computed = iteratee == null ? value : iteratee(value);

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (isCommon && computed === computed) {
                                        var valuesIndex = valuesLength;
                                        while (valuesIndex--) {
                                            if (values[valuesIndex] === computed) {
                                                continue outer;
                                            }
                                        }
                                        result.push(value);
                                    } else if (!includes(values, computed, comparator)) {
                                        result.push(value);
                                    }
                                }
                            return result;
                        }

                        /**
                         * The base implementation of `_.forEach` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         */
                        var baseEach = createBaseEach(baseForOwn);

                        /**
                         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         */
                        var baseEachRight = createBaseEach(baseForOwnRight, true);

                        /**
                         * The base implementation of `_.every` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {boolean} Returns `true` if all elements pass the predicate check,
                         *  else `false`
                         */
                        function baseEvery(collection, predicate) {
                            var result = true;
                            baseEach(collection, function(value, index, collection) {
                                result = !!predicate(value, index, collection);
                                return result;
                            });
                            return result;
                        }

                        /**
                         * The base implementation of methods like `_.max` and `_.min` which accepts a
                         * `comparator` to determine the extremum value.
                         *
                         * @private
                         * @param {Array} array The array to iterate over.
                         * @param {Function} iteratee The iteratee invoked per iteration.
                         * @param {Function} comparator The comparator used to compare values.
                         * @returns {*} Returns the extremum value.
                         */
                        function baseExtremum(array, iteratee, comparator) {
                            var index = -1,
                                length = array.length;

                            while (++index < length) {
                                var value = array[index],
                                    current = iteratee(value);

                                if (current != null && (computed === undefined
                                        ? (current === current && !isSymbol(current))
                                        : comparator(current, computed)
                                )) {
                                    var computed = current,
                                        result = value;
                                }
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.fill` without an iteratee call guard.
                         *
                         * @private
                         * @param {Array} array The array to fill.
                         * @param {*} value The value to fill `array` with.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns `array`.
                         */
                        function baseFill(array, value, start, end) {
                            var length = array.length;

                            start = toInteger(start);
                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = (end === undefined || end > length) ? length : toInteger(end);
                            if (end < 0) {
                                end += length;
                            }
                            end = start > end ? 0 : toLength(end);
                            while (start < end) {
                                array[start++] = value;
                            }
                            return array;
                        }

                        /**
                         * The base implementation of `_.filter` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         */
                        function baseFilter(collection, predicate) {
                            var result = [];
                            baseEach(collection, function(value, index, collection) {
                                if (predicate(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                            return result;
                        }

                        /**
                         * The base implementation of `_.flatten` with support for restricting flattening.
                         *
                         * @private
                         * @param {Array} array The array to flatten.
                         * @param {number} depth The maximum recursion depth.
                         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                         * @param {Array} [result=[]] The initial result value.
                         * @returns {Array} Returns the new flattened array.
                         */
                        function baseFlatten(array, depth, predicate, isStrict, result) {
                            var index = -1,
                                length = array.length;

                            predicate || (predicate = isFlattenable);
                            result || (result = []);

                            while (++index < length) {
                                var value = array[index];
                                if (depth > 0 && predicate(value)) {
                                    if (depth > 1) {
                                        // Recursively flatten arrays (susceptible to call stack limits).
                                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                                    } else {
                                        arrayPush(result, value);
                                    }
                                } else if (!isStrict) {
                                    result[result.length] = value;
                                }
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `baseForOwn` which iterates over `object`
                         * properties returned by `keysFunc` and invokes `iteratee` for each property.
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @returns {Object} Returns `object`.
                         */
                        var baseFor = createBaseFor();

                        /**
                         * This function is like `baseFor` except that it iterates over properties
                         * in the opposite order.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @returns {Object} Returns `object`.
                         */
                        var baseForRight = createBaseFor(true);

                        /**
                         * The base implementation of `_.forOwn` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         */
                        function baseForOwn(object, iteratee) {
                            return object && baseFor(object, iteratee, keys);
                        }

                        /**
                         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         */
                        function baseForOwnRight(object, iteratee) {
                            return object && baseForRight(object, iteratee, keys);
                        }

                        /**
                         * The base implementation of `_.functions` which creates an array of
                         * `object` function property names filtered from `props`.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Array} props The property names to filter.
                         * @returns {Array} Returns the function names.
                         */
                        function baseFunctions(object, props) {
                            return arrayFilter(props, function(key) {
                                return isFunction(object[key]);
                            });
                        }

                        /**
                         * The base implementation of `_.get` without support for default values.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to get.
                         * @returns {*} Returns the resolved value.
                         */
                        function baseGet(object, path) {
                            path = castPath(path, object);

                            var index = 0,
                                length = path.length;

                            while (object != null && index < length) {
                                object = object[toKey(path[index++])];
                            }
                            return (index && index == length) ? object : undefined;
                        }

                        /**
                         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @param {Function} symbolsFunc The function to get the symbols of `object`.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                        }

                        /**
                         * The base implementation of `getTag` without fallbacks for buggy environments.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */
                        function baseGetTag(value) {
                            if (value == null) {
                                return value === undefined ? undefinedTag : nullTag;
                            }
                            return (symToStringTag && symToStringTag in Object(value))
                                ? getRawTag(value)
                                : objectToString(value);
                        }

                        /**
                         * The base implementation of `_.gt` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than `other`,
                         *  else `false`.
                         */
                        function baseGt(value, other) {
                            return value > other;
                        }

                        /**
                         * The base implementation of `_.has` without support for deep paths.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {Array|string} key The key to check.
                         * @returns {boolean} Returns `true` if `key` exists, else `false`.
                         */
                        function baseHas(object, key) {
                            return object != null && hasOwnProperty.call(object, key);
                        }

                        /**
                         * The base implementation of `_.hasIn` without support for deep paths.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {Array|string} key The key to check.
                         * @returns {boolean} Returns `true` if `key` exists, else `false`.
                         */
                        function baseHasIn(object, key) {
                            return object != null && key in Object(object);
                        }

                        /**
                         * The base implementation of `_.inRange` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {number} number The number to check.
                         * @param {number} start The start of the range.
                         * @param {number} end The end of the range.
                         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                         */
                        function baseInRange(number, start, end) {
                            return number >= nativeMin(start, end) && number < nativeMax(start, end);
                        }

                        /**
                         * The base implementation of methods like `_.intersection`, without support
                         * for iteratee shorthands, that accepts an array of arrays to inspect.
                         *
                         * @private
                         * @param {Array} arrays The arrays to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of shared values.
                         */
                        function baseIntersection(arrays, iteratee, comparator) {
                            var includes = comparator ? arrayIncludesWith : arrayIncludes,
                                length = arrays[0].length,
                                othLength = arrays.length,
                                othIndex = othLength,
                                caches = Array(othLength),
                                maxLength = Infinity,
                                result = [];

                            while (othIndex--) {
                                var array = arrays[othIndex];
                                if (othIndex && iteratee) {
                                    array = arrayMap(array, baseUnary(iteratee));
                                }
                                maxLength = nativeMin(array.length, maxLength);
                                caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
                                    ? new SetCache(othIndex && array)
                                    : undefined;
                            }
                            array = arrays[0];

                            var index = -1,
                                seen = caches[0];

                            outer:
                                while (++index < length && result.length < maxLength) {
                                    var value = array[index],
                                        computed = iteratee ? iteratee(value) : value;

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (!(seen
                                            ? cacheHas(seen, computed)
                                            : includes(result, computed, comparator)
                                    )) {
                                        othIndex = othLength;
                                        while (--othIndex) {
                                            var cache = caches[othIndex];
                                            if (!(cache
                                                ? cacheHas(cache, computed)
                                                : includes(arrays[othIndex], computed, comparator))
                                            ) {
                                                continue outer;
                                            }
                                        }
                                        if (seen) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    }
                                }
                            return result;
                        }

                        /**
                         * The base implementation of `_.invert` and `_.invertBy` which inverts
                         * `object` with values transformed by `iteratee` and set by `setter`.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} setter The function to set `accumulator` values.
                         * @param {Function} iteratee The iteratee to transform values.
                         * @param {Object} accumulator The initial inverted object.
                         * @returns {Function} Returns `accumulator`.
                         */
                        function baseInverter(object, setter, iteratee, accumulator) {
                            baseForOwn(object, function(value, key, object) {
                                setter(accumulator, iteratee(value), key, object);
                            });
                            return accumulator;
                        }

                        /**
                         * The base implementation of `_.invoke` without support for individual
                         * method arguments.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {Array} args The arguments to invoke the method with.
                         * @returns {*} Returns the result of the invoked method.
                         */
                        function baseInvoke(object, path, args) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            var func = object == null ? object : object[toKey(last(path))];
                            return func == null ? undefined : apply(func, object, args);
                        }

                        /**
                         * The base implementation of `_.isArguments`.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         */
                        function baseIsArguments(value) {
                            return isObjectLike(value) && baseGetTag(value) == argsTag;
                        }

                        /**
                         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                         */
                        function baseIsArrayBuffer(value) {
                            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                        }

                        /**
                         * The base implementation of `_.isDate` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                         */
                        function baseIsDate(value) {
                            return isObjectLike(value) && baseGetTag(value) == dateTag;
                        }

                        /**
                         * The base implementation of `_.isEqual` which supports partial comparisons
                         * and tracks traversed objects.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @param {boolean} bitmask The bitmask flags.
                         *  1 - Unordered comparison
                         *  2 - Partial comparison
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         */
                        function baseIsEqual(value, other, bitmask, customizer, stack) {
                            if (value === other) {
                                return true;
                            }
                            if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
                                return value !== value && other !== other;
                            }
                            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                        }

                        /**
                         * A specialized version of `baseIsEqual` for arrays and objects which performs
                         * deep comparisons and tracks traversed objects enabling objects with circular
                         * references to be compared.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                            var objIsArr = isArray(object),
                                othIsArr = isArray(other),
                                objTag = objIsArr ? arrayTag : getTag(object),
                                othTag = othIsArr ? arrayTag : getTag(other);

                            objTag = objTag == argsTag ? objectTag : objTag;
                            othTag = othTag == argsTag ? objectTag : othTag;

                            var objIsObj = objTag == objectTag,
                                othIsObj = othTag == objectTag,
                                isSameTag = objTag == othTag;

                            if (isSameTag && isBuffer(object)) {
                                if (!isBuffer(other)) {
                                    return false;
                                }
                                objIsArr = true;
                                objIsObj = false;
                            }
                            if (isSameTag && !objIsObj) {
                                stack || (stack = new Stack);
                                return (objIsArr || isTypedArray(object))
                                    ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                                    : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                            }
                            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                    othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                                if (objIsWrapped || othIsWrapped) {
                                    var objUnwrapped = objIsWrapped ? object.value() : object,
                                        othUnwrapped = othIsWrapped ? other.value() : other;

                                    stack || (stack = new Stack);
                                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                                }
                            }
                            if (!isSameTag) {
                                return false;
                            }
                            stack || (stack = new Stack);
                            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                        }

                        /**
                         * The base implementation of `_.isMap` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                         */
                        function baseIsMap(value) {
                            return isObjectLike(value) && getTag(value) == mapTag;
                        }

                        /**
                         * The base implementation of `_.isMatch` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @param {Array} matchData The property names, values, and compare flags to match.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         */
                        function baseIsMatch(object, source, matchData, customizer) {
                            var index = matchData.length,
                                length = index,
                                noCustomizer = !customizer;

                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (index--) {
                                var data = matchData[index];
                                if ((noCustomizer && data[2])
                                    ? data[1] !== object[data[0]]
                                    : !(data[0] in object)
                                ) {
                                    return false;
                                }
                            }
                            while (++index < length) {
                                data = matchData[index];
                                var key = data[0],
                                    objValue = object[key],
                                    srcValue = data[1];

                                if (noCustomizer && data[2]) {
                                    if (objValue === undefined && !(key in object)) {
                                        return false;
                                    }
                                } else {
                                    var stack = new Stack;
                                    if (customizer) {
                                        var result = customizer(objValue, srcValue, key, object, source, stack);
                                    }
                                    if (!(result === undefined
                                            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                                            : result
                                    )) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }

                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */
                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }
                            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }

                        /**
                         * The base implementation of `_.isRegExp` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                         */
                        function baseIsRegExp(value) {
                            return isObjectLike(value) && baseGetTag(value) == regexpTag;
                        }

                        /**
                         * The base implementation of `_.isSet` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                         */
                        function baseIsSet(value) {
                            return isObjectLike(value) && getTag(value) == setTag;
                        }

                        /**
                         * The base implementation of `_.isTypedArray` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         */
                        function baseIsTypedArray(value) {
                            return isObjectLike(value) &&
                                isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                        }

                        /**
                         * The base implementation of `_.iteratee`.
                         *
                         * @private
                         * @param {*} [value=_.identity] The value to convert to an iteratee.
                         * @returns {Function} Returns the iteratee.
                         */
                        function baseIteratee(value) {
                            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                            if (typeof value == 'function') {
                                return value;
                            }
                            if (value == null) {
                                return identity;
                            }
                            if (typeof value == 'object') {
                                return isArray(value)
                                    ? baseMatchesProperty(value[0], value[1])
                                    : baseMatches(value);
                            }
                            return property(value);
                        }

                        /**
                         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }
                            var result = [];
                            for (var key in Object(object)) {
                                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                                    result.push(key);
                                }
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function baseKeysIn(object) {
                            if (!isObject(object)) {
                                return nativeKeysIn(object);
                            }
                            var isProto = isPrototype(object),
                                result = [];

                            for (var key in object) {
                                if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.lt` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than `other`,
                         *  else `false`.
                         */
                        function baseLt(value, other) {
                            return value < other;
                        }

                        /**
                         * The base implementation of `_.map` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns the new mapped array.
                         */
                        function baseMap(collection, iteratee) {
                            var index = -1,
                                result = isArrayLike(collection) ? Array(collection.length) : [];

                            baseEach(collection, function(value, key, collection) {
                                result[++index] = iteratee(value, key, collection);
                            });
                            return result;
                        }

                        /**
                         * The base implementation of `_.matches` which doesn't clone `source`.
                         *
                         * @private
                         * @param {Object} source The object of property values to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseMatches(source) {
                            var matchData = getMatchData(source);
                            if (matchData.length == 1 && matchData[0][2]) {
                                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                            }
                            return function(object) {
                                return object === source || baseIsMatch(object, source, matchData);
                            };
                        }

                        /**
                         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                         *
                         * @private
                         * @param {string} path The path of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseMatchesProperty(path, srcValue) {
                            if (isKey(path) && isStrictComparable(srcValue)) {
                                return matchesStrictComparable(toKey(path), srcValue);
                            }
                            return function(object) {
                                var objValue = get(object, path);
                                return (objValue === undefined && objValue === srcValue)
                                    ? hasIn(object, path)
                                    : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                            };
                        }

                        /**
                         * The base implementation of `_.merge` without support for multiple sources.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @param {number} srcIndex The index of `source`.
                         * @param {Function} [customizer] The function to customize merged values.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         */
                        function baseMerge(object, source, srcIndex, customizer, stack) {
                            if (object === source) {
                                return;
                            }
                            baseFor(source, function(srcValue, key) {
                                if (isObject(srcValue)) {
                                    stack || (stack = new Stack);
                                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                                } else {
                                    var newValue = customizer
                                        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                                        : undefined;

                                    if (newValue === undefined) {
                                        newValue = srcValue;
                                    }
                                    assignMergeValue(object, key, newValue);
                                }
                            }, keysIn);
                        }

                        /**
                         * A specialized version of `baseMerge` for arrays and objects which performs
                         * deep merges and tracks traversed objects enabling objects with circular
                         * references to be merged.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @param {string} key The key of the value to merge.
                         * @param {number} srcIndex The index of `source`.
                         * @param {Function} mergeFunc The function to merge values.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         */
                        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                            var objValue = safeGet(object, key),
                                srcValue = safeGet(source, key),
                                stacked = stack.get(srcValue);

                            if (stacked) {
                                assignMergeValue(object, key, stacked);
                                return;
                            }
                            var newValue = customizer
                                ? customizer(objValue, srcValue, (key + ''), object, source, stack)
                                : undefined;

                            var isCommon = newValue === undefined;

                            if (isCommon) {
                                var isArr = isArray(srcValue),
                                    isBuff = !isArr && isBuffer(srcValue),
                                    isTyped = !isArr && !isBuff && isTypedArray(srcValue);

                                newValue = srcValue;
                                if (isArr || isBuff || isTyped) {
                                    if (isArray(objValue)) {
                                        newValue = objValue;
                                    } else if (isArrayLikeObject(objValue)) {
                                        newValue = copyArray(objValue);
                                    } else if (isBuff) {
                                        isCommon = false;
                                        newValue = cloneBuffer(srcValue, true);
                                    } else if (isTyped) {
                                        isCommon = false;
                                        newValue = cloneTypedArray(srcValue, true);
                                    } else {
                                        newValue = [];
                                    }
                                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                    newValue = objValue;
                                    if (isArguments(objValue)) {
                                        newValue = toPlainObject(objValue);
                                    } else if (!isObject(objValue) || isFunction(objValue)) {
                                        newValue = initCloneObject(srcValue);
                                    }
                                } else {
                                    isCommon = false;
                                }
                            }
                            if (isCommon) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, newValue);
                                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                                stack['delete'](srcValue);
                            }
                            assignMergeValue(object, key, newValue);
                        }

                        /**
                         * The base implementation of `_.nth` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {Array} array The array to query.
                         * @param {number} n The index of the element to return.
                         * @returns {*} Returns the nth element of `array`.
                         */
                        function baseNth(array, n) {
                            var length = array.length;
                            if (!length) {
                                return;
                            }
                            n += n < 0 ? length : 0;
                            return isIndex(n, length) ? array[n] : undefined;
                        }

                        /**
                         * The base implementation of `_.orderBy` without param guards.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                         * @param {string[]} orders The sort orders of `iteratees`.
                         * @returns {Array} Returns the new sorted array.
                         */
                        function baseOrderBy(collection, iteratees, orders) {
                            var index = -1;
                            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

                            var result = baseMap(collection, function(value, key, collection) {
                                var criteria = arrayMap(iteratees, function(iteratee) {
                                    return iteratee(value);
                                });
                                return { 'criteria': criteria, 'index': ++index, 'value': value };
                            });

                            return baseSortBy(result, function(object, other) {
                                return compareMultiple(object, other, orders);
                            });
                        }

                        /**
                         * The base implementation of `_.pick` without support for individual
                         * property identifiers.
                         *
                         * @private
                         * @param {Object} object The source object.
                         * @param {string[]} paths The property paths to pick.
                         * @returns {Object} Returns the new object.
                         */
                        function basePick(object, paths) {
                            return basePickBy(object, paths, function(value, path) {
                                return hasIn(object, path);
                            });
                        }

                        /**
                         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The source object.
                         * @param {string[]} paths The property paths to pick.
                         * @param {Function} predicate The function invoked per property.
                         * @returns {Object} Returns the new object.
                         */
                        function basePickBy(object, paths, predicate) {
                            var index = -1,
                                length = paths.length,
                                result = {};

                            while (++index < length) {
                                var path = paths[index],
                                    value = baseGet(object, path);

                                if (predicate(value, path)) {
                                    baseSet(result, castPath(path, object), value);
                                }
                            }
                            return result;
                        }

                        /**
                         * A specialized version of `baseProperty` which supports deep paths.
                         *
                         * @private
                         * @param {Array|string} path The path of the property to get.
                         * @returns {Function} Returns the new accessor function.
                         */
                        function basePropertyDeep(path) {
                            return function(object) {
                                return baseGet(object, path);
                            };
                        }

                        /**
                         * The base implementation of `_.pullAllBy` without support for iteratee
                         * shorthands.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns `array`.
                         */
                        function basePullAll(array, values, iteratee, comparator) {
                            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                                index = -1,
                                length = values.length,
                                seen = array;

                            if (array === values) {
                                values = copyArray(values);
                            }
                            if (iteratee) {
                                seen = arrayMap(array, baseUnary(iteratee));
                            }
                            while (++index < length) {
                                var fromIndex = 0,
                                    value = values[index],
                                    computed = iteratee ? iteratee(value) : value;

                                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                                    if (seen !== array) {
                                        splice.call(seen, fromIndex, 1);
                                    }
                                    splice.call(array, fromIndex, 1);
                                }
                            }
                            return array;
                        }

                        /**
                         * The base implementation of `_.pullAt` without support for individual
                         * indexes or capturing the removed elements.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {number[]} indexes The indexes of elements to remove.
                         * @returns {Array} Returns `array`.
                         */
                        function basePullAt(array, indexes) {
                            var length = array ? indexes.length : 0,
                                lastIndex = length - 1;

                            while (length--) {
                                var index = indexes[length];
                                if (length == lastIndex || index !== previous) {
                                    var previous = index;
                                    if (isIndex(index)) {
                                        splice.call(array, index, 1);
                                    } else {
                                        baseUnset(array, index);
                                    }
                                }
                            }
                            return array;
                        }

                        /**
                         * The base implementation of `_.random` without support for returning
                         * floating-point numbers.
                         *
                         * @private
                         * @param {number} lower The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the random number.
                         */
                        function baseRandom(lower, upper) {
                            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                        }

                        /**
                         * The base implementation of `_.range` and `_.rangeRight` which doesn't
                         * coerce arguments.
                         *
                         * @private
                         * @param {number} start The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} step The value to increment or decrement by.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Array} Returns the range of numbers.
                         */
                        function baseRange(start, end, step, fromRight) {
                            var index = -1,
                                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                                result = Array(length);

                            while (length--) {
                                result[fromRight ? length : ++index] = start;
                                start += step;
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.repeat` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {string} string The string to repeat.
                         * @param {number} n The number of times to repeat the string.
                         * @returns {string} Returns the repeated string.
                         */
                        function baseRepeat(string, n) {
                            var result = '';
                            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                                return result;
                            }
                            // Leverage the exponentiation by squaring algorithm for a faster repeat.
                            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                            do {
                                if (n % 2) {
                                    result += string;
                                }
                                n = nativeFloor(n / 2);
                                if (n) {
                                    string += string;
                                }
                            } while (n);

                            return result;
                        }

                        /**
                         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @returns {Function} Returns the new function.
                         */
                        function baseRest(func, start) {
                            return setToString(overRest(func, start, identity), func + '');
                        }

                        /**
                         * The base implementation of `_.sample`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to sample.
                         * @returns {*} Returns the random element.
                         */
                        function baseSample(collection) {
                            return arraySample(values(collection));
                        }

                        /**
                         * The base implementation of `_.sampleSize` without param guards.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to sample.
                         * @param {number} n The number of elements to sample.
                         * @returns {Array} Returns the random elements.
                         */
                        function baseSampleSize(collection, n) {
                            var array = values(collection);
                            return shuffleSelf(array, baseClamp(n, 0, array.length));
                        }

                        /**
                         * The base implementation of `_.set`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @param {Function} [customizer] The function to customize path creation.
                         * @returns {Object} Returns `object`.
                         */
                        function baseSet(object, path, value, customizer) {
                            if (!isObject(object)) {
                                return object;
                            }
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length,
                                lastIndex = length - 1,
                                nested = object;

                            while (nested != null && ++index < length) {
                                var key = toKey(path[index]),
                                    newValue = value;

                                if (index != lastIndex) {
                                    var objValue = nested[key];
                                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                    if (newValue === undefined) {
                                        newValue = isObject(objValue)
                                            ? objValue
                                            : (isIndex(path[index + 1]) ? [] : {});
                                    }
                                }
                                assignValue(nested, key, newValue);
                                nested = nested[key];
                            }
                            return object;
                        }

                        /**
                         * The base implementation of `setData` without support for hot loop shorting.
                         *
                         * @private
                         * @param {Function} func The function to associate metadata with.
                         * @param {*} data The metadata.
                         * @returns {Function} Returns `func`.
                         */
                        var baseSetData = !metaMap ? identity : function(func, data) {
                            metaMap.set(func, data);
                            return func;
                        };

                        /**
                         * The base implementation of `setToString` without support for hot loop shorting.
                         *
                         * @private
                         * @param {Function} func The function to modify.
                         * @param {Function} string The `toString` result.
                         * @returns {Function} Returns `func`.
                         */
                        var baseSetToString = !defineProperty ? identity : function(func, string) {
                            return defineProperty(func, 'toString', {
                                'configurable': true,
                                'enumerable': false,
                                'value': constant(string),
                                'writable': true
                            });
                        };

                        /**
                         * The base implementation of `_.shuffle`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         */
                        function baseShuffle(collection) {
                            return shuffleSelf(values(collection));
                        }

                        /**
                         * The base implementation of `_.slice` without an iteratee call guard.
                         *
                         * @private
                         * @param {Array} array The array to slice.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function baseSlice(array, start, end) {
                            var index = -1,
                                length = array.length;

                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = end > length ? length : end;
                            if (end < 0) {
                                end += length;
                            }
                            length = start > end ? 0 : ((end - start) >>> 0);
                            start >>>= 0;

                            var result = Array(length);
                            while (++index < length) {
                                result[index] = array[index + start];
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.some` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {boolean} Returns `true` if any element passes the predicate check,
                         *  else `false`.
                         */
                        function baseSome(collection, predicate) {
                            var result;

                            baseEach(collection, function(value, index, collection) {
                                result = predicate(value, index, collection);
                                return !result;
                            });
                            return !!result;
                        }

                        /**
                         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
                         * performs a binary search of `array` to determine the index at which `value`
                         * should be inserted into `array` in order to maintain its sort order.
                         *
                         * @private
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {boolean} [retHighest] Specify returning the highest qualified index.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         */
                        function baseSortedIndex(array, value, retHighest) {
                            var low = 0,
                                high = array == null ? low : array.length;

                            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                                while (low < high) {
                                    var mid = (low + high) >>> 1,
                                        computed = array[mid];

                                    if (computed !== null && !isSymbol(computed) &&
                                        (retHighest ? (computed <= value) : (computed < value))) {
                                        low = mid + 1;
                                    } else {
                                        high = mid;
                                    }
                                }
                                return high;
                            }
                            return baseSortedIndexBy(array, value, identity, retHighest);
                        }

                        /**
                         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
                         * which invokes `iteratee` for `value` and each element of `array` to compute
                         * their sort ranking. The iteratee is invoked with one argument; (value).
                         *
                         * @private
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} iteratee The iteratee invoked per element.
                         * @param {boolean} [retHighest] Specify returning the highest qualified index.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         */
                        function baseSortedIndexBy(array, value, iteratee, retHighest) {
                            value = iteratee(value);

                            var low = 0,
                                high = array == null ? 0 : array.length,
                                valIsNaN = value !== value,
                                valIsNull = value === null,
                                valIsSymbol = isSymbol(value),
                                valIsUndefined = value === undefined;

                            while (low < high) {
                                var mid = nativeFloor((low + high) / 2),
                                    computed = iteratee(array[mid]),
                                    othIsDefined = computed !== undefined,
                                    othIsNull = computed === null,
                                    othIsReflexive = computed === computed,
                                    othIsSymbol = isSymbol(computed);

                                if (valIsNaN) {
                                    var setLow = retHighest || othIsReflexive;
                                } else if (valIsUndefined) {
                                    setLow = othIsReflexive && (retHighest || othIsDefined);
                                } else if (valIsNull) {
                                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                                } else if (valIsSymbol) {
                                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                                } else if (othIsNull || othIsSymbol) {
                                    setLow = false;
                                } else {
                                    setLow = retHighest ? (computed <= value) : (computed < value);
                                }
                                if (setLow) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return nativeMin(high, MAX_ARRAY_INDEX);
                        }

                        /**
                         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
                         * support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         */
                        function baseSortedUniq(array, iteratee) {
                            var index = -1,
                                length = array.length,
                                resIndex = 0,
                                result = [];

                            while (++index < length) {
                                var value = array[index],
                                    computed = iteratee ? iteratee(value) : value;

                                if (!index || !eq(computed, seen)) {
                                    var seen = computed;
                                    result[resIndex++] = value === 0 ? 0 : value;
                                }
                            }
                            return result;
                        }

                        /**
                         * The base implementation of `_.toNumber` which doesn't ensure correct
                         * conversions of binary, hexadecimal, or octal string values.
                         *
                         * @private
                         * @param {*} value The value to process.
                         * @returns {number} Returns the number.
                         */
                        function baseToNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            return +value;
                        }

                        /**
                         * The base implementation of `_.toString` which doesn't convert nullish
                         * values to empty strings.
                         *
                         * @private
                         * @param {*} value The value to process.
                         * @returns {string} Returns the string.
                         */
                        function baseToString(value) {
                            // Exit early for strings to avoid a performance hit in some environments.
                            if (typeof value == 'string') {
                                return value;
                            }
                            if (isArray(value)) {
                                // Recursively convert values (susceptible to call stack limits).
                                return arrayMap(value, baseToString) + '';
                            }
                            if (isSymbol(value)) {
                                return symbolToString ? symbolToString.call(value) : '';
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }

                        /**
                         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         */
                        function baseUniq(array, iteratee, comparator) {
                            var index = -1,
                                includes = arrayIncludes,
                                length = array.length,
                                isCommon = true,
                                result = [],
                                seen = result;

                            if (comparator) {
                                isCommon = false;
                                includes = arrayIncludesWith;
                            } else if (length >= LARGE_ARRAY_SIZE) {
                                var set = iteratee ? null : createSet(array);
                                if (set) {
                                    return setToArray(set);
                                }
                                isCommon = false;
                                includes = cacheHas;
                                seen = new SetCache;
                            } else {
                                seen = iteratee ? [] : result;
                            }
                            outer:
                                while (++index < length) {
                                    var value = array[index],
                                        computed = iteratee ? iteratee(value) : value;

                                    value = (comparator || value !== 0) ? value : 0;
                                    if (isCommon && computed === computed) {
                                        var seenIndex = seen.length;
                                        while (seenIndex--) {
                                            if (seen[seenIndex] === computed) {
                                                continue outer;
                                            }
                                        }
                                        if (iteratee) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    } else if (!includes(seen, computed, comparator)) {
                                        if (seen !== result) {
                                            seen.push(computed);
                                        }
                                        result.push(value);
                                    }
                                }
                            return result;
                        }

                        /**
                         * The base implementation of `_.unset`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The property path to unset.
                         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                         */
                        function baseUnset(object, path) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            return object == null || delete object[toKey(last(path))];
                        }

                        /**
                         * The base implementation of `_.update`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to update.
                         * @param {Function} updater The function to produce the updated value.
                         * @param {Function} [customizer] The function to customize path creation.
                         * @returns {Object} Returns `object`.
                         */
                        function baseUpdate(object, path, updater, customizer) {
                            return baseSet(object, path, updater(baseGet(object, path)), customizer);
                        }

                        /**
                         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
                         * without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to query.
                         * @param {Function} predicate The function invoked per iteration.
                         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function baseWhile(array, predicate, isDrop, fromRight) {
                            var length = array.length,
                                index = fromRight ? length : -1;

                            while ((fromRight ? index-- : ++index < length) &&
                            predicate(array[index], index, array)) {
                            }

                            return isDrop
                                ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                                : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                        }

                        /**
                         * The base implementation of `wrapperValue` which returns the result of
                         * performing a sequence of actions on the unwrapped `value`, where each
                         * successive action is supplied the return value of the previous.
                         *
                         * @private
                         * @param {*} value The unwrapped value.
                         * @param {Array} actions Actions to perform to resolve the unwrapped value.
                         * @returns {*} Returns the resolved value.
                         */
                        function baseWrapperValue(value, actions) {
                            var result = value;
                            if (result instanceof LazyWrapper) {
                                result = result.value();
                            }
                            return arrayReduce(actions, function(result, action) {
                                return action.func.apply(action.thisArg, arrayPush([result], action.args));
                            }, result);
                        }

                        /**
                         * The base implementation of methods like `_.xor`, without support for
                         * iteratee shorthands, that accepts an array of arrays to inspect.
                         *
                         * @private
                         * @param {Array} arrays The arrays to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of values.
                         */
                        function baseXor(arrays, iteratee, comparator) {
                            var length = arrays.length;
                            if (length < 2) {
                                return length ? baseUniq(arrays[0]) : [];
                            }
                            var index = -1,
                                result = Array(length);

                            while (++index < length) {
                                var array = arrays[index],
                                    othIndex = -1;

                                while (++othIndex < length) {
                                    if (othIndex != index) {
                                        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                                    }
                                }
                            }
                            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                        }

                        /**
                         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
                         *
                         * @private
                         * @param {Array} props The property identifiers.
                         * @param {Array} values The property values.
                         * @param {Function} assignFunc The function to assign values.
                         * @returns {Object} Returns the new object.
                         */
                        function baseZipObject(props, values, assignFunc) {
                            var index = -1,
                                length = props.length,
                                valsLength = values.length,
                                result = {};

                            while (++index < length) {
                                var value = index < valsLength ? values[index] : undefined;
                                assignFunc(result, props[index], value);
                            }
                            return result;
                        }

                        /**
                         * Casts `value` to an empty array if it's not an array like object.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {Array|Object} Returns the cast array-like object.
                         */
                        function castArrayLikeObject(value) {
                            return isArrayLikeObject(value) ? value : [];
                        }

                        /**
                         * Casts `value` to `identity` if it's not a function.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {Function} Returns cast function.
                         */
                        function castFunction(value) {
                            return typeof value == 'function' ? value : identity;
                        }

                        /**
                         * Casts `value` to a path array if it's not one.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @param {Object} [object] The object to query keys on.
                         * @returns {Array} Returns the cast property path array.
                         */
                        function castPath(value, object) {
                            if (isArray(value)) {
                                return value;
                            }
                            return isKey(value, object) ? [value] : stringToPath(toString(value));
                        }

                        /**
                         * A `baseRest` alias which can be replaced with `identity` by module
                         * replacement plugins.
                         *
                         * @private
                         * @type {Function}
                         * @param {Function} func The function to apply a rest parameter to.
                         * @returns {Function} Returns the new function.
                         */
                        var castRest = baseRest;

                        /**
                         * Casts `array` to a slice if it's needed.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {number} start The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the cast slice.
                         */
                        function castSlice(array, start, end) {
                            var length = array.length;
                            end = end === undefined ? length : end;
                            return (!start && end >= length) ? array : baseSlice(array, start, end);
                        }

                        /**
                         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
                         *
                         * @private
                         * @param {number|Object} id The timer id or timeout object of the timer to clear.
                         */
                        var clearTimeout = ctxClearTimeout || function(id) {
                            return root.clearTimeout(id);
                        };

                        /**
                         * Creates a clone of  `buffer`.
                         *
                         * @private
                         * @param {Buffer} buffer The buffer to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Buffer} Returns the cloned buffer.
                         */
                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }
                            var length = buffer.length,
                                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

                            buffer.copy(result);
                            return result;
                        }

                        /**
                         * Creates a clone of `arrayBuffer`.
                         *
                         * @private
                         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                         * @returns {ArrayBuffer} Returns the cloned array buffer.
                         */
                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                            return result;
                        }

                        /**
                         * Creates a clone of `dataView`.
                         *
                         * @private
                         * @param {Object} dataView The data view to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned data view.
                         */
                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                        }

                        /**
                         * Creates a clone of `regexp`.
                         *
                         * @private
                         * @param {Object} regexp The regexp to clone.
                         * @returns {Object} Returns the cloned regexp.
                         */
                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                            result.lastIndex = regexp.lastIndex;
                            return result;
                        }

                        /**
                         * Creates a clone of the `symbol` object.
                         *
                         * @private
                         * @param {Object} symbol The symbol object to clone.
                         * @returns {Object} Returns the cloned symbol object.
                         */
                        function cloneSymbol(symbol) {
                            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                        }

                        /**
                         * Creates a clone of `typedArray`.
                         *
                         * @private
                         * @param {Object} typedArray The typed array to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned typed array.
                         */
                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                        }

                        /**
                         * Compares values to sort them in ascending order.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {number} Returns the sort order indicator for `value`.
                         */
                        function compareAscending(value, other) {
                            if (value !== other) {
                                var valIsDefined = value !== undefined,
                                    valIsNull = value === null,
                                    valIsReflexive = value === value,
                                    valIsSymbol = isSymbol(value);

                                var othIsDefined = other !== undefined,
                                    othIsNull = other === null,
                                    othIsReflexive = other === other,
                                    othIsSymbol = isSymbol(other);

                                if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                                    (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                                    (valIsNull && othIsDefined && othIsReflexive) ||
                                    (!valIsDefined && othIsReflexive) ||
                                    !valIsReflexive) {
                                    return 1;
                                }
                                if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                                    (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                                    (othIsNull && valIsDefined && valIsReflexive) ||
                                    (!othIsDefined && valIsReflexive) ||
                                    !othIsReflexive) {
                                    return -1;
                                }
                            }
                            return 0;
                        }

                        /**
                         * Used by `_.orderBy` to compare multiple properties of a value to another
                         * and stable sort them.
                         *
                         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
                         * specify an order of "desc" for descending or "asc" for ascending sort order
                         * of corresponding values.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {boolean[]|string[]} orders The order to sort by for each property.
                         * @returns {number} Returns the sort order indicator for `object`.
                         */
                        function compareMultiple(object, other, orders) {
                            var index = -1,
                                objCriteria = object.criteria,
                                othCriteria = other.criteria,
                                length = objCriteria.length,
                                ordersLength = orders.length;

                            while (++index < length) {
                                var result = compareAscending(objCriteria[index], othCriteria[index]);
                                if (result) {
                                    if (index >= ordersLength) {
                                        return result;
                                    }
                                    var order = orders[index];
                                    return result * (order == 'desc' ? -1 : 1);
                                }
                            }
                            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                            // that causes it, under certain circumstances, to provide the same value for
                            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                            // for more details.
                            //
                            // This also ensures a stable sort in V8 and other engines.
                            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                            return object.index - other.index;
                        }

                        /**
                         * Creates an array that is the composition of partially applied arguments,
                         * placeholders, and provided arguments into a single array of arguments.
                         *
                         * @private
                         * @param {Array} args The provided arguments.
                         * @param {Array} partials The arguments to prepend to those provided.
                         * @param {Array} holders The `partials` placeholder indexes.
                         * @params {boolean} [isCurried] Specify composing for a curried function.
                         * @returns {Array} Returns the new array of composed arguments.
                         */
                        function composeArgs(args, partials, holders, isCurried) {
                            var argsIndex = -1,
                                argsLength = args.length,
                                holdersLength = holders.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(leftLength + rangeLength),
                                isUncurried = !isCurried;

                            while (++leftIndex < leftLength) {
                                result[leftIndex] = partials[leftIndex];
                            }
                            while (++argsIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[holders[argsIndex]] = args[argsIndex];
                                }
                            }
                            while (rangeLength--) {
                                result[leftIndex++] = args[argsIndex++];
                            }
                            return result;
                        }

                        /**
                         * This function is like `composeArgs` except that the arguments composition
                         * is tailored for `_.partialRight`.
                         *
                         * @private
                         * @param {Array} args The provided arguments.
                         * @param {Array} partials The arguments to append to those provided.
                         * @param {Array} holders The `partials` placeholder indexes.
                         * @params {boolean} [isCurried] Specify composing for a curried function.
                         * @returns {Array} Returns the new array of composed arguments.
                         */
                        function composeArgsRight(args, partials, holders, isCurried) {
                            var argsIndex = -1,
                                argsLength = args.length,
                                holdersIndex = -1,
                                holdersLength = holders.length,
                                rightIndex = -1,
                                rightLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(rangeLength + rightLength),
                                isUncurried = !isCurried;

                            while (++argsIndex < rangeLength) {
                                result[argsIndex] = args[argsIndex];
                            }
                            var offset = argsIndex;
                            while (++rightIndex < rightLength) {
                                result[offset + rightIndex] = partials[rightIndex];
                            }
                            while (++holdersIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                                }
                            }
                            return result;
                        }

                        /**
                         * Copies the values of `source` to `array`.
                         *
                         * @private
                         * @param {Array} source The array to copy values from.
                         * @param {Array} [array=[]] The array to copy values to.
                         * @returns {Array} Returns `array`.
                         */
                        function copyArray(source, array) {
                            var index = -1,
                                length = source.length;

                            array || (array = Array(length));
                            while (++index < length) {
                                array[index] = source[index];
                            }
                            return array;
                        }

                        /**
                         * Copies properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy properties from.
                         * @param {Array} props The property identifiers to copy.
                         * @param {Object} [object={}] The object to copy properties to.
                         * @param {Function} [customizer] The function to customize copied values.
                         * @returns {Object} Returns `object`.
                         */
                        function copyObject(source, props, object, customizer) {
                            var isNew = !object;
                            object || (object = {});

                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];

                                var newValue = customizer
                                    ? customizer(object[key], source[key], key, object, source)
                                    : undefined;

                                if (newValue === undefined) {
                                    newValue = source[key];
                                }
                                if (isNew) {
                                    baseAssignValue(object, key, newValue);
                                } else {
                                    assignValue(object, key, newValue);
                                }
                            }
                            return object;
                        }

                        /**
                         * Copies own symbols of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */
                        function copySymbols(source, object) {
                            return copyObject(source, getSymbols(source), object);
                        }

                        /**
                         * Copies own and inherited symbols of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */
                        function copySymbolsIn(source, object) {
                            return copyObject(source, getSymbolsIn(source), object);
                        }

                        /**
                         * Creates a function like `_.groupBy`.
                         *
                         * @private
                         * @param {Function} setter The function to set accumulator values.
                         * @param {Function} [initializer] The accumulator object initializer.
                         * @returns {Function} Returns the new aggregator function.
                         */
                        function createAggregator(setter, initializer) {
                            return function(collection, iteratee) {
                                var func = isArray(collection) ? arrayAggregator : baseAggregator,
                                    accumulator = initializer ? initializer() : {};

                                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                            };
                        }

                        /**
                         * Creates a function like `_.assign`.
                         *
                         * @private
                         * @param {Function} assigner The function to assign values.
                         * @returns {Function} Returns the new assigner function.
                         */
                        function createAssigner(assigner) {
                            return baseRest(function(object, sources) {
                                var index = -1,
                                    length = sources.length,
                                    customizer = length > 1 ? sources[length - 1] : undefined,
                                    guard = length > 2 ? sources[2] : undefined;

                                customizer = (assigner.length > 3 && typeof customizer == 'function')
                                    ? (length--, customizer)
                                    : undefined;

                                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                    customizer = length < 3 ? undefined : customizer;
                                    length = 1;
                                }
                                object = Object(object);
                                while (++index < length) {
                                    var source = sources[index];
                                    if (source) {
                                        assigner(object, source, index, customizer);
                                    }
                                }
                                return object;
                            });
                        }

                        /**
                         * Creates a `baseEach` or `baseEachRight` function.
                         *
                         * @private
                         * @param {Function} eachFunc The function to iterate over a collection.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new base function.
                         */
                        function createBaseEach(eachFunc, fromRight) {
                            return function(collection, iteratee) {
                                if (collection == null) {
                                    return collection;
                                }
                                if (!isArrayLike(collection)) {
                                    return eachFunc(collection, iteratee);
                                }
                                var length = collection.length,
                                    index = fromRight ? length : -1,
                                    iterable = Object(collection);

                                while ((fromRight ? index-- : ++index < length)) {
                                    if (iteratee(iterable[index], index, iterable) === false) {
                                        break;
                                    }
                                }
                                return collection;
                            };
                        }

                        /**
                         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new base function.
                         */
                        function createBaseFor(fromRight) {
                            return function(object, iteratee, keysFunc) {
                                var index = -1,
                                    iterable = Object(object),
                                    props = keysFunc(object),
                                    length = props.length;

                                while (length--) {
                                    var key = props[fromRight ? length : ++index];
                                    if (iteratee(iterable[key], key, iterable) === false) {
                                        break;
                                    }
                                }
                                return object;
                            };
                        }

                        /**
                         * Creates a function that wraps `func` to invoke it with the optional `this`
                         * binding of `thisArg`.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createBind(func, bitmask, thisArg) {
                            var isBind = bitmask & WRAP_BIND_FLAG,
                                Ctor = createCtor(func);

                            function wrapper() {
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return fn.apply(isBind ? thisArg : this, arguments);
                            }

                            return wrapper;
                        }

                        /**
                         * Creates a function like `_.lowerFirst`.
                         *
                         * @private
                         * @param {string} methodName The name of the `String` case method to use.
                         * @returns {Function} Returns the new case function.
                         */
                        function createCaseFirst(methodName) {
                            return function(string) {
                                string = toString(string);

                                var strSymbols = hasUnicode(string)
                                    ? stringToArray(string)
                                    : undefined;

                                var chr = strSymbols
                                    ? strSymbols[0]
                                    : string.charAt(0);

                                var trailing = strSymbols
                                    ? castSlice(strSymbols, 1).join('')
                                    : string.slice(1);

                                return chr[methodName]() + trailing;
                            };
                        }

                        /**
                         * Creates a function like `_.camelCase`.
                         *
                         * @private
                         * @param {Function} callback The function to combine each word.
                         * @returns {Function} Returns the new compounder function.
                         */
                        function createCompounder(callback) {
                            return function(string) {
                                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                            };
                        }

                        /**
                         * Creates a function that produces an instance of `Ctor` regardless of
                         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                         *
                         * @private
                         * @param {Function} Ctor The constructor to wrap.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createCtor(Ctor) {
                            return function() {
                                // Use a `switch` statement to work with class constructors. See
                                // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                                // for more details.
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return new Ctor;
                                    case 1:
                                        return new Ctor(args[0]);
                                    case 2:
                                        return new Ctor(args[0], args[1]);
                                    case 3:
                                        return new Ctor(args[0], args[1], args[2]);
                                    case 4:
                                        return new Ctor(args[0], args[1], args[2], args[3]);
                                    case 5:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                    case 6:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    case 7:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                                }
                                var thisBinding = baseCreate(Ctor.prototype),
                                    result = Ctor.apply(thisBinding, args);

                                // Mimic the constructor's `return` behavior.
                                // See https://es5.github.io/#x13.2.2 for more details.
                                return isObject(result) ? result : thisBinding;
                            };
                        }

                        /**
                         * Creates a function that wraps `func` to enable currying.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {number} arity The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createCurry(func, bitmask, arity) {
                            var Ctor = createCtor(func);

                            function wrapper() {
                                var length = arguments.length,
                                    args = Array(length),
                                    index = length,
                                    placeholder = getHolder(wrapper);

                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
                                    ? []
                                    : replaceHolders(args, placeholder);

                                length -= holders.length;
                                if (length < arity) {
                                    return createRecurry(
                                        func, bitmask, createHybrid, wrapper.placeholder, undefined,
                                        args, holders, undefined, undefined, arity - length);
                                }
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return apply(fn, this, args);
                            }

                            return wrapper;
                        }

                        /**
                         * Creates a `_.find` or `_.findLast` function.
                         *
                         * @private
                         * @param {Function} findIndexFunc The function to find the collection index.
                         * @returns {Function} Returns the new find function.
                         */
                        function createFind(findIndexFunc) {
                            return function(collection, predicate, fromIndex) {
                                var iterable = Object(collection);
                                if (!isArrayLike(collection)) {
                                    var iteratee = getIteratee(predicate, 3);
                                    collection = keys(collection);
                                    predicate = function(key) {
                                        return iteratee(iterable[key], key, iterable);
                                    };
                                }
                                var index = findIndexFunc(collection, predicate, fromIndex);
                                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                            };
                        }

                        /**
                         * Creates a `_.flow` or `_.flowRight` function.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new flow function.
                         */
                        function createFlow(fromRight) {
                            return flatRest(function(funcs) {
                                var length = funcs.length,
                                    index = length,
                                    prereq = LodashWrapper.prototype.thru;

                                if (fromRight) {
                                    funcs.reverse();
                                }
                                while (index--) {
                                    var func = funcs[index];
                                    if (typeof func != 'function') {
                                        throw new TypeError(FUNC_ERROR_TEXT);
                                    }
                                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                                        var wrapper = new LodashWrapper([], true);
                                    }
                                }
                                index = wrapper ? index : length;
                                while (++index < length) {
                                    func = funcs[index];

                                    var funcName = getFuncName(func),
                                        data = funcName == 'wrapper' ? getData(func) : undefined;

                                    if (data && isLaziable(data[0]) &&
                                        data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                                        !data[4].length && data[9] == 1
                                    ) {
                                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                    } else {
                                        wrapper = (func.length == 1 && isLaziable(func))
                                            ? wrapper[funcName]()
                                            : wrapper.thru(func);
                                    }
                                }
                                return function() {
                                    var args = arguments,
                                        value = args[0];

                                    if (wrapper && args.length == 1 && isArray(value)) {
                                        return wrapper.plant(value).value();
                                    }
                                    var index = 0,
                                        result = length ? funcs[index].apply(this, args) : value;

                                    while (++index < length) {
                                        result = funcs[index].call(this, result);
                                    }
                                    return result;
                                };
                            });
                        }

                        /**
                         * Creates a function that wraps `func` to invoke it with optional `this`
                         * binding of `thisArg`, partial application, and currying.
                         *
                         * @private
                         * @param {Function|string} func The function or method name to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to prepend to those provided to
                         *  the new function.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [partialsRight] The arguments to append to those provided
                         *  to the new function.
                         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                            var isAry = bitmask & WRAP_ARY_FLAG,
                                isBind = bitmask & WRAP_BIND_FLAG,
                                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                                isFlip = bitmask & WRAP_FLIP_FLAG,
                                Ctor = isBindKey ? undefined : createCtor(func);

                            function wrapper() {
                                var length = arguments.length,
                                    args = Array(length),
                                    index = length;

                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                if (isCurried) {
                                    var placeholder = getHolder(wrapper),
                                        holdersCount = countHolders(args, placeholder);
                                }
                                if (partials) {
                                    args = composeArgs(args, partials, holders, isCurried);
                                }
                                if (partialsRight) {
                                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                                }
                                length -= holdersCount;
                                if (isCurried && length < arity) {
                                    var newHolders = replaceHolders(args, placeholder);
                                    return createRecurry(
                                        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                                        args, newHolders, argPos, ary, arity - length
                                    );
                                }
                                var thisBinding = isBind ? thisArg : this,
                                    fn = isBindKey ? thisBinding[func] : func;

                                length = args.length;
                                if (argPos) {
                                    args = reorder(args, argPos);
                                } else if (isFlip && length > 1) {
                                    args.reverse();
                                }
                                if (isAry && ary < length) {
                                    args.length = ary;
                                }
                                if (this && this !== root && this instanceof wrapper) {
                                    fn = Ctor || createCtor(fn);
                                }
                                return fn.apply(thisBinding, args);
                            }

                            return wrapper;
                        }

                        /**
                         * Creates a function like `_.invertBy`.
                         *
                         * @private
                         * @param {Function} setter The function to set accumulator values.
                         * @param {Function} toIteratee The function to resolve iteratees.
                         * @returns {Function} Returns the new inverter function.
                         */
                        function createInverter(setter, toIteratee) {
                            return function(object, iteratee) {
                                return baseInverter(object, setter, toIteratee(iteratee), {});
                            };
                        }

                        /**
                         * Creates a function that performs a mathematical operation on two values.
                         *
                         * @private
                         * @param {Function} operator The function to perform the operation.
                         * @param {number} [defaultValue] The value used for `undefined` arguments.
                         * @returns {Function} Returns the new mathematical operation function.
                         */
                        function createMathOperation(operator, defaultValue) {
                            return function(value, other) {
                                var result;
                                if (value === undefined && other === undefined) {
                                    return defaultValue;
                                }
                                if (value !== undefined) {
                                    result = value;
                                }
                                if (other !== undefined) {
                                    if (result === undefined) {
                                        return other;
                                    }
                                    if (typeof value == 'string' || typeof other == 'string') {
                                        value = baseToString(value);
                                        other = baseToString(other);
                                    } else {
                                        value = baseToNumber(value);
                                        other = baseToNumber(other);
                                    }
                                    result = operator(value, other);
                                }
                                return result;
                            };
                        }

                        /**
                         * Creates a function like `_.over`.
                         *
                         * @private
                         * @param {Function} arrayFunc The function to iterate over iteratees.
                         * @returns {Function} Returns the new over function.
                         */
                        function createOver(arrayFunc) {
                            return flatRest(function(iteratees) {
                                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                                return baseRest(function(args) {
                                    var thisArg = this;
                                    return arrayFunc(iteratees, function(iteratee) {
                                        return apply(iteratee, thisArg, args);
                                    });
                                });
                            });
                        }

                        /**
                         * Creates the padding for `string` based on `length`. The `chars` string
                         * is truncated if the number of characters exceeds `length`.
                         *
                         * @private
                         * @param {number} length The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padding for `string`.
                         */
                        function createPadding(length, chars) {
                            chars = chars === undefined ? ' ' : baseToString(chars);

                            var charsLength = chars.length;
                            if (charsLength < 2) {
                                return charsLength ? baseRepeat(chars, length) : chars;
                            }
                            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                            return hasUnicode(chars)
                                ? castSlice(stringToArray(result), 0, length).join('')
                                : result.slice(0, length);
                        }

                        /**
                         * Creates a function that wraps `func` to invoke it with the `this` binding
                         * of `thisArg` and `partials` prepended to the arguments it receives.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} thisArg The `this` binding of `func`.
                         * @param {Array} partials The arguments to prepend to those provided to
                         *  the new function.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createPartial(func, bitmask, thisArg, partials) {
                            var isBind = bitmask & WRAP_BIND_FLAG,
                                Ctor = createCtor(func);

                            function wrapper() {
                                var argsIndex = -1,
                                    argsLength = arguments.length,
                                    leftIndex = -1,
                                    leftLength = partials.length,
                                    args = Array(leftLength + argsLength),
                                    fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

                                while (++leftIndex < leftLength) {
                                    args[leftIndex] = partials[leftIndex];
                                }
                                while (argsLength--) {
                                    args[leftIndex++] = arguments[++argsIndex];
                                }
                                return apply(fn, isBind ? thisArg : this, args);
                            }

                            return wrapper;
                        }

                        /**
                         * Creates a `_.range` or `_.rangeRight` function.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new range function.
                         */
                        function createRange(fromRight) {
                            return function(start, end, step) {
                                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                                    end = step = undefined;
                                }
                                // Ensure the sign of `-0` is preserved.
                                start = toFinite(start);
                                if (end === undefined) {
                                    end = start;
                                    start = 0;
                                } else {
                                    end = toFinite(end);
                                }
                                step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
                                return baseRange(start, end, step, fromRight);
                            };
                        }

                        /**
                         * Creates a function that performs a relational operation on two values.
                         *
                         * @private
                         * @param {Function} operator The function to perform the operation.
                         * @returns {Function} Returns the new relational operation function.
                         */
                        function createRelationalOperation(operator) {
                            return function(value, other) {
                                if (!(typeof value == 'string' && typeof other == 'string')) {
                                    value = toNumber(value);
                                    other = toNumber(other);
                                }
                                return operator(value, other);
                            };
                        }

                        /**
                         * Creates a function that wraps `func` to continue currying.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {Function} wrapFunc The function to create the `func` wrapper.
                         * @param {*} placeholder The placeholder value.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to prepend to those provided to
                         *  the new function.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                            var isCurry = bitmask & WRAP_CURRY_FLAG,
                                newHolders = isCurry ? holders : undefined,
                                newHoldersRight = isCurry ? undefined : holders,
                                newPartials = isCurry ? partials : undefined,
                                newPartialsRight = isCurry ? undefined : partials;

                            bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
                            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

                            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                                bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                            }
                            var newData = [
                                func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
                                newHoldersRight, argPos, ary, arity
                            ];

                            var result = wrapFunc.apply(undefined, newData);
                            if (isLaziable(func)) {
                                setData(result, newData);
                            }
                            result.placeholder = placeholder;
                            return setWrapToString(result, func, bitmask);
                        }

                        /**
                         * Creates a function like `_.round`.
                         *
                         * @private
                         * @param {string} methodName The name of the `Math` method to use when rounding.
                         * @returns {Function} Returns the new round function.
                         */
                        function createRound(methodName) {
                            var func = Math[methodName];
                            return function(number, precision) {
                                number = toNumber(number);
                                precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                                if (precision) {
                                    // Shift with exponential notation to avoid floating-point issues.
                                    // See [MDN](https://mdn.io/round#Examples) for more details.
                                    var pair = (toString(number) + 'e').split('e'),
                                        value = func(pair[0] + 'e' + (+pair[1] + precision));

                                    pair = (toString(value) + 'e').split('e');
                                    return +(pair[0] + 'e' + (+pair[1] - precision));
                                }
                                return func(number);
                            };
                        }

                        /**
                         * Creates a set object of `values`.
                         *
                         * @private
                         * @param {Array} values The values to add to the set.
                         * @returns {Object} Returns the new set.
                         */
                        var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function(values) {
                            return new Set(values);
                        };

                        /**
                         * Creates a `_.toPairs` or `_.toPairsIn` function.
                         *
                         * @private
                         * @param {Function} keysFunc The function to get the keys of a given object.
                         * @returns {Function} Returns the new pairs function.
                         */
                        function createToPairs(keysFunc) {
                            return function(object) {
                                var tag = getTag(object);
                                if (tag == mapTag) {
                                    return mapToArray(object);
                                }
                                if (tag == setTag) {
                                    return setToPairs(object);
                                }
                                return baseToPairs(object, keysFunc(object));
                            };
                        }

                        /**
                         * Creates a function that either curries or invokes `func` with optional
                         * `this` binding and partially applied arguments.
                         *
                         * @private
                         * @param {Function|string} func The function or method name to wrap.
                         * @param {number} bitmask The bitmask flags.
                         *    1 - `_.bind`
                         *    2 - `_.bindKey`
                         *    4 - `_.curry` or `_.curryRight` of a bound function
                         *    8 - `_.curry`
                         *   16 - `_.curryRight`
                         *   32 - `_.partial`
                         *   64 - `_.partialRight`
                         *  128 - `_.rearg`
                         *  256 - `_.ary`
                         *  512 - `_.flip`
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to be partially applied.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                            if (!isBindKey && typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var length = partials ? partials.length : 0;
                            if (!length) {
                                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                                partials = holders = undefined;
                            }
                            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                            arity = arity === undefined ? arity : toInteger(arity);
                            length -= holders ? holders.length : 0;

                            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                                var partialsRight = partials,
                                    holdersRight = holders;

                                partials = holders = undefined;
                            }
                            var data = isBindKey ? undefined : getData(func);

                            var newData = [
                                func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
                                argPos, ary, arity
                            ];

                            if (data) {
                                mergeData(newData, data);
                            }
                            func = newData[0];
                            bitmask = newData[1];
                            thisArg = newData[2];
                            partials = newData[3];
                            holders = newData[4];
                            arity = newData[9] = newData[9] === undefined
                                ? (isBindKey ? 0 : func.length)
                                : nativeMax(newData[9] - length, 0);

                            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                                bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                            }
                            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                                var result = createBind(func, bitmask, thisArg);
                            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                                result = createCurry(func, bitmask, arity);
                            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                                result = createPartial(func, bitmask, thisArg, partials);
                            } else {
                                result = createHybrid.apply(undefined, newData);
                            }
                            var setter = data ? baseSetData : setData;
                            return setWrapToString(setter(result, newData), func, bitmask);
                        }

                        /**
                         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
                         * of source objects to the destination object for all destination properties
                         * that resolve to `undefined`.
                         *
                         * @private
                         * @param {*} objValue The destination value.
                         * @param {*} srcValue The source value.
                         * @param {string} key The key of the property to assign.
                         * @param {Object} object The parent object of `objValue`.
                         * @returns {*} Returns the value to assign.
                         */
                        function customDefaultsAssignIn(objValue, srcValue, key, object) {
                            if (objValue === undefined ||
                                (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                return srcValue;
                            }
                            return objValue;
                        }

                        /**
                         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
                         * objects into destination objects that are passed thru.
                         *
                         * @private
                         * @param {*} objValue The destination value.
                         * @param {*} srcValue The source value.
                         * @param {string} key The key of the property to merge.
                         * @param {Object} object The parent object of `objValue`.
                         * @param {Object} source The parent object of `srcValue`.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         * @returns {*} Returns the value to assign.
                         */
                        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                            if (isObject(objValue) && isObject(srcValue)) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, objValue);
                                baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                                stack['delete'](srcValue);
                            }
                            return objValue;
                        }

                        /**
                         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
                         * objects.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @param {string} key The key of the property to inspect.
                         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
                         */
                        function customOmitClone(value) {
                            return isPlainObject(value) ? undefined : value;
                        }

                        /**
                         * A specialized version of `baseIsEqualDeep` for arrays with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Array} array The array to compare.
                         * @param {Array} other The other array to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `array` and `other` objects.
                         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                         */
                        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                arrLength = array.length,
                                othLength = other.length;

                            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                                return false;
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(array);
                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }
                            var index = -1,
                                result = true,
                                seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

                            stack.set(array, other);
                            stack.set(other, array);

                            // Ignore non-index properties.
                            while (++index < arrLength) {
                                var arrValue = array[index],
                                    othValue = other[index];

                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(othValue, arrValue, index, other, array, stack)
                                        : customizer(arrValue, othValue, index, array, other, stack);
                                }
                                if (compared !== undefined) {
                                    if (compared) {
                                        continue;
                                    }
                                    result = false;
                                    break;
                                }
                                // Recursively compare arrays (susceptible to call stack limits).
                                if (seen) {
                                    if (!arraySome(other, function(othValue, othIndex) {
                                        if (!cacheHas(seen, othIndex) &&
                                            (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                            return seen.push(othIndex);
                                        }
                                    })) {
                                        result = false;
                                        break;
                                    }
                                } else if (!(
                                    arrValue === othValue ||
                                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                                )) {
                                    result = false;
                                    break;
                                }
                            }
                            stack['delete'](array);
                            stack['delete'](other);
                            return result;
                        }

                        /**
                         * A specialized version of `baseIsEqualDeep` for comparing objects of
                         * the same `toStringTag`.
                         *
                         * **Note:** This function only supports comparing values with tags of
                         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {string} tag The `toStringTag` of the objects to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                            switch (tag) {
                                case dataViewTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        (object.byteOffset != other.byteOffset)) {
                                        return false;
                                    }
                                    object = object.buffer;
                                    other = other.buffer;

                                case arrayBufferTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                        return false;
                                    }
                                    return true;

                                case boolTag:
                                case dateTag:
                                case numberTag:
                                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                                    // Invalid dates are coerced to `NaN`.
                                    return eq(+object, +other);

                                case errorTag:
                                    return object.name == other.name && object.message == other.message;

                                case regexpTag:
                                case stringTag:
                                    // Coerce regexes to strings and treat strings, primitives and objects,
                                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                                    // for more details.
                                    return object == (other + '');

                                case mapTag:
                                    var convert = mapToArray;

                                case setTag:
                                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                                    convert || (convert = setToArray);

                                    if (object.size != other.size && !isPartial) {
                                        return false;
                                    }
                                    // Assume cyclic values are equal.
                                    var stacked = stack.get(object);
                                    if (stacked) {
                                        return stacked == other;
                                    }
                                    bitmask |= COMPARE_UNORDERED_FLAG;

                                    // Recursively compare objects (susceptible to call stack limits).
                                    stack.set(object, other);
                                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                                    stack['delete'](object);
                                    return result;

                                case symbolTag:
                                    if (symbolValueOf) {
                                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                                    }
                            }
                            return false;
                        }

                        /**
                         * A specialized version of `baseIsEqualDeep` for objects with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                objProps = getAllKeys(object),
                                objLength = objProps.length,
                                othProps = getAllKeys(other),
                                othLength = othProps.length;

                            if (objLength != othLength && !isPartial) {
                                return false;
                            }
                            var index = objLength;
                            while (index--) {
                                var key = objProps[index];
                                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                    return false;
                                }
                            }
                            // Assume cyclic values are equal.
                            var stacked = stack.get(object);
                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }
                            var result = true;
                            stack.set(object, other);
                            stack.set(other, object);

                            var skipCtor = isPartial;
                            while (++index < objLength) {
                                key = objProps[index];
                                var objValue = object[key],
                                    othValue = other[key];

                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(othValue, objValue, key, other, object, stack)
                                        : customizer(objValue, othValue, key, object, other, stack);
                                }
                                // Recursively compare objects (susceptible to call stack limits).
                                if (!(compared === undefined
                                        ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                                        : compared
                                )) {
                                    result = false;
                                    break;
                                }
                                skipCtor || (skipCtor = key == 'constructor');
                            }
                            if (result && !skipCtor) {
                                var objCtor = object.constructor,
                                    othCtor = other.constructor;

                                // Non `Object` object instances with different constructors are not equal.
                                if (objCtor != othCtor &&
                                    ('constructor' in object && 'constructor' in other) &&
                                    !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                        typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                    result = false;
                                }
                            }
                            stack['delete'](object);
                            stack['delete'](other);
                            return result;
                        }

                        /**
                         * A specialized version of `baseRest` which flattens the rest array.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @returns {Function} Returns the new function.
                         */
                        function flatRest(func) {
                            return setToString(overRest(func, undefined, flatten), func + '');
                        }

                        /**
                         * Creates an array of own enumerable property names and symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }

                        /**
                         * Creates an array of own and inherited enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function getAllKeysIn(object) {
                            return baseGetAllKeys(object, keysIn, getSymbolsIn);
                        }

                        /**
                         * Gets metadata for `func`.
                         *
                         * @private
                         * @param {Function} func The function to query.
                         * @returns {*} Returns the metadata for `func`.
                         */
                        var getData = !metaMap ? noop : function(func) {
                            return metaMap.get(func);
                        };

                        /**
                         * Gets the name of `func`.
                         *
                         * @private
                         * @param {Function} func The function to query.
                         * @returns {string} Returns the function name.
                         */
                        function getFuncName(func) {
                            var result = (func.name + ''),
                                array = realNames[result],
                                length = hasOwnProperty.call(realNames, result) ? array.length : 0;

                            while (length--) {
                                var data = array[length],
                                    otherFunc = data.func;
                                if (otherFunc == null || otherFunc == func) {
                                    return data.name;
                                }
                            }
                            return result;
                        }

                        /**
                         * Gets the argument placeholder value for `func`.
                         *
                         * @private
                         * @param {Function} func The function to inspect.
                         * @returns {*} Returns the placeholder value.
                         */
                        function getHolder(func) {
                            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                            return object.placeholder;
                        }

                        /**
                         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
                         * this function returns the custom method, otherwise it returns `baseIteratee`.
                         * If arguments are provided, the chosen function is invoked with them and
                         * its result is returned.
                         *
                         * @private
                         * @param {*} [value] The value to convert to an iteratee.
                         * @param {number} [arity] The arity of the created iteratee.
                         * @returns {Function} Returns the chosen function or its result.
                         */
                        function getIteratee() {
                            var result = lodash.iteratee || iteratee;
                            result = result === iteratee ? baseIteratee : result;
                            return arguments.length ? result(arguments[0], arguments[1]) : result;
                        }

                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */
                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[typeof key == 'string' ? 'string' : 'hash']
                                : data.map;
                        }

                        /**
                         * Gets the property names, values, and compare flags of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the match data of `object`.
                         */
                        function getMatchData(object) {
                            var result = keys(object),
                                length = result.length;

                            while (length--) {
                                var key = result[length],
                                    value = object[key];

                                result[length] = [key, value, isStrictComparable(value)];
                            }
                            return result;
                        }

                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */
                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }

                        /**
                         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the raw `toStringTag`.
                         */
                        function getRawTag(value) {
                            var isOwn = hasOwnProperty.call(value, symToStringTag),
                                tag = value[symToStringTag];

                            try {
                                value[symToStringTag] = undefined;
                                var unmasked = true;
                            } catch (e) {
                            }

                            var result = nativeObjectToString.call(value);
                            if (unmasked) {
                                if (isOwn) {
                                    value[symToStringTag] = tag;
                                } else {
                                    delete value[symToStringTag];
                                }
                            }
                            return result;
                        }

                        /**
                         * Creates an array of the own enumerable symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */
                        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                            if (object == null) {
                                return [];
                            }
                            object = Object(object);
                            return arrayFilter(nativeGetSymbols(object), function(symbol) {
                                return propertyIsEnumerable.call(object, symbol);
                            });
                        };

                        /**
                         * Creates an array of the own and inherited enumerable symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */
                        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                            var result = [];
                            while (object) {
                                arrayPush(result, getSymbols(object));
                                object = getPrototype(object);
                            }
                            return result;
                        };

                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */
                        var getTag = baseGetTag;

                        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
                        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                            (Map && getTag(new Map) != mapTag) ||
                            (Promise && getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set) != setTag) ||
                            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                            getTag = function(value) {
                                var result = baseGetTag(value),
                                    Ctor = result == objectTag ? value.constructor : undefined,
                                    ctorString = Ctor ? toSource(Ctor) : '';

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;
                                        case mapCtorString:
                                            return mapTag;
                                        case promiseCtorString:
                                            return promiseTag;
                                        case setCtorString:
                                            return setTag;
                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }
                                return result;
                            };
                        }

                        /**
                         * Gets the view, applying any `transforms` to the `start` and `end` positions.
                         *
                         * @private
                         * @param {number} start The start of the view.
                         * @param {number} end The end of the view.
                         * @param {Array} transforms The transformations to apply to the view.
                         * @returns {Object} Returns an object containing the `start` and `end`
                         *  positions of the view.
                         */
                        function getView(start, end, transforms) {
                            var index = -1,
                                length = transforms.length;

                            while (++index < length) {
                                var data = transforms[index],
                                    size = data.size;

                                switch (data.type) {
                                    case 'drop':
                                        start += size;
                                        break;
                                    case 'dropRight':
                                        end -= size;
                                        break;
                                    case 'take':
                                        end = nativeMin(end, start + size);
                                        break;
                                    case 'takeRight':
                                        start = nativeMax(start, end - size);
                                        break;
                                }
                            }
                            return { 'start': start, 'end': end };
                        }

                        /**
                         * Extracts wrapper details from the `source` body comment.
                         *
                         * @private
                         * @param {string} source The source to inspect.
                         * @returns {Array} Returns the wrapper details.
                         */
                        function getWrapDetails(source) {
                            var match = source.match(reWrapDetails);
                            return match ? match[1].split(reSplitDetails) : [];
                        }

                        /**
                         * Checks if `path` exists on `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @param {Function} hasFunc The function to check properties.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         */
                        function hasPath(object, path, hasFunc) {
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length,
                                result = false;

                            while (++index < length) {
                                var key = toKey(path[index]);
                                if (!(result = object != null && hasFunc(object, key))) {
                                    break;
                                }
                                object = object[key];
                            }
                            if (result || ++index != length) {
                                return result;
                            }
                            length = object == null ? 0 : object.length;
                            return !!length && isLength(length) && isIndex(key, length) &&
                                (isArray(object) || isArguments(object));
                        }

                        /**
                         * Initializes an array clone.
                         *
                         * @private
                         * @param {Array} array The array to clone.
                         * @returns {Array} Returns the initialized clone.
                         */
                        function initCloneArray(array) {
                            var length = array.length,
                                result = new array.constructor(length);

                            // Add properties assigned by `RegExp#exec`.
                            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                                result.index = array.index;
                                result.input = array.input;
                            }
                            return result;
                        }

                        /**
                         * Initializes an object clone.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @returns {Object} Returns the initialized clone.
                         */
                        function initCloneObject(object) {
                            return (typeof object.constructor == 'function' && !isPrototype(object))
                                ? baseCreate(getPrototype(object))
                                : {};
                        }

                        /**
                         * Initializes an object clone based on its `toStringTag`.
                         *
                         * **Note:** This function only supports cloning values with tags of
                         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @param {string} tag The `toStringTag` of the object to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the initialized clone.
                         */
                        function initCloneByTag(object, tag, isDeep) {
                            var Ctor = object.constructor;
                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);

                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);

                                case dataViewTag:
                                    return cloneDataView(object, isDeep);

                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);

                                case mapTag:
                                    return new Ctor;

                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);

                                case regexpTag:
                                    return cloneRegExp(object);

                                case setTag:
                                    return new Ctor;

                                case symbolTag:
                                    return cloneSymbol(object);
                            }
                        }

                        /**
                         * Inserts wrapper `details` in a comment at the top of the `source` body.
                         *
                         * @private
                         * @param {string} source The source to modify.
                         * @returns {Array} details The details to insert.
                         * @returns {string} Returns the modified source.
                         */
                        function insertWrapDetails(source, details) {
                            var length = details.length;
                            if (!length) {
                                return source;
                            }
                            var lastIndex = length - 1;
                            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                            details = details.join(length > 2 ? ', ' : ' ');
                            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
                        }

                        /**
                         * Checks if `value` is a flattenable `arguments` object or array.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                         */
                        function isFlattenable(value) {
                            return isArray(value) || isArguments(value) ||
                                !!(spreadableSymbol && value && value[spreadableSymbol]);
                        }

                        /**
                         * Checks if `value` is a valid array-like index.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                         */
                        function isIndex(value, length) {
                            var type = typeof value;
                            length = length == null ? MAX_SAFE_INTEGER : length;

                            return !!length &&
                                (type == 'number' ||
                                    (type != 'symbol' && reIsUint.test(value))) &&
                                (value > -1 && value % 1 == 0 && value < length);
                        }

                        /**
                         * Checks if the given arguments are from an iteratee call.
                         *
                         * @private
                         * @param {*} value The potential iteratee value argument.
                         * @param {*} index The potential iteratee index or key argument.
                         * @param {*} object The potential iteratee object argument.
                         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                         *  else `false`.
                         */
                        function isIterateeCall(value, index, object) {
                            if (!isObject(object)) {
                                return false;
                            }
                            var type = typeof index;
                            if (type == 'number'
                                ? (isArrayLike(object) && isIndex(index, object.length))
                                : (type == 'string' && index in object)
                            ) {
                                return eq(object[index], value);
                            }
                            return false;
                        }

                        /**
                         * Checks if `value` is a property name and not a property path.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {Object} [object] The object to query keys on.
                         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                         */
                        function isKey(value, object) {
                            if (isArray(value)) {
                                return false;
                            }
                            var type = typeof value;
                            if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                                value == null || isSymbol(value)) {
                                return true;
                            }
                            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                                (object != null && value in Object(object));
                        }

                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */
                        function isKeyable(value) {
                            var type = typeof value;
                            return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
                                ? (value !== '__proto__')
                                : (value === null);
                        }

                        /**
                         * Checks if `func` has a lazy counterpart.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
                         *  else `false`.
                         */
                        function isLaziable(func) {
                            var funcName = getFuncName(func),
                                other = lodash[funcName];

                            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                                return false;
                            }
                            if (func === other) {
                                return true;
                            }
                            var data = getData(other);
                            return !!data && func === data[0];
                        }

                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */
                        function isMasked(func) {
                            return !!maskSrcKey && (maskSrcKey in func);
                        }

                        /**
                         * Checks if `func` is capable of being masked.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
                         */
                        var isMaskable = coreJsData ? isFunction : stubFalse;

                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */
                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

                            return value === proto;
                        }

                        /**
                         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` if suitable for strict
                         *  equality comparisons, else `false`.
                         */
                        function isStrictComparable(value) {
                            return value === value && !isObject(value);
                        }

                        /**
                         * A specialized version of `matchesProperty` for source values suitable
                         * for strict equality comparisons, i.e. `===`.
                         *
                         * @private
                         * @param {string} key The key of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function matchesStrictComparable(key, srcValue) {
                            return function(object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === srcValue &&
                                    (srcValue !== undefined || (key in Object(object)));
                            };
                        }

                        /**
                         * A specialized version of `_.memoize` which clears the memoized function's
                         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
                         *
                         * @private
                         * @param {Function} func The function to have its output memoized.
                         * @returns {Function} Returns the new memoized function.
                         */
                        function memoizeCapped(func) {
                            var result = memoize(func, function(key) {
                                if (cache.size === MAX_MEMOIZE_SIZE) {
                                    cache.clear();
                                }
                                return key;
                            });

                            var cache = result.cache;
                            return result;
                        }

                        /**
                         * Merges the function metadata of `source` into `data`.
                         *
                         * Merging metadata reduces the number of wrappers used to invoke a function.
                         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                         * may be applied regardless of execution order. Methods like `_.ary` and
                         * `_.rearg` modify function arguments, making the order in which they are
                         * executed important, preventing the merging of metadata. However, we make
                         * an exception for a safe combined case where curried functions have `_.ary`
                         * and or `_.rearg` applied.
                         *
                         * @private
                         * @param {Array} data The destination metadata.
                         * @param {Array} source The source metadata.
                         * @returns {Array} Returns `data`.
                         */
                        function mergeData(data, source) {
                            var bitmask = data[1],
                                srcBitmask = source[1],
                                newBitmask = bitmask | srcBitmask,
                                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

                            var isCombo =
                                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
                                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
                                ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

                            // Exit early if metadata can't be merged.
                            if (!(isCommon || isCombo)) {
                                return data;
                            }
                            // Use source `thisArg` if available.
                            if (srcBitmask & WRAP_BIND_FLAG) {
                                data[2] = source[2];
                                // Set when currying a bound function.
                                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                            }
                            // Compose partial arguments.
                            var value = source[3];
                            if (value) {
                                var partials = data[3];
                                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                            }
                            // Compose partial right arguments.
                            value = source[5];
                            if (value) {
                                partials = data[5];
                                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                            }
                            // Use source `argPos` if available.
                            value = source[7];
                            if (value) {
                                data[7] = value;
                            }
                            // Use source `ary` if it's smaller.
                            if (srcBitmask & WRAP_ARY_FLAG) {
                                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                            }
                            // Use source `arity` if one is not provided.
                            if (data[9] == null) {
                                data[9] = source[9];
                            }
                            // Use source `func` and merge bitmasks.
                            data[0] = source[0];
                            data[1] = newBitmask;

                            return data;
                        }

                        /**
                         * This function is like
                         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * except that it includes inherited enumerable properties.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function nativeKeysIn(object) {
                            var result = [];
                            if (object != null) {
                                for (var key in Object(object)) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }

                        /**
                         * Converts `value` to a string using `Object.prototype.toString`.
                         *
                         * @private
                         * @param {*} value The value to convert.
                         * @returns {string} Returns the converted string.
                         */
                        function objectToString(value) {
                            return nativeObjectToString.call(value);
                        }

                        /**
                         * A specialized version of `baseRest` which transforms the rest array.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @param {Function} transform The rest array transform.
                         * @returns {Function} Returns the new function.
                         */
                        function overRest(func, start, transform) {
                            start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
                            return function() {
                                var args = arguments,
                                    index = -1,
                                    length = nativeMax(args.length - start, 0),
                                    array = Array(length);

                                while (++index < length) {
                                    array[index] = args[start + index];
                                }
                                index = -1;
                                var otherArgs = Array(start + 1);
                                while (++index < start) {
                                    otherArgs[index] = args[index];
                                }
                                otherArgs[start] = transform(array);
                                return apply(func, this, otherArgs);
                            };
                        }

                        /**
                         * Gets the parent value at `path` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array} path The path to get the parent value of.
                         * @returns {*} Returns the parent value.
                         */
                        function parent(object, path) {
                            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                        }

                        /**
                         * Reorder `array` according to the specified indexes where the element at
                         * the first index is assigned as the first element, the element at
                         * the second index is assigned as the second element, and so on.
                         *
                         * @private
                         * @param {Array} array The array to reorder.
                         * @param {Array} indexes The arranged array indexes.
                         * @returns {Array} Returns `array`.
                         */
                        function reorder(array, indexes) {
                            var arrLength = array.length,
                                length = nativeMin(indexes.length, arrLength),
                                oldArray = copyArray(array);

                            while (length--) {
                                var index = indexes[length];
                                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                            }
                            return array;
                        }

                        /**
                         * Gets the value at `key`, unless `key` is "__proto__".
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */
                        function safeGet(object, key) {
                            if (key == '__proto__') {
                                return;
                            }

                            return object[key];
                        }

                        /**
                         * Sets metadata for `func`.
                         *
                         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                         * period of time, it will trip its breaker and transition to an identity
                         * function to avoid garbage collection pauses in V8. See
                         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
                         * for more details.
                         *
                         * @private
                         * @param {Function} func The function to associate metadata with.
                         * @param {*} data The metadata.
                         * @returns {Function} Returns `func`.
                         */
                        var setData = shortOut(baseSetData);

                        /**
                         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
                         *
                         * @private
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @returns {number|Object} Returns the timer id or timeout object.
                         */
                        var setTimeout = ctxSetTimeout || function(func, wait) {
                            return root.setTimeout(func, wait);
                        };

                        /**
                         * Sets the `toString` method of `func` to return `string`.
                         *
                         * @private
                         * @param {Function} func The function to modify.
                         * @param {Function} string The `toString` result.
                         * @returns {Function} Returns `func`.
                         */
                        var setToString = shortOut(baseSetToString);

                        /**
                         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
                         * with wrapper details in a comment at the top of the source body.
                         *
                         * @private
                         * @param {Function} wrapper The function to modify.
                         * @param {Function} reference The reference function.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @returns {Function} Returns `wrapper`.
                         */
                        function setWrapToString(wrapper, reference, bitmask) {
                            var source = (reference + '');
                            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                        }

                        /**
                         * Creates a function that'll short out and invoke `identity` instead
                         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
                         * milliseconds.
                         *
                         * @private
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new shortable function.
                         */
                        function shortOut(func) {
                            var count = 0,
                                lastCalled = 0;

                            return function() {
                                var stamp = nativeNow(),
                                    remaining = HOT_SPAN - (stamp - lastCalled);

                                lastCalled = stamp;
                                if (remaining > 0) {
                                    if (++count >= HOT_COUNT) {
                                        return arguments[0];
                                    }
                                } else {
                                    count = 0;
                                }
                                return func.apply(undefined, arguments);
                            };
                        }

                        /**
                         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
                         *
                         * @private
                         * @param {Array} array The array to shuffle.
                         * @param {number} [size=array.length] The size of `array`.
                         * @returns {Array} Returns `array`.
                         */
                        function shuffleSelf(array, size) {
                            var index = -1,
                                length = array.length,
                                lastIndex = length - 1;

                            size = size === undefined ? length : size;
                            while (++index < size) {
                                var rand = baseRandom(index, lastIndex),
                                    value = array[rand];

                                array[rand] = array[index];
                                array[index] = value;
                            }
                            array.length = size;
                            return array;
                        }

                        /**
                         * Converts `string` to a property path array.
                         *
                         * @private
                         * @param {string} string The string to convert.
                         * @returns {Array} Returns the property path array.
                         */
                        var stringToPath = memoizeCapped(function(string) {
                            var result = [];
                            if (string.charCodeAt(0) === 46 /* . */) {
                                result.push('');
                            }
                            string.replace(rePropName, function(match, number, quote, subString) {
                                result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
                            });
                            return result;
                        });

                        /**
                         * Converts `value` to a string key if it's not a string or symbol.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {string|symbol} Returns the key.
                         */
                        function toKey(value) {
                            if (typeof value == 'string' || isSymbol(value)) {
                                return value;
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }

                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to convert.
                         * @returns {string} Returns the source code.
                         */
                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {
                                }
                                try {
                                    return (func + '');
                                } catch (e) {
                                }
                            }
                            return '';
                        }

                        /**
                         * Updates wrapper `details` based on `bitmask` flags.
                         *
                         * @private
                         * @returns {Array} details The details to modify.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @returns {Array} Returns `details`.
                         */
                        function updateWrapDetails(details, bitmask) {
                            arrayEach(wrapFlags, function(pair) {
                                var value = '_.' + pair[0];
                                if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
                                    details.push(value);
                                }
                            });
                            return details.sort();
                        }

                        /**
                         * Creates a clone of `wrapper`.
                         *
                         * @private
                         * @param {Object} wrapper The wrapper to clone.
                         * @returns {Object} Returns the cloned wrapper.
                         */
                        function wrapperClone(wrapper) {
                            if (wrapper instanceof LazyWrapper) {
                                return wrapper.clone();
                            }
                            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                            result.__actions__ = copyArray(wrapper.__actions__);
                            result.__index__ = wrapper.__index__;
                            result.__values__ = wrapper.__values__;
                            return result;
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates an array of elements split into groups the length of `size`.
                         * If `array` can't be split evenly, the final chunk will be the remaining
                         * elements.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to process.
                         * @param {number} [size=1] The length of each chunk
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the new array of chunks.
                         * @example
                         *
                         * _.chunk(['a', 'b', 'c', 'd'], 2);
                         * // => [['a', 'b'], ['c', 'd']]
                         *
                         * _.chunk(['a', 'b', 'c', 'd'], 3);
                         * // => [['a', 'b', 'c'], ['d']]
                         */
                        function chunk(array, size, guard) {
                            if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
                                size = 1;
                            } else {
                                size = nativeMax(toInteger(size), 0);
                            }
                            var length = array == null ? 0 : array.length;
                            if (!length || size < 1) {
                                return [];
                            }
                            var index = 0,
                                resIndex = 0,
                                result = Array(nativeCeil(length / size));

                            while (index < length) {
                                result[resIndex++] = baseSlice(array, index, (index += size));
                            }
                            return result;
                        }

                        /**
                         * Creates an array with all falsey values removed. The values `false`, `null`,
                         * `0`, `""`, `undefined`, and `NaN` are falsey.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to compact.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.compact([0, 1, false, 2, '', 3]);
                         * // => [1, 2, 3]
                         */
                        function compact(array) {
                            var index = -1,
                                length = array == null ? 0 : array.length,
                                resIndex = 0,
                                result = [];

                            while (++index < length) {
                                var value = array[index];
                                if (value) {
                                    result[resIndex++] = value;
                                }
                            }
                            return result;
                        }

                        /**
                         * Creates a new array concatenating `array` with any additional arrays
                         * and/or values.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to concatenate.
                         * @param {...*} [values] The values to concatenate.
                         * @returns {Array} Returns the new concatenated array.
                         * @example
                         *
                         * var array = [1];
                         * var other = _.concat(array, 2, [3], [[4]]);
                         *
                         * console.log(other);
                         * // => [1, 2, 3, [4]]
                         *
                         * console.log(array);
                         * // => [1]
                         */
                        function concat() {
                            var length = arguments.length;
                            if (!length) {
                                return [];
                            }
                            var args = Array(length - 1),
                                array = arguments[0],
                                index = length;

                            while (index--) {
                                args[index - 1] = arguments[index];
                            }
                            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                        }

                        /**
                         * Creates an array of `array` values not included in the other given arrays
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. The order and references of result values are
                         * determined by the first array.
                         *
                         * **Note:** Unlike `_.pullAll`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.without, _.xor
                         * @example
                         *
                         * _.difference([2, 1], [2, 3]);
                         * // => [1]
                         */
                        var difference = baseRest(function(array, values) {
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
                                : [];
                        });

                        /**
                         * This method is like `_.difference` except that it accepts `iteratee` which
                         * is invoked for each element of `array` and `values` to generate the criterion
                         * by which they're compared. The order and references of result values are
                         * determined by the first array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
                         * // => [{ 'x': 2 }]
                         */
                        var differenceBy = baseRest(function(array, values) {
                            var iteratee = last(values);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
                                : [];
                        });

                        /**
                         * This method is like `_.difference` except that it accepts `comparator`
                         * which is invoked to compare elements of `array` to `values`. The order and
                         * references of result values are determined by the first array. The comparator
                         * is invoked with two arguments: (arrVal, othVal).
                         *
                         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         *
                         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
                         * // => [{ 'x': 2, 'y': 1 }]
                         */
                        var differenceWith = baseRest(function(array, values) {
                            var comparator = last(values);
                            if (isArrayLikeObject(comparator)) {
                                comparator = undefined;
                            }
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
                                : [];
                        });

                        /**
                         * Creates a slice of `array` with `n` elements dropped from the beginning.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to drop.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.drop([1, 2, 3]);
                         * // => [2, 3]
                         *
                         * _.drop([1, 2, 3], 2);
                         * // => [3]
                         *
                         * _.drop([1, 2, 3], 5);
                         * // => []
                         *
                         * _.drop([1, 2, 3], 0);
                         * // => [1, 2, 3]
                         */
                        function drop(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }

                        /**
                         * Creates a slice of `array` with `n` elements dropped from the end.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to drop.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.dropRight([1, 2, 3]);
                         * // => [1, 2]
                         *
                         * _.dropRight([1, 2, 3], 2);
                         * // => [1]
                         *
                         * _.dropRight([1, 2, 3], 5);
                         * // => []
                         *
                         * _.dropRight([1, 2, 3], 0);
                         * // => [1, 2, 3]
                         */
                        function dropRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }

                        /**
                         * Creates a slice of `array` excluding elements dropped from the end.
                         * Elements are dropped until `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.dropRightWhile(users, function(o) { return !o.active; });
                         * // => objects for ['barney']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.dropRightWhile(users, ['active', false]);
                         * // => objects for ['barney']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.dropRightWhile(users, 'active');
                         * // => objects for ['barney', 'fred', 'pebbles']
                         */
                        function dropRightWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), true, true)
                                : [];
                        }

                        /**
                         * Creates a slice of `array` excluding elements dropped from the beginning.
                         * Elements are dropped until `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.dropWhile(users, function(o) { return !o.active; });
                         * // => objects for ['pebbles']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.dropWhile(users, { 'user': 'barney', 'active': false });
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.dropWhile(users, ['active', false]);
                         * // => objects for ['pebbles']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.dropWhile(users, 'active');
                         * // => objects for ['barney', 'fred', 'pebbles']
                         */
                        function dropWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), true)
                                : [];
                        }

                        /**
                         * Fills elements of `array` with `value` from `start` up to, but not
                         * including, `end`.
                         *
                         * **Note:** This method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Array
                         * @param {Array} array The array to fill.
                         * @param {*} value The value to fill `array` with.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _.fill(array, 'a');
                         * console.log(array);
                         * // => ['a', 'a', 'a']
                         *
                         * _.fill(Array(3), 2);
                         * // => [2, 2, 2]
                         *
                         * _.fill([4, 6, 8, 10], '*', 1, 3);
                         * // => [4, '*', '*', 10]
                         */
                        function fill(array, value, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                                start = 0;
                                end = length;
                            }
                            return baseFill(array, value, start, end);
                        }

                        /**
                         * This method is like `_.find` except that it returns the index of the first
                         * element `predicate` returns truthy for instead of the element itself.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {number} Returns the index of the found element, else `-1`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.findIndex(users, function(o) { return o.user == 'barney'; });
                         * // => 0
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findIndex(users, { 'user': 'fred', 'active': false });
                         * // => 1
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findIndex(users, ['active', false]);
                         * // => 0
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findIndex(users, 'active');
                         * // => 2
                         */
                        function findIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index);
                        }

                        /**
                         * This method is like `_.findIndex` except that it iterates over elements
                         * of `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=array.length-1] The index to search from.
                         * @returns {number} Returns the index of the found element, else `-1`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
                         * // => 2
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                         * // => 0
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findLastIndex(users, ['active', false]);
                         * // => 2
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findLastIndex(users, 'active');
                         * // => 0
                         */
                        function findLastIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length - 1;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = fromIndex < 0
                                    ? nativeMax(length + index, 0)
                                    : nativeMin(index, length - 1);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                        }

                        /**
                         * Flattens `array` a single level deep.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * _.flatten([1, [2, [3, [4]], 5]]);
                         * // => [1, 2, [3, [4]], 5]
                         */
                        function flatten(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, 1) : [];
                        }

                        /**
                         * Recursively flattens `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * _.flattenDeep([1, [2, [3, [4]], 5]]);
                         * // => [1, 2, 3, 4, 5]
                         */
                        function flattenDeep(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, INFINITY) : [];
                        }

                        /**
                         * Recursively flatten `array` up to `depth` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.4.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @param {number} [depth=1] The maximum recursion depth.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * var array = [1, [2, [3, [4]], 5]];
                         *
                         * _.flattenDepth(array, 1);
                         * // => [1, 2, [3, [4]], 5]
                         *
                         * _.flattenDepth(array, 2);
                         * // => [1, 2, 3, [4], 5]
                         */
                        function flattenDepth(array, depth) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(array, depth);
                        }

                        /**
                         * The inverse of `_.toPairs`; this method returns an object composed
                         * from key-value `pairs`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} pairs The key-value pairs.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.fromPairs([['a', 1], ['b', 2]]);
                         * // => { 'a': 1, 'b': 2 }
                         */
                        function fromPairs(pairs) {
                            var index = -1,
                                length = pairs == null ? 0 : pairs.length,
                                result = {};

                            while (++index < length) {
                                var pair = pairs[index];
                                result[pair[0]] = pair[1];
                            }
                            return result;
                        }

                        /**
                         * Gets the first element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @alias first
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {*} Returns the first element of `array`.
                         * @example
                         *
                         * _.head([1, 2, 3]);
                         * // => 1
                         *
                         * _.head([]);
                         * // => undefined
                         */
                        function head(array) {
                            return (array && array.length) ? array[0] : undefined;
                        }

                        /**
                         * Gets the index at which the first occurrence of `value` is found in `array`
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. If `fromIndex` is negative, it's used as the
                         * offset from the end of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.indexOf([1, 2, 1, 2], 2);
                         * // => 1
                         *
                         * // Search from the `fromIndex`.
                         * _.indexOf([1, 2, 1, 2], 2, 2);
                         * // => 3
                         */
                        function indexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseIndexOf(array, value, index);
                        }

                        /**
                         * Gets all but the last element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.initial([1, 2, 3]);
                         * // => [1, 2]
                         */
                        function initial(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 0, -1) : [];
                        }

                        /**
                         * Creates an array of unique values that are included in all given arrays
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. The order and references of result values are
                         * determined by the first array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * _.intersection([2, 1], [2, 3]);
                         * // => [2]
                         */
                        var intersection = baseRest(function(arrays) {
                            var mapped = arrayMap(arrays, castArrayLikeObject);
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped)
                                : [];
                        });

                        /**
                         * This method is like `_.intersection` except that it accepts `iteratee`
                         * which is invoked for each element of each `arrays` to generate the criterion
                         * by which they're compared. The order and references of result values are
                         * determined by the first array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [2.1]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }]
                         */
                        var intersectionBy = baseRest(function(arrays) {
                            var iteratee = last(arrays),
                                mapped = arrayMap(arrays, castArrayLikeObject);

                            if (iteratee === last(mapped)) {
                                iteratee = undefined;
                            } else {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped, getIteratee(iteratee, 2))
                                : [];
                        });

                        /**
                         * This method is like `_.intersection` except that it accepts `comparator`
                         * which is invoked to compare elements of `arrays`. The order and references
                         * of result values are determined by the first array. The comparator is
                         * invoked with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.intersectionWith(objects, others, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }]
                         */
                        var intersectionWith = baseRest(function(arrays) {
                            var comparator = last(arrays),
                                mapped = arrayMap(arrays, castArrayLikeObject);

                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            if (comparator) {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped, undefined, comparator)
                                : [];
                        });

                        /**
                         * Converts all elements in `array` into a string separated by `separator`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to convert.
                         * @param {string} [separator=','] The element separator.
                         * @returns {string} Returns the joined string.
                         * @example
                         *
                         * _.join(['a', 'b', 'c'], '~');
                         * // => 'a~b~c'
                         */
                        function join(array, separator) {
                            return array == null ? '' : nativeJoin.call(array, separator);
                        }

                        /**
                         * Gets the last element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {*} Returns the last element of `array`.
                         * @example
                         *
                         * _.last([1, 2, 3]);
                         * // => 3
                         */
                        function last(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? array[length - 1] : undefined;
                        }

                        /**
                         * This method is like `_.indexOf` except that it iterates over elements of
                         * `array` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=array.length-1] The index to search from.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.lastIndexOf([1, 2, 1, 2], 2);
                         * // => 3
                         *
                         * // Search from the `fromIndex`.
                         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                         * // => 1
                         */
                        function lastIndexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                            }
                            return value === value
                                ? strictLastIndexOf(array, value, index)
                                : baseFindIndex(array, baseIsNaN, index, true);
                        }

                        /**
                         * Gets the element at index `n` of `array`. If `n` is negative, the nth
                         * element from the end is returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.11.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=0] The index of the element to return.
                         * @returns {*} Returns the nth element of `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'd'];
                         *
                         * _.nth(array, 1);
                         * // => 'b'
                         *
                         * _.nth(array, -2);
                         * // => 'c';
                         */
                        function nth(array, n) {
                            return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
                        }

                        /**
                         * Removes all given values from `array` using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
                         * to remove elements from an array by predicate.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {...*} [values] The values to remove.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                         *
                         * _.pull(array, 'a', 'c');
                         * console.log(array);
                         * // => ['b', 'b']
                         */
                        var pull = baseRest(pullAll);

                        /**
                         * This method is like `_.pull` except that it accepts an array of values to remove.
                         *
                         * **Note:** Unlike `_.difference`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                         *
                         * _.pullAll(array, ['a', 'c']);
                         * console.log(array);
                         * // => ['b', 'b']
                         */
                        function pullAll(array, values) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values)
                                : array;
                        }

                        /**
                         * This method is like `_.pullAll` except that it accepts `iteratee` which is
                         * invoked for each element of `array` and `values` to generate the criterion
                         * by which they're compared. The iteratee is invoked with one argument: (value).
                         *
                         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
                         *
                         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
                         * console.log(array);
                         * // => [{ 'x': 2 }]
                         */
                        function pullAllBy(array, values, iteratee) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values, getIteratee(iteratee, 2))
                                : array;
                        }

                        /**
                         * This method is like `_.pullAll` except that it accepts `comparator` which
                         * is invoked to compare elements of `array` to `values`. The comparator is
                         * invoked with two arguments: (arrVal, othVal).
                         *
                         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
                         *
                         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
                         * console.log(array);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
                         */
                        function pullAllWith(array, values, comparator) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values, undefined, comparator)
                                : array;
                        }

                        /**
                         * Removes elements from `array` corresponding to `indexes` and returns an
                         * array of removed elements.
                         *
                         * **Note:** Unlike `_.at`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
                         * @returns {Array} Returns the new array of removed elements.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'd'];
                         * var pulled = _.pullAt(array, [1, 3]);
                         *
                         * console.log(array);
                         * // => ['a', 'c']
                         *
                         * console.log(pulled);
                         * // => ['b', 'd']
                         */
                        var pullAt = flatRest(function(array, indexes) {
                            var length = array == null ? 0 : array.length,
                                result = baseAt(array, indexes);

                            basePullAt(array, arrayMap(indexes, function(index) {
                                return isIndex(index, length) ? +index : index;
                            }).sort(compareAscending));

                            return result;
                        });

                        /**
                         * Removes all elements from `array` that `predicate` returns truthy for
                         * and returns an array of the removed elements. The predicate is invoked
                         * with three arguments: (value, index, array).
                         *
                         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
                         * to pull elements from an array by value.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new array of removed elements.
                         * @example
                         *
                         * var array = [1, 2, 3, 4];
                         * var evens = _.remove(array, function(n) {
                         *   return n % 2 == 0;
                         * });
                         *
                         * console.log(array);
                         * // => [1, 3]
                         *
                         * console.log(evens);
                         * // => [2, 4]
                         */
                        function remove(array, predicate) {
                            var result = [];
                            if (!(array && array.length)) {
                                return result;
                            }
                            var index = -1,
                                indexes = [],
                                length = array.length;

                            predicate = getIteratee(predicate, 3);
                            while (++index < length) {
                                var value = array[index];
                                if (predicate(value, index, array)) {
                                    result.push(value);
                                    indexes.push(index);
                                }
                            }
                            basePullAt(array, indexes);
                            return result;
                        }

                        /**
                         * Reverses `array` so that the first element becomes the last, the second
                         * element becomes the second to last, and so on.
                         *
                         * **Note:** This method mutates `array` and is based on
                         * [`Array#reverse`](https://mdn.io/Array/reverse).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _.reverse(array);
                         * // => [3, 2, 1]
                         *
                         * console.log(array);
                         * // => [3, 2, 1]
                         */
                        function reverse(array) {
                            return array == null ? array : nativeReverse.call(array);
                        }

                        /**
                         * Creates a slice of `array` from `start` up to, but not including, `end`.
                         *
                         * **Note:** This method is used instead of
                         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
                         * returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to slice.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function slice(array, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                                start = 0;
                                end = length;
                            } else {
                                start = start == null ? 0 : toInteger(start);
                                end = end === undefined ? length : toInteger(end);
                            }
                            return baseSlice(array, start, end);
                        }

                        /**
                         * Uses a binary search to determine the lowest index at which `value`
                         * should be inserted into `array` in order to maintain its sort order.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * _.sortedIndex([30, 50], 40);
                         * // => 1
                         */
                        function sortedIndex(array, value) {
                            return baseSortedIndex(array, value);
                        }

                        /**
                         * This method is like `_.sortedIndex` except that it accepts `iteratee`
                         * which is invoked for `value` and each element of `array` to compute their
                         * sort ranking. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * var objects = [{ 'x': 4 }, { 'x': 5 }];
                         *
                         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                         * // => 0
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
                         * // => 0
                         */
                        function sortedIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                        }

                        /**
                         * This method is like `_.indexOf` except that it performs a binary
                         * search on a sorted `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
                         * // => 1
                         */
                        function sortedIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value);
                                if (index < length && eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }

                        /**
                         * This method is like `_.sortedIndex` except that it returns the highest
                         * index at which `value` should be inserted into `array` in order to
                         * maintain its sort order.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
                         * // => 4
                         */
                        function sortedLastIndex(array, value) {
                            return baseSortedIndex(array, value, true);
                        }

                        /**
                         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
                         * which is invoked for `value` and each element of `array` to compute their
                         * sort ranking. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * var objects = [{ 'x': 4 }, { 'x': 5 }];
                         *
                         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                         * // => 1
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
                         * // => 1
                         */
                        function sortedLastIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
                        }

                        /**
                         * This method is like `_.lastIndexOf` except that it performs a binary
                         * search on a sorted `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
                         * // => 3
                         */
                        function sortedLastIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value, true) - 1;
                                if (eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }

                        /**
                         * This method is like `_.uniq` except that it's designed and optimized
                         * for sorted arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.sortedUniq([1, 1, 2]);
                         * // => [1, 2]
                         */
                        function sortedUniq(array) {
                            return (array && array.length)
                                ? baseSortedUniq(array)
                                : [];
                        }

                        /**
                         * This method is like `_.uniqBy` except that it's designed and optimized
                         * for sorted arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
                         * // => [1.1, 2.3]
                         */
                        function sortedUniqBy(array, iteratee) {
                            return (array && array.length)
                                ? baseSortedUniq(array, getIteratee(iteratee, 2))
                                : [];
                        }

                        /**
                         * Gets all but the first element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.tail([1, 2, 3]);
                         * // => [2, 3]
                         */
                        function tail(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 1, length) : [];
                        }

                        /**
                         * Creates a slice of `array` with `n` elements taken from the beginning.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to take.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.take([1, 2, 3]);
                         * // => [1]
                         *
                         * _.take([1, 2, 3], 2);
                         * // => [1, 2]
                         *
                         * _.take([1, 2, 3], 5);
                         * // => [1, 2, 3]
                         *
                         * _.take([1, 2, 3], 0);
                         * // => []
                         */
                        function take(array, n, guard) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }

                        /**
                         * Creates a slice of `array` with `n` elements taken from the end.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to take.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.takeRight([1, 2, 3]);
                         * // => [3]
                         *
                         * _.takeRight([1, 2, 3], 2);
                         * // => [2, 3]
                         *
                         * _.takeRight([1, 2, 3], 5);
                         * // => [1, 2, 3]
                         *
                         * _.takeRight([1, 2, 3], 0);
                         * // => []
                         */
                        function takeRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }

                        /**
                         * Creates a slice of `array` with elements taken from the end. Elements are
                         * taken until `predicate` returns falsey. The predicate is invoked with
                         * three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.takeRightWhile(users, function(o) { return !o.active; });
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
                         * // => objects for ['pebbles']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.takeRightWhile(users, ['active', false]);
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.takeRightWhile(users, 'active');
                         * // => []
                         */
                        function takeRightWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), false, true)
                                : [];
                        }

                        /**
                         * Creates a slice of `array` with elements taken from the beginning. Elements
                         * are taken until `predicate` returns falsey. The predicate is invoked with
                         * three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.takeWhile(users, function(o) { return !o.active; });
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.takeWhile(users, { 'user': 'barney', 'active': false });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.takeWhile(users, ['active', false]);
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.takeWhile(users, 'active');
                         * // => []
                         */
                        function takeWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3))
                                : [];
                        }

                        /**
                         * Creates an array of unique values, in order, from all given arrays using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * _.union([2], [1, 2]);
                         * // => [2, 1]
                         */
                        var union = baseRest(function(arrays) {
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                        });

                        /**
                         * This method is like `_.union` except that it accepts `iteratee` which is
                         * invoked for each element of each `arrays` to generate the criterion by
                         * which uniqueness is computed. Result values are chosen from the first
                         * array in which the value occurs. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
                         * // => [2.1, 1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }, { 'x': 2 }]
                         */
                        var unionBy = baseRest(function(arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                        });

                        /**
                         * This method is like `_.union` except that it accepts `comparator` which
                         * is invoked to compare elements of `arrays`. Result values are chosen from
                         * the first array in which the value occurs. The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.unionWith(objects, others, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                         */
                        var unionWith = baseRest(function(arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                        });

                        /**
                         * Creates a duplicate-free version of an array, using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons, in which only the first occurrence of each element
                         * is kept. The order of result values is determined by the order they occur
                         * in the array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.uniq([2, 1, 2]);
                         * // => [2, 1]
                         */
                        function uniq(array) {
                            return (array && array.length) ? baseUniq(array) : [];
                        }

                        /**
                         * This method is like `_.uniq` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * uniqueness is computed. The order of result values is determined by the
                         * order they occur in the array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
                         * // => [2.1, 1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }, { 'x': 2 }]
                         */
                        function uniqBy(array, iteratee) {
                            return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                        }

                        /**
                         * This method is like `_.uniq` except that it accepts `comparator` which
                         * is invoked to compare elements of `array`. The order of result values is
                         * determined by the order they occur in the array.The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.uniqWith(objects, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
                         */
                        function uniqWith(array, comparator) {
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
                        }

                        /**
                         * This method is like `_.zip` except that it accepts an array of grouped
                         * elements and creates an array regrouping the elements to their pre-zip
                         * configuration.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.2.0
                         * @category Array
                         * @param {Array} array The array of grouped elements to process.
                         * @returns {Array} Returns the new array of regrouped elements.
                         * @example
                         *
                         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
                         * // => [['a', 1, true], ['b', 2, false]]
                         *
                         * _.unzip(zipped);
                         * // => [['a', 'b'], [1, 2], [true, false]]
                         */
                        function unzip(array) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var length = 0;
                            array = arrayFilter(array, function(group) {
                                if (isArrayLikeObject(group)) {
                                    length = nativeMax(group.length, length);
                                    return true;
                                }
                            });
                            return baseTimes(length, function(index) {
                                return arrayMap(array, baseProperty(index));
                            });
                        }

                        /**
                         * This method is like `_.unzip` except that it accepts `iteratee` to specify
                         * how regrouped values should be combined. The iteratee is invoked with the
                         * elements of each group: (...group).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Array
                         * @param {Array} array The array of grouped elements to process.
                         * @param {Function} [iteratee=_.identity] The function to combine
                         *  regrouped values.
                         * @returns {Array} Returns the new array of regrouped elements.
                         * @example
                         *
                         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                         * // => [[1, 10, 100], [2, 20, 200]]
                         *
                         * _.unzipWith(zipped, _.add);
                         * // => [3, 30, 300]
                         */
                        function unzipWith(array, iteratee) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var result = unzip(array);
                            if (iteratee == null) {
                                return result;
                            }
                            return arrayMap(result, function(group) {
                                return apply(iteratee, undefined, group);
                            });
                        }

                        /**
                         * Creates an array excluding all given values using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * **Note:** Unlike `_.pull`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...*} [values] The values to exclude.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.difference, _.xor
                         * @example
                         *
                         * _.without([2, 1, 2, 3], 1, 2);
                         * // => [3]
                         */
                        var without = baseRest(function(array, values) {
                            return isArrayLikeObject(array)
                                ? baseDifference(array, values)
                                : [];
                        });

                        /**
                         * Creates an array of unique values that is the
                         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                         * of the given arrays. The order of result values is determined by the order
                         * they occur in the arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.difference, _.without
                         * @example
                         *
                         * _.xor([2, 1], [2, 3]);
                         * // => [1, 3]
                         */
                        var xor = baseRest(function(arrays) {
                            return baseXor(arrayFilter(arrays, isArrayLikeObject));
                        });

                        /**
                         * This method is like `_.xor` except that it accepts `iteratee` which is
                         * invoked for each element of each `arrays` to generate the criterion by
                         * which by which they're compared. The order of result values is determined
                         * by the order they occur in the arrays. The iteratee is invoked with one
                         * argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [1.2, 3.4]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 2 }]
                         */
                        var xorBy = baseRest(function(arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                        });

                        /**
                         * This method is like `_.xor` except that it accepts `comparator` which is
                         * invoked to compare elements of `arrays`. The order of result values is
                         * determined by the order they occur in the arrays. The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.xorWith(objects, others, _.isEqual);
                         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                         */
                        var xorWith = baseRest(function(arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                        });

                        /**
                         * Creates an array of grouped elements, the first of which contains the
                         * first elements of the given arrays, the second of which contains the
                         * second elements of the given arrays, and so on.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to process.
                         * @returns {Array} Returns the new array of grouped elements.
                         * @example
                         *
                         * _.zip(['a', 'b'], [1, 2], [true, false]);
                         * // => [['a', 1, true], ['b', 2, false]]
                         */
                        var zip = baseRest(unzip);

                        /**
                         * This method is like `_.fromPairs` except that it accepts two arrays,
                         * one of property identifiers and one of corresponding values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.4.0
                         * @category Array
                         * @param {Array} [props=[]] The property identifiers.
                         * @param {Array} [values=[]] The property values.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.zipObject(['a', 'b'], [1, 2]);
                         * // => { 'a': 1, 'b': 2 }
                         */
                        function zipObject(props, values) {
                            return baseZipObject(props || [], values || [], assignValue);
                        }

                        /**
                         * This method is like `_.zipObject` except that it supports property paths.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.1.0
                         * @category Array
                         * @param {Array} [props=[]] The property identifiers.
                         * @param {Array} [values=[]] The property values.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
                         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
                         */
                        function zipObjectDeep(props, values) {
                            return baseZipObject(props || [], values || [], baseSet);
                        }

                        /**
                         * This method is like `_.zip` except that it accepts `iteratee` to specify
                         * how grouped values should be combined. The iteratee is invoked with the
                         * elements of each group: (...group).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to process.
                         * @param {Function} [iteratee=_.identity] The function to combine
                         *  grouped values.
                         * @returns {Array} Returns the new array of grouped elements.
                         * @example
                         *
                         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
                         *   return a + b + c;
                         * });
                         * // => [111, 222]
                         */
                        var zipWith = baseRest(function(arrays) {
                            var length = arrays.length,
                                iteratee = length > 1 ? arrays[length - 1] : undefined;

                            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                            return unzipWith(arrays, iteratee);
                        });

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
                         * chain sequences enabled. The result of such sequences must be unwrapped
                         * with `_#value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.3.0
                         * @category Seq
                         * @param {*} value The value to wrap.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36 },
                         *   { 'user': 'fred',    'age': 40 },
                         *   { 'user': 'pebbles', 'age': 1 }
                         * ];
                         *
                         * var youngest = _
                         *   .chain(users)
                         *   .sortBy('age')
                         *   .map(function(o) {
                         *     return o.user + ' is ' + o.age;
                         *   })
                         *   .head()
                         *   .value();
                         * // => 'pebbles is 1'
                         */
                        function chain(value) {
                            var result = lodash(value);
                            result.__chain__ = true;
                            return result;
                        }

                        /**
                         * This method invokes `interceptor` and returns `value`. The interceptor
                         * is invoked with one argument; (value). The purpose of this method is to
                         * "tap into" a method chain sequence in order to modify intermediate results.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @param {*} value The value to provide to `interceptor`.
                         * @param {Function} interceptor The function to invoke.
                         * @returns {*} Returns `value`.
                         * @example
                         *
                         * _([1, 2, 3])
                         *  .tap(function(array) {
                         *    // Mutate input array.
                         *    array.pop();
                         *  })
                         *  .reverse()
                         *  .value();
                         * // => [2, 1]
                         */
                        function tap(value, interceptor) {
                            interceptor(value);
                            return value;
                        }

                        /**
                         * This method is like `_.tap` except that it returns the result of `interceptor`.
                         * The purpose of this method is to "pass thru" values replacing intermediate
                         * results in a method chain sequence.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Seq
                         * @param {*} value The value to provide to `interceptor`.
                         * @param {Function} interceptor The function to invoke.
                         * @returns {*} Returns the result of `interceptor`.
                         * @example
                         *
                         * _('  abc  ')
                         *  .chain()
                         *  .trim()
                         *  .thru(function(value) {
                         *    return [value];
                         *  })
                         *  .value();
                         * // => ['abc']
                         */
                        function thru(value, interceptor) {
                            return interceptor(value);
                        }

                        /**
                         * This method is the wrapper version of `_.at`.
                         *
                         * @name at
                         * @memberOf _
                         * @since 1.0.0
                         * @category Seq
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                         *
                         * _(object).at(['a[0].b.c', 'a[1]']).value();
                         * // => [3, 4]
                         */
                        var wrapperAt = flatRest(function(paths) {
                            var length = paths.length,
                                start = length ? paths[0] : 0,
                                value = this.__wrapped__,
                                interceptor = function(object) {
                                    return baseAt(object, paths);
                                };

                            if (length > 1 || this.__actions__.length ||
                                !(value instanceof LazyWrapper) || !isIndex(start)) {
                                return this.thru(interceptor);
                            }
                            value = value.slice(start, +start + (length ? 1 : 0));
                            value.__actions__.push({
                                'func': thru,
                                'args': [interceptor],
                                'thisArg': undefined
                            });
                            return new LodashWrapper(value, this.__chain__).thru(function(array) {
                                if (length && !array.length) {
                                    array.push(undefined);
                                }
                                return array;
                            });
                        });

                        /**
                         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
                         *
                         * @name chain
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36 },
                         *   { 'user': 'fred',   'age': 40 }
                         * ];
                         *
                         * // A sequence without explicit chaining.
                         * _(users).head();
                         * // => { 'user': 'barney', 'age': 36 }
                         *
                         * // A sequence with explicit chaining.
                         * _(users)
                         *   .chain()
                         *   .head()
                         *   .pick('user')
                         *   .value();
                         * // => { 'user': 'barney' }
                         */
                        function wrapperChain() {
                            return chain(this);
                        }

                        /**
                         * Executes the chain sequence and returns the wrapped result.
                         *
                         * @name commit
                         * @memberOf _
                         * @since 3.2.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var array = [1, 2];
                         * var wrapped = _(array).push(3);
                         *
                         * console.log(array);
                         * // => [1, 2]
                         *
                         * wrapped = wrapped.commit();
                         * console.log(array);
                         * // => [1, 2, 3]
                         *
                         * wrapped.last();
                         * // => 3
                         *
                         * console.log(array);
                         * // => [1, 2, 3]
                         */
                        function wrapperCommit() {
                            return new LodashWrapper(this.value(), this.__chain__);
                        }

                        /**
                         * Gets the next value on a wrapped object following the
                         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
                         *
                         * @name next
                         * @memberOf _
                         * @since 4.0.0
                         * @category Seq
                         * @returns {Object} Returns the next iterator value.
                         * @example
                         *
                         * var wrapped = _([1, 2]);
                         *
                         * wrapped.next();
                         * // => { 'done': false, 'value': 1 }
                         *
                         * wrapped.next();
                         * // => { 'done': false, 'value': 2 }
                         *
                         * wrapped.next();
                         * // => { 'done': true, 'value': undefined }
                         */
                        function wrapperNext() {
                            if (this.__values__ === undefined) {
                                this.__values__ = toArray(this.value());
                            }
                            var done = this.__index__ >= this.__values__.length,
                                value = done ? undefined : this.__values__[this.__index__++];

                            return { 'done': done, 'value': value };
                        }

                        /**
                         * Enables the wrapper to be iterable.
                         *
                         * @name Symbol.iterator
                         * @memberOf _
                         * @since 4.0.0
                         * @category Seq
                         * @returns {Object} Returns the wrapper object.
                         * @example
                         *
                         * var wrapped = _([1, 2]);
                         *
                         * wrapped[Symbol.iterator]() === wrapped;
                         * // => true
                         *
                         * Array.from(wrapped);
                         * // => [1, 2]
                         */
                        function wrapperToIterator() {
                            return this;
                        }

                        /**
                         * Creates a clone of the chain sequence planting `value` as the wrapped value.
                         *
                         * @name plant
                         * @memberOf _
                         * @since 3.2.0
                         * @category Seq
                         * @param {*} value The value to plant.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var wrapped = _([1, 2]).map(square);
                         * var other = wrapped.plant([3, 4]);
                         *
                         * other.value();
                         * // => [9, 16]
                         *
                         * wrapped.value();
                         * // => [1, 4]
                         */
                        function wrapperPlant(value) {
                            var result,
                                parent = this;

                            while (parent instanceof baseLodash) {
                                var clone = wrapperClone(parent);
                                clone.__index__ = 0;
                                clone.__values__ = undefined;
                                if (result) {
                                    previous.__wrapped__ = clone;
                                } else {
                                    result = clone;
                                }
                                var previous = clone;
                                parent = parent.__wrapped__;
                            }
                            previous.__wrapped__ = value;
                            return result;
                        }

                        /**
                         * This method is the wrapper version of `_.reverse`.
                         *
                         * **Note:** This method mutates the wrapped array.
                         *
                         * @name reverse
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _(array).reverse().value()
                         * // => [3, 2, 1]
                         *
                         * console.log(array);
                         * // => [3, 2, 1]
                         */
                        function wrapperReverse() {
                            var value = this.__wrapped__;
                            if (value instanceof LazyWrapper) {
                                var wrapped = value;
                                if (this.__actions__.length) {
                                    wrapped = new LazyWrapper(this);
                                }
                                wrapped = wrapped.reverse();
                                wrapped.__actions__.push({
                                    'func': thru,
                                    'args': [reverse],
                                    'thisArg': undefined
                                });
                                return new LodashWrapper(wrapped, this.__chain__);
                            }
                            return this.thru(reverse);
                        }

                        /**
                         * Executes the chain sequence to resolve the unwrapped value.
                         *
                         * @name value
                         * @memberOf _
                         * @since 0.1.0
                         * @alias toJSON, valueOf
                         * @category Seq
                         * @returns {*} Returns the resolved unwrapped value.
                         * @example
                         *
                         * _([1, 2, 3]).value();
                         * // => [1, 2, 3]
                         */
                        function wrapperValue() {
                            return baseWrapperValue(this.__wrapped__, this.__actions__);
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The corresponding value of
                         * each key is the number of times the key was returned by `iteratee`. The
                         * iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * _.countBy([6.1, 4.2, 6.3], Math.floor);
                         * // => { '4': 1, '6': 2 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.countBy(['one', 'two', 'three'], 'length');
                         * // => { '3': 2, '5': 1 }
                         */
                        var countBy = createAggregator(function(result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                ++result[key];
                            } else {
                                baseAssignValue(result, key, 1);
                            }
                        });

                        /**
                         * Checks if `predicate` returns truthy for **all** elements of `collection`.
                         * Iteration is stopped once `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index|key, collection).
                         *
                         * **Note:** This method returns `true` for
                         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
                         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
                         * elements of empty collections.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {boolean} Returns `true` if all elements pass the predicate check,
                         *  else `false`.
                         * @example
                         *
                         * _.every([true, 1, null, 'yes'], Boolean);
                         * // => false
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': false },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.every(users, { 'user': 'barney', 'active': false });
                         * // => false
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.every(users, ['active', false]);
                         * // => true
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.every(users, 'active');
                         * // => false
                         */
                        function every(collection, predicate, guard) {
                            var func = isArray(collection) ? arrayEvery : baseEvery;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }

                        /**
                         * Iterates over elements of `collection`, returning an array of all elements
                         * `predicate` returns truthy for. The predicate is invoked with three
                         * arguments: (value, index|key, collection).
                         *
                         * **Note:** Unlike `_.remove`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         * @see _.reject
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': true },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * _.filter(users, function(o) { return !o.active; });
                         * // => objects for ['fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.filter(users, { 'age': 36, 'active': true });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.filter(users, ['active', false]);
                         * // => objects for ['fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.filter(users, 'active');
                         * // => objects for ['barney']
                         */
                        function filter(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, getIteratee(predicate, 3));
                        }

                        /**
                         * Iterates over elements of `collection`, returning the first element
                         * `predicate` returns truthy for. The predicate is invoked with three
                         * arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {*} Returns the matched element, else `undefined`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36, 'active': true },
                         *   { 'user': 'fred',    'age': 40, 'active': false },
                         *   { 'user': 'pebbles', 'age': 1,  'active': true }
                         * ];
                         *
                         * _.find(users, function(o) { return o.age < 40; });
                         * // => object for 'barney'
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.find(users, { 'age': 1, 'active': true });
                         * // => object for 'pebbles'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.find(users, ['active', false]);
                         * // => object for 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.find(users, 'active');
                         * // => object for 'barney'
                         */
                        var find = createFind(findIndex);

                        /**
                         * This method is like `_.find` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=collection.length-1] The index to search from.
                         * @returns {*} Returns the matched element, else `undefined`.
                         * @example
                         *
                         * _.findLast([1, 2, 3, 4], function(n) {
                         *   return n % 2 == 1;
                         * });
                         * // => 3
                         */
                        var findLast = createFind(findLastIndex);

                        /**
                         * Creates a flattened array of values by running each element in `collection`
                         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
                         * with three arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [n, n];
                         * }
                         *
                         * _.flatMap([1, 2], duplicate);
                         * // => [1, 1, 2, 2]
                         */
                        function flatMap(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), 1);
                        }

                        /**
                         * This method is like `_.flatMap` except that it recursively flattens the
                         * mapped results.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [[[n, n]]];
                         * }
                         *
                         * _.flatMapDeep([1, 2], duplicate);
                         * // => [1, 1, 2, 2]
                         */
                        function flatMapDeep(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), INFINITY);
                        }

                        /**
                         * This method is like `_.flatMap` except that it recursively flattens the
                         * mapped results up to `depth` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {number} [depth=1] The maximum recursion depth.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [[[n, n]]];
                         * }
                         *
                         * _.flatMapDepth([1, 2], duplicate, 2);
                         * // => [[1, 1], [2, 2]]
                         */
                        function flatMapDepth(collection, iteratee, depth) {
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(map(collection, iteratee), depth);
                        }

                        /**
                         * Iterates over elements of `collection` and invokes `iteratee` for each element.
                         * The iteratee is invoked with three arguments: (value, index|key, collection).
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * **Note:** As with other "Collections" methods, objects with a "length"
                         * property are iterated like arrays. To avoid this behavior use `_.forIn`
                         * or `_.forOwn` for object iteration.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @alias each
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         * @see _.forEachRight
                         * @example
                         *
                         * _.forEach([1, 2], function(value) {
                         *   console.log(value);
                         * });
                         * // => Logs `1` then `2`.
                         *
                         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                         */
                        function forEach(collection, iteratee) {
                            var func = isArray(collection) ? arrayEach : baseEach;
                            return func(collection, getIteratee(iteratee, 3));
                        }

                        /**
                         * This method is like `_.forEach` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @alias eachRight
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         * @see _.forEach
                         * @example
                         *
                         * _.forEachRight([1, 2], function(value) {
                         *   console.log(value);
                         * });
                         * // => Logs `2` then `1`.
                         */
                        function forEachRight(collection, iteratee) {
                            var func = isArray(collection) ? arrayEachRight : baseEachRight;
                            return func(collection, getIteratee(iteratee, 3));
                        }

                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The order of grouped values
                         * is determined by the order they occur in `collection`. The corresponding
                         * value of each key is an array of elements responsible for generating the
                         * key. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
                         * // => { '4': [4.2], '6': [6.1, 6.3] }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.groupBy(['one', 'two', 'three'], 'length');
                         * // => { '3': ['one', 'two'], '5': ['three'] }
                         */
                        var groupBy = createAggregator(function(result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                result[key].push(value);
                            } else {
                                baseAssignValue(result, key, [value]);
                            }
                        });

                        /**
                         * Checks if `value` is in `collection`. If `collection` is a string, it's
                         * checked for a substring of `value`, otherwise
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * is used for equality comparisons. If `fromIndex` is negative, it's used as
                         * the offset from the end of `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object|string} collection The collection to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                         * @returns {boolean} Returns `true` if `value` is found, else `false`.
                         * @example
                         *
                         * _.includes([1, 2, 3], 1);
                         * // => true
                         *
                         * _.includes([1, 2, 3], 1, 2);
                         * // => false
                         *
                         * _.includes({ 'a': 1, 'b': 2 }, 1);
                         * // => true
                         *
                         * _.includes('abcd', 'bc');
                         * // => true
                         */
                        function includes(collection, value, fromIndex, guard) {
                            collection = isArrayLike(collection) ? collection : values(collection);
                            fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

                            var length = collection.length;
                            if (fromIndex < 0) {
                                fromIndex = nativeMax(length + fromIndex, 0);
                            }
                            return isString(collection)
                                ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
                                : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
                        }

                        /**
                         * Invokes the method at `path` of each element in `collection`, returning
                         * an array of the results of each invoked method. Any additional arguments
                         * are provided to each invoked method. If `path` is a function, it's invoked
                         * for, and `this` bound to, each element in `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Array|Function|string} path The path of the method to invoke or
                         *  the function invoked per iteration.
                         * @param {...*} [args] The arguments to invoke each method with.
                         * @returns {Array} Returns the array of results.
                         * @example
                         *
                         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
                         * // => [[1, 5, 7], [1, 2, 3]]
                         *
                         * _.invokeMap([123, 456], String.prototype.split, '');
                         * // => [['1', '2', '3'], ['4', '5', '6']]
                         */
                        var invokeMap = baseRest(function(collection, path, args) {
                            var index = -1,
                                isFunc = typeof path == 'function',
                                result = isArrayLike(collection) ? Array(collection.length) : [];

                            baseEach(collection, function(value) {
                                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                            });
                            return result;
                        });

                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The corresponding value of
                         * each key is the last element responsible for generating the key. The
                         * iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * var array = [
                         *   { 'dir': 'left', 'code': 97 },
                         *   { 'dir': 'right', 'code': 100 }
                         * ];
                         *
                         * _.keyBy(array, function(o) {
                         *   return String.fromCharCode(o.code);
                         * });
                         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                         *
                         * _.keyBy(array, 'dir');
                         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                         */
                        var keyBy = createAggregator(function(result, value, key) {
                            baseAssignValue(result, key, value);
                        });

                        /**
                         * Creates an array of values by running each element in `collection` thru
                         * `iteratee`. The iteratee is invoked with three arguments:
                         * (value, index|key, collection).
                         *
                         * Many lodash methods are guarded to work as iteratees for methods like
                         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                         *
                         * The guarded methods are:
                         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
                         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
                         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
                         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new mapped array.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * _.map([4, 8], square);
                         * // => [16, 64]
                         *
                         * _.map({ 'a': 4, 'b': 8 }, square);
                         * // => [16, 64] (iteration order is not guaranteed)
                         *
                         * var users = [
                         *   { 'user': 'barney' },
                         *   { 'user': 'fred' }
                         * ];
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.map(users, 'user');
                         * // => ['barney', 'fred']
                         */
                        function map(collection, iteratee) {
                            var func = isArray(collection) ? arrayMap : baseMap;
                            return func(collection, getIteratee(iteratee, 3));
                        }

                        /**
                         * This method is like `_.sortBy` except that it allows specifying the sort
                         * orders of the iteratees to sort by. If `orders` is unspecified, all values
                         * are sorted in ascending order. Otherwise, specify an order of "desc" for
                         * descending or "asc" for ascending sort order of corresponding values.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
                         *  The iteratees to sort by.
                         * @param {string[]} [orders] The sort orders of `iteratees`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                         * @returns {Array} Returns the new sorted array.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'fred',   'age': 48 },
                         *   { 'user': 'barney', 'age': 34 },
                         *   { 'user': 'fred',   'age': 40 },
                         *   { 'user': 'barney', 'age': 36 }
                         * ];
                         *
                         * // Sort by `user` in ascending order and by `age` in descending order.
                         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
                         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                         */
                        function orderBy(collection, iteratees, orders, guard) {
                            if (collection == null) {
                                return [];
                            }
                            if (!isArray(iteratees)) {
                                iteratees = iteratees == null ? [] : [iteratees];
                            }
                            orders = guard ? undefined : orders;
                            if (!isArray(orders)) {
                                orders = orders == null ? [] : [orders];
                            }
                            return baseOrderBy(collection, iteratees, orders);
                        }

                        /**
                         * Creates an array of elements split into two groups, the first of which
                         * contains elements `predicate` returns truthy for, the second of which
                         * contains elements `predicate` returns falsey for. The predicate is
                         * invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the array of grouped elements.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36, 'active': false },
                         *   { 'user': 'fred',    'age': 40, 'active': true },
                         *   { 'user': 'pebbles', 'age': 1,  'active': false }
                         * ];
                         *
                         * _.partition(users, function(o) { return o.active; });
                         * // => objects for [['fred'], ['barney', 'pebbles']]
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.partition(users, { 'age': 1, 'active': false });
                         * // => objects for [['pebbles'], ['barney', 'fred']]
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.partition(users, ['active', false]);
                         * // => objects for [['barney', 'pebbles'], ['fred']]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.partition(users, 'active');
                         * // => objects for [['fred'], ['barney', 'pebbles']]
                         */
                        var partition = createAggregator(function(result, value, key) {
                            result[key ? 0 : 1].push(value);
                        }, function() {
                            return [[], []];
                        });

                        /**
                         * Reduces `collection` to a value which is the accumulated result of running
                         * each element in `collection` thru `iteratee`, where each successive
                         * invocation is supplied the return value of the previous. If `accumulator`
                         * is not given, the first element of `collection` is used as the initial
                         * value. The iteratee is invoked with four arguments:
                         * (accumulator, value, index|key, collection).
                         *
                         * Many lodash methods are guarded to work as iteratees for methods like
                         * `_.reduce`, `_.reduceRight`, and `_.transform`.
                         *
                         * The guarded methods are:
                         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
                         * and `sortBy`
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @returns {*} Returns the accumulated value.
                         * @see _.reduceRight
                         * @example
                         *
                         * _.reduce([1, 2], function(sum, n) {
                         *   return sum + n;
                         * }, 0);
                         * // => 3
                         *
                         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                         *   (result[value] || (result[value] = [])).push(key);
                         *   return result;
                         * }, {});
                         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
                         */
                        function reduce(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduce : baseReduce,
                                initAccum = arguments.length < 3;

                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                        }

                        /**
                         * This method is like `_.reduce` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @returns {*} Returns the accumulated value.
                         * @see _.reduce
                         * @example
                         *
                         * var array = [[0, 1], [2, 3], [4, 5]];
                         *
                         * _.reduceRight(array, function(flattened, other) {
                         *   return flattened.concat(other);
                         * }, []);
                         * // => [4, 5, 2, 3, 0, 1]
                         */
                        function reduceRight(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                                initAccum = arguments.length < 3;

                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                        }

                        /**
                         * The opposite of `_.filter`; this method returns the elements of `collection`
                         * that `predicate` does **not** return truthy for.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         * @see _.filter
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': false },
                         *   { 'user': 'fred',   'age': 40, 'active': true }
                         * ];
                         *
                         * _.reject(users, function(o) { return !o.active; });
                         * // => objects for ['fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.reject(users, { 'age': 40, 'active': true });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.reject(users, ['active', false]);
                         * // => objects for ['fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.reject(users, 'active');
                         * // => objects for ['barney']
                         */
                        function reject(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, negate(getIteratee(predicate, 3)));
                        }

                        /**
                         * Gets a random element from `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to sample.
                         * @returns {*} Returns the random element.
                         * @example
                         *
                         * _.sample([1, 2, 3, 4]);
                         * // => 2
                         */
                        function sample(collection) {
                            var func = isArray(collection) ? arraySample : baseSample;
                            return func(collection);
                        }

                        /**
                         * Gets `n` random elements at unique keys from `collection` up to the
                         * size of `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to sample.
                         * @param {number} [n=1] The number of elements to sample.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the random elements.
                         * @example
                         *
                         * _.sampleSize([1, 2, 3], 2);
                         * // => [3, 1]
                         *
                         * _.sampleSize([1, 2, 3], 4);
                         * // => [2, 3, 1]
                         */
                        function sampleSize(collection, n, guard) {
                            if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
                                n = 1;
                            } else {
                                n = toInteger(n);
                            }
                            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                            return func(collection, n);
                        }

                        /**
                         * Creates an array of shuffled values, using a version of the
                         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         * @example
                         *
                         * _.shuffle([1, 2, 3, 4]);
                         * // => [4, 1, 3, 2]
                         */
                        function shuffle(collection) {
                            var func = isArray(collection) ? arrayShuffle : baseShuffle;
                            return func(collection);
                        }

                        /**
                         * Gets the size of `collection` by returning its length for array-like
                         * values or the number of own enumerable string keyed properties for objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object|string} collection The collection to inspect.
                         * @returns {number} Returns the collection size.
                         * @example
                         *
                         * _.size([1, 2, 3]);
                         * // => 3
                         *
                         * _.size({ 'a': 1, 'b': 2 });
                         * // => 2
                         *
                         * _.size('pebbles');
                         * // => 7
                         */
                        function size(collection) {
                            if (collection == null) {
                                return 0;
                            }
                            if (isArrayLike(collection)) {
                                return isString(collection) ? stringSize(collection) : collection.length;
                            }
                            var tag = getTag(collection);
                            if (tag == mapTag || tag == setTag) {
                                return collection.size;
                            }
                            return baseKeys(collection).length;
                        }

                        /**
                         * Checks if `predicate` returns truthy for **any** element of `collection`.
                         * Iteration is stopped once `predicate` returns truthy. The predicate is
                         * invoked with three arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {boolean} Returns `true` if any element passes the predicate check,
                         *  else `false`.
                         * @example
                         *
                         * _.some([null, 0, 'yes', false], Boolean);
                         * // => true
                         *
                         * var users = [
                         *   { 'user': 'barney', 'active': true },
                         *   { 'user': 'fred',   'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.some(users, { 'user': 'barney', 'active': false });
                         * // => false
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.some(users, ['active', false]);
                         * // => true
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.some(users, 'active');
                         * // => true
                         */
                        function some(collection, predicate, guard) {
                            var func = isArray(collection) ? arraySome : baseSome;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }

                        /**
                         * Creates an array of elements, sorted in ascending order by the results of
                         * running each element in a collection thru each iteratee. This method
                         * performs a stable sort, that is, it preserves the original sort order of
                         * equal elements. The iteratees are invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {...(Function|Function[])} [iteratees=[_.identity]]
                         *  The iteratees to sort by.
                         * @returns {Array} Returns the new sorted array.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'fred',   'age': 48 },
                         *   { 'user': 'barney', 'age': 36 },
                         *   { 'user': 'fred',   'age': 40 },
                         *   { 'user': 'barney', 'age': 34 }
                         * ];
                         *
                         * _.sortBy(users, [function(o) { return o.user; }]);
                         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                         *
                         * _.sortBy(users, ['user', 'age']);
                         * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
                         */
                        var sortBy = baseRest(function(collection, iteratees) {
                            if (collection == null) {
                                return [];
                            }
                            var length = iteratees.length;
                            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                                iteratees = [];
                            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                                iteratees = [iteratees[0]];
                            }
                            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                        });

                        /*------------------------------------------------------------------------*/

                        /**
                         * Gets the timestamp of the number of milliseconds that have elapsed since
                         * the Unix epoch (1 January 1970 00:00:00 UTC).
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Date
                         * @returns {number} Returns the timestamp.
                         * @example
                         *
                         * _.defer(function(stamp) {
                         *   console.log(_.now() - stamp);
                         * }, _.now());
                         * // => Logs the number of milliseconds it took for the deferred invocation.
                         */
                        var now = ctxNow || function() {
                            return root.Date.now();
                        };

                        /*------------------------------------------------------------------------*/

                        /**
                         * The opposite of `_.before`; this method creates a function that invokes
                         * `func` once it's called `n` or more times.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {number} n The number of calls before `func` is invoked.
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * var saves = ['profile', 'settings'];
                         *
                         * var done = _.after(saves.length, function() {
                         *   console.log('done saving!');
                         * });
                         *
                         * _.forEach(saves, function(type) {
                         *   asyncSave({ 'type': type, 'complete': done });
                         * });
                         * // => Logs 'done saving!' after the two async saves have completed.
                         */
                        function after(n, func) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function() {
                                if (--n < 1) {
                                    return func.apply(this, arguments);
                                }
                            };
                        }

                        /**
                         * Creates a function that invokes `func`, with up to `n` arguments,
                         * ignoring any additional arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to cap arguments for.
                         * @param {number} [n=func.length] The arity cap.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new capped function.
                         * @example
                         *
                         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                         * // => [6, 8, 10]
                         */
                        function ary(func, n, guard) {
                            n = guard ? undefined : n;
                            n = (func && n == null) ? func.length : n;
                            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
                        }

                        /**
                         * Creates a function that invokes `func`, with the `this` binding and arguments
                         * of the created function, while it's called less than `n` times. Subsequent
                         * calls to the created function return the result of the last `func` invocation.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {number} n The number of calls at which `func` is no longer invoked.
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * jQuery(element).on('click', _.before(5, addContactToList));
                         * // => Allows adding up to 4 contacts to the list.
                         */
                        function before(n, func) {
                            var result;
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function() {
                                if (--n > 0) {
                                    result = func.apply(this, arguments);
                                }
                                if (n <= 1) {
                                    func = undefined;
                                }
                                return result;
                            };
                        }

                        /**
                         * Creates a function that invokes `func` with the `this` binding of `thisArg`
                         * and `partials` prepended to the arguments it receives.
                         *
                         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                         * may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
                         * property of bound functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to bind.
                         * @param {*} thisArg The `this` binding of `func`.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new bound function.
                         * @example
                         *
                         * function greet(greeting, punctuation) {
                         *   return greeting + ' ' + this.user + punctuation;
                         * }
                         *
                         * var object = { 'user': 'fred' };
                         *
                         * var bound = _.bind(greet, object, 'hi');
                         * bound('!');
                         * // => 'hi fred!'
                         *
                         * // Bound with placeholders.
                         * var bound = _.bind(greet, object, _, '!');
                         * bound('hi');
                         * // => 'hi fred!'
                         */
                        var bind = baseRest(function(func, thisArg, partials) {
                            var bitmask = WRAP_BIND_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bind));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(func, bitmask, thisArg, partials, holders);
                        });

                        /**
                         * Creates a function that invokes the method at `object[key]` with `partials`
                         * prepended to the arguments it receives.
                         *
                         * This method differs from `_.bind` by allowing bound functions to reference
                         * methods that may be redefined or don't yet exist. See
                         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                         * for more details.
                         *
                         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.10.0
                         * @category Function
                         * @param {Object} object The object to invoke the method on.
                         * @param {string} key The key of the method.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new bound function.
                         * @example
                         *
                         * var object = {
                         *   'user': 'fred',
                         *   'greet': function(greeting, punctuation) {
                         *     return greeting + ' ' + this.user + punctuation;
                         *   }
                         * };
                         *
                         * var bound = _.bindKey(object, 'greet', 'hi');
                         * bound('!');
                         * // => 'hi fred!'
                         *
                         * object.greet = function(greeting, punctuation) {
                         *   return greeting + 'ya ' + this.user + punctuation;
                         * };
                         *
                         * bound('!');
                         * // => 'hiya fred!'
                         *
                         * // Bound with placeholders.
                         * var bound = _.bindKey(object, 'greet', _, '!');
                         * bound('hi');
                         * // => 'hiya fred!'
                         */
                        var bindKey = baseRest(function(object, key, partials) {
                            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bindKey));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(key, bitmask, object, partials, holders);
                        });

                        /**
                         * Creates a function that accepts arguments of `func` and either invokes
                         * `func` returning its result, if at least `arity` number of arguments have
                         * been provided, or returns a function that accepts the remaining `func`
                         * arguments, and so on. The arity of `func` may be specified if `func.length`
                         * is not sufficient.
                         *
                         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                         * may be used as a placeholder for provided arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of curried functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Function
                         * @param {Function} func The function to curry.
                         * @param {number} [arity=func.length] The arity of `func`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new curried function.
                         * @example
                         *
                         * var abc = function(a, b, c) {
                         *   return [a, b, c];
                         * };
                         *
                         * var curried = _.curry(abc);
                         *
                         * curried(1)(2)(3);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2)(3);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2, 3);
                         * // => [1, 2, 3]
                         *
                         * // Curried with placeholders.
                         * curried(1)(_, 3)(2);
                         * // => [1, 2, 3]
                         */
                        function curry(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curry.placeholder;
                            return result;
                        }

                        /**
                         * This method is like `_.curry` except that arguments are applied to `func`
                         * in the manner of `_.partialRight` instead of `_.partial`.
                         *
                         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for provided arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of curried functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to curry.
                         * @param {number} [arity=func.length] The arity of `func`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new curried function.
                         * @example
                         *
                         * var abc = function(a, b, c) {
                         *   return [a, b, c];
                         * };
                         *
                         * var curried = _.curryRight(abc);
                         *
                         * curried(3)(2)(1);
                         * // => [1, 2, 3]
                         *
                         * curried(2, 3)(1);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2, 3);
                         * // => [1, 2, 3]
                         *
                         * // Curried with placeholders.
                         * curried(3)(1, _)(2);
                         * // => [1, 2, 3]
                         */
                        function curryRight(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryRight.placeholder;
                            return result;
                        }

                        /**
                         * Creates a debounced function that delays invoking `func` until after `wait`
                         * milliseconds have elapsed since the last time the debounced function was
                         * invoked. The debounced function comes with a `cancel` method to cancel
                         * delayed `func` invocations and a `flush` method to immediately invoke them.
                         * Provide `options` to indicate whether `func` should be invoked on the
                         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
                         * with the last arguments provided to the debounced function. Subsequent
                         * calls to the debounced function return the result of the last `func`
                         * invocation.
                         *
                         * **Note:** If `leading` and `trailing` options are `true`, `func` is
                         * invoked on the trailing edge of the timeout only if the debounced function
                         * is invoked more than once during the `wait` timeout.
                         *
                         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                         *
                         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                         * for details over the differences between `_.debounce` and `_.throttle`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to debounce.
                         * @param {number} [wait=0] The number of milliseconds to delay.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.leading=false]
                         *  Specify invoking on the leading edge of the timeout.
                         * @param {number} [options.maxWait]
                         *  The maximum time `func` is allowed to be delayed before it's invoked.
                         * @param {boolean} [options.trailing=true]
                         *  Specify invoking on the trailing edge of the timeout.
                         * @returns {Function} Returns the new debounced function.
                         * @example
                         *
                         * // Avoid costly calculations while the window size is in flux.
                         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                         *
                         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
                         * jQuery(element).on('click', _.debounce(sendMail, 300, {
                         *   'leading': true,
                         *   'trailing': false
                         * }));
                         *
                         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
                         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
                         * var source = new EventSource('/stream');
                         * jQuery(source).on('message', debounced);
                         *
                         * // Cancel the trailing debounced invocation.
                         * jQuery(window).on('popstate', debounced.cancel);
                         */
                        function debounce(func, wait, options) {
                            var lastArgs,
                                lastThis,
                                maxWait,
                                result,
                                timerId,
                                lastCallTime,
                                lastInvokeTime = 0,
                                leading = false,
                                maxing = false,
                                trailing = true;

                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            wait = toNumber(wait) || 0;
                            if (isObject(options)) {
                                leading = !!options.leading;
                                maxing = 'maxWait' in options;
                                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }

                            function invokeFunc(time) {
                                var args = lastArgs,
                                    thisArg = lastThis;

                                lastArgs = lastThis = undefined;
                                lastInvokeTime = time;
                                result = func.apply(thisArg, args);
                                return result;
                            }

                            function leadingEdge(time) {
                                // Reset any `maxWait` timer.
                                lastInvokeTime = time;
                                // Start the timer for the trailing edge.
                                timerId = setTimeout(timerExpired, wait);
                                // Invoke the leading edge.
                                return leading ? invokeFunc(time) : result;
                            }

                            function remainingWait(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime,
                                    timeWaiting = wait - timeSinceLastCall;

                                return maxing
                                    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
                                    : timeWaiting;
                            }

                            function shouldInvoke(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime;

                                // Either this is the first call, activity has stopped and we're at the
                                // trailing edge, the system time has gone backwards and we're treating
                                // it as the trailing edge, or we've hit the `maxWait` limit.
                                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
                            }

                            function timerExpired() {
                                var time = now();
                                if (shouldInvoke(time)) {
                                    return trailingEdge(time);
                                }
                                // Restart the timer.
                                timerId = setTimeout(timerExpired, remainingWait(time));
                            }

                            function trailingEdge(time) {
                                timerId = undefined;

                                // Only invoke if we have `lastArgs` which means `func` has been
                                // debounced at least once.
                                if (trailing && lastArgs) {
                                    return invokeFunc(time);
                                }
                                lastArgs = lastThis = undefined;
                                return result;
                            }

                            function cancel() {
                                if (timerId !== undefined) {
                                    clearTimeout(timerId);
                                }
                                lastInvokeTime = 0;
                                lastArgs = lastCallTime = lastThis = timerId = undefined;
                            }

                            function flush() {
                                return timerId === undefined ? result : trailingEdge(now());
                            }

                            function debounced() {
                                var time = now(),
                                    isInvoking = shouldInvoke(time);

                                lastArgs = arguments;
                                lastThis = this;
                                lastCallTime = time;

                                if (isInvoking) {
                                    if (timerId === undefined) {
                                        return leadingEdge(lastCallTime);
                                    }
                                    if (maxing) {
                                        // Handle invocations in a tight loop.
                                        timerId = setTimeout(timerExpired, wait);
                                        return invokeFunc(lastCallTime);
                                    }
                                }
                                if (timerId === undefined) {
                                    timerId = setTimeout(timerExpired, wait);
                                }
                                return result;
                            }

                            debounced.cancel = cancel;
                            debounced.flush = flush;
                            return debounced;
                        }

                        /**
                         * Defers invoking the `func` until the current call stack has cleared. Any
                         * additional arguments are provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to defer.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {number} Returns the timer id.
                         * @example
                         *
                         * _.defer(function(text) {
                         *   console.log(text);
                         * }, 'deferred');
                         * // => Logs 'deferred' after one millisecond.
                         */
                        var defer = baseRest(function(func, args) {
                            return baseDelay(func, 1, args);
                        });

                        /**
                         * Invokes `func` after `wait` milliseconds. Any additional arguments are
                         * provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {number} Returns the timer id.
                         * @example
                         *
                         * _.delay(function(text) {
                         *   console.log(text);
                         * }, 1000, 'later');
                         * // => Logs 'later' after one second.
                         */
                        var delay = baseRest(function(func, wait, args) {
                            return baseDelay(func, toNumber(wait) || 0, args);
                        });

                        /**
                         * Creates a function that invokes `func` with arguments reversed.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to flip arguments for.
                         * @returns {Function} Returns the new flipped function.
                         * @example
                         *
                         * var flipped = _.flip(function() {
                         *   return _.toArray(arguments);
                         * });
                         *
                         * flipped('a', 'b', 'c', 'd');
                         * // => ['d', 'c', 'b', 'a']
                         */
                        function flip(func) {
                            return createWrap(func, WRAP_FLIP_FLAG);
                        }

                        /**
                         * Creates a function that memoizes the result of `func`. If `resolver` is
                         * provided, it determines the cache key for storing the result based on the
                         * arguments provided to the memoized function. By default, the first argument
                         * provided to the memoized function is used as the map cache key. The `func`
                         * is invoked with the `this` binding of the memoized function.
                         *
                         * **Note:** The cache is exposed as the `cache` property on the memoized
                         * function. Its creation may be customized by replacing the `_.memoize.Cache`
                         * constructor with one whose instances implement the
                         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to have its output memoized.
                         * @param {Function} [resolver] The function to resolve the cache key.
                         * @returns {Function} Returns the new memoized function.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         * var other = { 'c': 3, 'd': 4 };
                         *
                         * var values = _.memoize(_.values);
                         * values(object);
                         * // => [1, 2]
                         *
                         * values(other);
                         * // => [3, 4]
                         *
                         * object.a = 2;
                         * values(object);
                         * // => [1, 2]
                         *
                         * // Modify the result cache.
                         * values.cache.set(object, ['a', 'b']);
                         * values(object);
                         * // => ['a', 'b']
                         *
                         * // Replace `_.memoize.Cache`.
                         * _.memoize.Cache = WeakMap;
                         */
                        function memoize(func, resolver) {
                            if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var memoized = function() {
                                var args = arguments,
                                    key = resolver ? resolver.apply(this, args) : args[0],
                                    cache = memoized.cache;

                                if (cache.has(key)) {
                                    return cache.get(key);
                                }
                                var result = func.apply(this, args);
                                memoized.cache = cache.set(key, result) || cache;
                                return result;
                            };
                            memoized.cache = new (memoize.Cache || MapCache);
                            return memoized;
                        }

                        // Expose `MapCache`.
                        memoize.Cache = MapCache;

                        /**
                         * Creates a function that negates the result of the predicate `func`. The
                         * `func` predicate is invoked with the `this` binding and arguments of the
                         * created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} predicate The predicate to negate.
                         * @returns {Function} Returns the new negated function.
                         * @example
                         *
                         * function isEven(n) {
                         *   return n % 2 == 0;
                         * }
                         *
                         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                         * // => [1, 3, 5]
                         */
                        function negate(predicate) {
                            if (typeof predicate != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return function() {
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return !predicate.call(this);
                                    case 1:
                                        return !predicate.call(this, args[0]);
                                    case 2:
                                        return !predicate.call(this, args[0], args[1]);
                                    case 3:
                                        return !predicate.call(this, args[0], args[1], args[2]);
                                }
                                return !predicate.apply(this, args);
                            };
                        }

                        /**
                         * Creates a function that is restricted to invoking `func` once. Repeat calls
                         * to the function return the value of the first invocation. The `func` is
                         * invoked with the `this` binding and arguments of the created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * var initialize = _.once(createApplication);
                         * initialize();
                         * initialize();
                         * // => `createApplication` is invoked once
                         */
                        function once(func) {
                            return before(2, func);
                        }

                        /**
                         * Creates a function that invokes `func` with its arguments transformed.
                         *
                         * @static
                         * @since 4.0.0
                         * @memberOf _
                         * @category Function
                         * @param {Function} func The function to wrap.
                         * @param {...(Function|Function[])} [transforms=[_.identity]]
                         *  The argument transforms.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * function doubled(n) {
                         *   return n * 2;
                         * }
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var func = _.overArgs(function(x, y) {
                         *   return [x, y];
                         * }, [square, doubled]);
                         *
                         * func(9, 3);
                         * // => [81, 6]
                         *
                         * func(10, 5);
                         * // => [100, 10]
                         */
                        var overArgs = castRest(function(func, transforms) {
                            transforms = (transforms.length == 1 && isArray(transforms[0]))
                                ? arrayMap(transforms[0], baseUnary(getIteratee()))
                                : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

                            var funcsLength = transforms.length;
                            return baseRest(function(args) {
                                var index = -1,
                                    length = nativeMin(args.length, funcsLength);

                                while (++index < length) {
                                    args[index] = transforms[index].call(this, args[index]);
                                }
                                return apply(func, this, args);
                            });
                        });

                        /**
                         * Creates a function that invokes `func` with `partials` prepended to the
                         * arguments it receives. This method is like `_.bind` except it does **not**
                         * alter the `this` binding.
                         *
                         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of partially
                         * applied functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.2.0
                         * @category Function
                         * @param {Function} func The function to partially apply arguments to.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new partially applied function.
                         * @example
                         *
                         * function greet(greeting, name) {
                         *   return greeting + ' ' + name;
                         * }
                         *
                         * var sayHelloTo = _.partial(greet, 'hello');
                         * sayHelloTo('fred');
                         * // => 'hello fred'
                         *
                         * // Partially applied with placeholders.
                         * var greetFred = _.partial(greet, _, 'fred');
                         * greetFred('hi');
                         * // => 'hi fred'
                         */
                        var partial = baseRest(function(func, partials) {
                            var holders = replaceHolders(partials, getHolder(partial));
                            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                        });

                        /**
                         * This method is like `_.partial` except that partially applied arguments
                         * are appended to the arguments it receives.
                         *
                         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of partially
                         * applied functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Function
                         * @param {Function} func The function to partially apply arguments to.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new partially applied function.
                         * @example
                         *
                         * function greet(greeting, name) {
                         *   return greeting + ' ' + name;
                         * }
                         *
                         * var greetFred = _.partialRight(greet, 'fred');
                         * greetFred('hi');
                         * // => 'hi fred'
                         *
                         * // Partially applied with placeholders.
                         * var sayHelloTo = _.partialRight(greet, 'hello', _);
                         * sayHelloTo('fred');
                         * // => 'hello fred'
                         */
                        var partialRight = baseRest(function(func, partials) {
                            var holders = replaceHolders(partials, getHolder(partialRight));
                            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                        });

                        /**
                         * Creates a function that invokes `func` with arguments arranged according
                         * to the specified `indexes` where the argument value at the first index is
                         * provided as the first argument, the argument value at the second index is
                         * provided as the second argument, and so on.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to rearrange arguments for.
                         * @param {...(number|number[])} indexes The arranged argument indexes.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var rearged = _.rearg(function(a, b, c) {
                         *   return [a, b, c];
                         * }, [2, 0, 1]);
                         *
                         * rearged('b', 'c', 'a')
                         * // => ['a', 'b', 'c']
                         */
                        var rearg = flatRest(function(func, indexes) {
                            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                        });

                        /**
                         * Creates a function that invokes `func` with the `this` binding of the
                         * created function and arguments from `start` and beyond provided as
                         * an array.
                         *
                         * **Note:** This method is based on the
                         * [rest parameter](https://mdn.io/rest_parameters).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var say = _.rest(function(what, names) {
                         *   return what + ' ' + _.initial(names).join(', ') +
                         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
                         * });
                         *
                         * say('hello', 'fred', 'barney', 'pebbles');
                         * // => 'hello fred, barney, & pebbles'
                         */
                        function rest(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start === undefined ? start : toInteger(start);
                            return baseRest(func, start);
                        }

                        /**
                         * Creates a function that invokes `func` with the `this` binding of the
                         * create function and an array of arguments much like
                         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
                         *
                         * **Note:** This method is based on the
                         * [spread operator](https://mdn.io/spread_operator).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Function
                         * @param {Function} func The function to spread arguments over.
                         * @param {number} [start=0] The start position of the spread.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var say = _.spread(function(who, what) {
                         *   return who + ' says ' + what;
                         * });
                         *
                         * say(['fred', 'hello']);
                         * // => 'fred says hello'
                         *
                         * var numbers = Promise.all([
                         *   Promise.resolve(40),
                         *   Promise.resolve(36)
                         * ]);
                         *
                         * numbers.then(_.spread(function(x, y) {
                         *   return x + y;
                         * }));
                         * // => a Promise of 76
                         */
                        function spread(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start == null ? 0 : nativeMax(toInteger(start), 0);
                            return baseRest(function(args) {
                                var array = args[start],
                                    otherArgs = castSlice(args, 0, start);

                                if (array) {
                                    arrayPush(otherArgs, array);
                                }
                                return apply(func, this, otherArgs);
                            });
                        }

                        /**
                         * Creates a throttled function that only invokes `func` at most once per
                         * every `wait` milliseconds. The throttled function comes with a `cancel`
                         * method to cancel delayed `func` invocations and a `flush` method to
                         * immediately invoke them. Provide `options` to indicate whether `func`
                         * should be invoked on the leading and/or trailing edge of the `wait`
                         * timeout. The `func` is invoked with the last arguments provided to the
                         * throttled function. Subsequent calls to the throttled function return the
                         * result of the last `func` invocation.
                         *
                         * **Note:** If `leading` and `trailing` options are `true`, `func` is
                         * invoked on the trailing edge of the timeout only if the throttled function
                         * is invoked more than once during the `wait` timeout.
                         *
                         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                         *
                         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                         * for details over the differences between `_.throttle` and `_.debounce`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to throttle.
                         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.leading=true]
                         *  Specify invoking on the leading edge of the timeout.
                         * @param {boolean} [options.trailing=true]
                         *  Specify invoking on the trailing edge of the timeout.
                         * @returns {Function} Returns the new throttled function.
                         * @example
                         *
                         * // Avoid excessively updating the position while scrolling.
                         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                         *
                         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
                         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
                         * jQuery(element).on('click', throttled);
                         *
                         * // Cancel the trailing throttled invocation.
                         * jQuery(window).on('popstate', throttled.cancel);
                         */
                        function throttle(func, wait, options) {
                            var leading = true,
                                trailing = true;

                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            if (isObject(options)) {
                                leading = 'leading' in options ? !!options.leading : leading;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }
                            return debounce(func, wait, {
                                'leading': leading,
                                'maxWait': wait,
                                'trailing': trailing
                            });
                        }

                        /**
                         * Creates a function that accepts up to one argument, ignoring any
                         * additional arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to cap arguments for.
                         * @returns {Function} Returns the new capped function.
                         * @example
                         *
                         * _.map(['6', '8', '10'], _.unary(parseInt));
                         * // => [6, 8, 10]
                         */
                        function unary(func) {
                            return ary(func, 1);
                        }

                        /**
                         * Creates a function that provides `value` to `wrapper` as its first
                         * argument. Any additional arguments provided to the function are appended
                         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
                         * binding of the created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {*} value The value to wrap.
                         * @param {Function} [wrapper=identity] The wrapper function.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var p = _.wrap(_.escape, function(func, text) {
                         *   return '<p>' + func(text) + '</p>';
                         * });
                         *
                         * p('fred, barney, & pebbles');
                         * // => '<p>fred, barney, &amp; pebbles</p>'
                         */
                        function wrap(value, wrapper) {
                            return partial(castFunction(wrapper), value);
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Casts `value` as an array if it's not one.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.4.0
                         * @category Lang
                         * @param {*} value The value to inspect.
                         * @returns {Array} Returns the cast array.
                         * @example
                         *
                         * _.castArray(1);
                         * // => [1]
                         *
                         * _.castArray({ 'a': 1 });
                         * // => [{ 'a': 1 }]
                         *
                         * _.castArray('abc');
                         * // => ['abc']
                         *
                         * _.castArray(null);
                         * // => [null]
                         *
                         * _.castArray(undefined);
                         * // => [undefined]
                         *
                         * _.castArray();
                         * // => []
                         *
                         * var array = [1, 2, 3];
                         * console.log(_.castArray(array) === array);
                         * // => true
                         */
                        function castArray() {
                            if (!arguments.length) {
                                return [];
                            }
                            var value = arguments[0];
                            return isArray(value) ? value : [value];
                        }

                        /**
                         * Creates a shallow clone of `value`.
                         *
                         * **Note:** This method is loosely based on the
                         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                         * and supports cloning arrays, array buffers, booleans, date objects, maps,
                         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                         * arrays. The own enumerable properties of `arguments` objects are cloned
                         * as plain objects. An empty object is returned for uncloneable values such
                         * as error objects, functions, DOM nodes, and WeakMaps.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to clone.
                         * @returns {*} Returns the cloned value.
                         * @see _.cloneDeep
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var shallow = _.clone(objects);
                         * console.log(shallow[0] === objects[0]);
                         * // => true
                         */
                        function clone(value) {
                            return baseClone(value, CLONE_SYMBOLS_FLAG);
                        }

                        /**
                         * This method is like `_.clone` except that it accepts `customizer` which
                         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
                         * cloning is handled by the method instead. The `customizer` is invoked with
                         * up to four arguments; (value [, index|key, object, stack]).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to clone.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @returns {*} Returns the cloned value.
                         * @see _.cloneDeepWith
                         * @example
                         *
                         * function customizer(value) {
                         *   if (_.isElement(value)) {
                         *     return value.cloneNode(false);
                         *   }
                         * }
                         *
                         * var el = _.cloneWith(document.body, customizer);
                         *
                         * console.log(el === document.body);
                         * // => false
                         * console.log(el.nodeName);
                         * // => 'BODY'
                         * console.log(el.childNodes.length);
                         * // => 0
                         */
                        function cloneWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                        }

                        /**
                         * This method is like `_.clone` except that it recursively clones `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Lang
                         * @param {*} value The value to recursively clone.
                         * @returns {*} Returns the deep cloned value.
                         * @see _.clone
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var deep = _.cloneDeep(objects);
                         * console.log(deep[0] === objects[0]);
                         * // => false
                         */
                        function cloneDeep(value) {
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                        }

                        /**
                         * This method is like `_.cloneWith` except that it recursively clones `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to recursively clone.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @returns {*} Returns the deep cloned value.
                         * @see _.cloneWith
                         * @example
                         *
                         * function customizer(value) {
                         *   if (_.isElement(value)) {
                         *     return value.cloneNode(true);
                         *   }
                         * }
                         *
                         * var el = _.cloneDeepWith(document.body, customizer);
                         *
                         * console.log(el === document.body);
                         * // => false
                         * console.log(el.nodeName);
                         * // => 'BODY'
                         * console.log(el.childNodes.length);
                         * // => 20
                         */
                        function cloneDeepWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                        }

                        /**
                         * Checks if `object` conforms to `source` by invoking the predicate
                         * properties of `source` with the corresponding property values of `object`.
                         *
                         * **Note:** This method is equivalent to `_.conforms` when `source` is
                         * partially applied.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.14.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         *
                         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
                         * // => true
                         *
                         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
                         * // => false
                         */
                        function conformsTo(object, source) {
                            return source == null || baseConformsTo(object, source, keys(source));
                        }

                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */
                        function eq(value, other) {
                            return value === other || (value !== value && other !== other);
                        }

                        /**
                         * Checks if `value` is greater than `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than `other`,
                         *  else `false`.
                         * @see _.lt
                         * @example
                         *
                         * _.gt(3, 1);
                         * // => true
                         *
                         * _.gt(3, 3);
                         * // => false
                         *
                         * _.gt(1, 3);
                         * // => false
                         */
                        var gt = createRelationalOperation(baseGt);

                        /**
                         * Checks if `value` is greater than or equal to `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than or equal to
                         *  `other`, else `false`.
                         * @see _.lte
                         * @example
                         *
                         * _.gte(3, 1);
                         * // => true
                         *
                         * _.gte(3, 3);
                         * // => true
                         *
                         * _.gte(1, 3);
                         * // => false
                         */
                        var gte = createRelationalOperation(function(value, other) {
                            return value >= other;
                        });

                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */
                        var isArguments = baseIsArguments(function() {
                            return arguments;
                        }()) ? baseIsArguments : function(value) {
                            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
                                !propertyIsEnumerable.call(value, 'callee');
                        };

                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */
                        var isArray = Array.isArray;

                        /**
                         * Checks if `value` is classified as an `ArrayBuffer` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                         * @example
                         *
                         * _.isArrayBuffer(new ArrayBuffer(2));
                         * // => true
                         *
                         * _.isArrayBuffer(new Array(2));
                         * // => false
                         */
                        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */
                        function isArrayLike(value) {
                            return value != null && isLength(value.length) && !isFunction(value);
                        }

                        /**
                         * This method is like `_.isArrayLike` except that it also checks if `value`
                         * is an object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array-like object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArrayLikeObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLikeObject(document.body.children);
                         * // => true
                         *
                         * _.isArrayLikeObject('abc');
                         * // => false
                         *
                         * _.isArrayLikeObject(_.noop);
                         * // => false
                         */
                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }

                        /**
                         * Checks if `value` is classified as a boolean primitive or object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
                         * @example
                         *
                         * _.isBoolean(false);
                         * // => true
                         *
                         * _.isBoolean(null);
                         * // => false
                         */
                        function isBoolean(value) {
                            return value === true || value === false ||
                                (isObjectLike(value) && baseGetTag(value) == boolTag);
                        }

                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */
                        var isBuffer = nativeIsBuffer || stubFalse;

                        /**
                         * Checks if `value` is classified as a `Date` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                         * @example
                         *
                         * _.isDate(new Date);
                         * // => true
                         *
                         * _.isDate('Mon April 23 2012');
                         * // => false
                         */
                        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

                        /**
                         * Checks if `value` is likely a DOM element.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                         * @example
                         *
                         * _.isElement(document.body);
                         * // => true
                         *
                         * _.isElement('<body>');
                         * // => false
                         */
                        function isElement(value) {
                            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                        }

                        /**
                         * Checks if `value` is an empty object, collection, map, or set.
                         *
                         * Objects are considered empty if they have no own enumerable string keyed
                         * properties.
                         *
                         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                         * jQuery-like collections are considered empty if they have a `length` of `0`.
                         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                         * @example
                         *
                         * _.isEmpty(null);
                         * // => true
                         *
                         * _.isEmpty(true);
                         * // => true
                         *
                         * _.isEmpty(1);
                         * // => true
                         *
                         * _.isEmpty([1, 2, 3]);
                         * // => false
                         *
                         * _.isEmpty({ 'a': 1 });
                         * // => false
                         */
                        function isEmpty(value) {
                            if (value == null) {
                                return true;
                            }
                            if (isArrayLike(value) &&
                                (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                                    isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                                return !value.length;
                            }
                            var tag = getTag(value);
                            if (tag == mapTag || tag == setTag) {
                                return !value.size;
                            }
                            if (isPrototype(value)) {
                                return !baseKeys(value).length;
                            }
                            for (var key in value) {
                                if (hasOwnProperty.call(value, key)) {
                                    return false;
                                }
                            }
                            return true;
                        }

                        /**
                         * Performs a deep comparison between two values to determine if they are
                         * equivalent.
                         *
                         * **Note:** This method supports comparing arrays, array buffers, booleans,
                         * date objects, error objects, maps, numbers, `Object` objects, regexes,
                         * sets, strings, symbols, and typed arrays. `Object` objects are compared
                         * by their own, not inherited, enumerable properties. Functions and DOM
                         * nodes are compared by strict equality, i.e. `===`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.isEqual(object, other);
                         * // => true
                         *
                         * object === other;
                         * // => false
                         */
                        function isEqual(value, other) {
                            return baseIsEqual(value, other);
                        }

                        /**
                         * This method is like `_.isEqual` except that it accepts `customizer` which
                         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                         * are handled by the method instead. The `customizer` is invoked with up to
                         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * function isGreeting(value) {
                         *   return /^h(?:i|ello)$/.test(value);
                         * }
                         *
                         * function customizer(objValue, othValue) {
                         *   if (isGreeting(objValue) && isGreeting(othValue)) {
                         *     return true;
                         *   }
                         * }
                         *
                         * var array = ['hello', 'goodbye'];
                         * var other = ['hi', 'goodbye'];
                         *
                         * _.isEqualWith(array, other, customizer);
                         * // => true
                         */
                        function isEqualWith(value, other, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            var result = customizer ? customizer(value, other) : undefined;
                            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
                        }

                        /**
                         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                         * `SyntaxError`, `TypeError`, or `URIError` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                         * @example
                         *
                         * _.isError(new Error);
                         * // => true
                         *
                         * _.isError(Error);
                         * // => false
                         */
                        function isError(value) {
                            if (!isObjectLike(value)) {
                                return false;
                            }
                            var tag = baseGetTag(value);
                            return tag == errorTag || tag == domExcTag ||
                                (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
                        }

                        /**
                         * Checks if `value` is a finite primitive number.
                         *
                         * **Note:** This method is based on
                         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                         * @example
                         *
                         * _.isFinite(3);
                         * // => true
                         *
                         * _.isFinite(Number.MIN_VALUE);
                         * // => true
                         *
                         * _.isFinite(Infinity);
                         * // => false
                         *
                         * _.isFinite('3');
                         * // => false
                         */
                        function isFinite(value) {
                            return typeof value == 'number' && nativeIsFinite(value);
                        }

                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */
                        function isFunction(value) {
                            if (!isObject(value)) {
                                return false;
                            }
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 9 which returns 'object' for typed arrays and other constructors.
                            var tag = baseGetTag(value);
                            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                        }

                        /**
                         * Checks if `value` is an integer.
                         *
                         * **Note:** This method is based on
                         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
                         * @example
                         *
                         * _.isInteger(3);
                         * // => true
                         *
                         * _.isInteger(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isInteger(Infinity);
                         * // => false
                         *
                         * _.isInteger('3');
                         * // => false
                         */
                        function isInteger(value) {
                            return typeof value == 'number' && value == toInteger(value);
                        }

                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */
                        function isLength(value) {
                            return typeof value == 'number' &&
                                value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                        }

                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */
                        function isObject(value) {
                            var type = typeof value;
                            return value != null && (type == 'object' || type == 'function');
                        }

                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */
                        function isObjectLike(value) {
                            return value != null && typeof value == 'object';
                        }

                        /**
                         * Checks if `value` is classified as a `Map` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                         * @example
                         *
                         * _.isMap(new Map);
                         * // => true
                         *
                         * _.isMap(new WeakMap);
                         * // => false
                         */
                        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

                        /**
                         * Performs a partial deep comparison between `object` and `source` to
                         * determine if `object` contains equivalent property values.
                         *
                         * **Note:** This method is equivalent to `_.matches` when `source` is
                         * partially applied.
                         *
                         * Partial comparisons will match empty array and empty object `source`
                         * values against any array or object value, respectively. See `_.isEqual`
                         * for a list of supported value comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         *
                         * _.isMatch(object, { 'b': 2 });
                         * // => true
                         *
                         * _.isMatch(object, { 'b': 1 });
                         * // => false
                         */
                        function isMatch(object, source) {
                            return object === source || baseIsMatch(object, source, getMatchData(source));
                        }

                        /**
                         * This method is like `_.isMatch` except that it accepts `customizer` which
                         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                         * are handled by the method instead. The `customizer` is invoked with five
                         * arguments: (objValue, srcValue, index|key, object, source).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         * @example
                         *
                         * function isGreeting(value) {
                         *   return /^h(?:i|ello)$/.test(value);
                         * }
                         *
                         * function customizer(objValue, srcValue) {
                         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
                         *     return true;
                         *   }
                         * }
                         *
                         * var object = { 'greeting': 'hello' };
                         * var source = { 'greeting': 'hi' };
                         *
                         * _.isMatchWith(object, source, customizer);
                         * // => true
                         */
                        function isMatchWith(object, source, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseIsMatch(object, source, getMatchData(source), customizer);
                        }

                        /**
                         * Checks if `value` is `NaN`.
                         *
                         * **Note:** This method is based on
                         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
                         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
                         * `undefined` and other non-number values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                         * @example
                         *
                         * _.isNaN(NaN);
                         * // => true
                         *
                         * _.isNaN(new Number(NaN));
                         * // => true
                         *
                         * isNaN(undefined);
                         * // => true
                         *
                         * _.isNaN(undefined);
                         * // => false
                         */
                        function isNaN(value) {
                            // An `NaN` primitive is the only value that is not equal to itself.
                            // Perform the `toStringTag` check first to avoid errors with some
                            // ActiveX objects in IE.
                            return isNumber(value) && value != +value;
                        }

                        /**
                         * Checks if `value` is a pristine native function.
                         *
                         * **Note:** This method can't reliably detect native functions in the presence
                         * of the core-js package because core-js circumvents this kind of detection.
                         * Despite multiple requests, the core-js maintainer has made it clear: any
                         * attempt to fix the detection will be obstructed. As a result, we're left
                         * with little choice but to throw an error. Unfortunately, this also affects
                         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
                         * which rely on core-js.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         * @example
                         *
                         * _.isNative(Array.prototype.push);
                         * // => true
                         *
                         * _.isNative(_);
                         * // => false
                         */
                        function isNative(value) {
                            if (isMaskable(value)) {
                                throw new Error(CORE_ERROR_TEXT);
                            }
                            return baseIsNative(value);
                        }

                        /**
                         * Checks if `value` is `null`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                         * @example
                         *
                         * _.isNull(null);
                         * // => true
                         *
                         * _.isNull(void 0);
                         * // => false
                         */
                        function isNull(value) {
                            return value === null;
                        }

                        /**
                         * Checks if `value` is `null` or `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
                         * @example
                         *
                         * _.isNil(null);
                         * // => true
                         *
                         * _.isNil(void 0);
                         * // => true
                         *
                         * _.isNil(NaN);
                         * // => false
                         */
                        function isNil(value) {
                            return value == null;
                        }

                        /**
                         * Checks if `value` is classified as a `Number` primitive or object.
                         *
                         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
                         * classified as numbers, use the `_.isFinite` method.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
                         * @example
                         *
                         * _.isNumber(3);
                         * // => true
                         *
                         * _.isNumber(Number.MIN_VALUE);
                         * // => true
                         *
                         * _.isNumber(Infinity);
                         * // => true
                         *
                         * _.isNumber('3');
                         * // => false
                         */
                        function isNumber(value) {
                            return typeof value == 'number' ||
                                (isObjectLike(value) && baseGetTag(value) == numberTag);
                        }

                        /**
                         * Checks if `value` is a plain object, that is, an object created by the
                         * `Object` constructor or one with a `[[Prototype]]` of `null`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.8.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * _.isPlainObject(new Foo);
                         * // => false
                         *
                         * _.isPlainObject([1, 2, 3]);
                         * // => false
                         *
                         * _.isPlainObject({ 'x': 0, 'y': 0 });
                         * // => true
                         *
                         * _.isPlainObject(Object.create(null));
                         * // => true
                         */
                        function isPlainObject(value) {
                            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                                return false;
                            }
                            var proto = getPrototype(value);
                            if (proto === null) {
                                return true;
                            }
                            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                            return typeof Ctor == 'function' && Ctor instanceof Ctor &&
                                funcToString.call(Ctor) == objectCtorString;
                        }

                        /**
                         * Checks if `value` is classified as a `RegExp` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                         * @example
                         *
                         * _.isRegExp(/abc/);
                         * // => true
                         *
                         * _.isRegExp('/abc/');
                         * // => false
                         */
                        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

                        /**
                         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
                         * double precision number which isn't the result of a rounded unsafe integer.
                         *
                         * **Note:** This method is based on
                         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
                         * @example
                         *
                         * _.isSafeInteger(3);
                         * // => true
                         *
                         * _.isSafeInteger(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isSafeInteger(Infinity);
                         * // => false
                         *
                         * _.isSafeInteger('3');
                         * // => false
                         */
                        function isSafeInteger(value) {
                            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                        }

                        /**
                         * Checks if `value` is classified as a `Set` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                         * @example
                         *
                         * _.isSet(new Set);
                         * // => true
                         *
                         * _.isSet(new WeakSet);
                         * // => false
                         */
                        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

                        /**
                         * Checks if `value` is classified as a `String` primitive or object.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
                         * @example
                         *
                         * _.isString('abc');
                         * // => true
                         *
                         * _.isString(1);
                         * // => false
                         */
                        function isString(value) {
                            return typeof value == 'string' ||
                                (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
                        }

                        /**
                         * Checks if `value` is classified as a `Symbol` primitive or object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                         * @example
                         *
                         * _.isSymbol(Symbol.iterator);
                         * // => true
                         *
                         * _.isSymbol('abc');
                         * // => false
                         */
                        function isSymbol(value) {
                            return typeof value == 'symbol' ||
                                (isObjectLike(value) && baseGetTag(value) == symbolTag);
                        }

                        /**
                         * Checks if `value` is classified as a typed array.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         * @example
                         *
                         * _.isTypedArray(new Uint8Array);
                         * // => true
                         *
                         * _.isTypedArray([]);
                         * // => false
                         */
                        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

                        /**
                         * Checks if `value` is `undefined`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                         * @example
                         *
                         * _.isUndefined(void 0);
                         * // => true
                         *
                         * _.isUndefined(null);
                         * // => false
                         */
                        function isUndefined(value) {
                            return value === undefined;
                        }

                        /**
                         * Checks if `value` is classified as a `WeakMap` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
                         * @example
                         *
                         * _.isWeakMap(new WeakMap);
                         * // => true
                         *
                         * _.isWeakMap(new Map);
                         * // => false
                         */
                        function isWeakMap(value) {
                            return isObjectLike(value) && getTag(value) == weakMapTag;
                        }

                        /**
                         * Checks if `value` is classified as a `WeakSet` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
                         * @example
                         *
                         * _.isWeakSet(new WeakSet);
                         * // => true
                         *
                         * _.isWeakSet(new Set);
                         * // => false
                         */
                        function isWeakSet(value) {
                            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                        }

                        /**
                         * Checks if `value` is less than `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than `other`,
                         *  else `false`.
                         * @see _.gt
                         * @example
                         *
                         * _.lt(1, 3);
                         * // => true
                         *
                         * _.lt(3, 3);
                         * // => false
                         *
                         * _.lt(3, 1);
                         * // => false
                         */
                        var lt = createRelationalOperation(baseLt);

                        /**
                         * Checks if `value` is less than or equal to `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than or equal to
                         *  `other`, else `false`.
                         * @see _.gte
                         * @example
                         *
                         * _.lte(1, 3);
                         * // => true
                         *
                         * _.lte(3, 3);
                         * // => true
                         *
                         * _.lte(3, 1);
                         * // => false
                         */
                        var lte = createRelationalOperation(function(value, other) {
                            return value <= other;
                        });

                        /**
                         * Converts `value` to an array.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {Array} Returns the converted array.
                         * @example
                         *
                         * _.toArray({ 'a': 1, 'b': 2 });
                         * // => [1, 2]
                         *
                         * _.toArray('abc');
                         * // => ['a', 'b', 'c']
                         *
                         * _.toArray(1);
                         * // => []
                         *
                         * _.toArray(null);
                         * // => []
                         */
                        function toArray(value) {
                            if (!value) {
                                return [];
                            }
                            if (isArrayLike(value)) {
                                return isString(value) ? stringToArray(value) : copyArray(value);
                            }
                            if (symIterator && value[symIterator]) {
                                return iteratorToArray(value[symIterator]());
                            }
                            var tag = getTag(value),
                                func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

                            return func(value);
                        }

                        /**
                         * Converts `value` to a finite number.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.12.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted number.
                         * @example
                         *
                         * _.toFinite(3.2);
                         * // => 3.2
                         *
                         * _.toFinite(Number.MIN_VALUE);
                         * // => 5e-324
                         *
                         * _.toFinite(Infinity);
                         * // => 1.7976931348623157e+308
                         *
                         * _.toFinite('3.2');
                         * // => 3.2
                         */
                        function toFinite(value) {
                            if (!value) {
                                return value === 0 ? value : 0;
                            }
                            value = toNumber(value);
                            if (value === INFINITY || value === -INFINITY) {
                                var sign = (value < 0 ? -1 : 1);
                                return sign * MAX_INTEGER;
                            }
                            return value === value ? value : 0;
                        }

                        /**
                         * Converts `value` to an integer.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toInteger(3.2);
                         * // => 3
                         *
                         * _.toInteger(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toInteger(Infinity);
                         * // => 1.7976931348623157e+308
                         *
                         * _.toInteger('3.2');
                         * // => 3
                         */
                        function toInteger(value) {
                            var result = toFinite(value),
                                remainder = result % 1;

                            return result === result ? (remainder ? result - remainder : result) : 0;
                        }

                        /**
                         * Converts `value` to an integer suitable for use as the length of an
                         * array-like object.
                         *
                         * **Note:** This method is based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toLength(3.2);
                         * // => 3
                         *
                         * _.toLength(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toLength(Infinity);
                         * // => 4294967295
                         *
                         * _.toLength('3.2');
                         * // => 3
                         */
                        function toLength(value) {
                            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                        }

                        /**
                         * Converts `value` to a number.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to process.
                         * @returns {number} Returns the number.
                         * @example
                         *
                         * _.toNumber(3.2);
                         * // => 3.2
                         *
                         * _.toNumber(Number.MIN_VALUE);
                         * // => 5e-324
                         *
                         * _.toNumber(Infinity);
                         * // => Infinity
                         *
                         * _.toNumber('3.2');
                         * // => 3.2
                         */
                        function toNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            if (isObject(value)) {
                                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                                value = isObject(other) ? (other + '') : other;
                            }
                            if (typeof value != 'string') {
                                return value === 0 ? value : +value;
                            }
                            value = value.replace(reTrim, '');
                            var isBinary = reIsBinary.test(value);
                            return (isBinary || reIsOctal.test(value))
                                ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                                : (reIsBadHex.test(value) ? NAN : +value);
                        }

                        /**
                         * Converts `value` to a plain object flattening inherited enumerable string
                         * keyed properties of `value` to own properties of the plain object.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {Object} Returns the converted plain object.
                         * @example
                         *
                         * function Foo() {
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.assign({ 'a': 1 }, new Foo);
                         * // => { 'a': 1, 'b': 2 }
                         *
                         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                         * // => { 'a': 1, 'b': 2, 'c': 3 }
                         */
                        function toPlainObject(value) {
                            return copyObject(value, keysIn(value));
                        }

                        /**
                         * Converts `value` to a safe integer. A safe integer can be compared and
                         * represented correctly.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toSafeInteger(3.2);
                         * // => 3
                         *
                         * _.toSafeInteger(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toSafeInteger(Infinity);
                         * // => 9007199254740991
                         *
                         * _.toSafeInteger('3.2');
                         * // => 3
                         */
                        function toSafeInteger(value) {
                            return value
                                ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
                                : (value === 0 ? value : 0);
                        }

                        /**
                         * Converts `value` to a string. An empty string is returned for `null`
                         * and `undefined` values. The sign of `-0` is preserved.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.toString(null);
                         * // => ''
                         *
                         * _.toString(-0);
                         * // => '-0'
                         *
                         * _.toString([1, 2, 3]);
                         * // => '1,2,3'
                         */
                        function toString(value) {
                            return value == null ? '' : baseToString(value);
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Assigns own enumerable string keyed properties of source objects to the
                         * destination object. Source objects are applied from left to right.
                         * Subsequent sources overwrite property assignments of previous sources.
                         *
                         * **Note:** This method mutates `object` and is loosely based on
                         * [`Object.assign`](https://mdn.io/Object/assign).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.10.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.assignIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * function Bar() {
                         *   this.c = 3;
                         * }
                         *
                         * Foo.prototype.b = 2;
                         * Bar.prototype.d = 4;
                         *
                         * _.assign({ 'a': 0 }, new Foo, new Bar);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        var assign = createAssigner(function(object, source) {
                            if (isPrototype(source) || isArrayLike(source)) {
                                copyObject(source, keys(source), object);
                                return;
                            }
                            for (var key in source) {
                                if (hasOwnProperty.call(source, key)) {
                                    assignValue(object, key, source[key]);
                                }
                            }
                        });

                        /**
                         * This method is like `_.assign` except that it iterates over own and
                         * inherited source properties.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias extend
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.assign
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * function Bar() {
                         *   this.c = 3;
                         * }
                         *
                         * Foo.prototype.b = 2;
                         * Bar.prototype.d = 4;
                         *
                         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
                         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
                         */
                        var assignIn = createAssigner(function(object, source) {
                            copyObject(source, keysIn(source), object);
                        });

                        /**
                         * This method is like `_.assignIn` except that it accepts `customizer`
                         * which is invoked to produce the assigned values. If `customizer` returns
                         * `undefined`, assignment is handled by the method instead. The `customizer`
                         * is invoked with five arguments: (objValue, srcValue, key, object, source).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias extendWith
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @see _.assignWith
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   return _.isUndefined(objValue) ? srcValue : objValue;
                         * }
                         *
                         * var defaults = _.partialRight(_.assignInWith, customizer);
                         *
                         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                            copyObject(source, keysIn(source), object, customizer);
                        });

                        /**
                         * This method is like `_.assign` except that it accepts `customizer`
                         * which is invoked to produce the assigned values. If `customizer` returns
                         * `undefined`, assignment is handled by the method instead. The `customizer`
                         * is invoked with five arguments: (objValue, srcValue, key, object, source).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @see _.assignInWith
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   return _.isUndefined(objValue) ? srcValue : objValue;
                         * }
                         *
                         * var defaults = _.partialRight(_.assignWith, customizer);
                         *
                         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                            copyObject(source, keys(source), object, customizer);
                        });

                        /**
                         * Creates an array of values corresponding to `paths` of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Array} Returns the picked values.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                         *
                         * _.at(object, ['a[0].b.c', 'a[1]']);
                         * // => [3, 4]
                         */
                        var at = flatRest(baseAt);

                        /**
                         * Creates an object that inherits from the `prototype` object. If a
                         * `properties` object is given, its own enumerable string keyed properties
                         * are assigned to the created object.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.3.0
                         * @category Object
                         * @param {Object} prototype The object to inherit from.
                         * @param {Object} [properties] The properties to assign to the object.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * function Shape() {
                         *   this.x = 0;
                         *   this.y = 0;
                         * }
                         *
                         * function Circle() {
                         *   Shape.call(this);
                         * }
                         *
                         * Circle.prototype = _.create(Shape.prototype, {
                         *   'constructor': Circle
                         * });
                         *
                         * var circle = new Circle;
                         * circle instanceof Circle;
                         * // => true
                         *
                         * circle instanceof Shape;
                         * // => true
                         */
                        function create(prototype, properties) {
                            var result = baseCreate(prototype);
                            return properties == null ? result : baseAssign(result, properties);
                        }

                        /**
                         * Assigns own and inherited enumerable string keyed properties of source
                         * objects to the destination object for all destination properties that
                         * resolve to `undefined`. Source objects are applied from left to right.
                         * Once a property is set, additional values of the same property are ignored.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.defaultsDeep
                         * @example
                         *
                         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var defaults = baseRest(function(object, sources) {
                            object = Object(object);

                            var index = -1;
                            var length = sources.length;
                            var guard = length > 2 ? sources[2] : undefined;

                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                length = 1;
                            }

                            while (++index < length) {
                                var source = sources[index];
                                var props = keysIn(source);
                                var propsIndex = -1;
                                var propsLength = props.length;

                                while (++propsIndex < propsLength) {
                                    var key = props[propsIndex];
                                    var value = object[key];

                                    if (value === undefined ||
                                        (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                        object[key] = source[key];
                                    }
                                }
                            }

                            return object;
                        });

                        /**
                         * This method is like `_.defaults` except that it recursively assigns
                         * default properties.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.defaults
                         * @example
                         *
                         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
                         * // => { 'a': { 'b': 2, 'c': 3 } }
                         */
                        var defaultsDeep = baseRest(function(args) {
                            args.push(undefined, customDefaultsMerge);
                            return apply(mergeWith, undefined, args);
                        });

                        /**
                         * This method is like `_.find` except that it returns the key of the first
                         * element `predicate` returns truthy for instead of the element itself.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {string|undefined} Returns the key of the matched element,
                         *  else `undefined`.
                         * @example
                         *
                         * var users = {
                         *   'barney':  { 'age': 36, 'active': true },
                         *   'fred':    { 'age': 40, 'active': false },
                         *   'pebbles': { 'age': 1,  'active': true }
                         * };
                         *
                         * _.findKey(users, function(o) { return o.age < 40; });
                         * // => 'barney' (iteration order is not guaranteed)
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findKey(users, { 'age': 1, 'active': true });
                         * // => 'pebbles'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findKey(users, ['active', false]);
                         * // => 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findKey(users, 'active');
                         * // => 'barney'
                         */
                        function findKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                        }

                        /**
                         * This method is like `_.findKey` except that it iterates over elements of
                         * a collection in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {string|undefined} Returns the key of the matched element,
                         *  else `undefined`.
                         * @example
                         *
                         * var users = {
                         *   'barney':  { 'age': 36, 'active': true },
                         *   'fred':    { 'age': 40, 'active': false },
                         *   'pebbles': { 'age': 1,  'active': true }
                         * };
                         *
                         * _.findLastKey(users, function(o) { return o.age < 40; });
                         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findLastKey(users, { 'age': 36, 'active': true });
                         * // => 'barney'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findLastKey(users, ['active', false]);
                         * // => 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findLastKey(users, 'active');
                         * // => 'pebbles'
                         */
                        function findLastKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                        }

                        /**
                         * Iterates over own and inherited enumerable string keyed properties of an
                         * object and invokes `iteratee` for each property. The iteratee is invoked
                         * with three arguments: (value, key, object). Iteratee functions may exit
                         * iteration early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forInRight
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forIn(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
                         */
                        function forIn(object, iteratee) {
                            return object == null
                                ? object
                                : baseFor(object, getIteratee(iteratee, 3), keysIn);
                        }

                        /**
                         * This method is like `_.forIn` except that it iterates over properties of
                         * `object` in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forInRight(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
                         */
                        function forInRight(object, iteratee) {
                            return object == null
                                ? object
                                : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                        }

                        /**
                         * Iterates over own enumerable string keyed properties of an object and
                         * invokes `iteratee` for each property. The iteratee is invoked with three
                         * arguments: (value, key, object). Iteratee functions may exit iteration
                         * early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forOwnRight
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forOwn(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                         */
                        function forOwn(object, iteratee) {
                            return object && baseForOwn(object, getIteratee(iteratee, 3));
                        }

                        /**
                         * This method is like `_.forOwn` except that it iterates over properties of
                         * `object` in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forOwn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forOwnRight(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
                         */
                        function forOwnRight(object, iteratee) {
                            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                        }

                        /**
                         * Creates an array of function property names from own enumerable properties
                         * of `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @returns {Array} Returns the function names.
                         * @see _.functionsIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = _.constant('a');
                         *   this.b = _.constant('b');
                         * }
                         *
                         * Foo.prototype.c = _.constant('c');
                         *
                         * _.functions(new Foo);
                         * // => ['a', 'b']
                         */
                        function functions(object) {
                            return object == null ? [] : baseFunctions(object, keys(object));
                        }

                        /**
                         * Creates an array of function property names from own and inherited
                         * enumerable properties of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @returns {Array} Returns the function names.
                         * @see _.functions
                         * @example
                         *
                         * function Foo() {
                         *   this.a = _.constant('a');
                         *   this.b = _.constant('b');
                         * }
                         *
                         * Foo.prototype.c = _.constant('c');
                         *
                         * _.functionsIn(new Foo);
                         * // => ['a', 'b', 'c']
                         */
                        function functionsIn(object) {
                            return object == null ? [] : baseFunctions(object, keysIn(object));
                        }

                        /**
                         * Gets the value at `path` of `object`. If the resolved value is
                         * `undefined`, the `defaultValue` is returned in its place.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to get.
                         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.get(object, 'a[0].b.c');
                         * // => 3
                         *
                         * _.get(object, ['a', '0', 'b', 'c']);
                         * // => 3
                         *
                         * _.get(object, 'a.b.c', 'default');
                         * // => 'default'
                         */
                        function get(object, path, defaultValue) {
                            var result = object == null ? undefined : baseGet(object, path);
                            return result === undefined ? defaultValue : result;
                        }

                        /**
                         * Checks if `path` is a direct property of `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         * @example
                         *
                         * var object = { 'a': { 'b': 2 } };
                         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
                         *
                         * _.has(object, 'a');
                         * // => true
                         *
                         * _.has(object, 'a.b');
                         * // => true
                         *
                         * _.has(object, ['a', 'b']);
                         * // => true
                         *
                         * _.has(other, 'a');
                         * // => false
                         */
                        function has(object, path) {
                            return object != null && hasPath(object, path, baseHas);
                        }

                        /**
                         * Checks if `path` is a direct or inherited property of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         * @example
                         *
                         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                         *
                         * _.hasIn(object, 'a');
                         * // => true
                         *
                         * _.hasIn(object, 'a.b');
                         * // => true
                         *
                         * _.hasIn(object, ['a', 'b']);
                         * // => true
                         *
                         * _.hasIn(object, 'b');
                         * // => false
                         */
                        function hasIn(object, path) {
                            return object != null && hasPath(object, path, baseHasIn);
                        }

                        /**
                         * Creates an object composed of the inverted keys and values of `object`.
                         * If `object` contains duplicate values, subsequent values overwrite
                         * property assignments of previous values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.7.0
                         * @category Object
                         * @param {Object} object The object to invert.
                         * @returns {Object} Returns the new inverted object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2, 'c': 1 };
                         *
                         * _.invert(object);
                         * // => { '1': 'c', '2': 'b' }
                         */
                        var invert = createInverter(function(result, value, key) {
                            if (value != null &&
                                typeof value.toString != 'function') {
                                value = nativeObjectToString.call(value);
                            }

                            result[value] = key;
                        }, constant(identity));

                        /**
                         * This method is like `_.invert` except that the inverted object is generated
                         * from the results of running each element of `object` thru `iteratee`. The
                         * corresponding inverted value of each inverted key is an array of keys
                         * responsible for generating the inverted value. The iteratee is invoked
                         * with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.1.0
                         * @category Object
                         * @param {Object} object The object to invert.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Object} Returns the new inverted object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2, 'c': 1 };
                         *
                         * _.invertBy(object);
                         * // => { '1': ['a', 'c'], '2': ['b'] }
                         *
                         * _.invertBy(object, function(value) {
                         *   return 'group' + value;
                         * });
                         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
                         */
                        var invertBy = createInverter(function(result, value, key) {
                            if (value != null &&
                                typeof value.toString != 'function') {
                                value = nativeObjectToString.call(value);
                            }

                            if (hasOwnProperty.call(result, value)) {
                                result[value].push(key);
                            } else {
                                result[value] = [key];
                            }
                        }, getIteratee);

                        /**
                         * Invokes the method at `path` of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {*} Returns the result of the invoked method.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
                         *
                         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
                         * // => [2, 3]
                         */
                        var invoke = baseRest(baseInvoke);

                        /**
                         * Creates an array of the own enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects. See the
                         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * for more details.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keys(new Foo);
                         * // => ['a', 'b'] (iteration order is not guaranteed)
                         *
                         * _.keys('hi');
                         * // => ['0', '1']
                         */
                        function keys(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                        }

                        /**
                         * Creates an array of the own and inherited enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keysIn(new Foo);
                         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                         */
                        function keysIn(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                        }

                        /**
                         * The opposite of `_.mapValues`; this method creates an object with the
                         * same values as `object` and keys generated by running each own enumerable
                         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
                         * with three arguments: (value, key, object).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns the new mapped object.
                         * @see _.mapValues
                         * @example
                         *
                         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
                         *   return key + value;
                         * });
                         * // => { 'a1': 1, 'b2': 2 }
                         */
                        function mapKeys(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);

                            baseForOwn(object, function(value, key, object) {
                                baseAssignValue(result, iteratee(value, key, object), value);
                            });
                            return result;
                        }

                        /**
                         * Creates an object with the same keys as `object` and values generated
                         * by running each own enumerable string keyed property of `object` thru
                         * `iteratee`. The iteratee is invoked with three arguments:
                         * (value, key, object).
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns the new mapped object.
                         * @see _.mapKeys
                         * @example
                         *
                         * var users = {
                         *   'fred':    { 'user': 'fred',    'age': 40 },
                         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                         * };
                         *
                         * _.mapValues(users, function(o) { return o.age; });
                         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.mapValues(users, 'age');
                         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                         */
                        function mapValues(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);

                            baseForOwn(object, function(value, key, object) {
                                baseAssignValue(result, key, iteratee(value, key, object));
                            });
                            return result;
                        }

                        /**
                         * This method is like `_.assign` except that it recursively merges own and
                         * inherited enumerable string keyed properties of source objects into the
                         * destination object. Source properties that resolve to `undefined` are
                         * skipped if a destination value exists. Array and plain object properties
                         * are merged recursively. Other objects and value types are overridden by
                         * assignment. Source objects are applied from left to right. Subsequent
                         * sources overwrite property assignments of previous sources.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {
                         *   'a': [{ 'b': 2 }, { 'd': 4 }]
                         * };
                         *
                         * var other = {
                         *   'a': [{ 'c': 3 }, { 'e': 5 }]
                         * };
                         *
                         * _.merge(object, other);
                         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
                         */
                        var merge = createAssigner(function(object, source, srcIndex) {
                            baseMerge(object, source, srcIndex);
                        });

                        /**
                         * This method is like `_.merge` except that it accepts `customizer` which
                         * is invoked to produce the merged values of the destination and source
                         * properties. If `customizer` returns `undefined`, merging is handled by the
                         * method instead. The `customizer` is invoked with six arguments:
                         * (objValue, srcValue, key, object, source, stack).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} customizer The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   if (_.isArray(objValue)) {
                         *     return objValue.concat(srcValue);
                         *   }
                         * }
                         *
                         * var object = { 'a': [1], 'b': [2] };
                         * var other = { 'a': [3], 'b': [4] };
                         *
                         * _.mergeWith(object, other, customizer);
                         * // => { 'a': [1, 3], 'b': [2, 4] }
                         */
                        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                            baseMerge(object, source, srcIndex, customizer);
                        });

                        /**
                         * The opposite of `_.pick`; this method creates an object composed of the
                         * own and inherited enumerable property paths of `object` that are not omitted.
                         *
                         * **Note:** This method is considerably slower than `_.pick`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {...(string|string[])} [paths] The property paths to omit.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.omit(object, ['a', 'c']);
                         * // => { 'b': '2' }
                         */
                        var omit = flatRest(function(object, paths) {
                            var result = {};
                            if (object == null) {
                                return result;
                            }
                            var isDeep = false;
                            paths = arrayMap(paths, function(path) {
                                path = castPath(path, object);
                                isDeep || (isDeep = path.length > 1);
                                return path;
                            });
                            copyObject(object, getAllKeysIn(object), result);
                            if (isDeep) {
                                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                            }
                            var length = paths.length;
                            while (length--) {
                                baseUnset(result, paths[length]);
                            }
                            return result;
                        });

                        /**
                         * The opposite of `_.pickBy`; this method creates an object composed of
                         * the own and inherited enumerable string keyed properties of `object` that
                         * `predicate` doesn't return truthy for. The predicate is invoked with two
                         * arguments: (value, key).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {Function} [predicate=_.identity] The function invoked per property.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.omitBy(object, _.isNumber);
                         * // => { 'b': '2' }
                         */
                        function omitBy(object, predicate) {
                            return pickBy(object, negate(getIteratee(predicate)));
                        }

                        /**
                         * Creates an object composed of the picked `object` properties.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.pick(object, ['a', 'c']);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        var pick = flatRest(function(object, paths) {
                            return object == null ? {} : basePick(object, paths);
                        });

                        /**
                         * Creates an object composed of the `object` properties `predicate` returns
                         * truthy for. The predicate is invoked with two arguments: (value, key).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {Function} [predicate=_.identity] The function invoked per property.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.pickBy(object, _.isNumber);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        function pickBy(object, predicate) {
                            if (object == null) {
                                return {};
                            }
                            var props = arrayMap(getAllKeysIn(object), function(prop) {
                                return [prop];
                            });
                            predicate = getIteratee(predicate);
                            return basePickBy(object, props, function(value, path) {
                                return predicate(value, path[0]);
                            });
                        }

                        /**
                         * This method is like `_.get` except that if the resolved value is a
                         * function it's invoked with the `this` binding of its parent object and
                         * its result is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to resolve.
                         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                         *
                         * _.result(object, 'a[0].b.c1');
                         * // => 3
                         *
                         * _.result(object, 'a[0].b.c2');
                         * // => 4
                         *
                         * _.result(object, 'a[0].b.c3', 'default');
                         * // => 'default'
                         *
                         * _.result(object, 'a[0].b.c3', _.constant('default'));
                         * // => 'default'
                         */
                        function result(object, path, defaultValue) {
                            path = castPath(path, object);

                            var index = -1,
                                length = path.length;

                            // Ensure the loop is entered when path is empty.
                            if (!length) {
                                length = 1;
                                object = undefined;
                            }
                            while (++index < length) {
                                var value = object == null ? undefined : object[toKey(path[index])];
                                if (value === undefined) {
                                    index = length;
                                    value = defaultValue;
                                }
                                object = isFunction(value) ? value.call(object) : value;
                            }
                            return object;
                        }

                        /**
                         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
                         * it's created. Arrays are created for missing index properties while objects
                         * are created for all other missing properties. Use `_.setWith` to customize
                         * `path` creation.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.set(object, 'a[0].b.c', 4);
                         * console.log(object.a[0].b.c);
                         * // => 4
                         *
                         * _.set(object, ['x', '0', 'y', 'z'], 5);
                         * console.log(object.x[0].y.z);
                         * // => 5
                         */
                        function set(object, path, value) {
                            return object == null ? object : baseSet(object, path, value);
                        }

                        /**
                         * This method is like `_.set` except that it accepts `customizer` which is
                         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                         * path creation is handled by the method instead. The `customizer` is invoked
                         * with three arguments: (nsValue, key, nsObject).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {};
                         *
                         * _.setWith(object, '[0][1]', 'a', Object);
                         * // => { '0': { '1': 'a' } }
                         */
                        function setWith(object, path, value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseSet(object, path, value, customizer);
                        }

                        /**
                         * Creates an array of own enumerable string keyed-value pairs for `object`
                         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
                         * entries are returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias entries
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the key-value pairs.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.toPairs(new Foo);
                         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
                         */
                        var toPairs = createToPairs(keys);

                        /**
                         * Creates an array of own and inherited enumerable string keyed-value pairs
                         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
                         * or set, its entries are returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias entriesIn
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the key-value pairs.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.toPairsIn(new Foo);
                         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
                         */
                        var toPairsIn = createToPairs(keysIn);

                        /**
                         * An alternative to `_.reduce`; this method transforms `object` to a new
                         * `accumulator` object which is the result of running each of its own
                         * enumerable string keyed properties thru `iteratee`, with each invocation
                         * potentially mutating the `accumulator` object. If `accumulator` is not
                         * provided, a new object with the same `[[Prototype]]` will be used. The
                         * iteratee is invoked with four arguments: (accumulator, value, key, object).
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The custom accumulator value.
                         * @returns {*} Returns the accumulated value.
                         * @example
                         *
                         * _.transform([2, 3, 4], function(result, n) {
                         *   result.push(n *= n);
                         *   return n % 2 == 0;
                         * }, []);
                         * // => [4, 9]
                         *
                         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                         *   (result[value] || (result[value] = [])).push(key);
                         * }, {});
                         * // => { '1': ['a', 'c'], '2': ['b'] }
                         */
                        function transform(object, iteratee, accumulator) {
                            var isArr = isArray(object),
                                isArrLike = isArr || isBuffer(object) || isTypedArray(object);

                            iteratee = getIteratee(iteratee, 4);
                            if (accumulator == null) {
                                var Ctor = object && object.constructor;
                                if (isArrLike) {
                                    accumulator = isArr ? new Ctor : [];
                                } else if (isObject(object)) {
                                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                                } else {
                                    accumulator = {};
                                }
                            }
                            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                                return iteratee(accumulator, value, index, object);
                            });
                            return accumulator;
                        }

                        /**
                         * Removes the property at `path` of `object`.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to unset.
                         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
                         * _.unset(object, 'a[0].b.c');
                         * // => true
                         *
                         * console.log(object);
                         * // => { 'a': [{ 'b': {} }] };
                         *
                         * _.unset(object, ['a', '0', 'b', 'c']);
                         * // => true
                         *
                         * console.log(object);
                         * // => { 'a': [{ 'b': {} }] };
                         */
                        function unset(object, path) {
                            return object == null ? true : baseUnset(object, path);
                        }

                        /**
                         * This method is like `_.set` except that accepts `updater` to produce the
                         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
                         * is invoked with one argument: (value).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {Function} updater The function to produce the updated value.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
                         * console.log(object.a[0].b.c);
                         * // => 9
                         *
                         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
                         * console.log(object.x[0].y.z);
                         * // => 0
                         */
                        function update(object, path, updater) {
                            return object == null ? object : baseUpdate(object, path, castFunction(updater));
                        }

                        /**
                         * This method is like `_.update` except that it accepts `customizer` which is
                         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                         * path creation is handled by the method instead. The `customizer` is invoked
                         * with three arguments: (nsValue, key, nsObject).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {Function} updater The function to produce the updated value.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {};
                         *
                         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
                         * // => { '0': { '1': 'a' } }
                         */
                        function updateWith(object, path, updater, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                        }

                        /**
                         * Creates an array of the own enumerable string keyed property values of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property values.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.values(new Foo);
                         * // => [1, 2] (iteration order is not guaranteed)
                         *
                         * _.values('hi');
                         * // => ['h', 'i']
                         */
                        function values(object) {
                            return object == null ? [] : baseValues(object, keys(object));
                        }

                        /**
                         * Creates an array of the own and inherited enumerable string keyed property
                         * values of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property values.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.valuesIn(new Foo);
                         * // => [1, 2, 3] (iteration order is not guaranteed)
                         */
                        function valuesIn(object) {
                            return object == null ? [] : baseValues(object, keysIn(object));
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Clamps `number` within the inclusive `lower` and `upper` bounds.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Number
                         * @param {number} number The number to clamp.
                         * @param {number} [lower] The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the clamped number.
                         * @example
                         *
                         * _.clamp(-10, -5, 5);
                         * // => -5
                         *
                         * _.clamp(10, -5, 5);
                         * // => 5
                         */
                        function clamp(number, lower, upper) {
                            if (upper === undefined) {
                                upper = lower;
                                lower = undefined;
                            }
                            if (upper !== undefined) {
                                upper = toNumber(upper);
                                upper = upper === upper ? upper : 0;
                            }
                            if (lower !== undefined) {
                                lower = toNumber(lower);
                                lower = lower === lower ? lower : 0;
                            }
                            return baseClamp(toNumber(number), lower, upper);
                        }

                        /**
                         * Checks if `n` is between `start` and up to, but not including, `end`. If
                         * `end` is not specified, it's set to `start` with `start` then set to `0`.
                         * If `start` is greater than `end` the params are swapped to support
                         * negative ranges.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.3.0
                         * @category Number
                         * @param {number} number The number to check.
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                         * @see _.range, _.rangeRight
                         * @example
                         *
                         * _.inRange(3, 2, 4);
                         * // => true
                         *
                         * _.inRange(4, 8);
                         * // => true
                         *
                         * _.inRange(4, 2);
                         * // => false
                         *
                         * _.inRange(2, 2);
                         * // => false
                         *
                         * _.inRange(1.2, 2);
                         * // => true
                         *
                         * _.inRange(5.2, 4);
                         * // => false
                         *
                         * _.inRange(-3, -2, -6);
                         * // => true
                         */
                        function inRange(number, start, end) {
                            start = toFinite(start);
                            if (end === undefined) {
                                end = start;
                                start = 0;
                            } else {
                                end = toFinite(end);
                            }
                            number = toNumber(number);
                            return baseInRange(number, start, end);
                        }

                        /**
                         * Produces a random number between the inclusive `lower` and `upper` bounds.
                         * If only one argument is provided a number between `0` and the given number
                         * is returned. If `floating` is `true`, or either `lower` or `upper` are
                         * floats, a floating-point number is returned instead of an integer.
                         *
                         * **Note:** JavaScript follows the IEEE-754 standard for resolving
                         * floating-point values which can produce unexpected results.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.7.0
                         * @category Number
                         * @param {number} [lower=0] The lower bound.
                         * @param {number} [upper=1] The upper bound.
                         * @param {boolean} [floating] Specify returning a floating-point number.
                         * @returns {number} Returns the random number.
                         * @example
                         *
                         * _.random(0, 5);
                         * // => an integer between 0 and 5
                         *
                         * _.random(5);
                         * // => also an integer between 0 and 5
                         *
                         * _.random(5, true);
                         * // => a floating-point number between 0 and 5
                         *
                         * _.random(1.2, 5.2);
                         * // => a floating-point number between 1.2 and 5.2
                         */
                        function random(lower, upper, floating) {
                            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                                upper = floating = undefined;
                            }
                            if (floating === undefined) {
                                if (typeof upper == 'boolean') {
                                    floating = upper;
                                    upper = undefined;
                                } else if (typeof lower == 'boolean') {
                                    floating = lower;
                                    lower = undefined;
                                }
                            }
                            if (lower === undefined && upper === undefined) {
                                lower = 0;
                                upper = 1;
                            } else {
                                lower = toFinite(lower);
                                if (upper === undefined) {
                                    upper = lower;
                                    lower = 0;
                                } else {
                                    upper = toFinite(upper);
                                }
                            }
                            if (lower > upper) {
                                var temp = lower;
                                lower = upper;
                                upper = temp;
                            }
                            if (floating || lower % 1 || upper % 1) {
                                var rand = nativeRandom();
                                return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
                            }
                            return baseRandom(lower, upper);
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the camel cased string.
                         * @example
                         *
                         * _.camelCase('Foo Bar');
                         * // => 'fooBar'
                         *
                         * _.camelCase('--foo-bar--');
                         * // => 'fooBar'
                         *
                         * _.camelCase('__FOO_BAR__');
                         * // => 'fooBar'
                         */
                        var camelCase = createCompounder(function(result, word, index) {
                            word = word.toLowerCase();
                            return result + (index ? capitalize(word) : word);
                        });

                        /**
                         * Converts the first character of `string` to upper case and the remaining
                         * to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to capitalize.
                         * @returns {string} Returns the capitalized string.
                         * @example
                         *
                         * _.capitalize('FRED');
                         * // => 'Fred'
                         */
                        function capitalize(string) {
                            return upperFirst(toString(string).toLowerCase());
                        }

                        /**
                         * Deburrs `string` by converting
                         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
                         * letters to basic Latin letters and removing
                         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to deburr.
                         * @returns {string} Returns the deburred string.
                         * @example
                         *
                         * _.deburr('déjà vu');
                         * // => 'deja vu'
                         */
                        function deburr(string) {
                            string = toString(string);
                            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
                        }

                        /**
                         * Checks if `string` ends with the given target string.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {string} [target] The string to search for.
                         * @param {number} [position=string.length] The position to search up to.
                         * @returns {boolean} Returns `true` if `string` ends with `target`,
                         *  else `false`.
                         * @example
                         *
                         * _.endsWith('abc', 'c');
                         * // => true
                         *
                         * _.endsWith('abc', 'b');
                         * // => false
                         *
                         * _.endsWith('abc', 'b', 2);
                         * // => true
                         */
                        function endsWith(string, target, position) {
                            string = toString(string);
                            target = baseToString(target);

                            var length = string.length;
                            position = position === undefined
                                ? length
                                : baseClamp(toInteger(position), 0, length);

                            var end = position;
                            position -= target.length;
                            return position >= 0 && string.slice(position, end) == target;
                        }

                        /**
                         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
                         * corresponding HTML entities.
                         *
                         * **Note:** No other characters are escaped. To escape additional
                         * characters use a third-party library like [_he_](https://mths.be/he).
                         *
                         * Though the ">" character is escaped for symmetry, characters like
                         * ">" and "/" don't need escaping in HTML and have no special meaning
                         * unless they're part of a tag or unquoted attribute value. See
                         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                         * (under "semi-related fun fact") for more details.
                         *
                         * When working with HTML you should always
                         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
                         * XSS vectors.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category String
                         * @param {string} [string=''] The string to escape.
                         * @returns {string} Returns the escaped string.
                         * @example
                         *
                         * _.escape('fred, barney, & pebbles');
                         * // => 'fred, barney, &amp; pebbles'
                         */
                        function escape(string) {
                            string = toString(string);
                            return (string && reHasUnescapedHtml.test(string))
                                ? string.replace(reUnescapedHtml, escapeHtmlChar)
                                : string;
                        }

                        /**
                         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
                         * "?", "(", ")", "[", "]", "{', "}", and "|' in `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to escape.
                         * @returns {string} Returns the escaped string.
                         * @example
                         *
                         * _.escapeRegExp('[lodash](https://lodash.com/)');
                         * // => '\[lodash\]\(https://lodash\.com/\)'
                         */
                        function escapeRegExp(string) {
                            string = toString(string);
                            return (string && reHasRegExpChar.test(string))
                                ? string.replace(reRegExpChar, '\\$&')
                                : string;
                        }

                        /**
                         * Converts `string` to
                         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the kebab cased string.
                         * @example
                         *
                         * _.kebabCase('Foo Bar');
                         * // => 'foo-bar'
                         *
                         * _.kebabCase('fooBar');
                         * // => 'foo-bar'
                         *
                         * _.kebabCase('__FOO_BAR__');
                         * // => 'foo-bar'
                         */
                        var kebabCase = createCompounder(function(result, word, index) {
                            return result + (index ? '-' : '') + word.toLowerCase();
                        });

                        /**
                         * Converts `string`, as space separated words, to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the lower cased string.
                         * @example
                         *
                         * _.lowerCase('--Foo-Bar--');
                         * // => 'foo bar'
                         *
                         * _.lowerCase('fooBar');
                         * // => 'foo bar'
                         *
                         * _.lowerCase('__FOO_BAR__');
                         * // => 'foo bar'
                         */
                        var lowerCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + word.toLowerCase();
                        });

                        /**
                         * Converts the first character of `string` to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.lowerFirst('Fred');
                         * // => 'fred'
                         *
                         * _.lowerFirst('FRED');
                         * // => 'fRED'
                         */
                        var lowerFirst = createCaseFirst('toLowerCase');

                        /**
                         * Pads `string` on the left and right sides if it's shorter than `length`.
                         * Padding characters are truncated if they can't be evenly divided by `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.pad('abc', 8);
                         * // => '  abc   '
                         *
                         * _.pad('abc', 8, '_-');
                         * // => '_-abc_-_'
                         *
                         * _.pad('abc', 3);
                         * // => 'abc'
                         */
                        function pad(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            if (!length || strLength >= length) {
                                return string;
                            }
                            var mid = (length - strLength) / 2;
                            return (
                                createPadding(nativeFloor(mid), chars) +
                                string +
                                createPadding(nativeCeil(mid), chars)
                            );
                        }

                        /**
                         * Pads `string` on the right side if it's shorter than `length`. Padding
                         * characters are truncated if they exceed `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.padEnd('abc', 6);
                         * // => 'abc   '
                         *
                         * _.padEnd('abc', 6, '_-');
                         * // => 'abc_-_'
                         *
                         * _.padEnd('abc', 3);
                         * // => 'abc'
                         */
                        function padEnd(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length)
                                ? (string + createPadding(length - strLength, chars))
                                : string;
                        }

                        /**
                         * Pads `string` on the left side if it's shorter than `length`. Padding
                         * characters are truncated if they exceed `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.padStart('abc', 6);
                         * // => '   abc'
                         *
                         * _.padStart('abc', 6, '_-');
                         * // => '_-_abc'
                         *
                         * _.padStart('abc', 3);
                         * // => 'abc'
                         */
                        function padStart(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);

                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length)
                                ? (createPadding(length - strLength, chars) + string)
                                : string;
                        }

                        /**
                         * Converts `string` to an integer of the specified radix. If `radix` is
                         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
                         * hexadecimal, in which case a `radix` of `16` is used.
                         *
                         * **Note:** This method aligns with the
                         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category String
                         * @param {string} string The string to convert.
                         * @param {number} [radix=10] The radix to interpret `value` by.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.parseInt('08');
                         * // => 8
                         *
                         * _.map(['6', '08', '10'], _.parseInt);
                         * // => [6, 8, 10]
                         */
                        function parseInt(string, radix, guard) {
                            if (guard || radix == null) {
                                radix = 0;
                            } else if (radix) {
                                radix = +radix;
                            }
                            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
                        }

                        /**
                         * Repeats the given string `n` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to repeat.
                         * @param {number} [n=1] The number of times to repeat the string.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the repeated string.
                         * @example
                         *
                         * _.repeat('*', 3);
                         * // => '***'
                         *
                         * _.repeat('abc', 2);
                         * // => 'abcabc'
                         *
                         * _.repeat('abc', 0);
                         * // => ''
                         */
                        function repeat(string, n, guard) {
                            if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
                                n = 1;
                            } else {
                                n = toInteger(n);
                            }
                            return baseRepeat(toString(string), n);
                        }

                        /**
                         * Replaces matches for `pattern` in `string` with `replacement`.
                         *
                         * **Note:** This method is based on
                         * [`String#replace`](https://mdn.io/String/replace).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to modify.
                         * @param {RegExp|string} pattern The pattern to replace.
                         * @param {Function|string} replacement The match replacement.
                         * @returns {string} Returns the modified string.
                         * @example
                         *
                         * _.replace('Hi Fred', 'Fred', 'Barney');
                         * // => 'Hi Barney'
                         */
                        function replace() {
                            var args = arguments,
                                string = toString(args[0]);

                            return args.length < 3 ? string : string.replace(args[1], args[2]);
                        }

                        /**
                         * Converts `string` to
                         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the snake cased string.
                         * @example
                         *
                         * _.snakeCase('Foo Bar');
                         * // => 'foo_bar'
                         *
                         * _.snakeCase('fooBar');
                         * // => 'foo_bar'
                         *
                         * _.snakeCase('--FOO-BAR--');
                         * // => 'foo_bar'
                         */
                        var snakeCase = createCompounder(function(result, word, index) {
                            return result + (index ? '_' : '') + word.toLowerCase();
                        });

                        /**
                         * Splits `string` by `separator`.
                         *
                         * **Note:** This method is based on
                         * [`String#split`](https://mdn.io/String/split).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to split.
                         * @param {RegExp|string} separator The separator pattern to split by.
                         * @param {number} [limit] The length to truncate results to.
                         * @returns {Array} Returns the string segments.
                         * @example
                         *
                         * _.split('a-b-c', '-', 2);
                         * // => ['a', 'b']
                         */
                        function split(string, separator, limit) {
                            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                                separator = limit = undefined;
                            }
                            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                            if (!limit) {
                                return [];
                            }
                            string = toString(string);
                            if (string && (
                                typeof separator == 'string' ||
                                (separator != null && !isRegExp(separator))
                            )) {
                                separator = baseToString(separator);
                                if (!separator && hasUnicode(string)) {
                                    return castSlice(stringToArray(string), 0, limit);
                                }
                            }
                            return string.split(separator, limit);
                        }

                        /**
                         * Converts `string` to
                         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.1.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the start cased string.
                         * @example
                         *
                         * _.startCase('--foo-bar--');
                         * // => 'Foo Bar'
                         *
                         * _.startCase('fooBar');
                         * // => 'Foo Bar'
                         *
                         * _.startCase('__FOO_BAR__');
                         * // => 'FOO BAR'
                         */
                        var startCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + upperFirst(word);
                        });

                        /**
                         * Checks if `string` starts with the given target string.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {string} [target] The string to search for.
                         * @param {number} [position=0] The position to search from.
                         * @returns {boolean} Returns `true` if `string` starts with `target`,
                         *  else `false`.
                         * @example
                         *
                         * _.startsWith('abc', 'a');
                         * // => true
                         *
                         * _.startsWith('abc', 'b');
                         * // => false
                         *
                         * _.startsWith('abc', 'b', 1);
                         * // => true
                         */
                        function startsWith(string, target, position) {
                            string = toString(string);
                            position = position == null
                                ? 0
                                : baseClamp(toInteger(position), 0, string.length);

                            target = baseToString(target);
                            return string.slice(position, position + target.length) == target;
                        }

                        /**
                         * Creates a compiled template function that can interpolate data properties
                         * in "interpolate" delimiters, HTML-escape interpolated data properties in
                         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                         * properties may be accessed as free variables in the template. If a setting
                         * object is given, it takes precedence over `_.templateSettings` values.
                         *
                         * **Note:** In the development build `_.template` utilizes
                         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                         * for easier debugging.
                         *
                         * For more information on precompiling templates see
                         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                         *
                         * For more information on Chrome extension sandboxes see
                         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category String
                         * @param {string} [string=''] The template string.
                         * @param {Object} [options={}] The options object.
                         * @param {RegExp} [options.escape=_.templateSettings.escape]
                         *  The HTML "escape" delimiter.
                         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
                         *  The "evaluate" delimiter.
                         * @param {Object} [options.imports=_.templateSettings.imports]
                         *  An object to import into the template as free variables.
                         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
                         *  The "interpolate" delimiter.
                         * @param {string} [options.sourceURL='lodash.templateSources[n]']
                         *  The sourceURL of the compiled template.
                         * @param {string} [options.variable='obj']
                         *  The data object variable name.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the compiled template function.
                         * @example
                         *
                         * // Use the "interpolate" delimiter to create a compiled template.
                         * var compiled = _.template('hello <%= user %>!');
                         * compiled({ 'user': 'fred' });
                         * // => 'hello fred!'
                         *
                         * // Use the HTML "escape" delimiter to escape data property values.
                         * var compiled = _.template('<b><%- value %></b>');
                         * compiled({ 'value': '<script>' });
                         * // => '<b>&lt;script&gt;</b>'
                         *
                         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
                         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                         * compiled({ 'users': ['fred', 'barney'] });
                         * // => '<li>fred</li><li>barney</li>'
                         *
                         * // Use the internal `print` function in "evaluate" delimiters.
                         * var compiled = _.template('<% print("hello " + user); %>!');
                         * compiled({ 'user': 'barney' });
                         * // => 'hello barney!'
                         *
                         * // Use the ES template literal delimiter as an "interpolate" delimiter.
                         * // Disable support by replacing the "interpolate" delimiter.
                         * var compiled = _.template('hello ${ user }!');
                         * compiled({ 'user': 'pebbles' });
                         * // => 'hello pebbles!'
                         *
                         * // Use backslashes to treat delimiters as plain text.
                         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                         * compiled({ 'value': 'ignored' });
                         * // => '<%- value %>'
                         *
                         * // Use the `imports` option to import `jQuery` as `jq`.
                         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                         * compiled({ 'users': ['fred', 'barney'] });
                         * // => '<li>fred</li><li>barney</li>'
                         *
                         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
                         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                         * compiled(data);
                         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
                         *
                         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
                         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                         * compiled.source;
                         * // => function(data) {
                         * //   var __t, __p = '';
                         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
                         * //   return __p;
                         * // }
                         *
                         * // Use custom template delimiters.
                         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                         * var compiled = _.template('hello {{ user }}!');
                         * compiled({ 'user': 'mustache' });
                         * // => 'hello mustache!'
                         *
                         * // Use the `source` property to inline compiled templates for meaningful
                         * // line numbers in error messages and stack traces.
                         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
                         *   var JST = {\
                         *     "main": ' + _.template(mainText).source + '\
                         *   };\
                         * ');
                         */
                        function template(string, options, guard) {
                            // Based on John Resig's `tmpl` implementation
                            // (http://ejohn.org/blog/javascript-micro-templating/)
                            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                            var settings = lodash.templateSettings;

                            if (guard && isIterateeCall(string, options, guard)) {
                                options = undefined;
                            }
                            string = toString(string);
                            options = assignInWith({}, options, settings, customDefaultsAssignIn);

                            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                                importsKeys = keys(imports),
                                importsValues = baseValues(imports, importsKeys);

                            var isEscaping,
                                isEvaluating,
                                index = 0,
                                interpolate = options.interpolate || reNoMatch,
                                source = '__p += \'';

                            // Compile the regexp to match each delimiter.
                            var reDelimiters = RegExp(
                                (options.escape || reNoMatch).source + '|' +
                                interpolate.source + '|' +
                                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                                (options.evaluate || reNoMatch).source + '|$'
                                , 'g');

                            // Use a sourceURL for easier debugging.
                            var sourceURL = '//# sourceURL=' +
                                ('sourceURL' in options
                                        ? options.sourceURL
                                        : ('lodash.templateSources[' + (++templateCounter) + ']')
                                ) + '\n';

                            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                                interpolateValue || (interpolateValue = esTemplateValue);

                                // Escape characters that can't be included in string literals.
                                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                                // Replace delimiters with snippets.
                                if (escapeValue) {
                                    isEscaping = true;
                                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                                }
                                if (evaluateValue) {
                                    isEvaluating = true;
                                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                                }
                                if (interpolateValue) {
                                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                                }
                                index = offset + match.length;

                                // The JS engine embedded in Adobe products needs `match` returned in
                                // order to produce the correct `offset` value.
                                return match;
                            });

                            source += '\';\n';

                            // If `variable` is not specified wrap a with-statement around the generated
                            // code to add the data object to the top of the scope chain.
                            var variable = options.variable;
                            if (!variable) {
                                source = 'with (obj) {\n' + source + '\n}\n';
                            }
                            // Cleanup code by stripping empty strings.
                            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                                .replace(reEmptyStringMiddle, '$1')
                                .replace(reEmptyStringTrailing, '$1;');

                            // Frame code as the function body.
                            source = 'function(' + (variable || 'obj') + ') {\n' +
                                (variable
                                        ? ''
                                        : 'obj || (obj = {});\n'
                                ) +
                                'var __t, __p = \'\'' +
                                (isEscaping
                                        ? ', __e = _.escape'
                                        : ''
                                ) +
                                (isEvaluating
                                        ? ', __j = Array.prototype.join;\n' +
                                        'function print() { __p += __j.call(arguments, \'\') }\n'
                                        : ';\n'
                                ) +
                                source +
                                'return __p\n}';

                            var result = attempt(function() {
                                return Function(importsKeys, sourceURL + 'return ' + source)
                                    .apply(undefined, importsValues);
                            });

                            // Provide the compiled function's source by its `toString` method or
                            // the `source` property as a convenience for inlining compiled templates.
                            result.source = source;
                            if (isError(result)) {
                                throw result;
                            }
                            return result;
                        }

                        /**
                         * Converts `string`, as a whole, to lower case just like
                         * [String#toLowerCase](https://mdn.io/toLowerCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the lower cased string.
                         * @example
                         *
                         * _.toLower('--Foo-Bar--');
                         * // => '--foo-bar--'
                         *
                         * _.toLower('fooBar');
                         * // => 'foobar'
                         *
                         * _.toLower('__FOO_BAR__');
                         * // => '__foo_bar__'
                         */
                        function toLower(value) {
                            return toString(value).toLowerCase();
                        }

                        /**
                         * Converts `string`, as a whole, to upper case just like
                         * [String#toUpperCase](https://mdn.io/toUpperCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the upper cased string.
                         * @example
                         *
                         * _.toUpper('--foo-bar--');
                         * // => '--FOO-BAR--'
                         *
                         * _.toUpper('fooBar');
                         * // => 'FOOBAR'
                         *
                         * _.toUpper('__foo_bar__');
                         * // => '__FOO_BAR__'
                         */
                        function toUpper(value) {
                            return toString(value).toUpperCase();
                        }

                        /**
                         * Removes leading and trailing whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trim('  abc  ');
                         * // => 'abc'
                         *
                         * _.trim('-_-abc-_-', '_-');
                         * // => 'abc'
                         *
                         * _.map(['  foo  ', '  bar  '], _.trim);
                         * // => ['foo', 'bar']
                         */
                        function trim(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrim, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                chrSymbols = stringToArray(chars),
                                start = charsStartIndex(strSymbols, chrSymbols),
                                end = charsEndIndex(strSymbols, chrSymbols) + 1;

                            return castSlice(strSymbols, start, end).join('');
                        }

                        /**
                         * Removes trailing whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trimEnd('  abc  ');
                         * // => '  abc'
                         *
                         * _.trimEnd('-_-abc-_-', '_-');
                         * // => '-_-abc'
                         */
                        function trimEnd(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimEnd, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

                            return castSlice(strSymbols, 0, end).join('');
                        }

                        /**
                         * Removes leading whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trimStart('  abc  ');
                         * // => 'abc  '
                         *
                         * _.trimStart('-_-abc-_-', '_-');
                         * // => 'abc-_-'
                         */
                        function trimStart(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimStart, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string),
                                start = charsStartIndex(strSymbols, stringToArray(chars));

                            return castSlice(strSymbols, start).join('');
                        }

                        /**
                         * Truncates `string` if it's longer than the given maximum string length.
                         * The last characters of the truncated string are replaced with the omission
                         * string which defaults to "...".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to truncate.
                         * @param {Object} [options={}] The options object.
                         * @param {number} [options.length=30] The maximum string length.
                         * @param {string} [options.omission='...'] The string to indicate text is omitted.
                         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                         * @returns {string} Returns the truncated string.
                         * @example
                         *
                         * _.truncate('hi-diddly-ho there, neighborino');
                         * // => 'hi-diddly-ho there, neighbo...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'length': 24,
                         *   'separator': ' '
                         * });
                         * // => 'hi-diddly-ho there,...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'length': 24,
                         *   'separator': /,? +/
                         * });
                         * // => 'hi-diddly-ho there...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'omission': ' [...]'
                         * });
                         * // => 'hi-diddly-ho there, neig [...]'
                         */
                        function truncate(string, options) {
                            var length = DEFAULT_TRUNC_LENGTH,
                                omission = DEFAULT_TRUNC_OMISSION;

                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? toInteger(options.length) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            }
                            string = toString(string);

                            var strLength = string.length;
                            if (hasUnicode(string)) {
                                var strSymbols = stringToArray(string);
                                strLength = strSymbols.length;
                            }
                            if (length >= strLength) {
                                return string;
                            }
                            var end = length - stringSize(omission);
                            if (end < 1) {
                                return omission;
                            }
                            var result = strSymbols
                                ? castSlice(strSymbols, 0, end).join('')
                                : string.slice(0, end);

                            if (separator === undefined) {
                                return result + omission;
                            }
                            if (strSymbols) {
                                end += (result.length - end);
                            }
                            if (isRegExp(separator)) {
                                if (string.slice(end).search(separator)) {
                                    var match,
                                        substring = result;

                                    if (!separator.global) {
                                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                                    }
                                    separator.lastIndex = 0;
                                    while ((match = separator.exec(substring))) {
                                        var newEnd = match.index;
                                    }
                                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                                }
                            } else if (string.indexOf(baseToString(separator), end) != end) {
                                var index = result.lastIndexOf(separator);
                                if (index > -1) {
                                    result = result.slice(0, index);
                                }
                            }
                            return result + omission;
                        }

                        /**
                         * The inverse of `_.escape`; this method converts the HTML entities
                         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
                         * their corresponding characters.
                         *
                         * **Note:** No other HTML entities are unescaped. To unescape additional
                         * HTML entities use a third-party library like [_he_](https://mths.be/he).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.6.0
                         * @category String
                         * @param {string} [string=''] The string to unescape.
                         * @returns {string} Returns the unescaped string.
                         * @example
                         *
                         * _.unescape('fred, barney, &amp; pebbles');
                         * // => 'fred, barney, & pebbles'
                         */
                        function unescape(string) {
                            string = toString(string);
                            return (string && reHasEscapedHtml.test(string))
                                ? string.replace(reEscapedHtml, unescapeHtmlChar)
                                : string;
                        }

                        /**
                         * Converts `string`, as space separated words, to upper case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the upper cased string.
                         * @example
                         *
                         * _.upperCase('--foo-bar');
                         * // => 'FOO BAR'
                         *
                         * _.upperCase('fooBar');
                         * // => 'FOO BAR'
                         *
                         * _.upperCase('__foo_bar__');
                         * // => 'FOO BAR'
                         */
                        var upperCase = createCompounder(function(result, word, index) {
                            return result + (index ? ' ' : '') + word.toUpperCase();
                        });

                        /**
                         * Converts the first character of `string` to upper case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.upperFirst('fred');
                         * // => 'Fred'
                         *
                         * _.upperFirst('FRED');
                         * // => 'FRED'
                         */
                        var upperFirst = createCaseFirst('toUpperCase');

                        /**
                         * Splits `string` into an array of its words.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {RegExp|string} [pattern] The pattern to match words.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the words of `string`.
                         * @example
                         *
                         * _.words('fred, barney, & pebbles');
                         * // => ['fred', 'barney', 'pebbles']
                         *
                         * _.words('fred, barney, & pebbles', /[^, ]+/g);
                         * // => ['fred', 'barney', '&', 'pebbles']
                         */
                        function words(string, pattern, guard) {
                            string = toString(string);
                            pattern = guard ? undefined : pattern;

                            if (pattern === undefined) {
                                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                            }
                            return string.match(pattern) || [];
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Attempts to invoke `func`, returning either the result or the caught error
                         * object. Any additional arguments are provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Function} func The function to attempt.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {*} Returns the `func` result or error object.
                         * @example
                         *
                         * // Avoid throwing errors for invalid selectors.
                         * var elements = _.attempt(function(selector) {
                         *   return document.querySelectorAll(selector);
                         * }, '>_>');
                         *
                         * if (_.isError(elements)) {
                         *   elements = [];
                         * }
                         */
                        var attempt = baseRest(function(func, args) {
                            try {
                                return apply(func, undefined, args);
                            } catch (e) {
                                return isError(e) ? e : new Error(e);
                            }
                        });

                        /**
                         * Binds methods of an object to the object itself, overwriting the existing
                         * method.
                         *
                         * **Note:** This method doesn't set the "length" property of bound functions.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {Object} object The object to bind and assign the bound methods to.
                         * @param {...(string|string[])} methodNames The object method names to bind.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var view = {
                         *   'label': 'docs',
                         *   'click': function() {
                         *     console.log('clicked ' + this.label);
                         *   }
                         * };
                         *
                         * _.bindAll(view, ['click']);
                         * jQuery(element).on('click', view.click);
                         * // => Logs 'clicked docs' when clicked.
                         */
                        var bindAll = flatRest(function(object, methodNames) {
                            arrayEach(methodNames, function(key) {
                                key = toKey(key);
                                baseAssignValue(object, key, bind(object[key], object));
                            });
                            return object;
                        });

                        /**
                         * Creates a function that iterates over `pairs` and invokes the corresponding
                         * function of the first predicate to return truthy. The predicate-function
                         * pairs are invoked with the `this` binding and arguments of the created
                         * function.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {Array} pairs The predicate-function pairs.
                         * @returns {Function} Returns the new composite function.
                         * @example
                         *
                         * var func = _.cond([
                         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
                         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
                         *   [_.stubTrue,                      _.constant('no match')]
                         * ]);
                         *
                         * func({ 'a': 1, 'b': 2 });
                         * // => 'matches A'
                         *
                         * func({ 'a': 0, 'b': 1 });
                         * // => 'matches B'
                         *
                         * func({ 'a': '1', 'b': '2' });
                         * // => 'no match'
                         */
                        function cond(pairs) {
                            var length = pairs == null ? 0 : pairs.length,
                                toIteratee = getIteratee();

                            pairs = !length ? [] : arrayMap(pairs, function(pair) {
                                if (typeof pair[1] != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                return [toIteratee(pair[0]), pair[1]];
                            });

                            return baseRest(function(args) {
                                var index = -1;
                                while (++index < length) {
                                    var pair = pairs[index];
                                    if (apply(pair[0], this, args)) {
                                        return apply(pair[1], this, args);
                                    }
                                }
                            });
                        }

                        /**
                         * Creates a function that invokes the predicate properties of `source` with
                         * the corresponding property values of a given object, returning `true` if
                         * all predicates return truthy, else `false`.
                         *
                         * **Note:** The created function is equivalent to `_.conformsTo` with
                         * `source` partially applied.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 2, 'b': 1 },
                         *   { 'a': 1, 'b': 2 }
                         * ];
                         *
                         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
                         * // => [{ 'a': 1, 'b': 2 }]
                         */
                        function conforms(source) {
                            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                        }

                        /**
                         * Creates a function that returns `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Util
                         * @param {*} value The value to return from the new function.
                         * @returns {Function} Returns the new constant function.
                         * @example
                         *
                         * var objects = _.times(2, _.constant({ 'a': 1 }));
                         *
                         * console.log(objects);
                         * // => [{ 'a': 1 }, { 'a': 1 }]
                         *
                         * console.log(objects[0] === objects[1]);
                         * // => true
                         */
                        function constant(value) {
                            return function() {
                                return value;
                            };
                        }

                        /**
                         * Checks `value` to determine whether a default value should be returned in
                         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
                         * or `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.14.0
                         * @category Util
                         * @param {*} value The value to check.
                         * @param {*} defaultValue The default value.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * _.defaultTo(1, 10);
                         * // => 1
                         *
                         * _.defaultTo(undefined, 10);
                         * // => 10
                         */
                        function defaultTo(value, defaultValue) {
                            return (value == null || value !== value) ? defaultValue : value;
                        }

                        /**
                         * Creates a function that returns the result of invoking the given functions
                         * with the `this` binding of the created function, where each successive
                         * invocation is supplied the return value of the previous.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [funcs] The functions to invoke.
                         * @returns {Function} Returns the new composite function.
                         * @see _.flowRight
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var addSquare = _.flow([_.add, square]);
                         * addSquare(1, 2);
                         * // => 9
                         */
                        var flow = createFlow();

                        /**
                         * This method is like `_.flow` except that it creates a function that
                         * invokes the given functions from right to left.
                         *
                         * @static
                         * @since 3.0.0
                         * @memberOf _
                         * @category Util
                         * @param {...(Function|Function[])} [funcs] The functions to invoke.
                         * @returns {Function} Returns the new composite function.
                         * @see _.flow
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var addSquare = _.flowRight([square, _.add]);
                         * addSquare(1, 2);
                         * // => 9
                         */
                        var flowRight = createFlow(true);

                        /**
                         * This method returns the first argument it receives.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {*} value Any value.
                         * @returns {*} Returns `value`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         *
                         * console.log(_.identity(object) === object);
                         * // => true
                         */
                        function identity(value) {
                            return value;
                        }

                        /**
                         * Creates a function that invokes `func` with the arguments of the created
                         * function. If `func` is a property name, the created function returns the
                         * property value for a given element. If `func` is an array or object, the
                         * created function returns `true` for elements that contain the equivalent
                         * source properties, otherwise it returns `false`.
                         *
                         * @static
                         * @since 4.0.0
                         * @memberOf _
                         * @category Util
                         * @param {*} [func=_.identity] The value to convert to a callback.
                         * @returns {Function} Returns the callback.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': true },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
                         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.filter(users, _.iteratee(['user', 'fred']));
                         * // => [{ 'user': 'fred', 'age': 40 }]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.map(users, _.iteratee('user'));
                         * // => ['barney', 'fred']
                         *
                         * // Create custom iteratee shorthands.
                         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
                         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
                         *     return func.test(string);
                         *   };
                         * });
                         *
                         * _.filter(['abc', 'def'], /ef/);
                         * // => ['def']
                         */
                        function iteratee(func) {
                            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
                        }

                        /**
                         * Creates a function that performs a partial deep comparison between a given
                         * object and `source`, returning `true` if the given object has equivalent
                         * property values, else `false`.
                         *
                         * **Note:** The created function is equivalent to `_.isMatch` with `source`
                         * partially applied.
                         *
                         * Partial comparisons will match empty array and empty object `source`
                         * values against any array or object value, respectively. See `_.isEqual`
                         * for a list of supported value comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Object} source The object of property values to match.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 1, 'b': 2, 'c': 3 },
                         *   { 'a': 4, 'b': 5, 'c': 6 }
                         * ];
                         *
                         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
                         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
                         */
                        function matches(source) {
                            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                        }

                        /**
                         * Creates a function that performs a partial deep comparison between the
                         * value at `path` of a given object to `srcValue`, returning `true` if the
                         * object value is equivalent, else `false`.
                         *
                         * **Note:** Partial comparisons will match empty array and empty object
                         * `srcValue` values against any array or object value, respectively. See
                         * `_.isEqual` for a list of supported value comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Util
                         * @param {Array|string} path The path of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 1, 'b': 2, 'c': 3 },
                         *   { 'a': 4, 'b': 5, 'c': 6 }
                         * ];
                         *
                         * _.find(objects, _.matchesProperty('a', 4));
                         * // => { 'a': 4, 'b': 5, 'c': 6 }
                         */
                        function matchesProperty(path, srcValue) {
                            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                        }

                        /**
                         * Creates a function that invokes the method at `path` of a given object.
                         * Any additional arguments are provided to the invoked method.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Util
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {Function} Returns the new invoker function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': { 'b': _.constant(2) } },
                         *   { 'a': { 'b': _.constant(1) } }
                         * ];
                         *
                         * _.map(objects, _.method('a.b'));
                         * // => [2, 1]
                         *
                         * _.map(objects, _.method(['a', 'b']));
                         * // => [2, 1]
                         */
                        var method = baseRest(function(path, args) {
                            return function(object) {
                                return baseInvoke(object, path, args);
                            };
                        });

                        /**
                         * The opposite of `_.method`; this method creates a function that invokes
                         * the method at a given path of `object`. Any additional arguments are
                         * provided to the invoked method.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Util
                         * @param {Object} object The object to query.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {Function} Returns the new invoker function.
                         * @example
                         *
                         * var array = _.times(3, _.constant),
                         *     object = { 'a': array, 'b': array, 'c': array };
                         *
                         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                         * // => [2, 0]
                         *
                         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                         * // => [2, 0]
                         */
                        var methodOf = baseRest(function(object, args) {
                            return function(path) {
                                return baseInvoke(object, path, args);
                            };
                        });

                        /**
                         * Adds all own enumerable string keyed function properties of a source
                         * object to the destination object. If `object` is a function, then methods
                         * are added to its prototype as well.
                         *
                         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                         * avoid conflicts caused by modifying the original.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {Function|Object} [object=lodash] The destination object.
                         * @param {Object} source The object of functions to add.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
                         * @returns {Function|Object} Returns `object`.
                         * @example
                         *
                         * function vowels(string) {
                         *   return _.filter(string, function(v) {
                         *     return /[aeiou]/i.test(v);
                         *   });
                         * }
                         *
                         * _.mixin({ 'vowels': vowels });
                         * _.vowels('fred');
                         * // => ['e']
                         *
                         * _('fred').vowels().value();
                         * // => ['e']
                         *
                         * _.mixin({ 'vowels': vowels }, { 'chain': false });
                         * _('fred').vowels();
                         * // => ['e']
                         */
                        function mixin(object, source, options) {
                            var props = keys(source),
                                methodNames = baseFunctions(source, props);

                            if (options == null &&
                                !(isObject(source) && (methodNames.length || !props.length))) {
                                options = source;
                                source = object;
                                object = this;
                                methodNames = baseFunctions(source, keys(source));
                            }
                            var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                                isFunc = isFunction(object);

                            arrayEach(methodNames, function(methodName) {
                                var func = source[methodName];
                                object[methodName] = func;
                                if (isFunc) {
                                    object.prototype[methodName] = function() {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = copyArray(this.__actions__);

                                            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }
                            });

                            return object;
                        }

                        /**
                         * Reverts the `_` variable to its previous value and returns a reference to
                         * the `lodash` function.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @returns {Function} Returns the `lodash` function.
                         * @example
                         *
                         * var lodash = _.noConflict();
                         */
                        function noConflict() {
                            if (root._ === this) {
                                root._ = oldDash;
                            }
                            return this;
                        }

                        /**
                         * This method returns `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.3.0
                         * @category Util
                         * @example
                         *
                         * _.times(2, _.noop);
                         * // => [undefined, undefined]
                         */
                        function noop() {
                            // No operation performed.
                        }

                        /**
                         * Creates a function that gets the argument at index `n`. If `n` is negative,
                         * the nth argument from the end is returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {number} [n=0] The index of the argument to return.
                         * @returns {Function} Returns the new pass-thru function.
                         * @example
                         *
                         * var func = _.nthArg(1);
                         * func('a', 'b', 'c', 'd');
                         * // => 'b'
                         *
                         * var func = _.nthArg(-2);
                         * func('a', 'b', 'c', 'd');
                         * // => 'c'
                         */
                        function nthArg(n) {
                            n = toInteger(n);
                            return baseRest(function(args) {
                                return baseNth(args, n);
                            });
                        }

                        /**
                         * Creates a function that invokes `iteratees` with the arguments it receives
                         * and returns their results.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [iteratees=[_.identity]]
                         *  The iteratees to invoke.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.over([Math.max, Math.min]);
                         *
                         * func(1, 2, 3, 4);
                         * // => [4, 1]
                         */
                        var over = createOver(arrayMap);

                        /**
                         * Creates a function that checks if **all** of the `predicates` return
                         * truthy when invoked with the arguments it receives.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [predicates=[_.identity]]
                         *  The predicates to check.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.overEvery([Boolean, isFinite]);
                         *
                         * func('1');
                         * // => true
                         *
                         * func(null);
                         * // => false
                         *
                         * func(NaN);
                         * // => false
                         */
                        var overEvery = createOver(arrayEvery);

                        /**
                         * Creates a function that checks if **any** of the `predicates` return
                         * truthy when invoked with the arguments it receives.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [predicates=[_.identity]]
                         *  The predicates to check.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.overSome([Boolean, isFinite]);
                         *
                         * func('1');
                         * // => true
                         *
                         * func(null);
                         * // => true
                         *
                         * func(NaN);
                         * // => false
                         */
                        var overSome = createOver(arraySome);

                        /**
                         * Creates a function that returns the value at `path` of a given object.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Util
                         * @param {Array|string} path The path of the property to get.
                         * @returns {Function} Returns the new accessor function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': { 'b': 2 } },
                         *   { 'a': { 'b': 1 } }
                         * ];
                         *
                         * _.map(objects, _.property('a.b'));
                         * // => [2, 1]
                         *
                         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                         * // => [1, 2]
                         */
                        function property(path) {
                            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                        }

                        /**
                         * The opposite of `_.property`; this method creates a function that returns
                         * the value at a given path of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Object} object The object to query.
                         * @returns {Function} Returns the new accessor function.
                         * @example
                         *
                         * var array = [0, 1, 2],
                         *     object = { 'a': array, 'b': array, 'c': array };
                         *
                         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                         * // => [2, 0]
                         *
                         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                         * // => [2, 0]
                         */
                        function propertyOf(object) {
                            return function(path) {
                                return object == null ? undefined : baseGet(object, path);
                            };
                        }

                        /**
                         * Creates an array of numbers (positive and/or negative) progressing from
                         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
                         * `start` is specified without an `end` or `step`. If `end` is not specified,
                         * it's set to `start` with `start` then set to `0`.
                         *
                         * **Note:** JavaScript follows the IEEE-754 standard for resolving
                         * floating-point values which can produce unexpected results.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} [step=1] The value to increment or decrement by.
                         * @returns {Array} Returns the range of numbers.
                         * @see _.inRange, _.rangeRight
                         * @example
                         *
                         * _.range(4);
                         * // => [0, 1, 2, 3]
                         *
                         * _.range(-4);
                         * // => [0, -1, -2, -3]
                         *
                         * _.range(1, 5);
                         * // => [1, 2, 3, 4]
                         *
                         * _.range(0, 20, 5);
                         * // => [0, 5, 10, 15]
                         *
                         * _.range(0, -4, -1);
                         * // => [0, -1, -2, -3]
                         *
                         * _.range(1, 4, 0);
                         * // => [1, 1, 1]
                         *
                         * _.range(0);
                         * // => []
                         */
                        var range = createRange();

                        /**
                         * This method is like `_.range` except that it populates values in
                         * descending order.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} [step=1] The value to increment or decrement by.
                         * @returns {Array} Returns the range of numbers.
                         * @see _.inRange, _.range
                         * @example
                         *
                         * _.rangeRight(4);
                         * // => [3, 2, 1, 0]
                         *
                         * _.rangeRight(-4);
                         * // => [-3, -2, -1, 0]
                         *
                         * _.rangeRight(1, 5);
                         * // => [4, 3, 2, 1]
                         *
                         * _.rangeRight(0, 20, 5);
                         * // => [15, 10, 5, 0]
                         *
                         * _.rangeRight(0, -4, -1);
                         * // => [-3, -2, -1, 0]
                         *
                         * _.rangeRight(1, 4, 0);
                         * // => [1, 1, 1]
                         *
                         * _.rangeRight(0);
                         * // => []
                         */
                        var rangeRight = createRange(true);

                        /**
                         * This method returns a new empty array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Array} Returns the new empty array.
                         * @example
                         *
                         * var arrays = _.times(2, _.stubArray);
                         *
                         * console.log(arrays);
                         * // => [[], []]
                         *
                         * console.log(arrays[0] === arrays[1]);
                         * // => false
                         */
                        function stubArray() {
                            return [];
                        }

                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */
                        function stubFalse() {
                            return false;
                        }

                        /**
                         * This method returns a new empty object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Object} Returns the new empty object.
                         * @example
                         *
                         * var objects = _.times(2, _.stubObject);
                         *
                         * console.log(objects);
                         * // => [{}, {}]
                         *
                         * console.log(objects[0] === objects[1]);
                         * // => false
                         */
                        function stubObject() {
                            return {};
                        }

                        /**
                         * This method returns an empty string.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {string} Returns the empty string.
                         * @example
                         *
                         * _.times(2, _.stubString);
                         * // => ['', '']
                         */
                        function stubString() {
                            return '';
                        }

                        /**
                         * This method returns `true`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `true`.
                         * @example
                         *
                         * _.times(2, _.stubTrue);
                         * // => [true, true]
                         */
                        function stubTrue() {
                            return true;
                        }

                        /**
                         * Invokes the iteratee `n` times, returning an array of the results of
                         * each invocation. The iteratee is invoked with one argument; (index).
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {number} n The number of times to invoke `iteratee`.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the array of results.
                         * @example
                         *
                         * _.times(3, String);
                         * // => ['0', '1', '2']
                         *
                         *  _.times(4, _.constant(0));
                         * // => [0, 0, 0, 0]
                         */
                        function times(n, iteratee) {
                            n = toInteger(n);
                            if (n < 1 || n > MAX_SAFE_INTEGER) {
                                return [];
                            }
                            var index = MAX_ARRAY_LENGTH,
                                length = nativeMin(n, MAX_ARRAY_LENGTH);

                            iteratee = getIteratee(iteratee);
                            n -= MAX_ARRAY_LENGTH;

                            var result = baseTimes(length, iteratee);
                            while (++index < n) {
                                iteratee(index);
                            }
                            return result;
                        }

                        /**
                         * Converts `value` to a property path array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {*} value The value to convert.
                         * @returns {Array} Returns the new property path array.
                         * @example
                         *
                         * _.toPath('a.b.c');
                         * // => ['a', 'b', 'c']
                         *
                         * _.toPath('a[0].b.c');
                         * // => ['a', '0', 'b', 'c']
                         */
                        function toPath(value) {
                            if (isArray(value)) {
                                return arrayMap(value, toKey);
                            }
                            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
                        }

                        /**
                         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {string} [prefix=''] The value to prefix the ID with.
                         * @returns {string} Returns the unique ID.
                         * @example
                         *
                         * _.uniqueId('contact_');
                         * // => 'contact_104'
                         *
                         * _.uniqueId();
                         * // => '105'
                         */
                        function uniqueId(prefix) {
                            var id = ++idCounter;
                            return toString(prefix) + id;
                        }

                        /*------------------------------------------------------------------------*/

                        /**
                         * Adds two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.4.0
                         * @category Math
                         * @param {number} augend The first number in an addition.
                         * @param {number} addend The second number in an addition.
                         * @returns {number} Returns the total.
                         * @example
                         *
                         * _.add(6, 4);
                         * // => 10
                         */
                        var add = createMathOperation(function(augend, addend) {
                            return augend + addend;
                        }, 0);

                        /**
                         * Computes `number` rounded up to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round up.
                         * @param {number} [precision=0] The precision to round up to.
                         * @returns {number} Returns the rounded up number.
                         * @example
                         *
                         * _.ceil(4.006);
                         * // => 5
                         *
                         * _.ceil(6.004, 2);
                         * // => 6.01
                         *
                         * _.ceil(6040, -2);
                         * // => 6100
                         */
                        var ceil = createRound('ceil');

                        /**
                         * Divide two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {number} dividend The first number in a division.
                         * @param {number} divisor The second number in a division.
                         * @returns {number} Returns the quotient.
                         * @example
                         *
                         * _.divide(6, 4);
                         * // => 1.5
                         */
                        var divide = createMathOperation(function(dividend, divisor) {
                            return dividend / divisor;
                        }, 1);

                        /**
                         * Computes `number` rounded down to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round down.
                         * @param {number} [precision=0] The precision to round down to.
                         * @returns {number} Returns the rounded down number.
                         * @example
                         *
                         * _.floor(4.006);
                         * // => 4
                         *
                         * _.floor(0.046, 2);
                         * // => 0.04
                         *
                         * _.floor(4060, -2);
                         * // => 4000
                         */
                        var floor = createRound('floor');

                        /**
                         * Computes the maximum value of `array`. If `array` is empty or falsey,
                         * `undefined` is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {*} Returns the maximum value.
                         * @example
                         *
                         * _.max([4, 2, 8, 6]);
                         * // => 8
                         *
                         * _.max([]);
                         * // => undefined
                         */
                        function max(array) {
                            return (array && array.length)
                                ? baseExtremum(array, identity, baseGt)
                                : undefined;
                        }

                        /**
                         * This method is like `_.max` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * the value is ranked. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {*} Returns the maximum value.
                         * @example
                         *
                         * var objects = [{ 'n': 1 }, { 'n': 2 }];
                         *
                         * _.maxBy(objects, function(o) { return o.n; });
                         * // => { 'n': 2 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.maxBy(objects, 'n');
                         * // => { 'n': 2 }
                         */
                        function maxBy(array, iteratee) {
                            return (array && array.length)
                                ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
                                : undefined;
                        }

                        /**
                         * Computes the mean of the values in `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {number} Returns the mean.
                         * @example
                         *
                         * _.mean([4, 2, 8, 6]);
                         * // => 5
                         */
                        function mean(array) {
                            return baseMean(array, identity);
                        }

                        /**
                         * This method is like `_.mean` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the value to be averaged.
                         * The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the mean.
                         * @example
                         *
                         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                         *
                         * _.meanBy(objects, function(o) { return o.n; });
                         * // => 5
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.meanBy(objects, 'n');
                         * // => 5
                         */
                        function meanBy(array, iteratee) {
                            return baseMean(array, getIteratee(iteratee, 2));
                        }

                        /**
                         * Computes the minimum value of `array`. If `array` is empty or falsey,
                         * `undefined` is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {*} Returns the minimum value.
                         * @example
                         *
                         * _.min([4, 2, 8, 6]);
                         * // => 2
                         *
                         * _.min([]);
                         * // => undefined
                         */
                        function min(array) {
                            return (array && array.length)
                                ? baseExtremum(array, identity, baseLt)
                                : undefined;
                        }

                        /**
                         * This method is like `_.min` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * the value is ranked. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {*} Returns the minimum value.
                         * @example
                         *
                         * var objects = [{ 'n': 1 }, { 'n': 2 }];
                         *
                         * _.minBy(objects, function(o) { return o.n; });
                         * // => { 'n': 1 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.minBy(objects, 'n');
                         * // => { 'n': 1 }
                         */
                        function minBy(array, iteratee) {
                            return (array && array.length)
                                ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
                                : undefined;
                        }

                        /**
                         * Multiply two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {number} multiplier The first number in a multiplication.
                         * @param {number} multiplicand The second number in a multiplication.
                         * @returns {number} Returns the product.
                         * @example
                         *
                         * _.multiply(6, 4);
                         * // => 24
                         */
                        var multiply = createMathOperation(function(multiplier, multiplicand) {
                            return multiplier * multiplicand;
                        }, 1);

                        /**
                         * Computes `number` rounded to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round.
                         * @param {number} [precision=0] The precision to round to.
                         * @returns {number} Returns the rounded number.
                         * @example
                         *
                         * _.round(4.006);
                         * // => 4
                         *
                         * _.round(4.006, 2);
                         * // => 4.01
                         *
                         * _.round(4060, -2);
                         * // => 4100
                         */
                        var round = createRound('round');

                        /**
                         * Subtract two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {number} minuend The first number in a subtraction.
                         * @param {number} subtrahend The second number in a subtraction.
                         * @returns {number} Returns the difference.
                         * @example
                         *
                         * _.subtract(6, 4);
                         * // => 2
                         */
                        var subtract = createMathOperation(function(minuend, subtrahend) {
                            return minuend - subtrahend;
                        }, 0);

                        /**
                         * Computes the sum of the values in `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.4.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {number} Returns the sum.
                         * @example
                         *
                         * _.sum([4, 2, 8, 6]);
                         * // => 20
                         */
                        function sum(array) {
                            return (array && array.length)
                                ? baseSum(array, identity)
                                : 0;
                        }

                        /**
                         * This method is like `_.sum` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the value to be summed.
                         * The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the sum.
                         * @example
                         *
                         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                         *
                         * _.sumBy(objects, function(o) { return o.n; });
                         * // => 20
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sumBy(objects, 'n');
                         * // => 20
                         */
                        function sumBy(array, iteratee) {
                            return (array && array.length)
                                ? baseSum(array, getIteratee(iteratee, 2))
                                : 0;
                        }

                        /*------------------------------------------------------------------------*/

                        // Add methods that return wrapped values in chain sequences.
                        lodash.after = after;
                        lodash.ary = ary;
                        lodash.assign = assign;
                        lodash.assignIn = assignIn;
                        lodash.assignInWith = assignInWith;
                        lodash.assignWith = assignWith;
                        lodash.at = at;
                        lodash.before = before;
                        lodash.bind = bind;
                        lodash.bindAll = bindAll;
                        lodash.bindKey = bindKey;
                        lodash.castArray = castArray;
                        lodash.chain = chain;
                        lodash.chunk = chunk;
                        lodash.compact = compact;
                        lodash.concat = concat;
                        lodash.cond = cond;
                        lodash.conforms = conforms;
                        lodash.constant = constant;
                        lodash.countBy = countBy;
                        lodash.create = create;
                        lodash.curry = curry;
                        lodash.curryRight = curryRight;
                        lodash.debounce = debounce;
                        lodash.defaults = defaults;
                        lodash.defaultsDeep = defaultsDeep;
                        lodash.defer = defer;
                        lodash.delay = delay;
                        lodash.difference = difference;
                        lodash.differenceBy = differenceBy;
                        lodash.differenceWith = differenceWith;
                        lodash.drop = drop;
                        lodash.dropRight = dropRight;
                        lodash.dropRightWhile = dropRightWhile;
                        lodash.dropWhile = dropWhile;
                        lodash.fill = fill;
                        lodash.filter = filter;
                        lodash.flatMap = flatMap;
                        lodash.flatMapDeep = flatMapDeep;
                        lodash.flatMapDepth = flatMapDepth;
                        lodash.flatten = flatten;
                        lodash.flattenDeep = flattenDeep;
                        lodash.flattenDepth = flattenDepth;
                        lodash.flip = flip;
                        lodash.flow = flow;
                        lodash.flowRight = flowRight;
                        lodash.fromPairs = fromPairs;
                        lodash.functions = functions;
                        lodash.functionsIn = functionsIn;
                        lodash.groupBy = groupBy;
                        lodash.initial = initial;
                        lodash.intersection = intersection;
                        lodash.intersectionBy = intersectionBy;
                        lodash.intersectionWith = intersectionWith;
                        lodash.invert = invert;
                        lodash.invertBy = invertBy;
                        lodash.invokeMap = invokeMap;
                        lodash.iteratee = iteratee;
                        lodash.keyBy = keyBy;
                        lodash.keys = keys;
                        lodash.keysIn = keysIn;
                        lodash.map = map;
                        lodash.mapKeys = mapKeys;
                        lodash.mapValues = mapValues;
                        lodash.matches = matches;
                        lodash.matchesProperty = matchesProperty;
                        lodash.memoize = memoize;
                        lodash.merge = merge;
                        lodash.mergeWith = mergeWith;
                        lodash.method = method;
                        lodash.methodOf = methodOf;
                        lodash.mixin = mixin;
                        lodash.negate = negate;
                        lodash.nthArg = nthArg;
                        lodash.omit = omit;
                        lodash.omitBy = omitBy;
                        lodash.once = once;
                        lodash.orderBy = orderBy;
                        lodash.over = over;
                        lodash.overArgs = overArgs;
                        lodash.overEvery = overEvery;
                        lodash.overSome = overSome;
                        lodash.partial = partial;
                        lodash.partialRight = partialRight;
                        lodash.partition = partition;
                        lodash.pick = pick;
                        lodash.pickBy = pickBy;
                        lodash.property = property;
                        lodash.propertyOf = propertyOf;
                        lodash.pull = pull;
                        lodash.pullAll = pullAll;
                        lodash.pullAllBy = pullAllBy;
                        lodash.pullAllWith = pullAllWith;
                        lodash.pullAt = pullAt;
                        lodash.range = range;
                        lodash.rangeRight = rangeRight;
                        lodash.rearg = rearg;
                        lodash.reject = reject;
                        lodash.remove = remove;
                        lodash.rest = rest;
                        lodash.reverse = reverse;
                        lodash.sampleSize = sampleSize;
                        lodash.set = set;
                        lodash.setWith = setWith;
                        lodash.shuffle = shuffle;
                        lodash.slice = slice;
                        lodash.sortBy = sortBy;
                        lodash.sortedUniq = sortedUniq;
                        lodash.sortedUniqBy = sortedUniqBy;
                        lodash.split = split;
                        lodash.spread = spread;
                        lodash.tail = tail;
                        lodash.take = take;
                        lodash.takeRight = takeRight;
                        lodash.takeRightWhile = takeRightWhile;
                        lodash.takeWhile = takeWhile;
                        lodash.tap = tap;
                        lodash.throttle = throttle;
                        lodash.thru = thru;
                        lodash.toArray = toArray;
                        lodash.toPairs = toPairs;
                        lodash.toPairsIn = toPairsIn;
                        lodash.toPath = toPath;
                        lodash.toPlainObject = toPlainObject;
                        lodash.transform = transform;
                        lodash.unary = unary;
                        lodash.union = union;
                        lodash.unionBy = unionBy;
                        lodash.unionWith = unionWith;
                        lodash.uniq = uniq;
                        lodash.uniqBy = uniqBy;
                        lodash.uniqWith = uniqWith;
                        lodash.unset = unset;
                        lodash.unzip = unzip;
                        lodash.unzipWith = unzipWith;
                        lodash.update = update;
                        lodash.updateWith = updateWith;
                        lodash.values = values;
                        lodash.valuesIn = valuesIn;
                        lodash.without = without;
                        lodash.words = words;
                        lodash.wrap = wrap;
                        lodash.xor = xor;
                        lodash.xorBy = xorBy;
                        lodash.xorWith = xorWith;
                        lodash.zip = zip;
                        lodash.zipObject = zipObject;
                        lodash.zipObjectDeep = zipObjectDeep;
                        lodash.zipWith = zipWith;

                        // Add aliases.
                        lodash.entries = toPairs;
                        lodash.entriesIn = toPairsIn;
                        lodash.extend = assignIn;
                        lodash.extendWith = assignInWith;

                        // Add methods to `lodash.prototype`.
                        mixin(lodash, lodash);

                        /*------------------------------------------------------------------------*/

                        // Add methods that return unwrapped values in chain sequences.
                        lodash.add = add;
                        lodash.attempt = attempt;
                        lodash.camelCase = camelCase;
                        lodash.capitalize = capitalize;
                        lodash.ceil = ceil;
                        lodash.clamp = clamp;
                        lodash.clone = clone;
                        lodash.cloneDeep = cloneDeep;
                        lodash.cloneDeepWith = cloneDeepWith;
                        lodash.cloneWith = cloneWith;
                        lodash.conformsTo = conformsTo;
                        lodash.deburr = deburr;
                        lodash.defaultTo = defaultTo;
                        lodash.divide = divide;
                        lodash.endsWith = endsWith;
                        lodash.eq = eq;
                        lodash.escape = escape;
                        lodash.escapeRegExp = escapeRegExp;
                        lodash.every = every;
                        lodash.find = find;
                        lodash.findIndex = findIndex;
                        lodash.findKey = findKey;
                        lodash.findLast = findLast;
                        lodash.findLastIndex = findLastIndex;
                        lodash.findLastKey = findLastKey;
                        lodash.floor = floor;
                        lodash.forEach = forEach;
                        lodash.forEachRight = forEachRight;
                        lodash.forIn = forIn;
                        lodash.forInRight = forInRight;
                        lodash.forOwn = forOwn;
                        lodash.forOwnRight = forOwnRight;
                        lodash.get = get;
                        lodash.gt = gt;
                        lodash.gte = gte;
                        lodash.has = has;
                        lodash.hasIn = hasIn;
                        lodash.head = head;
                        lodash.identity = identity;
                        lodash.includes = includes;
                        lodash.indexOf = indexOf;
                        lodash.inRange = inRange;
                        lodash.invoke = invoke;
                        lodash.isArguments = isArguments;
                        lodash.isArray = isArray;
                        lodash.isArrayBuffer = isArrayBuffer;
                        lodash.isArrayLike = isArrayLike;
                        lodash.isArrayLikeObject = isArrayLikeObject;
                        lodash.isBoolean = isBoolean;
                        lodash.isBuffer = isBuffer;
                        lodash.isDate = isDate;
                        lodash.isElement = isElement;
                        lodash.isEmpty = isEmpty;
                        lodash.isEqual = isEqual;
                        lodash.isEqualWith = isEqualWith;
                        lodash.isError = isError;
                        lodash.isFinite = isFinite;
                        lodash.isFunction = isFunction;
                        lodash.isInteger = isInteger;
                        lodash.isLength = isLength;
                        lodash.isMap = isMap;
                        lodash.isMatch = isMatch;
                        lodash.isMatchWith = isMatchWith;
                        lodash.isNaN = isNaN;
                        lodash.isNative = isNative;
                        lodash.isNil = isNil;
                        lodash.isNull = isNull;
                        lodash.isNumber = isNumber;
                        lodash.isObject = isObject;
                        lodash.isObjectLike = isObjectLike;
                        lodash.isPlainObject = isPlainObject;
                        lodash.isRegExp = isRegExp;
                        lodash.isSafeInteger = isSafeInteger;
                        lodash.isSet = isSet;
                        lodash.isString = isString;
                        lodash.isSymbol = isSymbol;
                        lodash.isTypedArray = isTypedArray;
                        lodash.isUndefined = isUndefined;
                        lodash.isWeakMap = isWeakMap;
                        lodash.isWeakSet = isWeakSet;
                        lodash.join = join;
                        lodash.kebabCase = kebabCase;
                        lodash.last = last;
                        lodash.lastIndexOf = lastIndexOf;
                        lodash.lowerCase = lowerCase;
                        lodash.lowerFirst = lowerFirst;
                        lodash.lt = lt;
                        lodash.lte = lte;
                        lodash.max = max;
                        lodash.maxBy = maxBy;
                        lodash.mean = mean;
                        lodash.meanBy = meanBy;
                        lodash.min = min;
                        lodash.minBy = minBy;
                        lodash.stubArray = stubArray;
                        lodash.stubFalse = stubFalse;
                        lodash.stubObject = stubObject;
                        lodash.stubString = stubString;
                        lodash.stubTrue = stubTrue;
                        lodash.multiply = multiply;
                        lodash.nth = nth;
                        lodash.noConflict = noConflict;
                        lodash.noop = noop;
                        lodash.now = now;
                        lodash.pad = pad;
                        lodash.padEnd = padEnd;
                        lodash.padStart = padStart;
                        lodash.parseInt = parseInt;
                        lodash.random = random;
                        lodash.reduce = reduce;
                        lodash.reduceRight = reduceRight;
                        lodash.repeat = repeat;
                        lodash.replace = replace;
                        lodash.result = result;
                        lodash.round = round;
                        lodash.runInContext = runInContext;
                        lodash.sample = sample;
                        lodash.size = size;
                        lodash.snakeCase = snakeCase;
                        lodash.some = some;
                        lodash.sortedIndex = sortedIndex;
                        lodash.sortedIndexBy = sortedIndexBy;
                        lodash.sortedIndexOf = sortedIndexOf;
                        lodash.sortedLastIndex = sortedLastIndex;
                        lodash.sortedLastIndexBy = sortedLastIndexBy;
                        lodash.sortedLastIndexOf = sortedLastIndexOf;
                        lodash.startCase = startCase;
                        lodash.startsWith = startsWith;
                        lodash.subtract = subtract;
                        lodash.sum = sum;
                        lodash.sumBy = sumBy;
                        lodash.template = template;
                        lodash.times = times;
                        lodash.toFinite = toFinite;
                        lodash.toInteger = toInteger;
                        lodash.toLength = toLength;
                        lodash.toLower = toLower;
                        lodash.toNumber = toNumber;
                        lodash.toSafeInteger = toSafeInteger;
                        lodash.toString = toString;
                        lodash.toUpper = toUpper;
                        lodash.trim = trim;
                        lodash.trimEnd = trimEnd;
                        lodash.trimStart = trimStart;
                        lodash.truncate = truncate;
                        lodash.unescape = unescape;
                        lodash.uniqueId = uniqueId;
                        lodash.upperCase = upperCase;
                        lodash.upperFirst = upperFirst;

                        // Add aliases.
                        lodash.each = forEach;
                        lodash.eachRight = forEachRight;
                        lodash.first = head;

                        mixin(lodash, (function() {
                            var source = {};
                            baseForOwn(lodash, function(func, methodName) {
                                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                    source[methodName] = func;
                                }
                            });
                            return source;
                        }()), { 'chain': false });

                        /*------------------------------------------------------------------------*/

                        /**
                         * The semantic version number.
                         *
                         * @static
                         * @memberOf _
                         * @type {string}
                         */
                        lodash.VERSION = VERSION;

                        // Assign default placeholders.
                        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
                            lodash[methodName].placeholder = lodash;
                        });

                        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                        arrayEach(['drop', 'take'], function(methodName, index) {
                            LazyWrapper.prototype[methodName] = function(n) {
                                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

                                var result = (this.__filtered__ && !index)
                                    ? new LazyWrapper(this)
                                    : this.clone();

                                if (result.__filtered__) {
                                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                                } else {
                                    result.__views__.push({
                                        'size': nativeMin(n, MAX_ARRAY_LENGTH),
                                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                    });
                                }
                                return result;
                            };

                            LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                                return this.reverse()[methodName](n).reverse();
                            };
                        });

                        // Add `LazyWrapper` methods that accept an `iteratee` value.
                        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
                            var type = index + 1,
                                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

                            LazyWrapper.prototype[methodName] = function(iteratee) {
                                var result = this.clone();
                                result.__iteratees__.push({
                                    'iteratee': getIteratee(iteratee, 3),
                                    'type': type
                                });
                                result.__filtered__ = result.__filtered__ || isFilter;
                                return result;
                            };
                        });

                        // Add `LazyWrapper` methods for `_.head` and `_.last`.
                        arrayEach(['head', 'last'], function(methodName, index) {
                            var takeName = 'take' + (index ? 'Right' : '');

                            LazyWrapper.prototype[methodName] = function() {
                                return this[takeName](1).value()[0];
                            };
                        });

                        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
                        arrayEach(['initial', 'tail'], function(methodName, index) {
                            var dropName = 'drop' + (index ? '' : 'Right');

                            LazyWrapper.prototype[methodName] = function() {
                                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                            };
                        });

                        LazyWrapper.prototype.compact = function() {
                            return this.filter(identity);
                        };

                        LazyWrapper.prototype.find = function(predicate) {
                            return this.filter(predicate).head();
                        };

                        LazyWrapper.prototype.findLast = function(predicate) {
                            return this.reverse().find(predicate);
                        };

                        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                            if (typeof path == 'function') {
                                return new LazyWrapper(this);
                            }
                            return this.map(function(value) {
                                return baseInvoke(value, path, args);
                            });
                        });

                        LazyWrapper.prototype.reject = function(predicate) {
                            return this.filter(negate(getIteratee(predicate)));
                        };

                        LazyWrapper.prototype.slice = function(start, end) {
                            start = toInteger(start);

                            var result = this;
                            if (result.__filtered__ && (start > 0 || end < 0)) {
                                return new LazyWrapper(result);
                            }
                            if (start < 0) {
                                result = result.takeRight(-start);
                            } else if (start) {
                                result = result.drop(start);
                            }
                            if (end !== undefined) {
                                end = toInteger(end);
                                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                            }
                            return result;
                        };

                        LazyWrapper.prototype.takeRightWhile = function(predicate) {
                            return this.reverse().takeWhile(predicate).reverse();
                        };

                        LazyWrapper.prototype.toArray = function() {
                            return this.take(MAX_ARRAY_LENGTH);
                        };

                        // Add `LazyWrapper` methods to `lodash.prototype`.
                        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                                isTaker = /^(?:head|last)$/.test(methodName),
                                lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
                                retUnwrapped = isTaker || /^find/.test(methodName);

                            if (!lodashFunc) {
                                return;
                            }
                            lodash.prototype[methodName] = function() {
                                var value = this.__wrapped__,
                                    args = isTaker ? [1] : arguments,
                                    isLazy = value instanceof LazyWrapper,
                                    iteratee = args[0],
                                    useLazy = isLazy || isArray(value);

                                var interceptor = function(value) {
                                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                    return (isTaker && chainAll) ? result[0] : result;
                                };

                                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                    isLazy = useLazy = false;
                                }
                                var chainAll = this.__chain__,
                                    isHybrid = !!this.__actions__.length,
                                    isUnwrapped = retUnwrapped && !chainAll,
                                    onlyLazy = isLazy && !isHybrid;

                                if (!retUnwrapped && useLazy) {
                                    value = onlyLazy ? value : new LazyWrapper(this);
                                    var result = func.apply(value, args);
                                    result.__actions__.push({
                                        'func': thru,
                                        'args': [interceptor],
                                        'thisArg': undefined
                                    });
                                    return new LodashWrapper(result, chainAll);
                                }
                                if (isUnwrapped && onlyLazy) {
                                    return func.apply(this, args);
                                }
                                result = this.thru(interceptor);
                                return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
                            };
                        });

                        // Add `Array` methods to `lodash.prototype`.
                        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
                            var func = arrayProto[methodName],
                                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                                retUnwrapped = /^(?:pop|shift)$/.test(methodName);

                            lodash.prototype[methodName] = function() {
                                var args = arguments;
                                if (retUnwrapped && !this.__chain__) {
                                    var value = this.value();
                                    return func.apply(isArray(value) ? value : [], args);
                                }
                                return this[chainName](function(value) {
                                    return func.apply(isArray(value) ? value : [], args);
                                });
                            };
                        });

                        // Map minified method names to their real names.
                        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                            var lodashFunc = lodash[methodName];
                            if (lodashFunc) {
                                var key = (lodashFunc.name + ''),
                                    names = realNames[key] || (realNames[key] = []);

                                names.push({ 'name': methodName, 'func': lodashFunc });
                            }
                        });

                        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                            'name': 'wrapper',
                            'func': undefined
                        }];

                        // Add methods to `LazyWrapper`.
                        LazyWrapper.prototype.clone = lazyClone;
                        LazyWrapper.prototype.reverse = lazyReverse;
                        LazyWrapper.prototype.value = lazyValue;

                        // Add chain sequence methods to the `lodash` wrapper.
                        lodash.prototype.at = wrapperAt;
                        lodash.prototype.chain = wrapperChain;
                        lodash.prototype.commit = wrapperCommit;
                        lodash.prototype.next = wrapperNext;
                        lodash.prototype.plant = wrapperPlant;
                        lodash.prototype.reverse = wrapperReverse;
                        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                        // Add lazy aliases.
                        lodash.prototype.first = lodash.prototype.head;

                        if (symIterator) {
                            lodash.prototype[symIterator] = wrapperToIterator;
                        }
                        return lodash;
                    });

                    /*--------------------------------------------------------------------------*/

                    // Export lodash.
                    var _ = runInContext();

                    // Some AMD build optimizers, like r.js, check for condition patterns like:
                    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                        // Expose Lodash on the global object to prevent errors when Lodash is
                        // loaded by a script tag in the presence of an AMD loader.
                        // See http://requirejs.org/docs/errors.html#mismatch for more details.
                        // Use `_.noConflict` to remove Lodash from the global object.
                        root._ = _;

                        // Define as an anonymous module so, through path mapping, it can be
                        // referenced as the "underscore" module.
                        define(function() {
                            return _;
                        });
                    }
                    // Check for `exports` after `define` in case a build optimizer adds it.
                    else if (freeModule) {
                        // Export for Node.js.
                        (freeModule.exports = _)._ = _;
                        // Export for CommonJS support.
                        freeExports._ = _;
                    } else {
                        // Export to the global object.
                        root._ = _;
                    }
                }.call(this));

            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, {}],
        121: [function(require, module, exports) {
            'use strict';
            var inherits = require('inherits');
            var HashBase = require('hash-base');
            var Buffer = require('safe-buffer').Buffer;

            var ARRAY16 = new Array(16);

            function MD5() {
                HashBase.call(this, 64);

                // state
                this._a = 0x67452301;
                this._b = 0xefcdab89;
                this._c = 0x98badcfe;
                this._d = 0x10325476;
            }

            inherits(MD5, HashBase);

            MD5.prototype._update = function() {
                var M = ARRAY16;
                for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

                var a = this._a;
                var b = this._b;
                var c = this._c;
                var d = this._d;

                a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
                d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
                c = fnF(c, d, a, b, M[2], 0x242070db, 17);
                b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
                a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
                d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
                c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
                b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
                a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
                d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
                c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
                b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
                a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
                d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
                c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
                b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

                a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
                d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
                c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
                b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
                a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
                d = fnG(d, a, b, c, M[10], 0x02441453, 9);
                c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
                b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
                a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
                d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
                c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
                b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
                a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
                d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
                c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
                b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

                a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
                d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
                c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
                b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
                a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
                d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
                c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
                b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
                a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
                d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
                c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
                b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
                a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
                d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
                c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
                b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

                a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
                d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
                c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
                b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
                a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
                d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
                c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
                b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
                a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
                d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
                c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
                b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
                a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
                d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
                c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
                b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

                this._a = (this._a + a) | 0;
                this._b = (this._b + b) | 0;
                this._c = (this._c + c) | 0;
                this._d = (this._d + d) | 0;
            };

            MD5.prototype._digest = function() {
                // create padding and handle blocks
                this._block[this._blockOffset++] = 0x80;
                if (this._blockOffset > 56) {
                    this._block.fill(0, this._blockOffset, 64);
                    this._update();
                    this._blockOffset = 0;
                }

                this._block.fill(0, this._blockOffset, 56);
                this._block.writeUInt32LE(this._length[0], 56);
                this._block.writeUInt32LE(this._length[1], 60);
                this._update();

                // produce result
                var buffer = Buffer.allocUnsafe(16);
                buffer.writeInt32LE(this._a, 0);
                buffer.writeInt32LE(this._b, 4);
                buffer.writeInt32LE(this._c, 8);
                buffer.writeInt32LE(this._d, 12);
                return buffer;
            };

            function rotl(x, n) {
                return (x << n) | (x >>> (32 - n));
            }

            function fnF(a, b, c, d, m, k, s) {
                return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0;
            }

            function fnG(a, b, c, d, m, k, s) {
                return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0;
            }

            function fnH(a, b, c, d, m, k, s) {
                return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0;
            }

            function fnI(a, b, c, d, m, k, s) {
                return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0;
            }

            module.exports = MD5;

        }, { 'hash-base': 99, 'inherits': 116, 'safe-buffer': 169 }],
        122: [function(require, module, exports) {
            var bn = require('bn.js');
            var brorand = require('brorand');

            function MillerRabin(rand) {
                this.rand = rand || new brorand.Rand();
            }

            module.exports = MillerRabin;

            MillerRabin.create = function create(rand) {
                return new MillerRabin(rand);
            };

            MillerRabin.prototype._randbelow = function _randbelow(n) {
                var len = n.bitLength();
                var min_bytes = Math.ceil(len / 8);

                // Generage random bytes until a number less than n is found.
                // This ensures that 0..n-1 have an equal probability of being selected.
                do
                    var a = new bn(this.rand.generate(min_bytes));
                while (a.cmp(n) >= 0);

                return a;
            };

            MillerRabin.prototype._randrange = function _randrange(start, stop) {
                // Generate a random number greater than or equal to start and less than stop.
                var size = stop.sub(start);
                return start.add(this._randbelow(size));
            };

            MillerRabin.prototype.test = function test(n, k, cb) {
                var len = n.bitLength();
                var red = bn.mont(n);
                var rone = new bn(1).toRed(red);

                if (!k)
                    k = Math.max(1, (len / 48) | 0);

                // Find d and s, (n - 1) = (2 ^ s) * d;
                var n1 = n.subn(1);
                for (var s = 0; !n1.testn(s); s++) {
                }
                var d = n.shrn(s);

                var rn1 = n1.toRed(red);

                var prime = true;
                for (; k > 0; k--) {
                    var a = this._randrange(new bn(2), n1);
                    if (cb)
                        cb(a);

                    var x = a.toRed(red).redPow(d);
                    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                        continue;

                    for (var i = 1; i < s; i++) {
                        x = x.redSqr();

                        if (x.cmp(rone) === 0)
                            return false;
                        if (x.cmp(rn1) === 0)
                            break;
                    }

                    if (i === s)
                        return false;
                }

                return prime;
            };

            MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
                var len = n.bitLength();
                var red = bn.mont(n);
                var rone = new bn(1).toRed(red);

                if (!k)
                    k = Math.max(1, (len / 48) | 0);

                // Find d and s, (n - 1) = (2 ^ s) * d;
                var n1 = n.subn(1);
                for (var s = 0; !n1.testn(s); s++) {
                }
                var d = n.shrn(s);

                var rn1 = n1.toRed(red);

                for (; k > 0; k--) {
                    var a = this._randrange(new bn(2), n1);

                    var g = n.gcd(a);
                    if (g.cmpn(1) !== 0)
                        return g;

                    var x = a.toRed(red).redPow(d);
                    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                        continue;

                    for (var i = 1; i < s; i++) {
                        x = x.redSqr();

                        if (x.cmp(rone) === 0)
                            return x.fromRed().subn(1).gcd(n);
                        if (x.cmp(rn1) === 0)
                            break;
                    }

                    if (i === s) {
                        x = x.redSqr();
                        return x.fromRed().subn(1).gcd(n);
                    }
                }

                return false;
            };

        }, { 'bn.js': 27, 'brorand': 28 }],
        123: [function(require, module, exports) {
            module.exports = {
                'application/1d-interleaved-parityfec': {
                    'source': 'iana'
                },
                'application/3gpdash-qoe-report+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/3gpp-ims+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/a2l': {
                    'source': 'iana'
                },
                'application/activemessage': {
                    'source': 'iana'
                },
                'application/activity+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-costmap+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-costmapfilter+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-directory+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-endpointcost+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-endpointcostparams+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-endpointprop+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-endpointpropparams+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-error+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-networkmap+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/alto-networkmapfilter+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/aml': {
                    'source': 'iana'
                },
                'application/andrew-inset': {
                    'source': 'iana',
                    'extensions': ['ez']
                },
                'application/applefile': {
                    'source': 'iana'
                },
                'application/applixware': {
                    'source': 'apache',
                    'extensions': ['aw']
                },
                'application/atf': {
                    'source': 'iana'
                },
                'application/atfx': {
                    'source': 'iana'
                },
                'application/atom+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['atom']
                },
                'application/atomcat+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['atomcat']
                },
                'application/atomdeleted+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/atomicmail': {
                    'source': 'iana'
                },
                'application/atomsvc+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['atomsvc']
                },
                'application/atxml': {
                    'source': 'iana'
                },
                'application/auth-policy+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/bacnet-xdd+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/batch-smtp': {
                    'source': 'iana'
                },
                'application/bdoc': {
                    'compressible': false,
                    'extensions': ['bdoc']
                },
                'application/beep+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/calendar+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/calendar+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/call-completion': {
                    'source': 'iana'
                },
                'application/cals-1840': {
                    'source': 'iana'
                },
                'application/cbor': {
                    'source': 'iana'
                },
                'application/cccex': {
                    'source': 'iana'
                },
                'application/ccmp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/ccxml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['ccxml']
                },
                'application/cdfx+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cdmi-capability': {
                    'source': 'iana',
                    'extensions': ['cdmia']
                },
                'application/cdmi-container': {
                    'source': 'iana',
                    'extensions': ['cdmic']
                },
                'application/cdmi-domain': {
                    'source': 'iana',
                    'extensions': ['cdmid']
                },
                'application/cdmi-object': {
                    'source': 'iana',
                    'extensions': ['cdmio']
                },
                'application/cdmi-queue': {
                    'source': 'iana',
                    'extensions': ['cdmiq']
                },
                'application/cdni': {
                    'source': 'iana'
                },
                'application/cea': {
                    'source': 'iana'
                },
                'application/cea-2018+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cellml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cfw': {
                    'source': 'iana'
                },
                'application/clue_info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cms': {
                    'source': 'iana'
                },
                'application/cnrp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/coap-group+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/coap-payload': {
                    'source': 'iana'
                },
                'application/commonground': {
                    'source': 'iana'
                },
                'application/conference-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cose': {
                    'source': 'iana'
                },
                'application/cose-key': {
                    'source': 'iana'
                },
                'application/cose-key-set': {
                    'source': 'iana'
                },
                'application/cpl+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/csrattrs': {
                    'source': 'iana'
                },
                'application/csta+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cstadata+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/csvm+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/cu-seeme': {
                    'source': 'apache',
                    'extensions': ['cu']
                },
                'application/cwt': {
                    'source': 'iana'
                },
                'application/cybercash': {
                    'source': 'iana'
                },
                'application/dart': {
                    'compressible': true
                },
                'application/dash+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mpd']
                },
                'application/dashdelta': {
                    'source': 'iana'
                },
                'application/davmount+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['davmount']
                },
                'application/dca-rft': {
                    'source': 'iana'
                },
                'application/dcd': {
                    'source': 'iana'
                },
                'application/dec-dx': {
                    'source': 'iana'
                },
                'application/dialog-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/dicom': {
                    'source': 'iana'
                },
                'application/dicom+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/dicom+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/dii': {
                    'source': 'iana'
                },
                'application/dit': {
                    'source': 'iana'
                },
                'application/dns': {
                    'source': 'iana'
                },
                'application/dns+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/dns-message': {
                    'source': 'iana'
                },
                'application/docbook+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['dbk']
                },
                'application/dskpp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/dssc+der': {
                    'source': 'iana',
                    'extensions': ['dssc']
                },
                'application/dssc+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xdssc']
                },
                'application/dvcs': {
                    'source': 'iana'
                },
                'application/ecmascript': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['ecma', 'es']
                },
                'application/edi-consent': {
                    'source': 'iana'
                },
                'application/edi-x12': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/edifact': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/efi': {
                    'source': 'iana'
                },
                'application/emergencycalldata.comment+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.control+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.deviceinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.ecall.msd': {
                    'source': 'iana'
                },
                'application/emergencycalldata.providerinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.serviceinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.subscriberinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emergencycalldata.veds+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/emma+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['emma']
                },
                'application/emotionml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/encaprtp': {
                    'source': 'iana'
                },
                'application/epp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/epub+zip': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['epub']
                },
                'application/eshop': {
                    'source': 'iana'
                },
                'application/exi': {
                    'source': 'iana',
                    'extensions': ['exi']
                },
                'application/fastinfoset': {
                    'source': 'iana'
                },
                'application/fastsoap': {
                    'source': 'iana'
                },
                'application/fdt+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/fhir+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/fhir+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/fido.trusted-apps+json': {
                    'compressible': true
                },
                'application/fits': {
                    'source': 'iana'
                },
                'application/font-sfnt': {
                    'source': 'iana'
                },
                'application/font-tdpfr': {
                    'source': 'iana',
                    'extensions': ['pfr']
                },
                'application/font-woff': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/framework-attributes+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/geo+json': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['geojson']
                },
                'application/geo+json-seq': {
                    'source': 'iana'
                },
                'application/geopackage+sqlite3': {
                    'source': 'iana'
                },
                'application/geoxacml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/gltf-buffer': {
                    'source': 'iana'
                },
                'application/gml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['gml']
                },
                'application/gpx+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['gpx']
                },
                'application/gxf': {
                    'source': 'apache',
                    'extensions': ['gxf']
                },
                'application/gzip': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['gz']
                },
                'application/h224': {
                    'source': 'iana'
                },
                'application/held+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/hjson': {
                    'extensions': ['hjson']
                },
                'application/http': {
                    'source': 'iana'
                },
                'application/hyperstudio': {
                    'source': 'iana',
                    'extensions': ['stk']
                },
                'application/ibe-key-request+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/ibe-pkg-reply+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/ibe-pp-data': {
                    'source': 'iana'
                },
                'application/iges': {
                    'source': 'iana'
                },
                'application/im-iscomposing+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/index': {
                    'source': 'iana'
                },
                'application/index.cmd': {
                    'source': 'iana'
                },
                'application/index.obj': {
                    'source': 'iana'
                },
                'application/index.response': {
                    'source': 'iana'
                },
                'application/index.vnd': {
                    'source': 'iana'
                },
                'application/inkml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['ink', 'inkml']
                },
                'application/iotp': {
                    'source': 'iana'
                },
                'application/ipfix': {
                    'source': 'iana',
                    'extensions': ['ipfix']
                },
                'application/ipp': {
                    'source': 'iana'
                },
                'application/isup': {
                    'source': 'iana'
                },
                'application/its+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/java-archive': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['jar', 'war', 'ear']
                },
                'application/java-serialized-object': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['ser']
                },
                'application/java-vm': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['class']
                },
                'application/javascript': {
                    'source': 'iana',
                    'charset': 'UTF-8',
                    'compressible': true,
                    'extensions': ['js', 'mjs']
                },
                'application/jf2feed+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/jose': {
                    'source': 'iana'
                },
                'application/jose+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/jrd+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/json': {
                    'source': 'iana',
                    'charset': 'UTF-8',
                    'compressible': true,
                    'extensions': ['json', 'map']
                },
                'application/json-patch+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/json-seq': {
                    'source': 'iana'
                },
                'application/json5': {
                    'extensions': ['json5']
                },
                'application/jsonml+json': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['jsonml']
                },
                'application/jwk+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/jwk-set+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/jwt': {
                    'source': 'iana'
                },
                'application/kpml-request+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/kpml-response+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/ld+json': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['jsonld']
                },
                'application/lgr+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/link-format': {
                    'source': 'iana'
                },
                'application/load-control+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/lost+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['lostxml']
                },
                'application/lostsync+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/lxf': {
                    'source': 'iana'
                },
                'application/mac-binhex40': {
                    'source': 'iana',
                    'extensions': ['hqx']
                },
                'application/mac-compactpro': {
                    'source': 'apache',
                    'extensions': ['cpt']
                },
                'application/macwriteii': {
                    'source': 'iana'
                },
                'application/mads+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mads']
                },
                'application/manifest+json': {
                    'charset': 'UTF-8',
                    'compressible': true,
                    'extensions': ['webmanifest']
                },
                'application/marc': {
                    'source': 'iana',
                    'extensions': ['mrc']
                },
                'application/marcxml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mrcx']
                },
                'application/mathematica': {
                    'source': 'iana',
                    'extensions': ['ma', 'nb', 'mb']
                },
                'application/mathml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mathml']
                },
                'application/mathml-content+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mathml-presentation+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-associated-procedure-description+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-deregister+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-envelope+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-msk+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-msk-response+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-protection-description+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-reception-report+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-register+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-register-response+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-schedule+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbms-user-service-description+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mbox': {
                    'source': 'iana',
                    'extensions': ['mbox']
                },
                'application/media-policy-dataset+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/media_control+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mediaservercontrol+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mscml']
                },
                'application/merge-patch+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/metalink+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['metalink']
                },
                'application/metalink4+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['meta4']
                },
                'application/mets+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mets']
                },
                'application/mf4': {
                    'source': 'iana'
                },
                'application/mikey': {
                    'source': 'iana'
                },
                'application/mmt-usd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mods+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mods']
                },
                'application/moss-keys': {
                    'source': 'iana'
                },
                'application/moss-signature': {
                    'source': 'iana'
                },
                'application/mosskey-data': {
                    'source': 'iana'
                },
                'application/mosskey-request': {
                    'source': 'iana'
                },
                'application/mp21': {
                    'source': 'iana',
                    'extensions': ['m21', 'mp21']
                },
                'application/mp4': {
                    'source': 'iana',
                    'extensions': ['mp4s', 'm4p']
                },
                'application/mpeg4-generic': {
                    'source': 'iana'
                },
                'application/mpeg4-iod': {
                    'source': 'iana'
                },
                'application/mpeg4-iod-xmt': {
                    'source': 'iana'
                },
                'application/mrb-consumer+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mrb-publish+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/msc-ivr+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/msc-mixer+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/msword': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['doc', 'dot']
                },
                'application/mud+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/mxf': {
                    'source': 'iana',
                    'extensions': ['mxf']
                },
                'application/n-quads': {
                    'source': 'iana'
                },
                'application/n-triples': {
                    'source': 'iana'
                },
                'application/nasdata': {
                    'source': 'iana'
                },
                'application/news-checkgroups': {
                    'source': 'iana'
                },
                'application/news-groupinfo': {
                    'source': 'iana'
                },
                'application/news-transmission': {
                    'source': 'iana'
                },
                'application/nlsml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/node': {
                    'source': 'iana'
                },
                'application/nss': {
                    'source': 'iana'
                },
                'application/ocsp-request': {
                    'source': 'iana'
                },
                'application/ocsp-response': {
                    'source': 'iana'
                },
                'application/octet-stream': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy', 'exe', 'dll', 'deb', 'dmg', 'iso', 'img', 'msi', 'msp', 'msm', 'buffer']
                },
                'application/oda': {
                    'source': 'iana',
                    'extensions': ['oda']
                },
                'application/odx': {
                    'source': 'iana'
                },
                'application/oebps-package+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['opf']
                },
                'application/ogg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['ogx']
                },
                'application/omdoc+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['omdoc']
                },
                'application/onenote': {
                    'source': 'apache',
                    'extensions': ['onetoc', 'onetoc2', 'onetmp', 'onepkg']
                },
                'application/oxps': {
                    'source': 'iana',
                    'extensions': ['oxps']
                },
                'application/p2p-overlay+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/parityfec': {
                    'source': 'iana'
                },
                'application/passport': {
                    'source': 'iana'
                },
                'application/patch-ops-error+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xer']
                },
                'application/pdf': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['pdf']
                },
                'application/pdx': {
                    'source': 'iana'
                },
                'application/pgp-encrypted': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['pgp']
                },
                'application/pgp-keys': {
                    'source': 'iana'
                },
                'application/pgp-signature': {
                    'source': 'iana',
                    'extensions': ['asc', 'sig']
                },
                'application/pics-rules': {
                    'source': 'apache',
                    'extensions': ['prf']
                },
                'application/pidf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/pidf-diff+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/pkcs10': {
                    'source': 'iana',
                    'extensions': ['p10']
                },
                'application/pkcs12': {
                    'source': 'iana'
                },
                'application/pkcs7-mime': {
                    'source': 'iana',
                    'extensions': ['p7m', 'p7c']
                },
                'application/pkcs7-signature': {
                    'source': 'iana',
                    'extensions': ['p7s']
                },
                'application/pkcs8': {
                    'source': 'iana',
                    'extensions': ['p8']
                },
                'application/pkcs8-encrypted': {
                    'source': 'iana'
                },
                'application/pkix-attr-cert': {
                    'source': 'iana',
                    'extensions': ['ac']
                },
                'application/pkix-cert': {
                    'source': 'iana',
                    'extensions': ['cer']
                },
                'application/pkix-crl': {
                    'source': 'iana',
                    'extensions': ['crl']
                },
                'application/pkix-pkipath': {
                    'source': 'iana',
                    'extensions': ['pkipath']
                },
                'application/pkixcmp': {
                    'source': 'iana',
                    'extensions': ['pki']
                },
                'application/pls+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['pls']
                },
                'application/poc-settings+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/postscript': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['ai', 'eps', 'ps']
                },
                'application/ppsp-tracker+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/problem+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/problem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/provenance+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/prs.alvestrand.titrax-sheet': {
                    'source': 'iana'
                },
                'application/prs.cww': {
                    'source': 'iana',
                    'extensions': ['cww']
                },
                'application/prs.hpub+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/prs.nprend': {
                    'source': 'iana'
                },
                'application/prs.plucker': {
                    'source': 'iana'
                },
                'application/prs.rdf-xml-crypt': {
                    'source': 'iana'
                },
                'application/prs.xsf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/pskc+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['pskcxml']
                },
                'application/qsig': {
                    'source': 'iana'
                },
                'application/raml+yaml': {
                    'compressible': true,
                    'extensions': ['raml']
                },
                'application/raptorfec': {
                    'source': 'iana'
                },
                'application/rdap+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/rdf+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rdf', 'owl']
                },
                'application/reginfo+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rif']
                },
                'application/relax-ng-compact-syntax': {
                    'source': 'iana',
                    'extensions': ['rnc']
                },
                'application/remote-printing': {
                    'source': 'iana'
                },
                'application/reputon+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/resource-lists+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rl']
                },
                'application/resource-lists-diff+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rld']
                },
                'application/rfc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/riscos': {
                    'source': 'iana'
                },
                'application/rlmi+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/rls-services+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rs']
                },
                'application/route-apd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/route-s-tsid+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/route-usd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/rpki-ghostbusters': {
                    'source': 'iana',
                    'extensions': ['gbr']
                },
                'application/rpki-manifest': {
                    'source': 'iana',
                    'extensions': ['mft']
                },
                'application/rpki-publication': {
                    'source': 'iana'
                },
                'application/rpki-roa': {
                    'source': 'iana',
                    'extensions': ['roa']
                },
                'application/rpki-updown': {
                    'source': 'iana'
                },
                'application/rsd+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['rsd']
                },
                'application/rss+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['rss']
                },
                'application/rtf': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rtf']
                },
                'application/rtploopback': {
                    'source': 'iana'
                },
                'application/rtx': {
                    'source': 'iana'
                },
                'application/samlassertion+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/samlmetadata+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sbml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['sbml']
                },
                'application/scaip+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/scim+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/scvp-cv-request': {
                    'source': 'iana',
                    'extensions': ['scq']
                },
                'application/scvp-cv-response': {
                    'source': 'iana',
                    'extensions': ['scs']
                },
                'application/scvp-vp-request': {
                    'source': 'iana',
                    'extensions': ['spq']
                },
                'application/scvp-vp-response': {
                    'source': 'iana',
                    'extensions': ['spp']
                },
                'application/sdp': {
                    'source': 'iana',
                    'extensions': ['sdp']
                },
                'application/secevent+jwt': {
                    'source': 'iana'
                },
                'application/senml+cbor': {
                    'source': 'iana'
                },
                'application/senml+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/senml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/senml-exi': {
                    'source': 'iana'
                },
                'application/sensml+cbor': {
                    'source': 'iana'
                },
                'application/sensml+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sensml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sensml-exi': {
                    'source': 'iana'
                },
                'application/sep+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sep-exi': {
                    'source': 'iana'
                },
                'application/session-info': {
                    'source': 'iana'
                },
                'application/set-payment': {
                    'source': 'iana'
                },
                'application/set-payment-initiation': {
                    'source': 'iana',
                    'extensions': ['setpay']
                },
                'application/set-registration': {
                    'source': 'iana'
                },
                'application/set-registration-initiation': {
                    'source': 'iana',
                    'extensions': ['setreg']
                },
                'application/sgml': {
                    'source': 'iana'
                },
                'application/sgml-open-catalog': {
                    'source': 'iana'
                },
                'application/shf+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['shf']
                },
                'application/sieve': {
                    'source': 'iana'
                },
                'application/simple-filter+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/simple-message-summary': {
                    'source': 'iana'
                },
                'application/simplesymbolcontainer': {
                    'source': 'iana'
                },
                'application/slate': {
                    'source': 'iana'
                },
                'application/smil': {
                    'source': 'iana'
                },
                'application/smil+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['smi', 'smil']
                },
                'application/smpte336m': {
                    'source': 'iana'
                },
                'application/soap+fastinfoset': {
                    'source': 'iana'
                },
                'application/soap+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sparql-query': {
                    'source': 'iana',
                    'extensions': ['rq']
                },
                'application/sparql-results+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['srx']
                },
                'application/spirits-event+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/sql': {
                    'source': 'iana'
                },
                'application/srgs': {
                    'source': 'iana',
                    'extensions': ['gram']
                },
                'application/srgs+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['grxml']
                },
                'application/sru+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['sru']
                },
                'application/ssdl+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['ssdl']
                },
                'application/ssml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['ssml']
                },
                'application/stix+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/tamp-apex-update': {
                    'source': 'iana'
                },
                'application/tamp-apex-update-confirm': {
                    'source': 'iana'
                },
                'application/tamp-community-update': {
                    'source': 'iana'
                },
                'application/tamp-community-update-confirm': {
                    'source': 'iana'
                },
                'application/tamp-error': {
                    'source': 'iana'
                },
                'application/tamp-sequence-adjust': {
                    'source': 'iana'
                },
                'application/tamp-sequence-adjust-confirm': {
                    'source': 'iana'
                },
                'application/tamp-status-query': {
                    'source': 'iana'
                },
                'application/tamp-status-response': {
                    'source': 'iana'
                },
                'application/tamp-update': {
                    'source': 'iana'
                },
                'application/tamp-update-confirm': {
                    'source': 'iana'
                },
                'application/tar': {
                    'compressible': true
                },
                'application/taxii+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/tei+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['tei', 'teicorpus']
                },
                'application/thraud+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['tfi']
                },
                'application/timestamp-query': {
                    'source': 'iana'
                },
                'application/timestamp-reply': {
                    'source': 'iana'
                },
                'application/timestamped-data': {
                    'source': 'iana',
                    'extensions': ['tsd']
                },
                'application/tlsrpt+gzip': {
                    'source': 'iana'
                },
                'application/tlsrpt+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/tnauthlist': {
                    'source': 'iana'
                },
                'application/trickle-ice-sdpfrag': {
                    'source': 'iana'
                },
                'application/trig': {
                    'source': 'iana'
                },
                'application/ttml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/tve-trigger': {
                    'source': 'iana'
                },
                'application/ulpfec': {
                    'source': 'iana'
                },
                'application/urc-grpsheet+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/urc-ressheet+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/urc-targetdesc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/urc-uisocketdesc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vcard+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vcard+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vemmi': {
                    'source': 'iana'
                },
                'application/vividence.scriptfile': {
                    'source': 'apache'
                },
                'application/vnd.1000minds.decision-model+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp-prose+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp-prose-pc3ch+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp-v2x-local-service-information': {
                    'source': 'iana'
                },
                'application/vnd.3gpp.access-transfer-events+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.bsf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.gmop+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mc-signalling-ear': {
                    'source': 'iana'
                },
                'application/vnd.3gpp.mcdata-payload': {
                    'source': 'iana'
                },
                'application/vnd.3gpp.mcdata-signalling': {
                    'source': 'iana'
                },
                'application/vnd.3gpp.mcptt-affiliation-command+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mcptt-floor-request+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mcptt-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mcptt-location-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mcptt-mbms-usage-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mcptt-signed+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.mid-call+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.pic-bw-large': {
                    'source': 'iana',
                    'extensions': ['plb']
                },
                'application/vnd.3gpp.pic-bw-small': {
                    'source': 'iana',
                    'extensions': ['psb']
                },
                'application/vnd.3gpp.pic-bw-var': {
                    'source': 'iana',
                    'extensions': ['pvb']
                },
                'application/vnd.3gpp.sms': {
                    'source': 'iana'
                },
                'application/vnd.3gpp.sms+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.srvcc-ext+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.srvcc-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.state-and-event-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp.ussd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp2.bcmcsinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.3gpp2.sms': {
                    'source': 'iana'
                },
                'application/vnd.3gpp2.tcap': {
                    'source': 'iana',
                    'extensions': ['tcap']
                },
                'application/vnd.3lightssoftware.imagescal': {
                    'source': 'iana'
                },
                'application/vnd.3m.post-it-notes': {
                    'source': 'iana',
                    'extensions': ['pwn']
                },
                'application/vnd.accpac.simply.aso': {
                    'source': 'iana',
                    'extensions': ['aso']
                },
                'application/vnd.accpac.simply.imp': {
                    'source': 'iana',
                    'extensions': ['imp']
                },
                'application/vnd.acucobol': {
                    'source': 'iana',
                    'extensions': ['acu']
                },
                'application/vnd.acucorp': {
                    'source': 'iana',
                    'extensions': ['atc', 'acutc']
                },
                'application/vnd.adobe.air-application-installer-package+zip': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['air']
                },
                'application/vnd.adobe.flash.movie': {
                    'source': 'iana'
                },
                'application/vnd.adobe.formscentral.fcdt': {
                    'source': 'iana',
                    'extensions': ['fcdt']
                },
                'application/vnd.adobe.fxp': {
                    'source': 'iana',
                    'extensions': ['fxp', 'fxpl']
                },
                'application/vnd.adobe.partial-upload': {
                    'source': 'iana'
                },
                'application/vnd.adobe.xdp+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xdp']
                },
                'application/vnd.adobe.xfdf': {
                    'source': 'iana',
                    'extensions': ['xfdf']
                },
                'application/vnd.aether.imp': {
                    'source': 'iana'
                },
                'application/vnd.afpc.afplinedata': {
                    'source': 'iana'
                },
                'application/vnd.afpc.modca': {
                    'source': 'iana'
                },
                'application/vnd.ah-barcode': {
                    'source': 'iana'
                },
                'application/vnd.ahead.space': {
                    'source': 'iana',
                    'extensions': ['ahead']
                },
                'application/vnd.airzip.filesecure.azf': {
                    'source': 'iana',
                    'extensions': ['azf']
                },
                'application/vnd.airzip.filesecure.azs': {
                    'source': 'iana',
                    'extensions': ['azs']
                },
                'application/vnd.amadeus+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.amazon.ebook': {
                    'source': 'apache',
                    'extensions': ['azw']
                },
                'application/vnd.amazon.mobi8-ebook': {
                    'source': 'iana'
                },
                'application/vnd.americandynamics.acc': {
                    'source': 'iana',
                    'extensions': ['acc']
                },
                'application/vnd.amiga.ami': {
                    'source': 'iana',
                    'extensions': ['ami']
                },
                'application/vnd.amundsen.maze+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.android.package-archive': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['apk']
                },
                'application/vnd.anki': {
                    'source': 'iana'
                },
                'application/vnd.anser-web-certificate-issue-initiation': {
                    'source': 'iana',
                    'extensions': ['cii']
                },
                'application/vnd.anser-web-funds-transfer-initiation': {
                    'source': 'apache',
                    'extensions': ['fti']
                },
                'application/vnd.antix.game-component': {
                    'source': 'iana',
                    'extensions': ['atx']
                },
                'application/vnd.apache.thrift.binary': {
                    'source': 'iana'
                },
                'application/vnd.apache.thrift.compact': {
                    'source': 'iana'
                },
                'application/vnd.apache.thrift.json': {
                    'source': 'iana'
                },
                'application/vnd.api+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.apothekende.reservation+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.apple.installer+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mpkg']
                },
                'application/vnd.apple.keynote': {
                    'source': 'iana',
                    'extensions': ['keynote']
                },
                'application/vnd.apple.mpegurl': {
                    'source': 'iana',
                    'extensions': ['m3u8']
                },
                'application/vnd.apple.numbers': {
                    'source': 'iana',
                    'extensions': ['numbers']
                },
                'application/vnd.apple.pages': {
                    'source': 'iana',
                    'extensions': ['pages']
                },
                'application/vnd.apple.pkpass': {
                    'compressible': false,
                    'extensions': ['pkpass']
                },
                'application/vnd.arastra.swi': {
                    'source': 'iana'
                },
                'application/vnd.aristanetworks.swi': {
                    'source': 'iana',
                    'extensions': ['swi']
                },
                'application/vnd.artisan+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.artsquare': {
                    'source': 'iana'
                },
                'application/vnd.astraea-software.iota': {
                    'source': 'iana',
                    'extensions': ['iota']
                },
                'application/vnd.audiograph': {
                    'source': 'iana',
                    'extensions': ['aep']
                },
                'application/vnd.autopackage': {
                    'source': 'iana'
                },
                'application/vnd.avalon+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.avistar+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.balsamiq.bmml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.balsamiq.bmpr': {
                    'source': 'iana'
                },
                'application/vnd.banana-accounting': {
                    'source': 'iana'
                },
                'application/vnd.bbf.usp.msg': {
                    'source': 'iana'
                },
                'application/vnd.bbf.usp.msg+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.bekitzur-stech+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.bint.med-content': {
                    'source': 'iana'
                },
                'application/vnd.biopax.rdf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.blink-idb-value-wrapper': {
                    'source': 'iana'
                },
                'application/vnd.blueice.multipass': {
                    'source': 'iana',
                    'extensions': ['mpm']
                },
                'application/vnd.bluetooth.ep.oob': {
                    'source': 'iana'
                },
                'application/vnd.bluetooth.le.oob': {
                    'source': 'iana'
                },
                'application/vnd.bmi': {
                    'source': 'iana',
                    'extensions': ['bmi']
                },
                'application/vnd.businessobjects': {
                    'source': 'iana',
                    'extensions': ['rep']
                },
                'application/vnd.byu.uapi+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.cab-jscript': {
                    'source': 'iana'
                },
                'application/vnd.canon-cpdl': {
                    'source': 'iana'
                },
                'application/vnd.canon-lips': {
                    'source': 'iana'
                },
                'application/vnd.capasystems-pg+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.cendio.thinlinc.clientconf': {
                    'source': 'iana'
                },
                'application/vnd.century-systems.tcp_stream': {
                    'source': 'iana'
                },
                'application/vnd.chemdraw+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['cdxml']
                },
                'application/vnd.chess-pgn': {
                    'source': 'iana'
                },
                'application/vnd.chipnuts.karaoke-mmd': {
                    'source': 'iana',
                    'extensions': ['mmd']
                },
                'application/vnd.cinderella': {
                    'source': 'iana',
                    'extensions': ['cdy']
                },
                'application/vnd.cirpack.isdn-ext': {
                    'source': 'iana'
                },
                'application/vnd.citationstyles.style+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['csl']
                },
                'application/vnd.claymore': {
                    'source': 'iana',
                    'extensions': ['cla']
                },
                'application/vnd.cloanto.rp9': {
                    'source': 'iana',
                    'extensions': ['rp9']
                },
                'application/vnd.clonk.c4group': {
                    'source': 'iana',
                    'extensions': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u']
                },
                'application/vnd.cluetrust.cartomobile-config': {
                    'source': 'iana',
                    'extensions': ['c11amc']
                },
                'application/vnd.cluetrust.cartomobile-config-pkg': {
                    'source': 'iana',
                    'extensions': ['c11amz']
                },
                'application/vnd.coffeescript': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.document': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.document-template': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.presentation': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.presentation-template': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.spreadsheet': {
                    'source': 'iana'
                },
                'application/vnd.collabio.xodocuments.spreadsheet-template': {
                    'source': 'iana'
                },
                'application/vnd.collection+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.collection.doc+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.collection.next+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.comicbook+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.comicbook-rar': {
                    'source': 'iana'
                },
                'application/vnd.commerce-battelle': {
                    'source': 'iana'
                },
                'application/vnd.commonspace': {
                    'source': 'iana',
                    'extensions': ['csp']
                },
                'application/vnd.contact.cmsg': {
                    'source': 'iana',
                    'extensions': ['cdbcmsg']
                },
                'application/vnd.coreos.ignition+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.cosmocaller': {
                    'source': 'iana',
                    'extensions': ['cmc']
                },
                'application/vnd.crick.clicker': {
                    'source': 'iana',
                    'extensions': ['clkx']
                },
                'application/vnd.crick.clicker.keyboard': {
                    'source': 'iana',
                    'extensions': ['clkk']
                },
                'application/vnd.crick.clicker.palette': {
                    'source': 'iana',
                    'extensions': ['clkp']
                },
                'application/vnd.crick.clicker.template': {
                    'source': 'iana',
                    'extensions': ['clkt']
                },
                'application/vnd.crick.clicker.wordbank': {
                    'source': 'iana',
                    'extensions': ['clkw']
                },
                'application/vnd.criticaltools.wbs+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['wbs']
                },
                'application/vnd.ctc-posml': {
                    'source': 'iana',
                    'extensions': ['pml']
                },
                'application/vnd.ctct.ws+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.cups-pdf': {
                    'source': 'iana'
                },
                'application/vnd.cups-postscript': {
                    'source': 'iana'
                },
                'application/vnd.cups-ppd': {
                    'source': 'iana',
                    'extensions': ['ppd']
                },
                'application/vnd.cups-raster': {
                    'source': 'iana'
                },
                'application/vnd.cups-raw': {
                    'source': 'iana'
                },
                'application/vnd.curl': {
                    'source': 'iana'
                },
                'application/vnd.curl.car': {
                    'source': 'apache',
                    'extensions': ['car']
                },
                'application/vnd.curl.pcurl': {
                    'source': 'apache',
                    'extensions': ['pcurl']
                },
                'application/vnd.cyan.dean.root+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.cybank': {
                    'source': 'iana'
                },
                'application/vnd.d2l.coursepackage1p0+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.dart': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['dart']
                },
                'application/vnd.data-vision.rdz': {
                    'source': 'iana',
                    'extensions': ['rdz']
                },
                'application/vnd.datapackage+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dataresource+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.debian.binary-package': {
                    'source': 'iana'
                },
                'application/vnd.dece.data': {
                    'source': 'iana',
                    'extensions': ['uvf', 'uvvf', 'uvd', 'uvvd']
                },
                'application/vnd.dece.ttml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['uvt', 'uvvt']
                },
                'application/vnd.dece.unspecified': {
                    'source': 'iana',
                    'extensions': ['uvx', 'uvvx']
                },
                'application/vnd.dece.zip': {
                    'source': 'iana',
                    'extensions': ['uvz', 'uvvz']
                },
                'application/vnd.denovo.fcselayout-link': {
                    'source': 'iana',
                    'extensions': ['fe_launch']
                },
                'application/vnd.desmume.movie': {
                    'source': 'iana'
                },
                'application/vnd.dir-bi.plate-dl-nosuffix': {
                    'source': 'iana'
                },
                'application/vnd.dm.delegation+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dna': {
                    'source': 'iana',
                    'extensions': ['dna']
                },
                'application/vnd.document+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dolby.mlp': {
                    'source': 'apache',
                    'extensions': ['mlp']
                },
                'application/vnd.dolby.mobile.1': {
                    'source': 'iana'
                },
                'application/vnd.dolby.mobile.2': {
                    'source': 'iana'
                },
                'application/vnd.doremir.scorecloud-binary-document': {
                    'source': 'iana'
                },
                'application/vnd.dpgraph': {
                    'source': 'iana',
                    'extensions': ['dpg']
                },
                'application/vnd.dreamfactory': {
                    'source': 'iana',
                    'extensions': ['dfac']
                },
                'application/vnd.drive+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ds-keypoint': {
                    'source': 'apache',
                    'extensions': ['kpxx']
                },
                'application/vnd.dtg.local': {
                    'source': 'iana'
                },
                'application/vnd.dtg.local.flash': {
                    'source': 'iana'
                },
                'application/vnd.dtg.local.html': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ait': {
                    'source': 'iana',
                    'extensions': ['ait']
                },
                'application/vnd.dvb.dvbj': {
                    'source': 'iana'
                },
                'application/vnd.dvb.esgcontainer': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ipdcdftnotifaccess': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ipdcesgaccess': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ipdcesgaccess2': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ipdcesgpdd': {
                    'source': 'iana'
                },
                'application/vnd.dvb.ipdcroaming': {
                    'source': 'iana'
                },
                'application/vnd.dvb.iptv.alfec-base': {
                    'source': 'iana'
                },
                'application/vnd.dvb.iptv.alfec-enhancement': {
                    'source': 'iana'
                },
                'application/vnd.dvb.notif-aggregate-root+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-container+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-generic+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-ia-msglist+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-ia-registration-request+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-ia-registration-response+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.notif-init+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.dvb.pfr': {
                    'source': 'iana'
                },
                'application/vnd.dvb.service': {
                    'source': 'iana',
                    'extensions': ['svc']
                },
                'application/vnd.dxr': {
                    'source': 'iana'
                },
                'application/vnd.dynageo': {
                    'source': 'iana',
                    'extensions': ['geo']
                },
                'application/vnd.dzr': {
                    'source': 'iana'
                },
                'application/vnd.easykaraoke.cdgdownload': {
                    'source': 'iana'
                },
                'application/vnd.ecdis-update': {
                    'source': 'iana'
                },
                'application/vnd.ecip.rlp': {
                    'source': 'iana'
                },
                'application/vnd.ecowin.chart': {
                    'source': 'iana',
                    'extensions': ['mag']
                },
                'application/vnd.ecowin.filerequest': {
                    'source': 'iana'
                },
                'application/vnd.ecowin.fileupdate': {
                    'source': 'iana'
                },
                'application/vnd.ecowin.series': {
                    'source': 'iana'
                },
                'application/vnd.ecowin.seriesrequest': {
                    'source': 'iana'
                },
                'application/vnd.ecowin.seriesupdate': {
                    'source': 'iana'
                },
                'application/vnd.efi.img': {
                    'source': 'iana'
                },
                'application/vnd.efi.iso': {
                    'source': 'iana'
                },
                'application/vnd.emclient.accessrequest+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.enliven': {
                    'source': 'iana',
                    'extensions': ['nml']
                },
                'application/vnd.enphase.envoy': {
                    'source': 'iana'
                },
                'application/vnd.eprints.data+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.epson.esf': {
                    'source': 'iana',
                    'extensions': ['esf']
                },
                'application/vnd.epson.msf': {
                    'source': 'iana',
                    'extensions': ['msf']
                },
                'application/vnd.epson.quickanime': {
                    'source': 'iana',
                    'extensions': ['qam']
                },
                'application/vnd.epson.salt': {
                    'source': 'iana',
                    'extensions': ['slt']
                },
                'application/vnd.epson.ssf': {
                    'source': 'iana',
                    'extensions': ['ssf']
                },
                'application/vnd.ericsson.quickcall': {
                    'source': 'iana'
                },
                'application/vnd.espass-espass+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.eszigno3+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['es3', 'et3']
                },
                'application/vnd.etsi.aoc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.asic-e+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.etsi.asic-s+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.etsi.cug+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvcommand+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvdiscovery+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvprofile+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvsad-bc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvsad-cod+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvsad-npvr+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvservice+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvsync+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.iptvueprofile+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.mcid+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.mheg5': {
                    'source': 'iana'
                },
                'application/vnd.etsi.overload-control-policy-dataset+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.pstn+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.sci+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.simservs+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.timestamp-token': {
                    'source': 'iana'
                },
                'application/vnd.etsi.tsl+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.etsi.tsl.der': {
                    'source': 'iana'
                },
                'application/vnd.eudora.data': {
                    'source': 'iana'
                },
                'application/vnd.evolv.ecig.profile': {
                    'source': 'iana'
                },
                'application/vnd.evolv.ecig.settings': {
                    'source': 'iana'
                },
                'application/vnd.evolv.ecig.theme': {
                    'source': 'iana'
                },
                'application/vnd.exstream-empower+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.ezpix-album': {
                    'source': 'iana',
                    'extensions': ['ez2']
                },
                'application/vnd.ezpix-package': {
                    'source': 'iana',
                    'extensions': ['ez3']
                },
                'application/vnd.f-secure.mobile': {
                    'source': 'iana'
                },
                'application/vnd.fastcopy-disk-image': {
                    'source': 'iana'
                },
                'application/vnd.fdf': {
                    'source': 'iana',
                    'extensions': ['fdf']
                },
                'application/vnd.fdsn.mseed': {
                    'source': 'iana',
                    'extensions': ['mseed']
                },
                'application/vnd.fdsn.seed': {
                    'source': 'iana',
                    'extensions': ['seed', 'dataless']
                },
                'application/vnd.ffsns': {
                    'source': 'iana'
                },
                'application/vnd.filmit.zfc': {
                    'source': 'iana'
                },
                'application/vnd.fints': {
                    'source': 'iana'
                },
                'application/vnd.firemonkeys.cloudcell': {
                    'source': 'iana'
                },
                'application/vnd.flographit': {
                    'source': 'iana',
                    'extensions': ['gph']
                },
                'application/vnd.fluxtime.clip': {
                    'source': 'iana',
                    'extensions': ['ftc']
                },
                'application/vnd.font-fontforge-sfd': {
                    'source': 'iana'
                },
                'application/vnd.framemaker': {
                    'source': 'iana',
                    'extensions': ['fm', 'frame', 'maker', 'book']
                },
                'application/vnd.frogans.fnc': {
                    'source': 'iana',
                    'extensions': ['fnc']
                },
                'application/vnd.frogans.ltf': {
                    'source': 'iana',
                    'extensions': ['ltf']
                },
                'application/vnd.fsc.weblaunch': {
                    'source': 'iana',
                    'extensions': ['fsc']
                },
                'application/vnd.fujitsu.oasys': {
                    'source': 'iana',
                    'extensions': ['oas']
                },
                'application/vnd.fujitsu.oasys2': {
                    'source': 'iana',
                    'extensions': ['oa2']
                },
                'application/vnd.fujitsu.oasys3': {
                    'source': 'iana',
                    'extensions': ['oa3']
                },
                'application/vnd.fujitsu.oasysgp': {
                    'source': 'iana',
                    'extensions': ['fg5']
                },
                'application/vnd.fujitsu.oasysprs': {
                    'source': 'iana',
                    'extensions': ['bh2']
                },
                'application/vnd.fujixerox.art-ex': {
                    'source': 'iana'
                },
                'application/vnd.fujixerox.art4': {
                    'source': 'iana'
                },
                'application/vnd.fujixerox.ddd': {
                    'source': 'iana',
                    'extensions': ['ddd']
                },
                'application/vnd.fujixerox.docuworks': {
                    'source': 'iana',
                    'extensions': ['xdw']
                },
                'application/vnd.fujixerox.docuworks.binder': {
                    'source': 'iana',
                    'extensions': ['xbd']
                },
                'application/vnd.fujixerox.docuworks.container': {
                    'source': 'iana'
                },
                'application/vnd.fujixerox.hbpl': {
                    'source': 'iana'
                },
                'application/vnd.fut-misnet': {
                    'source': 'iana'
                },
                'application/vnd.futoin+cbor': {
                    'source': 'iana'
                },
                'application/vnd.futoin+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.fuzzysheet': {
                    'source': 'iana',
                    'extensions': ['fzs']
                },
                'application/vnd.genomatix.tuxedo': {
                    'source': 'iana',
                    'extensions': ['txd']
                },
                'application/vnd.geo+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.geocube+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.geogebra.file': {
                    'source': 'iana',
                    'extensions': ['ggb']
                },
                'application/vnd.geogebra.tool': {
                    'source': 'iana',
                    'extensions': ['ggt']
                },
                'application/vnd.geometry-explorer': {
                    'source': 'iana',
                    'extensions': ['gex', 'gre']
                },
                'application/vnd.geonext': {
                    'source': 'iana',
                    'extensions': ['gxt']
                },
                'application/vnd.geoplan': {
                    'source': 'iana',
                    'extensions': ['g2w']
                },
                'application/vnd.geospace': {
                    'source': 'iana',
                    'extensions': ['g3w']
                },
                'application/vnd.gerber': {
                    'source': 'iana'
                },
                'application/vnd.globalplatform.card-content-mgt': {
                    'source': 'iana'
                },
                'application/vnd.globalplatform.card-content-mgt-response': {
                    'source': 'iana'
                },
                'application/vnd.gmx': {
                    'source': 'iana',
                    'extensions': ['gmx']
                },
                'application/vnd.google-apps.document': {
                    'compressible': false,
                    'extensions': ['gdoc']
                },
                'application/vnd.google-apps.presentation': {
                    'compressible': false,
                    'extensions': ['gslides']
                },
                'application/vnd.google-apps.spreadsheet': {
                    'compressible': false,
                    'extensions': ['gsheet']
                },
                'application/vnd.google-earth.kml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['kml']
                },
                'application/vnd.google-earth.kmz': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['kmz']
                },
                'application/vnd.gov.sk.e-form+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.gov.sk.e-form+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.gov.sk.xmldatacontainer+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.grafeq': {
                    'source': 'iana',
                    'extensions': ['gqf', 'gqs']
                },
                'application/vnd.gridmp': {
                    'source': 'iana'
                },
                'application/vnd.groove-account': {
                    'source': 'iana',
                    'extensions': ['gac']
                },
                'application/vnd.groove-help': {
                    'source': 'iana',
                    'extensions': ['ghf']
                },
                'application/vnd.groove-identity-message': {
                    'source': 'iana',
                    'extensions': ['gim']
                },
                'application/vnd.groove-injector': {
                    'source': 'iana',
                    'extensions': ['grv']
                },
                'application/vnd.groove-tool-message': {
                    'source': 'iana',
                    'extensions': ['gtm']
                },
                'application/vnd.groove-tool-template': {
                    'source': 'iana',
                    'extensions': ['tpl']
                },
                'application/vnd.groove-vcard': {
                    'source': 'iana',
                    'extensions': ['vcg']
                },
                'application/vnd.hal+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hal+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['hal']
                },
                'application/vnd.handheld-entertainment+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['zmm']
                },
                'application/vnd.hbci': {
                    'source': 'iana',
                    'extensions': ['hbci']
                },
                'application/vnd.hc+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hcl-bireports': {
                    'source': 'iana'
                },
                'application/vnd.hdt': {
                    'source': 'iana'
                },
                'application/vnd.heroku+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hhe.lesson-player': {
                    'source': 'iana',
                    'extensions': ['les']
                },
                'application/vnd.hp-hpgl': {
                    'source': 'iana',
                    'extensions': ['hpgl']
                },
                'application/vnd.hp-hpid': {
                    'source': 'iana',
                    'extensions': ['hpid']
                },
                'application/vnd.hp-hps': {
                    'source': 'iana',
                    'extensions': ['hps']
                },
                'application/vnd.hp-jlyt': {
                    'source': 'iana',
                    'extensions': ['jlt']
                },
                'application/vnd.hp-pcl': {
                    'source': 'iana',
                    'extensions': ['pcl']
                },
                'application/vnd.hp-pclxl': {
                    'source': 'iana',
                    'extensions': ['pclxl']
                },
                'application/vnd.httphone': {
                    'source': 'iana'
                },
                'application/vnd.hydrostatix.sof-data': {
                    'source': 'iana',
                    'extensions': ['sfd-hdstx']
                },
                'application/vnd.hyper+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hyper-item+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hyperdrive+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.hzn-3d-crossword': {
                    'source': 'iana'
                },
                'application/vnd.ibm.afplinedata': {
                    'source': 'iana'
                },
                'application/vnd.ibm.electronic-media': {
                    'source': 'iana'
                },
                'application/vnd.ibm.minipay': {
                    'source': 'iana',
                    'extensions': ['mpy']
                },
                'application/vnd.ibm.modcap': {
                    'source': 'iana',
                    'extensions': ['afp', 'listafp', 'list3820']
                },
                'application/vnd.ibm.rights-management': {
                    'source': 'iana',
                    'extensions': ['irm']
                },
                'application/vnd.ibm.secure-container': {
                    'source': 'iana',
                    'extensions': ['sc']
                },
                'application/vnd.iccprofile': {
                    'source': 'iana',
                    'extensions': ['icc', 'icm']
                },
                'application/vnd.ieee.1905': {
                    'source': 'iana'
                },
                'application/vnd.igloader': {
                    'source': 'iana',
                    'extensions': ['igl']
                },
                'application/vnd.imagemeter.folder+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.imagemeter.image+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'application/vnd.immervision-ivp': {
                    'source': 'iana',
                    'extensions': ['ivp']
                },
                'application/vnd.immervision-ivu': {
                    'source': 'iana',
                    'extensions': ['ivu']
                },
                'application/vnd.ims.imsccv1p1': {
                    'source': 'iana'
                },
                'application/vnd.ims.imsccv1p2': {
                    'source': 'iana'
                },
                'application/vnd.ims.imsccv1p3': {
                    'source': 'iana'
                },
                'application/vnd.ims.lis.v2.result+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ims.lti.v2.toolconsumerprofile+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ims.lti.v2.toolproxy+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ims.lti.v2.toolproxy.id+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ims.lti.v2.toolsettings+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ims.lti.v2.toolsettings.simple+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.informedcontrol.rms+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.informix-visionary': {
                    'source': 'iana'
                },
                'application/vnd.infotech.project': {
                    'source': 'iana'
                },
                'application/vnd.infotech.project+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.innopath.wamp.notification': {
                    'source': 'iana'
                },
                'application/vnd.insors.igm': {
                    'source': 'iana',
                    'extensions': ['igm']
                },
                'application/vnd.intercon.formnet': {
                    'source': 'iana',
                    'extensions': ['xpw', 'xpx']
                },
                'application/vnd.intergeo': {
                    'source': 'iana',
                    'extensions': ['i2g']
                },
                'application/vnd.intertrust.digibox': {
                    'source': 'iana'
                },
                'application/vnd.intertrust.nncp': {
                    'source': 'iana'
                },
                'application/vnd.intu.qbo': {
                    'source': 'iana',
                    'extensions': ['qbo']
                },
                'application/vnd.intu.qfx': {
                    'source': 'iana',
                    'extensions': ['qfx']
                },
                'application/vnd.iptc.g2.catalogitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.conceptitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.knowledgeitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.newsitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.newsmessage+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.packageitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.iptc.g2.planningitem+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ipunplugged.rcprofile': {
                    'source': 'iana',
                    'extensions': ['rcprofile']
                },
                'application/vnd.irepository.package+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['irp']
                },
                'application/vnd.is-xpr': {
                    'source': 'iana',
                    'extensions': ['xpr']
                },
                'application/vnd.isac.fcs': {
                    'source': 'iana',
                    'extensions': ['fcs']
                },
                'application/vnd.jam': {
                    'source': 'iana',
                    'extensions': ['jam']
                },
                'application/vnd.japannet-directory-service': {
                    'source': 'iana'
                },
                'application/vnd.japannet-jpnstore-wakeup': {
                    'source': 'iana'
                },
                'application/vnd.japannet-payment-wakeup': {
                    'source': 'iana'
                },
                'application/vnd.japannet-registration': {
                    'source': 'iana'
                },
                'application/vnd.japannet-registration-wakeup': {
                    'source': 'iana'
                },
                'application/vnd.japannet-setstore-wakeup': {
                    'source': 'iana'
                },
                'application/vnd.japannet-verification': {
                    'source': 'iana'
                },
                'application/vnd.japannet-verification-wakeup': {
                    'source': 'iana'
                },
                'application/vnd.jcp.javame.midlet-rms': {
                    'source': 'iana',
                    'extensions': ['rms']
                },
                'application/vnd.jisp': {
                    'source': 'iana',
                    'extensions': ['jisp']
                },
                'application/vnd.joost.joda-archive': {
                    'source': 'iana',
                    'extensions': ['joda']
                },
                'application/vnd.jsk.isdn-ngn': {
                    'source': 'iana'
                },
                'application/vnd.kahootz': {
                    'source': 'iana',
                    'extensions': ['ktz', 'ktr']
                },
                'application/vnd.kde.karbon': {
                    'source': 'iana',
                    'extensions': ['karbon']
                },
                'application/vnd.kde.kchart': {
                    'source': 'iana',
                    'extensions': ['chrt']
                },
                'application/vnd.kde.kformula': {
                    'source': 'iana',
                    'extensions': ['kfo']
                },
                'application/vnd.kde.kivio': {
                    'source': 'iana',
                    'extensions': ['flw']
                },
                'application/vnd.kde.kontour': {
                    'source': 'iana',
                    'extensions': ['kon']
                },
                'application/vnd.kde.kpresenter': {
                    'source': 'iana',
                    'extensions': ['kpr', 'kpt']
                },
                'application/vnd.kde.kspread': {
                    'source': 'iana',
                    'extensions': ['ksp']
                },
                'application/vnd.kde.kword': {
                    'source': 'iana',
                    'extensions': ['kwd', 'kwt']
                },
                'application/vnd.kenameaapp': {
                    'source': 'iana',
                    'extensions': ['htke']
                },
                'application/vnd.kidspiration': {
                    'source': 'iana',
                    'extensions': ['kia']
                },
                'application/vnd.kinar': {
                    'source': 'iana',
                    'extensions': ['kne', 'knp']
                },
                'application/vnd.koan': {
                    'source': 'iana',
                    'extensions': ['skp', 'skd', 'skt', 'skm']
                },
                'application/vnd.kodak-descriptor': {
                    'source': 'iana',
                    'extensions': ['sse']
                },
                'application/vnd.las.las+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.las.las+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['lasxml']
                },
                'application/vnd.leap+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.liberty-request+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.llamagraphics.life-balance.desktop': {
                    'source': 'iana',
                    'extensions': ['lbd']
                },
                'application/vnd.llamagraphics.life-balance.exchange+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['lbe']
                },
                'application/vnd.lotus-1-2-3': {
                    'source': 'iana',
                    'extensions': ['123']
                },
                'application/vnd.lotus-approach': {
                    'source': 'iana',
                    'extensions': ['apr']
                },
                'application/vnd.lotus-freelance': {
                    'source': 'iana',
                    'extensions': ['pre']
                },
                'application/vnd.lotus-notes': {
                    'source': 'iana',
                    'extensions': ['nsf']
                },
                'application/vnd.lotus-organizer': {
                    'source': 'iana',
                    'extensions': ['org']
                },
                'application/vnd.lotus-screencam': {
                    'source': 'iana',
                    'extensions': ['scm']
                },
                'application/vnd.lotus-wordpro': {
                    'source': 'iana',
                    'extensions': ['lwp']
                },
                'application/vnd.macports.portpkg': {
                    'source': 'iana',
                    'extensions': ['portpkg']
                },
                'application/vnd.mapbox-vector-tile': {
                    'source': 'iana'
                },
                'application/vnd.marlin.drm.actiontoken+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.marlin.drm.conftoken+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.marlin.drm.license+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.marlin.drm.mdcf': {
                    'source': 'iana'
                },
                'application/vnd.mason+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.maxmind.maxmind-db': {
                    'source': 'iana'
                },
                'application/vnd.mcd': {
                    'source': 'iana',
                    'extensions': ['mcd']
                },
                'application/vnd.medcalcdata': {
                    'source': 'iana',
                    'extensions': ['mc1']
                },
                'application/vnd.mediastation.cdkey': {
                    'source': 'iana',
                    'extensions': ['cdkey']
                },
                'application/vnd.meridian-slingshot': {
                    'source': 'iana'
                },
                'application/vnd.mfer': {
                    'source': 'iana',
                    'extensions': ['mwf']
                },
                'application/vnd.mfmp': {
                    'source': 'iana',
                    'extensions': ['mfm']
                },
                'application/vnd.micro+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.micrografx.flo': {
                    'source': 'iana',
                    'extensions': ['flo']
                },
                'application/vnd.micrografx.igx': {
                    'source': 'iana',
                    'extensions': ['igx']
                },
                'application/vnd.microsoft.portable-executable': {
                    'source': 'iana'
                },
                'application/vnd.microsoft.windows.thumbnail-cache': {
                    'source': 'iana'
                },
                'application/vnd.miele+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.mif': {
                    'source': 'iana',
                    'extensions': ['mif']
                },
                'application/vnd.minisoft-hp3000-save': {
                    'source': 'iana'
                },
                'application/vnd.mitsubishi.misty-guard.trustweb': {
                    'source': 'iana'
                },
                'application/vnd.mobius.daf': {
                    'source': 'iana',
                    'extensions': ['daf']
                },
                'application/vnd.mobius.dis': {
                    'source': 'iana',
                    'extensions': ['dis']
                },
                'application/vnd.mobius.mbk': {
                    'source': 'iana',
                    'extensions': ['mbk']
                },
                'application/vnd.mobius.mqy': {
                    'source': 'iana',
                    'extensions': ['mqy']
                },
                'application/vnd.mobius.msl': {
                    'source': 'iana',
                    'extensions': ['msl']
                },
                'application/vnd.mobius.plc': {
                    'source': 'iana',
                    'extensions': ['plc']
                },
                'application/vnd.mobius.txf': {
                    'source': 'iana',
                    'extensions': ['txf']
                },
                'application/vnd.mophun.application': {
                    'source': 'iana',
                    'extensions': ['mpn']
                },
                'application/vnd.mophun.certificate': {
                    'source': 'iana',
                    'extensions': ['mpc']
                },
                'application/vnd.motorola.flexsuite': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.adsi': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.fis': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.gotap': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.kmr': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.ttc': {
                    'source': 'iana'
                },
                'application/vnd.motorola.flexsuite.wem': {
                    'source': 'iana'
                },
                'application/vnd.motorola.iprm': {
                    'source': 'iana'
                },
                'application/vnd.mozilla.xul+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xul']
                },
                'application/vnd.ms-3mfdocument': {
                    'source': 'iana'
                },
                'application/vnd.ms-artgalry': {
                    'source': 'iana',
                    'extensions': ['cil']
                },
                'application/vnd.ms-asf': {
                    'source': 'iana'
                },
                'application/vnd.ms-cab-compressed': {
                    'source': 'iana',
                    'extensions': ['cab']
                },
                'application/vnd.ms-color.iccprofile': {
                    'source': 'apache'
                },
                'application/vnd.ms-excel': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw']
                },
                'application/vnd.ms-excel.addin.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['xlam']
                },
                'application/vnd.ms-excel.sheet.binary.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['xlsb']
                },
                'application/vnd.ms-excel.sheet.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['xlsm']
                },
                'application/vnd.ms-excel.template.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['xltm']
                },
                'application/vnd.ms-fontobject': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['eot']
                },
                'application/vnd.ms-htmlhelp': {
                    'source': 'iana',
                    'extensions': ['chm']
                },
                'application/vnd.ms-ims': {
                    'source': 'iana',
                    'extensions': ['ims']
                },
                'application/vnd.ms-lrm': {
                    'source': 'iana',
                    'extensions': ['lrm']
                },
                'application/vnd.ms-office.activex+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ms-officetheme': {
                    'source': 'iana',
                    'extensions': ['thmx']
                },
                'application/vnd.ms-opentype': {
                    'source': 'apache',
                    'compressible': true
                },
                'application/vnd.ms-outlook': {
                    'compressible': false,
                    'extensions': ['msg']
                },
                'application/vnd.ms-package.obfuscated-opentype': {
                    'source': 'apache'
                },
                'application/vnd.ms-pki.seccat': {
                    'source': 'apache',
                    'extensions': ['cat']
                },
                'application/vnd.ms-pki.stl': {
                    'source': 'apache',
                    'extensions': ['stl']
                },
                'application/vnd.ms-playready.initiator+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ms-powerpoint': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['ppt', 'pps', 'pot']
                },
                'application/vnd.ms-powerpoint.addin.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['ppam']
                },
                'application/vnd.ms-powerpoint.presentation.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['pptm']
                },
                'application/vnd.ms-powerpoint.slide.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['sldm']
                },
                'application/vnd.ms-powerpoint.slideshow.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['ppsm']
                },
                'application/vnd.ms-powerpoint.template.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['potm']
                },
                'application/vnd.ms-printdevicecapabilities+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ms-printing.printticket+xml': {
                    'source': 'apache',
                    'compressible': true
                },
                'application/vnd.ms-printschematicket+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.ms-project': {
                    'source': 'iana',
                    'extensions': ['mpp', 'mpt']
                },
                'application/vnd.ms-tnef': {
                    'source': 'iana'
                },
                'application/vnd.ms-windows.devicepairing': {
                    'source': 'iana'
                },
                'application/vnd.ms-windows.nwprinting.oob': {
                    'source': 'iana'
                },
                'application/vnd.ms-windows.printerpairing': {
                    'source': 'iana'
                },
                'application/vnd.ms-windows.wsd.oob': {
                    'source': 'iana'
                },
                'application/vnd.ms-wmdrm.lic-chlg-req': {
                    'source': 'iana'
                },
                'application/vnd.ms-wmdrm.lic-resp': {
                    'source': 'iana'
                },
                'application/vnd.ms-wmdrm.meter-chlg-req': {
                    'source': 'iana'
                },
                'application/vnd.ms-wmdrm.meter-resp': {
                    'source': 'iana'
                },
                'application/vnd.ms-word.document.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['docm']
                },
                'application/vnd.ms-word.template.macroenabled.12': {
                    'source': 'iana',
                    'extensions': ['dotm']
                },
                'application/vnd.ms-works': {
                    'source': 'iana',
                    'extensions': ['wps', 'wks', 'wcm', 'wdb']
                },
                'application/vnd.ms-wpl': {
                    'source': 'iana',
                    'extensions': ['wpl']
                },
                'application/vnd.ms-xpsdocument': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['xps']
                },
                'application/vnd.msa-disk-image': {
                    'source': 'iana'
                },
                'application/vnd.mseq': {
                    'source': 'iana',
                    'extensions': ['mseq']
                },
                'application/vnd.msign': {
                    'source': 'iana'
                },
                'application/vnd.multiad.creator': {
                    'source': 'iana'
                },
                'application/vnd.multiad.creator.cif': {
                    'source': 'iana'
                },
                'application/vnd.music-niff': {
                    'source': 'iana'
                },
                'application/vnd.musician': {
                    'source': 'iana',
                    'extensions': ['mus']
                },
                'application/vnd.muvee.style': {
                    'source': 'iana',
                    'extensions': ['msty']
                },
                'application/vnd.mynfc': {
                    'source': 'iana',
                    'extensions': ['taglet']
                },
                'application/vnd.ncd.control': {
                    'source': 'iana'
                },
                'application/vnd.ncd.reference': {
                    'source': 'iana'
                },
                'application/vnd.nearst.inv+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nervana': {
                    'source': 'iana'
                },
                'application/vnd.netfpx': {
                    'source': 'iana'
                },
                'application/vnd.neurolanguage.nlu': {
                    'source': 'iana',
                    'extensions': ['nlu']
                },
                'application/vnd.nimn': {
                    'source': 'iana'
                },
                'application/vnd.nintendo.nitro.rom': {
                    'source': 'iana'
                },
                'application/vnd.nintendo.snes.rom': {
                    'source': 'iana'
                },
                'application/vnd.nitf': {
                    'source': 'iana',
                    'extensions': ['ntf', 'nitf']
                },
                'application/vnd.noblenet-directory': {
                    'source': 'iana',
                    'extensions': ['nnd']
                },
                'application/vnd.noblenet-sealer': {
                    'source': 'iana',
                    'extensions': ['nns']
                },
                'application/vnd.noblenet-web': {
                    'source': 'iana',
                    'extensions': ['nnw']
                },
                'application/vnd.nokia.catalogs': {
                    'source': 'iana'
                },
                'application/vnd.nokia.conml+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.nokia.conml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.iptv.config+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.isds-radio-presets': {
                    'source': 'iana'
                },
                'application/vnd.nokia.landmark+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.nokia.landmark+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.landmarkcollection+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.n-gage.ac+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.n-gage.data': {
                    'source': 'iana',
                    'extensions': ['ngdat']
                },
                'application/vnd.nokia.n-gage.symbian.install': {
                    'source': 'iana',
                    'extensions': ['n-gage']
                },
                'application/vnd.nokia.ncd': {
                    'source': 'iana'
                },
                'application/vnd.nokia.pcd+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.nokia.pcd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.nokia.radio-preset': {
                    'source': 'iana',
                    'extensions': ['rpst']
                },
                'application/vnd.nokia.radio-presets': {
                    'source': 'iana',
                    'extensions': ['rpss']
                },
                'application/vnd.novadigm.edm': {
                    'source': 'iana',
                    'extensions': ['edm']
                },
                'application/vnd.novadigm.edx': {
                    'source': 'iana',
                    'extensions': ['edx']
                },
                'application/vnd.novadigm.ext': {
                    'source': 'iana',
                    'extensions': ['ext']
                },
                'application/vnd.ntt-local.content-share': {
                    'source': 'iana'
                },
                'application/vnd.ntt-local.file-transfer': {
                    'source': 'iana'
                },
                'application/vnd.ntt-local.ogw_remote-access': {
                    'source': 'iana'
                },
                'application/vnd.ntt-local.sip-ta_remote': {
                    'source': 'iana'
                },
                'application/vnd.ntt-local.sip-ta_tcp_stream': {
                    'source': 'iana'
                },
                'application/vnd.oasis.opendocument.chart': {
                    'source': 'iana',
                    'extensions': ['odc']
                },
                'application/vnd.oasis.opendocument.chart-template': {
                    'source': 'iana',
                    'extensions': ['otc']
                },
                'application/vnd.oasis.opendocument.database': {
                    'source': 'iana',
                    'extensions': ['odb']
                },
                'application/vnd.oasis.opendocument.formula': {
                    'source': 'iana',
                    'extensions': ['odf']
                },
                'application/vnd.oasis.opendocument.formula-template': {
                    'source': 'iana',
                    'extensions': ['odft']
                },
                'application/vnd.oasis.opendocument.graphics': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['odg']
                },
                'application/vnd.oasis.opendocument.graphics-template': {
                    'source': 'iana',
                    'extensions': ['otg']
                },
                'application/vnd.oasis.opendocument.image': {
                    'source': 'iana',
                    'extensions': ['odi']
                },
                'application/vnd.oasis.opendocument.image-template': {
                    'source': 'iana',
                    'extensions': ['oti']
                },
                'application/vnd.oasis.opendocument.presentation': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['odp']
                },
                'application/vnd.oasis.opendocument.presentation-template': {
                    'source': 'iana',
                    'extensions': ['otp']
                },
                'application/vnd.oasis.opendocument.spreadsheet': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['ods']
                },
                'application/vnd.oasis.opendocument.spreadsheet-template': {
                    'source': 'iana',
                    'extensions': ['ots']
                },
                'application/vnd.oasis.opendocument.text': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['odt']
                },
                'application/vnd.oasis.opendocument.text-master': {
                    'source': 'iana',
                    'extensions': ['odm']
                },
                'application/vnd.oasis.opendocument.text-template': {
                    'source': 'iana',
                    'extensions': ['ott']
                },
                'application/vnd.oasis.opendocument.text-web': {
                    'source': 'iana',
                    'extensions': ['oth']
                },
                'application/vnd.obn': {
                    'source': 'iana'
                },
                'application/vnd.ocf+cbor': {
                    'source': 'iana'
                },
                'application/vnd.oftn.l10n+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.contentaccessdownload+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.contentaccessstreaming+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.cspg-hexbinary': {
                    'source': 'iana'
                },
                'application/vnd.oipf.dae.svg+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.dae.xhtml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.mippvcontrolmessage+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.pae.gem': {
                    'source': 'iana'
                },
                'application/vnd.oipf.spdiscovery+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.spdlist+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.ueprofile+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oipf.userprofile+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.olpc-sugar': {
                    'source': 'iana',
                    'extensions': ['xo']
                },
                'application/vnd.oma-scws-config': {
                    'source': 'iana'
                },
                'application/vnd.oma-scws-http-request': {
                    'source': 'iana'
                },
                'application/vnd.oma-scws-http-response': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.associated-procedure-parameter+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.drm-trigger+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.imd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.ltkm': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.notification+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.provisioningtrigger': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.sgboot': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.sgdd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.sgdu': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.simple-symbol-container': {
                    'source': 'iana'
                },
                'application/vnd.oma.bcast.smartcard-trigger+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.sprov+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.bcast.stkm': {
                    'source': 'iana'
                },
                'application/vnd.oma.cab-address-book+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.cab-feature-handler+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.cab-pcc+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.cab-subs-invite+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.cab-user-prefs+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.dcd': {
                    'source': 'iana'
                },
                'application/vnd.oma.dcdc': {
                    'source': 'iana'
                },
                'application/vnd.oma.dd2+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['dd2']
                },
                'application/vnd.oma.drm.risd+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.group-usage-list+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.lwm2m+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.lwm2m+tlv': {
                    'source': 'iana'
                },
                'application/vnd.oma.pal+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.poc.detailed-progress-report+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.poc.final-report+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.poc.groups+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.poc.invocation-descriptor+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.poc.optimized-progress-report+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.push': {
                    'source': 'iana'
                },
                'application/vnd.oma.scidm.messages+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oma.xcap-directory+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.omads-email+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.omads-file+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.omads-folder+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.omaloc-supl-init': {
                    'source': 'iana'
                },
                'application/vnd.onepager': {
                    'source': 'iana'
                },
                'application/vnd.onepagertamp': {
                    'source': 'iana'
                },
                'application/vnd.onepagertamx': {
                    'source': 'iana'
                },
                'application/vnd.onepagertat': {
                    'source': 'iana'
                },
                'application/vnd.onepagertatp': {
                    'source': 'iana'
                },
                'application/vnd.onepagertatx': {
                    'source': 'iana'
                },
                'application/vnd.openblox.game+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openblox.game-binary': {
                    'source': 'iana'
                },
                'application/vnd.openeye.oeb': {
                    'source': 'iana'
                },
                'application/vnd.openofficeorg.extension': {
                    'source': 'apache',
                    'extensions': ['oxt']
                },
                'application/vnd.openstreetmap.data+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.custom-properties+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawing+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.extended-properties+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['pptx']
                },
                'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slide': {
                    'source': 'iana',
                    'extensions': ['sldx']
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slideshow': {
                    'source': 'iana',
                    'extensions': ['ppsx']
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.template': {
                    'source': 'iana',
                    'extensions': ['potx']
                },
                'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['xlsx']
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.template': {
                    'source': 'iana',
                    'extensions': ['xltx']
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.theme+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.themeoverride+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.vmldrawing': {
                    'source': 'iana'
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['docx']
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.template': {
                    'source': 'iana',
                    'extensions': ['dotx']
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-package.core-properties+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.openxmlformats-package.relationships+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oracle.resource+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.orange.indata': {
                    'source': 'iana'
                },
                'application/vnd.osa.netdeploy': {
                    'source': 'iana'
                },
                'application/vnd.osgeo.mapguide.package': {
                    'source': 'iana',
                    'extensions': ['mgp']
                },
                'application/vnd.osgi.bundle': {
                    'source': 'iana'
                },
                'application/vnd.osgi.dp': {
                    'source': 'iana',
                    'extensions': ['dp']
                },
                'application/vnd.osgi.subsystem': {
                    'source': 'iana',
                    'extensions': ['esa']
                },
                'application/vnd.otps.ct-kip+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.oxli.countgraph': {
                    'source': 'iana'
                },
                'application/vnd.pagerduty+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.palm': {
                    'source': 'iana',
                    'extensions': ['pdb', 'pqa', 'oprc']
                },
                'application/vnd.panoply': {
                    'source': 'iana'
                },
                'application/vnd.paos.xml': {
                    'source': 'iana'
                },
                'application/vnd.patentdive': {
                    'source': 'iana'
                },
                'application/vnd.pawaafile': {
                    'source': 'iana',
                    'extensions': ['paw']
                },
                'application/vnd.pcos': {
                    'source': 'iana'
                },
                'application/vnd.pg.format': {
                    'source': 'iana',
                    'extensions': ['str']
                },
                'application/vnd.pg.osasli': {
                    'source': 'iana',
                    'extensions': ['ei6']
                },
                'application/vnd.piaccess.application-licence': {
                    'source': 'iana'
                },
                'application/vnd.picsel': {
                    'source': 'iana',
                    'extensions': ['efif']
                },
                'application/vnd.pmi.widget': {
                    'source': 'iana',
                    'extensions': ['wg']
                },
                'application/vnd.poc.group-advertisement+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.pocketlearn': {
                    'source': 'iana',
                    'extensions': ['plf']
                },
                'application/vnd.powerbuilder6': {
                    'source': 'iana',
                    'extensions': ['pbd']
                },
                'application/vnd.powerbuilder6-s': {
                    'source': 'iana'
                },
                'application/vnd.powerbuilder7': {
                    'source': 'iana'
                },
                'application/vnd.powerbuilder7-s': {
                    'source': 'iana'
                },
                'application/vnd.powerbuilder75': {
                    'source': 'iana'
                },
                'application/vnd.powerbuilder75-s': {
                    'source': 'iana'
                },
                'application/vnd.preminet': {
                    'source': 'iana'
                },
                'application/vnd.previewsystems.box': {
                    'source': 'iana',
                    'extensions': ['box']
                },
                'application/vnd.proteus.magazine': {
                    'source': 'iana',
                    'extensions': ['mgz']
                },
                'application/vnd.psfs': {
                    'source': 'iana'
                },
                'application/vnd.publishare-delta-tree': {
                    'source': 'iana',
                    'extensions': ['qps']
                },
                'application/vnd.pvi.ptid1': {
                    'source': 'iana',
                    'extensions': ['ptid']
                },
                'application/vnd.pwg-multiplexed': {
                    'source': 'iana'
                },
                'application/vnd.pwg-xhtml-print+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.qualcomm.brew-app-res': {
                    'source': 'iana'
                },
                'application/vnd.quarantainenet': {
                    'source': 'iana'
                },
                'application/vnd.quark.quarkxpress': {
                    'source': 'iana',
                    'extensions': ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb']
                },
                'application/vnd.quobject-quoxdocument': {
                    'source': 'iana'
                },
                'application/vnd.radisys.moml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-audit+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-audit-conf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-audit-conn+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-audit-dialog+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-audit-stream+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-conf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-base+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-fax-detect+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-group+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-speech+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.radisys.msml-dialog-transform+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.rainstor.data': {
                    'source': 'iana'
                },
                'application/vnd.rapid': {
                    'source': 'iana'
                },
                'application/vnd.rar': {
                    'source': 'iana'
                },
                'application/vnd.realvnc.bed': {
                    'source': 'iana',
                    'extensions': ['bed']
                },
                'application/vnd.recordare.musicxml': {
                    'source': 'iana',
                    'extensions': ['mxl']
                },
                'application/vnd.recordare.musicxml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['musicxml']
                },
                'application/vnd.renlearn.rlprint': {
                    'source': 'iana'
                },
                'application/vnd.restful+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.rig.cryptonote': {
                    'source': 'iana',
                    'extensions': ['cryptonote']
                },
                'application/vnd.rim.cod': {
                    'source': 'apache',
                    'extensions': ['cod']
                },
                'application/vnd.rn-realmedia': {
                    'source': 'apache',
                    'extensions': ['rm']
                },
                'application/vnd.rn-realmedia-vbr': {
                    'source': 'apache',
                    'extensions': ['rmvb']
                },
                'application/vnd.route66.link66+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['link66']
                },
                'application/vnd.rs-274x': {
                    'source': 'iana'
                },
                'application/vnd.ruckus.download': {
                    'source': 'iana'
                },
                'application/vnd.s3sms': {
                    'source': 'iana'
                },
                'application/vnd.sailingtracker.track': {
                    'source': 'iana',
                    'extensions': ['st']
                },
                'application/vnd.sbm.cid': {
                    'source': 'iana'
                },
                'application/vnd.sbm.mid2': {
                    'source': 'iana'
                },
                'application/vnd.scribus': {
                    'source': 'iana'
                },
                'application/vnd.sealed.3df': {
                    'source': 'iana'
                },
                'application/vnd.sealed.csf': {
                    'source': 'iana'
                },
                'application/vnd.sealed.doc': {
                    'source': 'iana'
                },
                'application/vnd.sealed.eml': {
                    'source': 'iana'
                },
                'application/vnd.sealed.mht': {
                    'source': 'iana'
                },
                'application/vnd.sealed.net': {
                    'source': 'iana'
                },
                'application/vnd.sealed.ppt': {
                    'source': 'iana'
                },
                'application/vnd.sealed.tiff': {
                    'source': 'iana'
                },
                'application/vnd.sealed.xls': {
                    'source': 'iana'
                },
                'application/vnd.sealedmedia.softseal.html': {
                    'source': 'iana'
                },
                'application/vnd.sealedmedia.softseal.pdf': {
                    'source': 'iana'
                },
                'application/vnd.seemail': {
                    'source': 'iana',
                    'extensions': ['see']
                },
                'application/vnd.sema': {
                    'source': 'iana',
                    'extensions': ['sema']
                },
                'application/vnd.semd': {
                    'source': 'iana',
                    'extensions': ['semd']
                },
                'application/vnd.semf': {
                    'source': 'iana',
                    'extensions': ['semf']
                },
                'application/vnd.shana.informed.formdata': {
                    'source': 'iana',
                    'extensions': ['ifm']
                },
                'application/vnd.shana.informed.formtemplate': {
                    'source': 'iana',
                    'extensions': ['itp']
                },
                'application/vnd.shana.informed.interchange': {
                    'source': 'iana',
                    'extensions': ['iif']
                },
                'application/vnd.shana.informed.package': {
                    'source': 'iana',
                    'extensions': ['ipk']
                },
                'application/vnd.shootproof+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.sigrok.session': {
                    'source': 'iana'
                },
                'application/vnd.simtech-mindmapper': {
                    'source': 'iana',
                    'extensions': ['twd', 'twds']
                },
                'application/vnd.siren+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.smaf': {
                    'source': 'iana',
                    'extensions': ['mmf']
                },
                'application/vnd.smart.notebook': {
                    'source': 'iana'
                },
                'application/vnd.smart.teacher': {
                    'source': 'iana',
                    'extensions': ['teacher']
                },
                'application/vnd.software602.filler.form+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.software602.filler.form-xml-zip': {
                    'source': 'iana'
                },
                'application/vnd.solent.sdkm+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['sdkm', 'sdkd']
                },
                'application/vnd.spotfire.dxp': {
                    'source': 'iana',
                    'extensions': ['dxp']
                },
                'application/vnd.spotfire.sfs': {
                    'source': 'iana',
                    'extensions': ['sfs']
                },
                'application/vnd.sqlite3': {
                    'source': 'iana'
                },
                'application/vnd.sss-cod': {
                    'source': 'iana'
                },
                'application/vnd.sss-dtf': {
                    'source': 'iana'
                },
                'application/vnd.sss-ntf': {
                    'source': 'iana'
                },
                'application/vnd.stardivision.calc': {
                    'source': 'apache',
                    'extensions': ['sdc']
                },
                'application/vnd.stardivision.draw': {
                    'source': 'apache',
                    'extensions': ['sda']
                },
                'application/vnd.stardivision.impress': {
                    'source': 'apache',
                    'extensions': ['sdd']
                },
                'application/vnd.stardivision.math': {
                    'source': 'apache',
                    'extensions': ['smf']
                },
                'application/vnd.stardivision.writer': {
                    'source': 'apache',
                    'extensions': ['sdw', 'vor']
                },
                'application/vnd.stardivision.writer-global': {
                    'source': 'apache',
                    'extensions': ['sgl']
                },
                'application/vnd.stepmania.package': {
                    'source': 'iana',
                    'extensions': ['smzip']
                },
                'application/vnd.stepmania.stepchart': {
                    'source': 'iana',
                    'extensions': ['sm']
                },
                'application/vnd.street-stream': {
                    'source': 'iana'
                },
                'application/vnd.sun.wadl+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['wadl']
                },
                'application/vnd.sun.xml.calc': {
                    'source': 'apache',
                    'extensions': ['sxc']
                },
                'application/vnd.sun.xml.calc.template': {
                    'source': 'apache',
                    'extensions': ['stc']
                },
                'application/vnd.sun.xml.draw': {
                    'source': 'apache',
                    'extensions': ['sxd']
                },
                'application/vnd.sun.xml.draw.template': {
                    'source': 'apache',
                    'extensions': ['std']
                },
                'application/vnd.sun.xml.impress': {
                    'source': 'apache',
                    'extensions': ['sxi']
                },
                'application/vnd.sun.xml.impress.template': {
                    'source': 'apache',
                    'extensions': ['sti']
                },
                'application/vnd.sun.xml.math': {
                    'source': 'apache',
                    'extensions': ['sxm']
                },
                'application/vnd.sun.xml.writer': {
                    'source': 'apache',
                    'extensions': ['sxw']
                },
                'application/vnd.sun.xml.writer.global': {
                    'source': 'apache',
                    'extensions': ['sxg']
                },
                'application/vnd.sun.xml.writer.template': {
                    'source': 'apache',
                    'extensions': ['stw']
                },
                'application/vnd.sus-calendar': {
                    'source': 'iana',
                    'extensions': ['sus', 'susp']
                },
                'application/vnd.svd': {
                    'source': 'iana',
                    'extensions': ['svd']
                },
                'application/vnd.swiftview-ics': {
                    'source': 'iana'
                },
                'application/vnd.symbian.install': {
                    'source': 'apache',
                    'extensions': ['sis', 'sisx']
                },
                'application/vnd.syncml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xsm']
                },
                'application/vnd.syncml.dm+wbxml': {
                    'source': 'iana',
                    'extensions': ['bdm']
                },
                'application/vnd.syncml.dm+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xdm']
                },
                'application/vnd.syncml.dm.notification': {
                    'source': 'iana'
                },
                'application/vnd.syncml.dmddf+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.syncml.dmddf+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.syncml.dmtnds+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.syncml.dmtnds+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.syncml.ds.notification': {
                    'source': 'iana'
                },
                'application/vnd.tableschema+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.tao.intent-module-archive': {
                    'source': 'iana',
                    'extensions': ['tao']
                },
                'application/vnd.tcpdump.pcap': {
                    'source': 'iana',
                    'extensions': ['pcap', 'cap', 'dmp']
                },
                'application/vnd.think-cell.ppttc+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.tmd.mediaflex.api+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.tml': {
                    'source': 'iana'
                },
                'application/vnd.tmobile-livetv': {
                    'source': 'iana',
                    'extensions': ['tmo']
                },
                'application/vnd.tri.onesource': {
                    'source': 'iana'
                },
                'application/vnd.trid.tpt': {
                    'source': 'iana',
                    'extensions': ['tpt']
                },
                'application/vnd.triscape.mxs': {
                    'source': 'iana',
                    'extensions': ['mxs']
                },
                'application/vnd.trueapp': {
                    'source': 'iana',
                    'extensions': ['tra']
                },
                'application/vnd.truedoc': {
                    'source': 'iana'
                },
                'application/vnd.ubisoft.webplayer': {
                    'source': 'iana'
                },
                'application/vnd.ufdl': {
                    'source': 'iana',
                    'extensions': ['ufd', 'ufdl']
                },
                'application/vnd.uiq.theme': {
                    'source': 'iana',
                    'extensions': ['utz']
                },
                'application/vnd.umajin': {
                    'source': 'iana',
                    'extensions': ['umj']
                },
                'application/vnd.unity': {
                    'source': 'iana',
                    'extensions': ['unityweb']
                },
                'application/vnd.uoml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['uoml']
                },
                'application/vnd.uplanet.alert': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.alert-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.bearer-choice': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.bearer-choice-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.cacheop': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.cacheop-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.channel': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.channel-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.list': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.list-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.listcmd': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.listcmd-wbxml': {
                    'source': 'iana'
                },
                'application/vnd.uplanet.signal': {
                    'source': 'iana'
                },
                'application/vnd.uri-map': {
                    'source': 'iana'
                },
                'application/vnd.valve.source.material': {
                    'source': 'iana'
                },
                'application/vnd.vcx': {
                    'source': 'iana',
                    'extensions': ['vcx']
                },
                'application/vnd.vd-study': {
                    'source': 'iana'
                },
                'application/vnd.vectorworks': {
                    'source': 'iana'
                },
                'application/vnd.vel+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.verimatrix.vcas': {
                    'source': 'iana'
                },
                'application/vnd.vidsoft.vidconference': {
                    'source': 'iana'
                },
                'application/vnd.visio': {
                    'source': 'iana',
                    'extensions': ['vsd', 'vst', 'vss', 'vsw']
                },
                'application/vnd.visionary': {
                    'source': 'iana',
                    'extensions': ['vis']
                },
                'application/vnd.vividence.scriptfile': {
                    'source': 'iana'
                },
                'application/vnd.vsf': {
                    'source': 'iana',
                    'extensions': ['vsf']
                },
                'application/vnd.wap.sic': {
                    'source': 'iana'
                },
                'application/vnd.wap.slc': {
                    'source': 'iana'
                },
                'application/vnd.wap.wbxml': {
                    'source': 'iana',
                    'extensions': ['wbxml']
                },
                'application/vnd.wap.wmlc': {
                    'source': 'iana',
                    'extensions': ['wmlc']
                },
                'application/vnd.wap.wmlscriptc': {
                    'source': 'iana',
                    'extensions': ['wmlsc']
                },
                'application/vnd.webturbo': {
                    'source': 'iana',
                    'extensions': ['wtb']
                },
                'application/vnd.wfa.p2p': {
                    'source': 'iana'
                },
                'application/vnd.wfa.wsc': {
                    'source': 'iana'
                },
                'application/vnd.windows.devicepairing': {
                    'source': 'iana'
                },
                'application/vnd.wmc': {
                    'source': 'iana'
                },
                'application/vnd.wmf.bootstrap': {
                    'source': 'iana'
                },
                'application/vnd.wolfram.mathematica': {
                    'source': 'iana'
                },
                'application/vnd.wolfram.mathematica.package': {
                    'source': 'iana'
                },
                'application/vnd.wolfram.player': {
                    'source': 'iana',
                    'extensions': ['nbp']
                },
                'application/vnd.wordperfect': {
                    'source': 'iana',
                    'extensions': ['wpd']
                },
                'application/vnd.wqd': {
                    'source': 'iana',
                    'extensions': ['wqd']
                },
                'application/vnd.wrq-hp3000-labelled': {
                    'source': 'iana'
                },
                'application/vnd.wt.stf': {
                    'source': 'iana',
                    'extensions': ['stf']
                },
                'application/vnd.wv.csp+wbxml': {
                    'source': 'iana'
                },
                'application/vnd.wv.csp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.wv.ssp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.xacml+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.xara': {
                    'source': 'iana',
                    'extensions': ['xar']
                },
                'application/vnd.xfdl': {
                    'source': 'iana',
                    'extensions': ['xfdl']
                },
                'application/vnd.xfdl.webform': {
                    'source': 'iana'
                },
                'application/vnd.xmi+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vnd.xmpie.cpkg': {
                    'source': 'iana'
                },
                'application/vnd.xmpie.dpkg': {
                    'source': 'iana'
                },
                'application/vnd.xmpie.plan': {
                    'source': 'iana'
                },
                'application/vnd.xmpie.ppkg': {
                    'source': 'iana'
                },
                'application/vnd.xmpie.xlim': {
                    'source': 'iana'
                },
                'application/vnd.yamaha.hv-dic': {
                    'source': 'iana',
                    'extensions': ['hvd']
                },
                'application/vnd.yamaha.hv-script': {
                    'source': 'iana',
                    'extensions': ['hvs']
                },
                'application/vnd.yamaha.hv-voice': {
                    'source': 'iana',
                    'extensions': ['hvp']
                },
                'application/vnd.yamaha.openscoreformat': {
                    'source': 'iana',
                    'extensions': ['osf']
                },
                'application/vnd.yamaha.openscoreformat.osfpvg+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['osfpvg']
                },
                'application/vnd.yamaha.remote-setup': {
                    'source': 'iana'
                },
                'application/vnd.yamaha.smaf-audio': {
                    'source': 'iana',
                    'extensions': ['saf']
                },
                'application/vnd.yamaha.smaf-phrase': {
                    'source': 'iana',
                    'extensions': ['spf']
                },
                'application/vnd.yamaha.through-ngn': {
                    'source': 'iana'
                },
                'application/vnd.yamaha.tunnel-udpencap': {
                    'source': 'iana'
                },
                'application/vnd.yaoweme': {
                    'source': 'iana'
                },
                'application/vnd.yellowriver-custom-menu': {
                    'source': 'iana',
                    'extensions': ['cmp']
                },
                'application/vnd.youtube.yt': {
                    'source': 'iana'
                },
                'application/vnd.zul': {
                    'source': 'iana',
                    'extensions': ['zir', 'zirz']
                },
                'application/vnd.zzazz.deck+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['zaz']
                },
                'application/voicexml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['vxml']
                },
                'application/voucher-cms+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/vq-rtcpxr': {
                    'source': 'iana'
                },
                'application/wasm': {
                    'compressible': true,
                    'extensions': ['wasm']
                },
                'application/watcherinfo+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/webpush-options+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/whoispp-query': {
                    'source': 'iana'
                },
                'application/whoispp-response': {
                    'source': 'iana'
                },
                'application/widget': {
                    'source': 'iana',
                    'extensions': ['wgt']
                },
                'application/winhlp': {
                    'source': 'apache',
                    'extensions': ['hlp']
                },
                'application/wita': {
                    'source': 'iana'
                },
                'application/wordperfect5.1': {
                    'source': 'iana'
                },
                'application/wsdl+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['wsdl']
                },
                'application/wspolicy+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['wspolicy']
                },
                'application/x-7z-compressed': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['7z']
                },
                'application/x-abiword': {
                    'source': 'apache',
                    'extensions': ['abw']
                },
                'application/x-ace-compressed': {
                    'source': 'apache',
                    'extensions': ['ace']
                },
                'application/x-amf': {
                    'source': 'apache'
                },
                'application/x-apple-diskimage': {
                    'source': 'apache',
                    'extensions': ['dmg']
                },
                'application/x-arj': {
                    'compressible': false,
                    'extensions': ['arj']
                },
                'application/x-authorware-bin': {
                    'source': 'apache',
                    'extensions': ['aab', 'x32', 'u32', 'vox']
                },
                'application/x-authorware-map': {
                    'source': 'apache',
                    'extensions': ['aam']
                },
                'application/x-authorware-seg': {
                    'source': 'apache',
                    'extensions': ['aas']
                },
                'application/x-bcpio': {
                    'source': 'apache',
                    'extensions': ['bcpio']
                },
                'application/x-bdoc': {
                    'compressible': false,
                    'extensions': ['bdoc']
                },
                'application/x-bittorrent': {
                    'source': 'apache',
                    'extensions': ['torrent']
                },
                'application/x-blorb': {
                    'source': 'apache',
                    'extensions': ['blb', 'blorb']
                },
                'application/x-bzip': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['bz']
                },
                'application/x-bzip2': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['bz2', 'boz']
                },
                'application/x-cbr': {
                    'source': 'apache',
                    'extensions': ['cbr', 'cba', 'cbt', 'cbz', 'cb7']
                },
                'application/x-cdlink': {
                    'source': 'apache',
                    'extensions': ['vcd']
                },
                'application/x-cfs-compressed': {
                    'source': 'apache',
                    'extensions': ['cfs']
                },
                'application/x-chat': {
                    'source': 'apache',
                    'extensions': ['chat']
                },
                'application/x-chess-pgn': {
                    'source': 'apache',
                    'extensions': ['pgn']
                },
                'application/x-chrome-extension': {
                    'extensions': ['crx']
                },
                'application/x-cocoa': {
                    'source': 'nginx',
                    'extensions': ['cco']
                },
                'application/x-compress': {
                    'source': 'apache'
                },
                'application/x-conference': {
                    'source': 'apache',
                    'extensions': ['nsc']
                },
                'application/x-cpio': {
                    'source': 'apache',
                    'extensions': ['cpio']
                },
                'application/x-csh': {
                    'source': 'apache',
                    'extensions': ['csh']
                },
                'application/x-deb': {
                    'compressible': false
                },
                'application/x-debian-package': {
                    'source': 'apache',
                    'extensions': ['deb', 'udeb']
                },
                'application/x-dgc-compressed': {
                    'source': 'apache',
                    'extensions': ['dgc']
                },
                'application/x-director': {
                    'source': 'apache',
                    'extensions': ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa']
                },
                'application/x-doom': {
                    'source': 'apache',
                    'extensions': ['wad']
                },
                'application/x-dtbncx+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['ncx']
                },
                'application/x-dtbook+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['dtb']
                },
                'application/x-dtbresource+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['res']
                },
                'application/x-dvi': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['dvi']
                },
                'application/x-envoy': {
                    'source': 'apache',
                    'extensions': ['evy']
                },
                'application/x-eva': {
                    'source': 'apache',
                    'extensions': ['eva']
                },
                'application/x-font-bdf': {
                    'source': 'apache',
                    'extensions': ['bdf']
                },
                'application/x-font-dos': {
                    'source': 'apache'
                },
                'application/x-font-framemaker': {
                    'source': 'apache'
                },
                'application/x-font-ghostscript': {
                    'source': 'apache',
                    'extensions': ['gsf']
                },
                'application/x-font-libgrx': {
                    'source': 'apache'
                },
                'application/x-font-linux-psf': {
                    'source': 'apache',
                    'extensions': ['psf']
                },
                'application/x-font-pcf': {
                    'source': 'apache',
                    'extensions': ['pcf']
                },
                'application/x-font-snf': {
                    'source': 'apache',
                    'extensions': ['snf']
                },
                'application/x-font-speedo': {
                    'source': 'apache'
                },
                'application/x-font-sunos-news': {
                    'source': 'apache'
                },
                'application/x-font-type1': {
                    'source': 'apache',
                    'extensions': ['pfa', 'pfb', 'pfm', 'afm']
                },
                'application/x-font-vfont': {
                    'source': 'apache'
                },
                'application/x-freearc': {
                    'source': 'apache',
                    'extensions': ['arc']
                },
                'application/x-futuresplash': {
                    'source': 'apache',
                    'extensions': ['spl']
                },
                'application/x-gca-compressed': {
                    'source': 'apache',
                    'extensions': ['gca']
                },
                'application/x-glulx': {
                    'source': 'apache',
                    'extensions': ['ulx']
                },
                'application/x-gnumeric': {
                    'source': 'apache',
                    'extensions': ['gnumeric']
                },
                'application/x-gramps-xml': {
                    'source': 'apache',
                    'extensions': ['gramps']
                },
                'application/x-gtar': {
                    'source': 'apache',
                    'extensions': ['gtar']
                },
                'application/x-gzip': {
                    'source': 'apache'
                },
                'application/x-hdf': {
                    'source': 'apache',
                    'extensions': ['hdf']
                },
                'application/x-httpd-php': {
                    'compressible': true,
                    'extensions': ['php']
                },
                'application/x-install-instructions': {
                    'source': 'apache',
                    'extensions': ['install']
                },
                'application/x-iso9660-image': {
                    'source': 'apache',
                    'extensions': ['iso']
                },
                'application/x-java-archive-diff': {
                    'source': 'nginx',
                    'extensions': ['jardiff']
                },
                'application/x-java-jnlp-file': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['jnlp']
                },
                'application/x-javascript': {
                    'compressible': true
                },
                'application/x-latex': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['latex']
                },
                'application/x-lua-bytecode': {
                    'extensions': ['luac']
                },
                'application/x-lzh-compressed': {
                    'source': 'apache',
                    'extensions': ['lzh', 'lha']
                },
                'application/x-makeself': {
                    'source': 'nginx',
                    'extensions': ['run']
                },
                'application/x-mie': {
                    'source': 'apache',
                    'extensions': ['mie']
                },
                'application/x-mobipocket-ebook': {
                    'source': 'apache',
                    'extensions': ['prc', 'mobi']
                },
                'application/x-mpegurl': {
                    'compressible': false
                },
                'application/x-ms-application': {
                    'source': 'apache',
                    'extensions': ['application']
                },
                'application/x-ms-shortcut': {
                    'source': 'apache',
                    'extensions': ['lnk']
                },
                'application/x-ms-wmd': {
                    'source': 'apache',
                    'extensions': ['wmd']
                },
                'application/x-ms-wmz': {
                    'source': 'apache',
                    'extensions': ['wmz']
                },
                'application/x-ms-xbap': {
                    'source': 'apache',
                    'extensions': ['xbap']
                },
                'application/x-msaccess': {
                    'source': 'apache',
                    'extensions': ['mdb']
                },
                'application/x-msbinder': {
                    'source': 'apache',
                    'extensions': ['obd']
                },
                'application/x-mscardfile': {
                    'source': 'apache',
                    'extensions': ['crd']
                },
                'application/x-msclip': {
                    'source': 'apache',
                    'extensions': ['clp']
                },
                'application/x-msdos-program': {
                    'extensions': ['exe']
                },
                'application/x-msdownload': {
                    'source': 'apache',
                    'extensions': ['exe', 'dll', 'com', 'bat', 'msi']
                },
                'application/x-msmediaview': {
                    'source': 'apache',
                    'extensions': ['mvb', 'm13', 'm14']
                },
                'application/x-msmetafile': {
                    'source': 'apache',
                    'extensions': ['wmf', 'wmz', 'emf', 'emz']
                },
                'application/x-msmoney': {
                    'source': 'apache',
                    'extensions': ['mny']
                },
                'application/x-mspublisher': {
                    'source': 'apache',
                    'extensions': ['pub']
                },
                'application/x-msschedule': {
                    'source': 'apache',
                    'extensions': ['scd']
                },
                'application/x-msterminal': {
                    'source': 'apache',
                    'extensions': ['trm']
                },
                'application/x-mswrite': {
                    'source': 'apache',
                    'extensions': ['wri']
                },
                'application/x-netcdf': {
                    'source': 'apache',
                    'extensions': ['nc', 'cdf']
                },
                'application/x-ns-proxy-autoconfig': {
                    'compressible': true,
                    'extensions': ['pac']
                },
                'application/x-nzb': {
                    'source': 'apache',
                    'extensions': ['nzb']
                },
                'application/x-perl': {
                    'source': 'nginx',
                    'extensions': ['pl', 'pm']
                },
                'application/x-pilot': {
                    'source': 'nginx',
                    'extensions': ['prc', 'pdb']
                },
                'application/x-pkcs12': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['p12', 'pfx']
                },
                'application/x-pkcs7-certificates': {
                    'source': 'apache',
                    'extensions': ['p7b', 'spc']
                },
                'application/x-pkcs7-certreqresp': {
                    'source': 'apache',
                    'extensions': ['p7r']
                },
                'application/x-rar-compressed': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['rar']
                },
                'application/x-redhat-package-manager': {
                    'source': 'nginx',
                    'extensions': ['rpm']
                },
                'application/x-research-info-systems': {
                    'source': 'apache',
                    'extensions': ['ris']
                },
                'application/x-sea': {
                    'source': 'nginx',
                    'extensions': ['sea']
                },
                'application/x-sh': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['sh']
                },
                'application/x-shar': {
                    'source': 'apache',
                    'extensions': ['shar']
                },
                'application/x-shockwave-flash': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['swf']
                },
                'application/x-silverlight-app': {
                    'source': 'apache',
                    'extensions': ['xap']
                },
                'application/x-sql': {
                    'source': 'apache',
                    'extensions': ['sql']
                },
                'application/x-stuffit': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['sit']
                },
                'application/x-stuffitx': {
                    'source': 'apache',
                    'extensions': ['sitx']
                },
                'application/x-subrip': {
                    'source': 'apache',
                    'extensions': ['srt']
                },
                'application/x-sv4cpio': {
                    'source': 'apache',
                    'extensions': ['sv4cpio']
                },
                'application/x-sv4crc': {
                    'source': 'apache',
                    'extensions': ['sv4crc']
                },
                'application/x-t3vm-image': {
                    'source': 'apache',
                    'extensions': ['t3']
                },
                'application/x-tads': {
                    'source': 'apache',
                    'extensions': ['gam']
                },
                'application/x-tar': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['tar']
                },
                'application/x-tcl': {
                    'source': 'apache',
                    'extensions': ['tcl', 'tk']
                },
                'application/x-tex': {
                    'source': 'apache',
                    'extensions': ['tex']
                },
                'application/x-tex-tfm': {
                    'source': 'apache',
                    'extensions': ['tfm']
                },
                'application/x-texinfo': {
                    'source': 'apache',
                    'extensions': ['texinfo', 'texi']
                },
                'application/x-tgif': {
                    'source': 'apache',
                    'extensions': ['obj']
                },
                'application/x-ustar': {
                    'source': 'apache',
                    'extensions': ['ustar']
                },
                'application/x-virtualbox-hdd': {
                    'compressible': true,
                    'extensions': ['hdd']
                },
                'application/x-virtualbox-ova': {
                    'compressible': true,
                    'extensions': ['ova']
                },
                'application/x-virtualbox-ovf': {
                    'compressible': true,
                    'extensions': ['ovf']
                },
                'application/x-virtualbox-vbox': {
                    'compressible': true,
                    'extensions': ['vbox']
                },
                'application/x-virtualbox-vbox-extpack': {
                    'compressible': false,
                    'extensions': ['vbox-extpack']
                },
                'application/x-virtualbox-vdi': {
                    'compressible': true,
                    'extensions': ['vdi']
                },
                'application/x-virtualbox-vhd': {
                    'compressible': true,
                    'extensions': ['vhd']
                },
                'application/x-virtualbox-vmdk': {
                    'compressible': true,
                    'extensions': ['vmdk']
                },
                'application/x-wais-source': {
                    'source': 'apache',
                    'extensions': ['src']
                },
                'application/x-web-app-manifest+json': {
                    'compressible': true,
                    'extensions': ['webapp']
                },
                'application/x-www-form-urlencoded': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/x-x509-ca-cert': {
                    'source': 'apache',
                    'extensions': ['der', 'crt', 'pem']
                },
                'application/x-xfig': {
                    'source': 'apache',
                    'extensions': ['fig']
                },
                'application/x-xliff+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['xlf']
                },
                'application/x-xpinstall': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['xpi']
                },
                'application/x-xz': {
                    'source': 'apache',
                    'extensions': ['xz']
                },
                'application/x-zmachine': {
                    'source': 'apache',
                    'extensions': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8']
                },
                'application/x400-bp': {
                    'source': 'iana'
                },
                'application/xacml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xaml+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['xaml']
                },
                'application/xcap-att+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcap-caps+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcap-diff+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xdf']
                },
                'application/xcap-el+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcap-error+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcap-ns+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcon-conference-info+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xcon-conference-info-diff+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xenc+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xenc']
                },
                'application/xhtml+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xhtml', 'xht']
                },
                'application/xhtml-voice+xml': {
                    'source': 'apache',
                    'compressible': true
                },
                'application/xliff+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xml', 'xsl', 'xsd', 'rng']
                },
                'application/xml-dtd': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['dtd']
                },
                'application/xml-external-parsed-entity': {
                    'source': 'iana'
                },
                'application/xml-patch+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xmpp+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/xop+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xop']
                },
                'application/xproc+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['xpl']
                },
                'application/xslt+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xslt']
                },
                'application/xspf+xml': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['xspf']
                },
                'application/xv+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['mxml', 'xhvml', 'xvml', 'xvm']
                },
                'application/yang': {
                    'source': 'iana',
                    'extensions': ['yang']
                },
                'application/yang-data+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/yang-data+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/yang-patch+json': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/yang-patch+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'application/yin+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['yin']
                },
                'application/zip': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['zip']
                },
                'application/zlib': {
                    'source': 'iana'
                },
                'application/zstd': {
                    'source': 'iana'
                },
                'audio/1d-interleaved-parityfec': {
                    'source': 'iana'
                },
                'audio/32kadpcm': {
                    'source': 'iana'
                },
                'audio/3gpp': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['3gpp']
                },
                'audio/3gpp2': {
                    'source': 'iana'
                },
                'audio/aac': {
                    'source': 'iana'
                },
                'audio/ac3': {
                    'source': 'iana'
                },
                'audio/adpcm': {
                    'source': 'apache',
                    'extensions': ['adp']
                },
                'audio/amr': {
                    'source': 'iana'
                },
                'audio/amr-wb': {
                    'source': 'iana'
                },
                'audio/amr-wb+': {
                    'source': 'iana'
                },
                'audio/aptx': {
                    'source': 'iana'
                },
                'audio/asc': {
                    'source': 'iana'
                },
                'audio/atrac-advanced-lossless': {
                    'source': 'iana'
                },
                'audio/atrac-x': {
                    'source': 'iana'
                },
                'audio/atrac3': {
                    'source': 'iana'
                },
                'audio/basic': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['au', 'snd']
                },
                'audio/bv16': {
                    'source': 'iana'
                },
                'audio/bv32': {
                    'source': 'iana'
                },
                'audio/clearmode': {
                    'source': 'iana'
                },
                'audio/cn': {
                    'source': 'iana'
                },
                'audio/dat12': {
                    'source': 'iana'
                },
                'audio/dls': {
                    'source': 'iana'
                },
                'audio/dsr-es201108': {
                    'source': 'iana'
                },
                'audio/dsr-es202050': {
                    'source': 'iana'
                },
                'audio/dsr-es202211': {
                    'source': 'iana'
                },
                'audio/dsr-es202212': {
                    'source': 'iana'
                },
                'audio/dv': {
                    'source': 'iana'
                },
                'audio/dvi4': {
                    'source': 'iana'
                },
                'audio/eac3': {
                    'source': 'iana'
                },
                'audio/encaprtp': {
                    'source': 'iana'
                },
                'audio/evrc': {
                    'source': 'iana'
                },
                'audio/evrc-qcp': {
                    'source': 'iana'
                },
                'audio/evrc0': {
                    'source': 'iana'
                },
                'audio/evrc1': {
                    'source': 'iana'
                },
                'audio/evrcb': {
                    'source': 'iana'
                },
                'audio/evrcb0': {
                    'source': 'iana'
                },
                'audio/evrcb1': {
                    'source': 'iana'
                },
                'audio/evrcnw': {
                    'source': 'iana'
                },
                'audio/evrcnw0': {
                    'source': 'iana'
                },
                'audio/evrcnw1': {
                    'source': 'iana'
                },
                'audio/evrcwb': {
                    'source': 'iana'
                },
                'audio/evrcwb0': {
                    'source': 'iana'
                },
                'audio/evrcwb1': {
                    'source': 'iana'
                },
                'audio/evs': {
                    'source': 'iana'
                },
                'audio/fwdred': {
                    'source': 'iana'
                },
                'audio/g711-0': {
                    'source': 'iana'
                },
                'audio/g719': {
                    'source': 'iana'
                },
                'audio/g722': {
                    'source': 'iana'
                },
                'audio/g7221': {
                    'source': 'iana'
                },
                'audio/g723': {
                    'source': 'iana'
                },
                'audio/g726-16': {
                    'source': 'iana'
                },
                'audio/g726-24': {
                    'source': 'iana'
                },
                'audio/g726-32': {
                    'source': 'iana'
                },
                'audio/g726-40': {
                    'source': 'iana'
                },
                'audio/g728': {
                    'source': 'iana'
                },
                'audio/g729': {
                    'source': 'iana'
                },
                'audio/g7291': {
                    'source': 'iana'
                },
                'audio/g729d': {
                    'source': 'iana'
                },
                'audio/g729e': {
                    'source': 'iana'
                },
                'audio/gsm': {
                    'source': 'iana'
                },
                'audio/gsm-efr': {
                    'source': 'iana'
                },
                'audio/gsm-hr-08': {
                    'source': 'iana'
                },
                'audio/ilbc': {
                    'source': 'iana'
                },
                'audio/ip-mr_v2.5': {
                    'source': 'iana'
                },
                'audio/isac': {
                    'source': 'apache'
                },
                'audio/l16': {
                    'source': 'iana'
                },
                'audio/l20': {
                    'source': 'iana'
                },
                'audio/l24': {
                    'source': 'iana',
                    'compressible': false
                },
                'audio/l8': {
                    'source': 'iana'
                },
                'audio/lpc': {
                    'source': 'iana'
                },
                'audio/melp': {
                    'source': 'iana'
                },
                'audio/melp1200': {
                    'source': 'iana'
                },
                'audio/melp2400': {
                    'source': 'iana'
                },
                'audio/melp600': {
                    'source': 'iana'
                },
                'audio/midi': {
                    'source': 'apache',
                    'extensions': ['mid', 'midi', 'kar', 'rmi']
                },
                'audio/mobile-xmf': {
                    'source': 'iana'
                },
                'audio/mp3': {
                    'compressible': false,
                    'extensions': ['mp3']
                },
                'audio/mp4': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['m4a', 'mp4a']
                },
                'audio/mp4a-latm': {
                    'source': 'iana'
                },
                'audio/mpa': {
                    'source': 'iana'
                },
                'audio/mpa-robust': {
                    'source': 'iana'
                },
                'audio/mpeg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a']
                },
                'audio/mpeg4-generic': {
                    'source': 'iana'
                },
                'audio/musepack': {
                    'source': 'apache'
                },
                'audio/ogg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['oga', 'ogg', 'spx']
                },
                'audio/opus': {
                    'source': 'iana'
                },
                'audio/parityfec': {
                    'source': 'iana'
                },
                'audio/pcma': {
                    'source': 'iana'
                },
                'audio/pcma-wb': {
                    'source': 'iana'
                },
                'audio/pcmu': {
                    'source': 'iana'
                },
                'audio/pcmu-wb': {
                    'source': 'iana'
                },
                'audio/prs.sid': {
                    'source': 'iana'
                },
                'audio/qcelp': {
                    'source': 'iana'
                },
                'audio/raptorfec': {
                    'source': 'iana'
                },
                'audio/red': {
                    'source': 'iana'
                },
                'audio/rtp-enc-aescm128': {
                    'source': 'iana'
                },
                'audio/rtp-midi': {
                    'source': 'iana'
                },
                'audio/rtploopback': {
                    'source': 'iana'
                },
                'audio/rtx': {
                    'source': 'iana'
                },
                'audio/s3m': {
                    'source': 'apache',
                    'extensions': ['s3m']
                },
                'audio/silk': {
                    'source': 'apache',
                    'extensions': ['sil']
                },
                'audio/smv': {
                    'source': 'iana'
                },
                'audio/smv-qcp': {
                    'source': 'iana'
                },
                'audio/smv0': {
                    'source': 'iana'
                },
                'audio/sp-midi': {
                    'source': 'iana'
                },
                'audio/speex': {
                    'source': 'iana'
                },
                'audio/t140c': {
                    'source': 'iana'
                },
                'audio/t38': {
                    'source': 'iana'
                },
                'audio/telephone-event': {
                    'source': 'iana'
                },
                'audio/tone': {
                    'source': 'iana'
                },
                'audio/uemclip': {
                    'source': 'iana'
                },
                'audio/ulpfec': {
                    'source': 'iana'
                },
                'audio/usac': {
                    'source': 'iana'
                },
                'audio/vdvi': {
                    'source': 'iana'
                },
                'audio/vmr-wb': {
                    'source': 'iana'
                },
                'audio/vnd.3gpp.iufp': {
                    'source': 'iana'
                },
                'audio/vnd.4sb': {
                    'source': 'iana'
                },
                'audio/vnd.audiokoz': {
                    'source': 'iana'
                },
                'audio/vnd.celp': {
                    'source': 'iana'
                },
                'audio/vnd.cisco.nse': {
                    'source': 'iana'
                },
                'audio/vnd.cmles.radio-events': {
                    'source': 'iana'
                },
                'audio/vnd.cns.anp1': {
                    'source': 'iana'
                },
                'audio/vnd.cns.inf1': {
                    'source': 'iana'
                },
                'audio/vnd.dece.audio': {
                    'source': 'iana',
                    'extensions': ['uva', 'uvva']
                },
                'audio/vnd.digital-winds': {
                    'source': 'iana',
                    'extensions': ['eol']
                },
                'audio/vnd.dlna.adts': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.heaac.1': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.heaac.2': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.mlp': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.mps': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.pl2': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.pl2x': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.pl2z': {
                    'source': 'iana'
                },
                'audio/vnd.dolby.pulse.1': {
                    'source': 'iana'
                },
                'audio/vnd.dra': {
                    'source': 'iana',
                    'extensions': ['dra']
                },
                'audio/vnd.dts': {
                    'source': 'iana',
                    'extensions': ['dts']
                },
                'audio/vnd.dts.hd': {
                    'source': 'iana',
                    'extensions': ['dtshd']
                },
                'audio/vnd.dvb.file': {
                    'source': 'iana'
                },
                'audio/vnd.everad.plj': {
                    'source': 'iana'
                },
                'audio/vnd.hns.audio': {
                    'source': 'iana'
                },
                'audio/vnd.lucent.voice': {
                    'source': 'iana',
                    'extensions': ['lvp']
                },
                'audio/vnd.ms-playready.media.pya': {
                    'source': 'iana',
                    'extensions': ['pya']
                },
                'audio/vnd.nokia.mobile-xmf': {
                    'source': 'iana'
                },
                'audio/vnd.nortel.vbk': {
                    'source': 'iana'
                },
                'audio/vnd.nuera.ecelp4800': {
                    'source': 'iana',
                    'extensions': ['ecelp4800']
                },
                'audio/vnd.nuera.ecelp7470': {
                    'source': 'iana',
                    'extensions': ['ecelp7470']
                },
                'audio/vnd.nuera.ecelp9600': {
                    'source': 'iana',
                    'extensions': ['ecelp9600']
                },
                'audio/vnd.octel.sbc': {
                    'source': 'iana'
                },
                'audio/vnd.presonus.multitrack': {
                    'source': 'iana'
                },
                'audio/vnd.qcelp': {
                    'source': 'iana'
                },
                'audio/vnd.rhetorex.32kadpcm': {
                    'source': 'iana'
                },
                'audio/vnd.rip': {
                    'source': 'iana',
                    'extensions': ['rip']
                },
                'audio/vnd.rn-realaudio': {
                    'compressible': false
                },
                'audio/vnd.sealedmedia.softseal.mpeg': {
                    'source': 'iana'
                },
                'audio/vnd.vmx.cvsd': {
                    'source': 'iana'
                },
                'audio/vnd.wave': {
                    'compressible': false
                },
                'audio/vorbis': {
                    'source': 'iana',
                    'compressible': false
                },
                'audio/vorbis-config': {
                    'source': 'iana'
                },
                'audio/wav': {
                    'compressible': false,
                    'extensions': ['wav']
                },
                'audio/wave': {
                    'compressible': false,
                    'extensions': ['wav']
                },
                'audio/webm': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['weba']
                },
                'audio/x-aac': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['aac']
                },
                'audio/x-aiff': {
                    'source': 'apache',
                    'extensions': ['aif', 'aiff', 'aifc']
                },
                'audio/x-caf': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['caf']
                },
                'audio/x-flac': {
                    'source': 'apache',
                    'extensions': ['flac']
                },
                'audio/x-m4a': {
                    'source': 'nginx',
                    'extensions': ['m4a']
                },
                'audio/x-matroska': {
                    'source': 'apache',
                    'extensions': ['mka']
                },
                'audio/x-mpegurl': {
                    'source': 'apache',
                    'extensions': ['m3u']
                },
                'audio/x-ms-wax': {
                    'source': 'apache',
                    'extensions': ['wax']
                },
                'audio/x-ms-wma': {
                    'source': 'apache',
                    'extensions': ['wma']
                },
                'audio/x-pn-realaudio': {
                    'source': 'apache',
                    'extensions': ['ram', 'ra']
                },
                'audio/x-pn-realaudio-plugin': {
                    'source': 'apache',
                    'extensions': ['rmp']
                },
                'audio/x-realaudio': {
                    'source': 'nginx',
                    'extensions': ['ra']
                },
                'audio/x-tta': {
                    'source': 'apache'
                },
                'audio/x-wav': {
                    'source': 'apache',
                    'extensions': ['wav']
                },
                'audio/xm': {
                    'source': 'apache',
                    'extensions': ['xm']
                },
                'chemical/x-cdx': {
                    'source': 'apache',
                    'extensions': ['cdx']
                },
                'chemical/x-cif': {
                    'source': 'apache',
                    'extensions': ['cif']
                },
                'chemical/x-cmdf': {
                    'source': 'apache',
                    'extensions': ['cmdf']
                },
                'chemical/x-cml': {
                    'source': 'apache',
                    'extensions': ['cml']
                },
                'chemical/x-csml': {
                    'source': 'apache',
                    'extensions': ['csml']
                },
                'chemical/x-pdb': {
                    'source': 'apache'
                },
                'chemical/x-xyz': {
                    'source': 'apache',
                    'extensions': ['xyz']
                },
                'font/collection': {
                    'source': 'iana',
                    'extensions': ['ttc']
                },
                'font/otf': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['otf']
                },
                'font/sfnt': {
                    'source': 'iana'
                },
                'font/ttf': {
                    'source': 'iana',
                    'extensions': ['ttf']
                },
                'font/woff': {
                    'source': 'iana',
                    'extensions': ['woff']
                },
                'font/woff2': {
                    'source': 'iana',
                    'extensions': ['woff2']
                },
                'image/aces': {
                    'source': 'iana',
                    'extensions': ['exr']
                },
                'image/apng': {
                    'compressible': false,
                    'extensions': ['apng']
                },
                'image/avci': {
                    'source': 'iana'
                },
                'image/avcs': {
                    'source': 'iana'
                },
                'image/bmp': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['bmp']
                },
                'image/cgm': {
                    'source': 'iana',
                    'extensions': ['cgm']
                },
                'image/dicom-rle': {
                    'source': 'iana',
                    'extensions': ['drle']
                },
                'image/emf': {
                    'source': 'iana',
                    'extensions': ['emf']
                },
                'image/fits': {
                    'source': 'iana',
                    'extensions': ['fits']
                },
                'image/g3fax': {
                    'source': 'iana',
                    'extensions': ['g3']
                },
                'image/gif': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['gif']
                },
                'image/heic': {
                    'source': 'iana',
                    'extensions': ['heic']
                },
                'image/heic-sequence': {
                    'source': 'iana',
                    'extensions': ['heics']
                },
                'image/heif': {
                    'source': 'iana',
                    'extensions': ['heif']
                },
                'image/heif-sequence': {
                    'source': 'iana',
                    'extensions': ['heifs']
                },
                'image/ief': {
                    'source': 'iana',
                    'extensions': ['ief']
                },
                'image/jls': {
                    'source': 'iana',
                    'extensions': ['jls']
                },
                'image/jp2': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['jp2', 'jpg2']
                },
                'image/jpeg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['jpeg', 'jpg', 'jpe']
                },
                'image/jpm': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['jpm']
                },
                'image/jpx': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['jpx', 'jpf']
                },
                'image/ktx': {
                    'source': 'iana',
                    'extensions': ['ktx']
                },
                'image/naplps': {
                    'source': 'iana'
                },
                'image/pjpeg': {
                    'compressible': false
                },
                'image/png': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['png']
                },
                'image/prs.btif': {
                    'source': 'iana',
                    'extensions': ['btif']
                },
                'image/prs.pti': {
                    'source': 'iana',
                    'extensions': ['pti']
                },
                'image/pwg-raster': {
                    'source': 'iana'
                },
                'image/sgi': {
                    'source': 'apache',
                    'extensions': ['sgi']
                },
                'image/svg+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['svg', 'svgz']
                },
                'image/t38': {
                    'source': 'iana',
                    'extensions': ['t38']
                },
                'image/tiff': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['tif', 'tiff']
                },
                'image/tiff-fx': {
                    'source': 'iana',
                    'extensions': ['tfx']
                },
                'image/vnd.adobe.photoshop': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['psd']
                },
                'image/vnd.airzip.accelerator.azv': {
                    'source': 'iana',
                    'extensions': ['azv']
                },
                'image/vnd.cns.inf2': {
                    'source': 'iana'
                },
                'image/vnd.dece.graphic': {
                    'source': 'iana',
                    'extensions': ['uvi', 'uvvi', 'uvg', 'uvvg']
                },
                'image/vnd.djvu': {
                    'source': 'iana',
                    'extensions': ['djvu', 'djv']
                },
                'image/vnd.dvb.subtitle': {
                    'source': 'iana',
                    'extensions': ['sub']
                },
                'image/vnd.dwg': {
                    'source': 'iana',
                    'extensions': ['dwg']
                },
                'image/vnd.dxf': {
                    'source': 'iana',
                    'extensions': ['dxf']
                },
                'image/vnd.fastbidsheet': {
                    'source': 'iana',
                    'extensions': ['fbs']
                },
                'image/vnd.fpx': {
                    'source': 'iana',
                    'extensions': ['fpx']
                },
                'image/vnd.fst': {
                    'source': 'iana',
                    'extensions': ['fst']
                },
                'image/vnd.fujixerox.edmics-mmr': {
                    'source': 'iana',
                    'extensions': ['mmr']
                },
                'image/vnd.fujixerox.edmics-rlc': {
                    'source': 'iana',
                    'extensions': ['rlc']
                },
                'image/vnd.globalgraphics.pgb': {
                    'source': 'iana'
                },
                'image/vnd.microsoft.icon': {
                    'source': 'iana',
                    'extensions': ['ico']
                },
                'image/vnd.mix': {
                    'source': 'iana'
                },
                'image/vnd.mozilla.apng': {
                    'source': 'iana'
                },
                'image/vnd.ms-modi': {
                    'source': 'iana',
                    'extensions': ['mdi']
                },
                'image/vnd.ms-photo': {
                    'source': 'apache',
                    'extensions': ['wdp']
                },
                'image/vnd.net-fpx': {
                    'source': 'iana',
                    'extensions': ['npx']
                },
                'image/vnd.radiance': {
                    'source': 'iana'
                },
                'image/vnd.sealed.png': {
                    'source': 'iana'
                },
                'image/vnd.sealedmedia.softseal.gif': {
                    'source': 'iana'
                },
                'image/vnd.sealedmedia.softseal.jpg': {
                    'source': 'iana'
                },
                'image/vnd.svf': {
                    'source': 'iana'
                },
                'image/vnd.tencent.tap': {
                    'source': 'iana',
                    'extensions': ['tap']
                },
                'image/vnd.valve.source.texture': {
                    'source': 'iana',
                    'extensions': ['vtf']
                },
                'image/vnd.wap.wbmp': {
                    'source': 'iana',
                    'extensions': ['wbmp']
                },
                'image/vnd.xiff': {
                    'source': 'iana',
                    'extensions': ['xif']
                },
                'image/vnd.zbrush.pcx': {
                    'source': 'iana',
                    'extensions': ['pcx']
                },
                'image/webp': {
                    'source': 'apache',
                    'extensions': ['webp']
                },
                'image/wmf': {
                    'source': 'iana',
                    'extensions': ['wmf']
                },
                'image/x-3ds': {
                    'source': 'apache',
                    'extensions': ['3ds']
                },
                'image/x-cmu-raster': {
                    'source': 'apache',
                    'extensions': ['ras']
                },
                'image/x-cmx': {
                    'source': 'apache',
                    'extensions': ['cmx']
                },
                'image/x-freehand': {
                    'source': 'apache',
                    'extensions': ['fh', 'fhc', 'fh4', 'fh5', 'fh7']
                },
                'image/x-icon': {
                    'source': 'apache',
                    'compressible': true,
                    'extensions': ['ico']
                },
                'image/x-jng': {
                    'source': 'nginx',
                    'extensions': ['jng']
                },
                'image/x-mrsid-image': {
                    'source': 'apache',
                    'extensions': ['sid']
                },
                'image/x-ms-bmp': {
                    'source': 'nginx',
                    'compressible': true,
                    'extensions': ['bmp']
                },
                'image/x-pcx': {
                    'source': 'apache',
                    'extensions': ['pcx']
                },
                'image/x-pict': {
                    'source': 'apache',
                    'extensions': ['pic', 'pct']
                },
                'image/x-portable-anymap': {
                    'source': 'apache',
                    'extensions': ['pnm']
                },
                'image/x-portable-bitmap': {
                    'source': 'apache',
                    'extensions': ['pbm']
                },
                'image/x-portable-graymap': {
                    'source': 'apache',
                    'extensions': ['pgm']
                },
                'image/x-portable-pixmap': {
                    'source': 'apache',
                    'extensions': ['ppm']
                },
                'image/x-rgb': {
                    'source': 'apache',
                    'extensions': ['rgb']
                },
                'image/x-tga': {
                    'source': 'apache',
                    'extensions': ['tga']
                },
                'image/x-xbitmap': {
                    'source': 'apache',
                    'extensions': ['xbm']
                },
                'image/x-xcf': {
                    'compressible': false
                },
                'image/x-xpixmap': {
                    'source': 'apache',
                    'extensions': ['xpm']
                },
                'image/x-xwindowdump': {
                    'source': 'apache',
                    'extensions': ['xwd']
                },
                'message/cpim': {
                    'source': 'iana'
                },
                'message/delivery-status': {
                    'source': 'iana'
                },
                'message/disposition-notification': {
                    'source': 'iana',
                    'extensions': [
                        'disposition-notification'
                    ]
                },
                'message/external-body': {
                    'source': 'iana'
                },
                'message/feedback-report': {
                    'source': 'iana'
                },
                'message/global': {
                    'source': 'iana',
                    'extensions': ['u8msg']
                },
                'message/global-delivery-status': {
                    'source': 'iana',
                    'extensions': ['u8dsn']
                },
                'message/global-disposition-notification': {
                    'source': 'iana',
                    'extensions': ['u8mdn']
                },
                'message/global-headers': {
                    'source': 'iana',
                    'extensions': ['u8hdr']
                },
                'message/http': {
                    'source': 'iana',
                    'compressible': false
                },
                'message/imdn+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'message/news': {
                    'source': 'iana'
                },
                'message/partial': {
                    'source': 'iana',
                    'compressible': false
                },
                'message/rfc822': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['eml', 'mime']
                },
                'message/s-http': {
                    'source': 'iana'
                },
                'message/sip': {
                    'source': 'iana'
                },
                'message/sipfrag': {
                    'source': 'iana'
                },
                'message/tracking-status': {
                    'source': 'iana'
                },
                'message/vnd.si.simp': {
                    'source': 'iana'
                },
                'message/vnd.wfa.wsc': {
                    'source': 'iana',
                    'extensions': ['wsc']
                },
                'model/3mf': {
                    'source': 'iana'
                },
                'model/gltf+json': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['gltf']
                },
                'model/gltf-binary': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['glb']
                },
                'model/iges': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['igs', 'iges']
                },
                'model/mesh': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['msh', 'mesh', 'silo']
                },
                'model/stl': {
                    'source': 'iana'
                },
                'model/vnd.collada+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['dae']
                },
                'model/vnd.dwf': {
                    'source': 'iana',
                    'extensions': ['dwf']
                },
                'model/vnd.flatland.3dml': {
                    'source': 'iana'
                },
                'model/vnd.gdl': {
                    'source': 'iana',
                    'extensions': ['gdl']
                },
                'model/vnd.gs-gdl': {
                    'source': 'apache'
                },
                'model/vnd.gs.gdl': {
                    'source': 'iana'
                },
                'model/vnd.gtw': {
                    'source': 'iana',
                    'extensions': ['gtw']
                },
                'model/vnd.moml+xml': {
                    'source': 'iana',
                    'compressible': true
                },
                'model/vnd.mts': {
                    'source': 'iana',
                    'extensions': ['mts']
                },
                'model/vnd.opengex': {
                    'source': 'iana'
                },
                'model/vnd.parasolid.transmit.binary': {
                    'source': 'iana'
                },
                'model/vnd.parasolid.transmit.text': {
                    'source': 'iana'
                },
                'model/vnd.rosette.annotated-data-model': {
                    'source': 'iana'
                },
                'model/vnd.usdz+zip': {
                    'source': 'iana',
                    'compressible': false
                },
                'model/vnd.valve.source.compiled-map': {
                    'source': 'iana'
                },
                'model/vnd.vtu': {
                    'source': 'iana',
                    'extensions': ['vtu']
                },
                'model/vrml': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['wrl', 'vrml']
                },
                'model/x3d+binary': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['x3db', 'x3dbz']
                },
                'model/x3d+fastinfoset': {
                    'source': 'iana'
                },
                'model/x3d+vrml': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['x3dv', 'x3dvz']
                },
                'model/x3d+xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['x3d', 'x3dz']
                },
                'model/x3d-vrml': {
                    'source': 'iana'
                },
                'multipart/alternative': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/appledouble': {
                    'source': 'iana'
                },
                'multipart/byteranges': {
                    'source': 'iana'
                },
                'multipart/digest': {
                    'source': 'iana'
                },
                'multipart/encrypted': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/form-data': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/header-set': {
                    'source': 'iana'
                },
                'multipart/mixed': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/multilingual': {
                    'source': 'iana'
                },
                'multipart/parallel': {
                    'source': 'iana'
                },
                'multipart/related': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/report': {
                    'source': 'iana'
                },
                'multipart/signed': {
                    'source': 'iana',
                    'compressible': false
                },
                'multipart/vnd.bint.med-plus': {
                    'source': 'iana'
                },
                'multipart/voice-message': {
                    'source': 'iana'
                },
                'multipart/x-mixed-replace': {
                    'source': 'iana'
                },
                'text/1d-interleaved-parityfec': {
                    'source': 'iana'
                },
                'text/cache-manifest': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['appcache', 'manifest']
                },
                'text/calendar': {
                    'source': 'iana',
                    'extensions': ['ics', 'ifb']
                },
                'text/calender': {
                    'compressible': true
                },
                'text/cmd': {
                    'compressible': true
                },
                'text/coffeescript': {
                    'extensions': ['coffee', 'litcoffee']
                },
                'text/css': {
                    'source': 'iana',
                    'charset': 'UTF-8',
                    'compressible': true,
                    'extensions': ['css']
                },
                'text/csv': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['csv']
                },
                'text/csv-schema': {
                    'source': 'iana'
                },
                'text/directory': {
                    'source': 'iana'
                },
                'text/dns': {
                    'source': 'iana'
                },
                'text/ecmascript': {
                    'source': 'iana'
                },
                'text/encaprtp': {
                    'source': 'iana'
                },
                'text/enriched': {
                    'source': 'iana'
                },
                'text/fwdred': {
                    'source': 'iana'
                },
                'text/grammar-ref-list': {
                    'source': 'iana'
                },
                'text/html': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['html', 'htm', 'shtml']
                },
                'text/jade': {
                    'extensions': ['jade']
                },
                'text/javascript': {
                    'source': 'iana',
                    'compressible': true
                },
                'text/jcr-cnd': {
                    'source': 'iana'
                },
                'text/jsx': {
                    'compressible': true,
                    'extensions': ['jsx']
                },
                'text/less': {
                    'extensions': ['less']
                },
                'text/markdown': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['markdown', 'md']
                },
                'text/mathml': {
                    'source': 'nginx',
                    'extensions': ['mml']
                },
                'text/mizar': {
                    'source': 'iana'
                },
                'text/n3': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['n3']
                },
                'text/parameters': {
                    'source': 'iana'
                },
                'text/parityfec': {
                    'source': 'iana'
                },
                'text/plain': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini']
                },
                'text/provenance-notation': {
                    'source': 'iana'
                },
                'text/prs.fallenstein.rst': {
                    'source': 'iana'
                },
                'text/prs.lines.tag': {
                    'source': 'iana',
                    'extensions': ['dsc']
                },
                'text/prs.prop.logic': {
                    'source': 'iana'
                },
                'text/raptorfec': {
                    'source': 'iana'
                },
                'text/red': {
                    'source': 'iana'
                },
                'text/rfc822-headers': {
                    'source': 'iana'
                },
                'text/richtext': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rtx']
                },
                'text/rtf': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['rtf']
                },
                'text/rtp-enc-aescm128': {
                    'source': 'iana'
                },
                'text/rtploopback': {
                    'source': 'iana'
                },
                'text/rtx': {
                    'source': 'iana'
                },
                'text/sgml': {
                    'source': 'iana',
                    'extensions': ['sgml', 'sgm']
                },
                'text/shex': {
                    'extensions': ['shex']
                },
                'text/slim': {
                    'extensions': ['slim', 'slm']
                },
                'text/strings': {
                    'source': 'iana'
                },
                'text/stylus': {
                    'extensions': ['stylus', 'styl']
                },
                'text/t140': {
                    'source': 'iana'
                },
                'text/tab-separated-values': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['tsv']
                },
                'text/troff': {
                    'source': 'iana',
                    'extensions': ['t', 'tr', 'roff', 'man', 'me', 'ms']
                },
                'text/turtle': {
                    'source': 'iana',
                    'charset': 'UTF-8',
                    'extensions': ['ttl']
                },
                'text/ulpfec': {
                    'source': 'iana'
                },
                'text/uri-list': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['uri', 'uris', 'urls']
                },
                'text/vcard': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['vcard']
                },
                'text/vnd.a': {
                    'source': 'iana'
                },
                'text/vnd.abc': {
                    'source': 'iana'
                },
                'text/vnd.ascii-art': {
                    'source': 'iana'
                },
                'text/vnd.curl': {
                    'source': 'iana',
                    'extensions': ['curl']
                },
                'text/vnd.curl.dcurl': {
                    'source': 'apache',
                    'extensions': ['dcurl']
                },
                'text/vnd.curl.mcurl': {
                    'source': 'apache',
                    'extensions': ['mcurl']
                },
                'text/vnd.curl.scurl': {
                    'source': 'apache',
                    'extensions': ['scurl']
                },
                'text/vnd.debian.copyright': {
                    'source': 'iana'
                },
                'text/vnd.dmclientscript': {
                    'source': 'iana'
                },
                'text/vnd.dvb.subtitle': {
                    'source': 'iana',
                    'extensions': ['sub']
                },
                'text/vnd.esmertec.theme-descriptor': {
                    'source': 'iana'
                },
                'text/vnd.fly': {
                    'source': 'iana',
                    'extensions': ['fly']
                },
                'text/vnd.fmi.flexstor': {
                    'source': 'iana',
                    'extensions': ['flx']
                },
                'text/vnd.gml': {
                    'source': 'iana'
                },
                'text/vnd.graphviz': {
                    'source': 'iana',
                    'extensions': ['gv']
                },
                'text/vnd.hgl': {
                    'source': 'iana'
                },
                'text/vnd.in3d.3dml': {
                    'source': 'iana',
                    'extensions': ['3dml']
                },
                'text/vnd.in3d.spot': {
                    'source': 'iana',
                    'extensions': ['spot']
                },
                'text/vnd.iptc.newsml': {
                    'source': 'iana'
                },
                'text/vnd.iptc.nitf': {
                    'source': 'iana'
                },
                'text/vnd.latex-z': {
                    'source': 'iana'
                },
                'text/vnd.motorola.reflex': {
                    'source': 'iana'
                },
                'text/vnd.ms-mediapackage': {
                    'source': 'iana'
                },
                'text/vnd.net2phone.commcenter.command': {
                    'source': 'iana'
                },
                'text/vnd.radisys.msml-basic-layout': {
                    'source': 'iana'
                },
                'text/vnd.si.uricatalogue': {
                    'source': 'iana'
                },
                'text/vnd.sun.j2me.app-descriptor': {
                    'source': 'iana',
                    'extensions': ['jad']
                },
                'text/vnd.trolltech.linguist': {
                    'source': 'iana'
                },
                'text/vnd.wap.si': {
                    'source': 'iana'
                },
                'text/vnd.wap.sl': {
                    'source': 'iana'
                },
                'text/vnd.wap.wml': {
                    'source': 'iana',
                    'extensions': ['wml']
                },
                'text/vnd.wap.wmlscript': {
                    'source': 'iana',
                    'extensions': ['wmls']
                },
                'text/vtt': {
                    'charset': 'UTF-8',
                    'compressible': true,
                    'extensions': ['vtt']
                },
                'text/x-asm': {
                    'source': 'apache',
                    'extensions': ['s', 'asm']
                },
                'text/x-c': {
                    'source': 'apache',
                    'extensions': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic']
                },
                'text/x-component': {
                    'source': 'nginx',
                    'extensions': ['htc']
                },
                'text/x-fortran': {
                    'source': 'apache',
                    'extensions': ['f', 'for', 'f77', 'f90']
                },
                'text/x-gwt-rpc': {
                    'compressible': true
                },
                'text/x-handlebars-template': {
                    'extensions': ['hbs']
                },
                'text/x-java-source': {
                    'source': 'apache',
                    'extensions': ['java']
                },
                'text/x-jquery-tmpl': {
                    'compressible': true
                },
                'text/x-lua': {
                    'extensions': ['lua']
                },
                'text/x-markdown': {
                    'compressible': true,
                    'extensions': ['mkd']
                },
                'text/x-nfo': {
                    'source': 'apache',
                    'extensions': ['nfo']
                },
                'text/x-opml': {
                    'source': 'apache',
                    'extensions': ['opml']
                },
                'text/x-org': {
                    'compressible': true,
                    'extensions': ['org']
                },
                'text/x-pascal': {
                    'source': 'apache',
                    'extensions': ['p', 'pas']
                },
                'text/x-processing': {
                    'compressible': true,
                    'extensions': ['pde']
                },
                'text/x-sass': {
                    'extensions': ['sass']
                },
                'text/x-scss': {
                    'extensions': ['scss']
                },
                'text/x-setext': {
                    'source': 'apache',
                    'extensions': ['etx']
                },
                'text/x-sfv': {
                    'source': 'apache',
                    'extensions': ['sfv']
                },
                'text/x-suse-ymp': {
                    'compressible': true,
                    'extensions': ['ymp']
                },
                'text/x-uuencode': {
                    'source': 'apache',
                    'extensions': ['uu']
                },
                'text/x-vcalendar': {
                    'source': 'apache',
                    'extensions': ['vcs']
                },
                'text/x-vcard': {
                    'source': 'apache',
                    'extensions': ['vcf']
                },
                'text/xml': {
                    'source': 'iana',
                    'compressible': true,
                    'extensions': ['xml']
                },
                'text/xml-external-parsed-entity': {
                    'source': 'iana'
                },
                'text/yaml': {
                    'extensions': ['yaml', 'yml']
                },
                'video/1d-interleaved-parityfec': {
                    'source': 'iana'
                },
                'video/3gpp': {
                    'source': 'iana',
                    'extensions': ['3gp', '3gpp']
                },
                'video/3gpp-tt': {
                    'source': 'iana'
                },
                'video/3gpp2': {
                    'source': 'iana',
                    'extensions': ['3g2']
                },
                'video/bmpeg': {
                    'source': 'iana'
                },
                'video/bt656': {
                    'source': 'iana'
                },
                'video/celb': {
                    'source': 'iana'
                },
                'video/dv': {
                    'source': 'iana'
                },
                'video/encaprtp': {
                    'source': 'iana'
                },
                'video/h261': {
                    'source': 'iana',
                    'extensions': ['h261']
                },
                'video/h263': {
                    'source': 'iana',
                    'extensions': ['h263']
                },
                'video/h263-1998': {
                    'source': 'iana'
                },
                'video/h263-2000': {
                    'source': 'iana'
                },
                'video/h264': {
                    'source': 'iana',
                    'extensions': ['h264']
                },
                'video/h264-rcdo': {
                    'source': 'iana'
                },
                'video/h264-svc': {
                    'source': 'iana'
                },
                'video/h265': {
                    'source': 'iana'
                },
                'video/iso.segment': {
                    'source': 'iana'
                },
                'video/jpeg': {
                    'source': 'iana',
                    'extensions': ['jpgv']
                },
                'video/jpeg2000': {
                    'source': 'iana'
                },
                'video/jpm': {
                    'source': 'apache',
                    'extensions': ['jpm', 'jpgm']
                },
                'video/mj2': {
                    'source': 'iana',
                    'extensions': ['mj2', 'mjp2']
                },
                'video/mp1s': {
                    'source': 'iana'
                },
                'video/mp2p': {
                    'source': 'iana'
                },
                'video/mp2t': {
                    'source': 'iana',
                    'extensions': ['ts']
                },
                'video/mp4': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['mp4', 'mp4v', 'mpg4']
                },
                'video/mp4v-es': {
                    'source': 'iana'
                },
                'video/mpeg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v']
                },
                'video/mpeg4-generic': {
                    'source': 'iana'
                },
                'video/mpv': {
                    'source': 'iana'
                },
                'video/nv': {
                    'source': 'iana'
                },
                'video/ogg': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['ogv']
                },
                'video/parityfec': {
                    'source': 'iana'
                },
                'video/pointer': {
                    'source': 'iana'
                },
                'video/quicktime': {
                    'source': 'iana',
                    'compressible': false,
                    'extensions': ['qt', 'mov']
                },
                'video/raptorfec': {
                    'source': 'iana'
                },
                'video/raw': {
                    'source': 'iana'
                },
                'video/rtp-enc-aescm128': {
                    'source': 'iana'
                },
                'video/rtploopback': {
                    'source': 'iana'
                },
                'video/rtx': {
                    'source': 'iana'
                },
                'video/smpte291': {
                    'source': 'iana'
                },
                'video/smpte292m': {
                    'source': 'iana'
                },
                'video/ulpfec': {
                    'source': 'iana'
                },
                'video/vc1': {
                    'source': 'iana'
                },
                'video/vc2': {
                    'source': 'iana'
                },
                'video/vnd.cctv': {
                    'source': 'iana'
                },
                'video/vnd.dece.hd': {
                    'source': 'iana',
                    'extensions': ['uvh', 'uvvh']
                },
                'video/vnd.dece.mobile': {
                    'source': 'iana',
                    'extensions': ['uvm', 'uvvm']
                },
                'video/vnd.dece.mp4': {
                    'source': 'iana'
                },
                'video/vnd.dece.pd': {
                    'source': 'iana',
                    'extensions': ['uvp', 'uvvp']
                },
                'video/vnd.dece.sd': {
                    'source': 'iana',
                    'extensions': ['uvs', 'uvvs']
                },
                'video/vnd.dece.video': {
                    'source': 'iana',
                    'extensions': ['uvv', 'uvvv']
                },
                'video/vnd.directv.mpeg': {
                    'source': 'iana'
                },
                'video/vnd.directv.mpeg-tts': {
                    'source': 'iana'
                },
                'video/vnd.dlna.mpeg-tts': {
                    'source': 'iana'
                },
                'video/vnd.dvb.file': {
                    'source': 'iana',
                    'extensions': ['dvb']
                },
                'video/vnd.fvt': {
                    'source': 'iana',
                    'extensions': ['fvt']
                },
                'video/vnd.hns.video': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.1dparityfec-1010': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.1dparityfec-2005': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.2dparityfec-1010': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.2dparityfec-2005': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.ttsavc': {
                    'source': 'iana'
                },
                'video/vnd.iptvforum.ttsmpeg2': {
                    'source': 'iana'
                },
                'video/vnd.motorola.video': {
                    'source': 'iana'
                },
                'video/vnd.motorola.videop': {
                    'source': 'iana'
                },
                'video/vnd.mpegurl': {
                    'source': 'iana',
                    'extensions': ['mxu', 'm4u']
                },
                'video/vnd.ms-playready.media.pyv': {
                    'source': 'iana',
                    'extensions': ['pyv']
                },
                'video/vnd.nokia.interleaved-multimedia': {
                    'source': 'iana'
                },
                'video/vnd.nokia.mp4vr': {
                    'source': 'iana'
                },
                'video/vnd.nokia.videovoip': {
                    'source': 'iana'
                },
                'video/vnd.objectvideo': {
                    'source': 'iana'
                },
                'video/vnd.radgamettools.bink': {
                    'source': 'iana'
                },
                'video/vnd.radgamettools.smacker': {
                    'source': 'iana'
                },
                'video/vnd.sealed.mpeg1': {
                    'source': 'iana'
                },
                'video/vnd.sealed.mpeg4': {
                    'source': 'iana'
                },
                'video/vnd.sealed.swf': {
                    'source': 'iana'
                },
                'video/vnd.sealedmedia.softseal.mov': {
                    'source': 'iana'
                },
                'video/vnd.uvvu.mp4': {
                    'source': 'iana',
                    'extensions': ['uvu', 'uvvu']
                },
                'video/vnd.vivo': {
                    'source': 'iana',
                    'extensions': ['viv']
                },
                'video/vp8': {
                    'source': 'iana'
                },
                'video/webm': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['webm']
                },
                'video/x-f4v': {
                    'source': 'apache',
                    'extensions': ['f4v']
                },
                'video/x-fli': {
                    'source': 'apache',
                    'extensions': ['fli']
                },
                'video/x-flv': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['flv']
                },
                'video/x-m4v': {
                    'source': 'apache',
                    'extensions': ['m4v']
                },
                'video/x-matroska': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['mkv', 'mk3d', 'mks']
                },
                'video/x-mng': {
                    'source': 'apache',
                    'extensions': ['mng']
                },
                'video/x-ms-asf': {
                    'source': 'apache',
                    'extensions': ['asf', 'asx']
                },
                'video/x-ms-vob': {
                    'source': 'apache',
                    'extensions': ['vob']
                },
                'video/x-ms-wm': {
                    'source': 'apache',
                    'extensions': ['wm']
                },
                'video/x-ms-wmv': {
                    'source': 'apache',
                    'compressible': false,
                    'extensions': ['wmv']
                },
                'video/x-ms-wmx': {
                    'source': 'apache',
                    'extensions': ['wmx']
                },
                'video/x-ms-wvx': {
                    'source': 'apache',
                    'extensions': ['wvx']
                },
                'video/x-msvideo': {
                    'source': 'apache',
                    'extensions': ['avi']
                },
                'video/x-sgi-movie': {
                    'source': 'apache',
                    'extensions': ['movie']
                },
                'video/x-smv': {
                    'source': 'apache',
                    'extensions': ['smv']
                },
                'x-conference/x-cooltalk': {
                    'source': 'apache',
                    'extensions': ['ice']
                },
                'x-shader/x-fragment': {
                    'compressible': true
                },
                'x-shader/x-vertex': {
                    'compressible': true
                }
            };

        }, {}],
        124: [function(require, module, exports) {
            /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

            /**
             * Module exports.
             */

            module.exports = require('./db.json');

        }, { './db.json': 123 }],
        125: [function(require, module, exports) {
            /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

            'use strict';

            /**
             * Module dependencies.
             * @private
             */

            var db = require('mime-db');
            var extname = require('path').extname;

            /**
             * Module variables.
             * @private
             */

            var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            var TEXT_TYPE_REGEXP = /^text\//i;

            /**
             * Module exports.
             * @public
             */

            exports.charset = charset;
            exports.charsets = { lookup: charset };
            exports.contentType = contentType;
            exports.extension = extension;
            exports.extensions = Object.create(null);
            exports.lookup = lookup;
            exports.types = Object.create(null);

// Populate the extensions/types maps
            populateMaps(exports.extensions, exports.types);

            /**
             * Get the default charset for a MIME type.
             *
             * @param {string} type
             * @return {boolean|string}
             */

            function charset(type) {
                if (!type || typeof type !== 'string') {
                    return false;
                }

                // TODO: use media-typer
                var match = EXTRACT_TYPE_REGEXP.exec(type);
                var mime = match && db[match[1].toLowerCase()];

                if (mime && mime.charset) {
                    return mime.charset;
                }

                // default text/* to utf-8
                if (match && TEXT_TYPE_REGEXP.test(match[1])) {
                    return 'UTF-8';
                }

                return false;
            }

            /**
             * Create a full Content-Type header given a MIME type or extension.
             *
             * @param {string} str
             * @return {boolean|string}
             */

            function contentType(str) {
                // TODO: should this even be in this module?
                if (!str || typeof str !== 'string') {
                    return false;
                }

                var mime = str.indexOf('/') === -1
                    ? exports.lookup(str)
                    : str;

                if (!mime) {
                    return false;
                }

                // TODO: use content-type or other module
                if (mime.indexOf('charset') === -1) {
                    var charset = exports.charset(mime);
                    if (charset) mime += '; charset=' + charset.toLowerCase();
                }

                return mime;
            }

            /**
             * Get the default extension for a MIME type.
             *
             * @param {string} type
             * @return {boolean|string}
             */

            function extension(type) {
                if (!type || typeof type !== 'string') {
                    return false;
                }

                // TODO: use media-typer
                var match = EXTRACT_TYPE_REGEXP.exec(type);

                // get extensions
                var exts = match && exports.extensions[match[1].toLowerCase()];

                if (!exts || !exts.length) {
                    return false;
                }

                return exts[0];
            }

            /**
             * Lookup the MIME type for a file path/extension.
             *
             * @param {string} path
             * @return {boolean|string}
             */

            function lookup(path) {
                if (!path || typeof path !== 'string') {
                    return false;
                }

                // get the extension ("ext" or ".ext" or full path)
                var extension = extname('x.' + path)
                    .toLowerCase()
                    .substr(1);

                if (!extension) {
                    return false;
                }

                return exports.types[extension] || false;
            }

            /**
             * Populate the extensions and types maps.
             * @private
             */

            function populateMaps(extensions, types) {
                // source preference (least -> most)
                var preference = ['nginx', 'apache', undefined, 'iana'];

                Object.keys(db).forEach(function forEachMimeType(type) {
                    var mime = db[type];
                    var exts = mime.extensions;

                    if (!exts || !exts.length) {
                        return;
                    }

                    // mime -> extensions
                    extensions[type] = exts;

                    // extension -> mime
                    for (var i = 0; i < exts.length; i++) {
                        var extension = exts[i];

                        if (types[extension]) {
                            var from = preference.indexOf(db[types[extension]].source);
                            var to = preference.indexOf(mime.source);

                            if (types[extension] !== 'application/octet-stream' &&
                                (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
                                // skip the remapping
                                continue;
                            }
                        }

                        // set the extension -> mime
                        types[extension] = type;
                    }
                });
            }

        }, { 'mime-db': 124, 'path': 134 }],
        126: [function(require, module, exports) {
            module.exports = assert;

            function assert(val, msg) {
                if (!val)
                    throw new Error(msg || 'Assertion failed');
            }

            assert.equal = function assertEqual(l, r, msg) {
                if (l != r)
                    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
            };

        }, {}],
        127: [function(require, module, exports) {
            'use strict';

            var utils = exports;

            function toArray(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if (typeof msg !== 'string') {
                    for (var i = 0; i < msg.length; i++)
                        res[i] = msg[i] | 0;
                    return res;
                }
                if (enc === 'hex') {
                    msg = msg.replace(/[^a-z0-9]+/ig, '');
                    if (msg.length % 2 !== 0)
                        msg = '0' + msg;
                    for (var i = 0; i < msg.length; i += 2)
                        res.push(parseInt(msg[i] + msg[i + 1], 16));
                } else {
                    for (var i = 0; i < msg.length; i++) {
                        var c = msg.charCodeAt(i);
                        var hi = c >> 8;
                        var lo = c & 0xff;
                        if (hi)
                            res.push(hi, lo);
                        else
                            res.push(lo);
                    }
                }
                return res;
            }

            utils.toArray = toArray;

            function zero2(word) {
                if (word.length === 1)
                    return '0' + word;
                else
                    return word;
            }

            utils.zero2 = zero2;

            function toHex(msg) {
                var res = '';
                for (var i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res;
            }

            utils.toHex = toHex;

            utils.encode = function encode(arr, enc) {
                if (enc === 'hex')
                    return toHex(arr);
                else
                    return arr;
            };

        }, {}],
        128: [function(require, module, exports) {
            (function(process) {
                var path = require('path');
                var fs = require('fs');
                var _0777 = parseInt('0777', 8);

                module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

                function mkdirP(p, opts, f, made) {
                    if (typeof opts === 'function') {
                        f = opts;
                        opts = {};
                    } else if (!opts || typeof opts !== 'object') {
                        opts = { mode: opts };
                    }

                    var mode = opts.mode;
                    var xfs = opts.fs || fs;

                    if (mode === undefined) {
                        mode = _0777 & (~process.umask());
                    }
                    if (!made) made = null;

                    var cb = f || function() {
                    };
                    p = path.resolve(p);

                    xfs.mkdir(p, mode, function(er) {
                        if (!er) {
                            made = made || p;
                            return cb(null, made);
                        }
                        switch (er.code) {
                            case 'ENOENT':
                                mkdirP(path.dirname(p), opts, function(er, made) {
                                    if (er) cb(er, made);
                                    else mkdirP(p, opts, cb, made);
                                });
                                break;

                            // In the case of any other error, just see if there's a dir
                            // there already.  If so, then hooray!  If not, then something
                            // is borked.
                            default:
                                xfs.stat(p, function(er2, stat) {
                                    // if the stat fails, then that's super weird.
                                    // let the original error be the failure reason.
                                    if (er2 || !stat.isDirectory()) cb(er, made);
                                    else cb(null, made);
                                });
                                break;
                        }
                    });
                }

                mkdirP.sync = function sync(p, opts, made) {
                    if (!opts || typeof opts !== 'object') {
                        opts = { mode: opts };
                    }

                    var mode = opts.mode;
                    var xfs = opts.fs || fs;

                    if (mode === undefined) {
                        mode = _0777 & (~process.umask());
                    }
                    if (!made) made = null;

                    p = path.resolve(p);

                    try {
                        xfs.mkdirSync(p, mode);
                        made = made || p;
                    } catch (err0) {
                        switch (err0.code) {
                            case 'ENOENT' :
                                made = sync(path.dirname(p), opts, made);
                                sync(p, opts, made);
                                break;

                            // In the case of any other error, just see if there's a dir
                            // there already.  If so, then hooray!  If not, then something
                            // is borked.
                            default:
                                var stat;
                                try {
                                    stat = xfs.statSync(p);
                                } catch (err1) {
                                    throw err0;
                                }
                                if (!stat.isDirectory()) throw err0;
                                break;
                        }
                    }

                    return made;
                };

            }).call(this, require('_process'));
        }, { '_process': 141, 'fs': 57, 'path': 134 }],
        129: [function(require, module, exports) {
            module.exports = {
                '2.16.840.1.101.3.4.1.1': 'aes-128-ecb',
                '2.16.840.1.101.3.4.1.2': 'aes-128-cbc',
                '2.16.840.1.101.3.4.1.3': 'aes-128-ofb',
                '2.16.840.1.101.3.4.1.4': 'aes-128-cfb',
                '2.16.840.1.101.3.4.1.21': 'aes-192-ecb',
                '2.16.840.1.101.3.4.1.22': 'aes-192-cbc',
                '2.16.840.1.101.3.4.1.23': 'aes-192-ofb',
                '2.16.840.1.101.3.4.1.24': 'aes-192-cfb',
                '2.16.840.1.101.3.4.1.41': 'aes-256-ecb',
                '2.16.840.1.101.3.4.1.42': 'aes-256-cbc',
                '2.16.840.1.101.3.4.1.43': 'aes-256-ofb',
                '2.16.840.1.101.3.4.1.44': 'aes-256-cfb'
            };
        }, {}],
        130: [function(require, module, exports) {
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
            'use strict';

            var asn1 = require('asn1.js');

            exports.certificate = require('./certificate');

            var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('modulus').int(),
                    this.key('publicExponent').int(),
                    this.key('privateExponent').int(),
                    this.key('prime1').int(),
                    this.key('prime2').int(),
                    this.key('exponent1').int(),
                    this.key('exponent2').int(),
                    this.key('coefficient').int()
                );
            });
            exports.RSAPrivateKey = RSAPrivateKey;

            var RSAPublicKey = asn1.define('RSAPublicKey', function() {
                this.seq().obj(
                    this.key('modulus').int(),
                    this.key('publicExponent').int()
                );
            });
            exports.RSAPublicKey = RSAPublicKey;

            var PublicKey = asn1.define('SubjectPublicKeyInfo', function() {
                this.seq().obj(
                    this.key('algorithm').use(AlgorithmIdentifier),
                    this.key('subjectPublicKey').bitstr()
                );
            });
            exports.PublicKey = PublicKey;

            var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
                this.seq().obj(
                    this.key('algorithm').objid(),
                    this.key('none').null_().optional(),
                    this.key('curve').objid().optional(),
                    this.key('params').seq().obj(
                        this.key('p').int(),
                        this.key('q').int(),
                        this.key('g').int()
                    ).optional()
                );
            });

            var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('algorithm').use(AlgorithmIdentifier),
                    this.key('subjectPrivateKey').octstr()
                );
            });
            exports.PrivateKey = PrivateKeyInfo;
            var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
                this.seq().obj(
                    this.key('algorithm').seq().obj(
                        this.key('id').objid(),
                        this.key('decrypt').seq().obj(
                            this.key('kde').seq().obj(
                                this.key('id').objid(),
                                this.key('kdeparams').seq().obj(
                                    this.key('salt').octstr(),
                                    this.key('iters').int()
                                )
                            ),
                            this.key('cipher').seq().obj(
                                this.key('algo').objid(),
                                this.key('iv').octstr()
                            )
                        )
                    ),
                    this.key('subjectPrivateKey').octstr()
                );
            });

            exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

            var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('p').int(),
                    this.key('q').int(),
                    this.key('g').int(),
                    this.key('pub_key').int(),
                    this.key('priv_key').int()
                );
            });
            exports.DSAPrivateKey = DSAPrivateKey;

            exports.DSAparam = asn1.define('DSAparam', function() {
                this.int();
            });

            var ECPrivateKey = asn1.define('ECPrivateKey', function() {
                this.seq().obj(
                    this.key('version').int(),
                    this.key('privateKey').octstr(),
                    this.key('parameters').optional().explicit(0).use(ECParameters),
                    this.key('publicKey').optional().explicit(1).bitstr()
                );
            });
            exports.ECPrivateKey = ECPrivateKey;

            var ECParameters = asn1.define('ECParameters', function() {
                this.choice({
                    namedCurve: this.objid()
                });
            });

            exports.signature = asn1.define('signature', function() {
                this.seq().obj(
                    this.key('r').int(),
                    this.key('s').int()
                );
            });

        }, { './certificate': 131, 'asn1.js': 10 }],
        131: [function(require, module, exports) {
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

            'use strict';

            var asn = require('asn1.js');

            var Time = asn.define('Time', function() {
                this.choice({
                    utcTime: this.utctime(),
                    generalTime: this.gentime()
                });
            });

            var AttributeTypeValue = asn.define('AttributeTypeValue', function() {
                this.seq().obj(
                    this.key('type').objid(),
                    this.key('value').any()
                );
            });

            var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function() {
                this.seq().obj(
                    this.key('algorithm').objid(),
                    this.key('parameters').optional()
                );
            });

            var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function() {
                this.seq().obj(
                    this.key('algorithm').use(AlgorithmIdentifier),
                    this.key('subjectPublicKey').bitstr()
                );
            });

            var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function() {
                this.setof(AttributeTypeValue);
            });

            var RDNSequence = asn.define('RDNSequence', function() {
                this.seqof(RelativeDistinguishedName);
            });

            var Name = asn.define('Name', function() {
                this.choice({
                    rdnSequence: this.use(RDNSequence)
                });
            });

            var Validity = asn.define('Validity', function() {
                this.seq().obj(
                    this.key('notBefore').use(Time),
                    this.key('notAfter').use(Time)
                );
            });

            var Extension = asn.define('Extension', function() {
                this.seq().obj(
                    this.key('extnID').objid(),
                    this.key('critical').bool().def(false),
                    this.key('extnValue').octstr()
                );
            });

            var TBSCertificate = asn.define('TBSCertificate', function() {
                this.seq().obj(
                    this.key('version').explicit(0).int(),
                    this.key('serialNumber').int(),
                    this.key('signature').use(AlgorithmIdentifier),
                    this.key('issuer').use(Name),
                    this.key('validity').use(Validity),
                    this.key('subject').use(Name),
                    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
                    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
                    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
                    this.key('extensions').explicit(3).seqof(Extension).optional()
                );
            });

            var X509Certificate = asn.define('X509Certificate', function() {
                this.seq().obj(
                    this.key('tbsCertificate').use(TBSCertificate),
                    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
                    this.key('signatureValue').bitstr()
                );
            });

            module.exports = X509Certificate;

        }, { 'asn1.js': 10 }],
        132: [function(require, module, exports) {
            (function(Buffer) {
// adapted from https://github.com/apatil/pemstrip
                var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m;
                var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m;
                var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m;
                var evp = require('evp_bytestokey');
                var ciphers = require('browserify-aes');
                module.exports = function(okey, password) {
                    var key = okey.toString();
                    var match = key.match(findProc);
                    var decrypted;
                    if (!match) {
                        var match2 = key.match(fullRegex);
                        decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64');
                    } else {
                        var suite = 'aes' + match[1];
                        var iv = new Buffer(match[2], 'hex');
                        var cipherText = new Buffer(match[3].replace(/[\r\n]/g, ''), 'base64');
                        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
                        var out = [];
                        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
                        out.push(cipher.update(cipherText));
                        out.push(cipher.final());
                        decrypted = Buffer.concat(out);
                    }
                    var tag = key.match(startRegex)[1];
                    return {
                        tag: tag,
                        data: decrypted
                    };
                };

            }).call(this, require('buffer').Buffer);
        }, { 'browserify-aes': 32, 'buffer': 59, 'evp_bytestokey': 98 }],
        133: [function(require, module, exports) {
            (function(Buffer) {
                var asn1 = require('./asn1');
                var aesid = require('./aesid.json');
                var fixProc = require('./fixProc');
                var ciphers = require('browserify-aes');
                var compat = require('pbkdf2');
                module.exports = parseKeys;

                function parseKeys(buffer) {
                    var password;
                    if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
                        password = buffer.passphrase;
                        buffer = buffer.key;
                    }
                    if (typeof buffer === 'string') {
                        buffer = new Buffer(buffer);
                    }

                    var stripped = fixProc(buffer, password);

                    var type = stripped.tag;
                    var data = stripped.data;
                    var subtype, ndata;
                    switch (type) {
                        case 'CERTIFICATE':
                            ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
                        // falls through
                        case 'PUBLIC KEY':
                            if (!ndata) {
                                ndata = asn1.PublicKey.decode(data, 'der');
                            }
                            subtype = ndata.algorithm.algorithm.join('.');
                            switch (subtype) {
                                case '1.2.840.113549.1.1.1':
                                    return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
                                case '1.2.840.10045.2.1':
                                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                                    return {
                                        type: 'ec',
                                        data: ndata
                                    };
                                case '1.2.840.10040.4.1':
                                    ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
                                    return {
                                        type: 'dsa',
                                        data: ndata.algorithm.params
                                    };
                                default:
                                    throw new Error('unknown key id ' + subtype);
                            }
                            throw new Error('unknown key type ' + type);
                        case 'ENCRYPTED PRIVATE KEY':
                            data = asn1.EncryptedPrivateKey.decode(data, 'der');
                            data = decrypt(data, password);
                        // falls through
                        case 'PRIVATE KEY':
                            ndata = asn1.PrivateKey.decode(data, 'der');
                            subtype = ndata.algorithm.algorithm.join('.');
                            switch (subtype) {
                                case '1.2.840.113549.1.1.1':
                                    return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
                                case '1.2.840.10045.2.1':
                                    return {
                                        curve: ndata.algorithm.curve,
                                        privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
                                    };
                                case '1.2.840.10040.4.1':
                                    ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
                                    return {
                                        type: 'dsa',
                                        params: ndata.algorithm.params
                                    };
                                default:
                                    throw new Error('unknown key id ' + subtype);
                            }
                            throw new Error('unknown key type ' + type);
                        case 'RSA PUBLIC KEY':
                            return asn1.RSAPublicKey.decode(data, 'der');
                        case 'RSA PRIVATE KEY':
                            return asn1.RSAPrivateKey.decode(data, 'der');
                        case 'DSA PRIVATE KEY':
                            return {
                                type: 'dsa',
                                params: asn1.DSAPrivateKey.decode(data, 'der')
                            };
                        case 'EC PRIVATE KEY':
                            data = asn1.ECPrivateKey.decode(data, 'der');
                            return {
                                curve: data.parameters.value,
                                privateKey: data.privateKey
                            };
                        default:
                            throw new Error('unknown key type ' + type);
                    }
                }

                parseKeys.signature = asn1.signature;

                function decrypt(data, password) {
                    var salt = data.algorithm.decrypt.kde.kdeparams.salt;
                    var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
                    var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
                    var iv = data.algorithm.decrypt.cipher.iv;
                    var cipherText = data.subjectPrivateKey;
                    var keylen = parseInt(algo.split('-')[1], 10) / 8;
                    var key = compat.pbkdf2Sync(password, salt, iters, keylen);
                    var cipher = ciphers.createDecipheriv(algo, key, iv);
                    var out = [];
                    out.push(cipher.update(cipherText));
                    out.push(cipher.final());
                    return Buffer.concat(out);
                }

            }).call(this, require('buffer').Buffer);
        }, { './aesid.json': 129, './asn1': 130, './fixProc': 132, 'browserify-aes': 32, 'buffer': 59, 'pbkdf2': 135 }],
        134: [function(require, module, exports) {
            (function(process) {
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
                function normalizeArray(parts, allowAboveRoot) {
                    // if the path tries to go above the root, `up` ends up > 0
                    var up = 0;
                    for (var i = parts.length - 1; i >= 0; i--) {
                        var last = parts[i];
                        if (last === '.') {
                            parts.splice(i, 1);
                        } else if (last === '..') {
                            parts.splice(i, 1);
                            up++;
                        } else if (up) {
                            parts.splice(i, 1);
                            up--;
                        }
                    }

                    // if the path is allowed to go above the root, restore leading ..s
                    if (allowAboveRoot) {
                        for (; up--; up) {
                            parts.unshift('..');
                        }
                    }

                    return parts;
                }

// path.resolve([from ...], to)
// posix version
                exports.resolve = function() {
                    var resolvedPath = '',
                        resolvedAbsolute = false;

                    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                        var path = (i >= 0) ? arguments[i] : process.cwd();

                        // Skip empty and invalid entries
                        if (typeof path !== 'string') {
                            throw new TypeError('Arguments to path.resolve must be strings');
                        } else if (!path) {
                            continue;
                        }

                        resolvedPath = path + '/' + resolvedPath;
                        resolvedAbsolute = path.charAt(0) === '/';
                    }

                    // At this point the path should be resolved to a full absolute path, but
                    // handle relative paths to be safe (might happen when process.cwd() fails)

                    // Normalize the path
                    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
                        return !!p;
                    }), !resolvedAbsolute).join('/');

                    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
                };

// path.normalize(path)
// posix version
                exports.normalize = function(path) {
                    var isAbsolute = exports.isAbsolute(path),
                        trailingSlash = substr(path, -1) === '/';

                    // Normalize the path
                    path = normalizeArray(filter(path.split('/'), function(p) {
                        return !!p;
                    }), !isAbsolute).join('/');

                    if (!path && !isAbsolute) {
                        path = '.';
                    }
                    if (path && trailingSlash) {
                        path += '/';
                    }

                    return (isAbsolute ? '/' : '') + path;
                };

// posix version
                exports.isAbsolute = function(path) {
                    return path.charAt(0) === '/';
                };

// posix version
                exports.join = function() {
                    var paths = Array.prototype.slice.call(arguments, 0);
                    return exports.normalize(filter(paths, function(p, index) {
                        if (typeof p !== 'string') {
                            throw new TypeError('Arguments to path.join must be strings');
                        }
                        return p;
                    }).join('/'));
                };


// path.relative(from, to)
// posix version
                exports.relative = function(from, to) {
                    from = exports.resolve(from).substr(1);
                    to = exports.resolve(to).substr(1);

                    function trim(arr) {
                        var start = 0;
                        for (; start < arr.length; start++) {
                            if (arr[start] !== '') break;
                        }

                        var end = arr.length - 1;
                        for (; end >= 0; end--) {
                            if (arr[end] !== '') break;
                        }

                        if (start > end) return [];
                        return arr.slice(start, end - start + 1);
                    }

                    var fromParts = trim(from.split('/'));
                    var toParts = trim(to.split('/'));

                    var length = Math.min(fromParts.length, toParts.length);
                    var samePartsLength = length;
                    for (var i = 0; i < length; i++) {
                        if (fromParts[i] !== toParts[i]) {
                            samePartsLength = i;
                            break;
                        }
                    }

                    var outputParts = [];
                    for (var i = samePartsLength; i < fromParts.length; i++) {
                        outputParts.push('..');
                    }

                    outputParts = outputParts.concat(toParts.slice(samePartsLength));

                    return outputParts.join('/');
                };

                exports.sep = '/';
                exports.delimiter = ':';

                exports.dirname = function(path) {
                    if (typeof path !== 'string') path = path + '';
                    if (path.length === 0) return '.';
                    var code = path.charCodeAt(0);
                    var hasRoot = code === 47 /*/*/;
                    var end = -1;
                    var matchedSlash = true;
                    for (var i = path.length - 1; i >= 1; --i) {
                        code = path.charCodeAt(i);
                        if (code === 47 /*/*/) {
                            if (!matchedSlash) {
                                end = i;
                                break;
                            }
                        } else {
                            // We saw the first non-path separator
                            matchedSlash = false;
                        }
                    }

                    if (end === -1) return hasRoot ? '/' : '.';
                    if (hasRoot && end === 1) {
                        // return '//';
                        // Backwards-compat fix:
                        return '/';
                    }
                    return path.slice(0, end);
                };

                function basename(path) {
                    if (typeof path !== 'string') path = path + '';

                    var start = 0;
                    var end = -1;
                    var matchedSlash = true;
                    var i;

                    for (i = path.length - 1; i >= 0; --i) {
                        if (path.charCodeAt(i) === 47 /*/*/) {
                            // If we reached a path separator that was not part of a set of path
                            // separators at the end of the string, stop now
                            if (!matchedSlash) {
                                start = i + 1;
                                break;
                            }
                        } else if (end === -1) {
                            // We saw the first non-path separator, mark this as the end of our
                            // path component
                            matchedSlash = false;
                            end = i + 1;
                        }
                    }

                    if (end === -1) return '';
                    return path.slice(start, end);
                }

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
                exports.basename = function(path, ext) {
                    var f = basename(path);
                    if (ext && f.substr(-1 * ext.length) === ext) {
                        f = f.substr(0, f.length - ext.length);
                    }
                    return f;
                };

                exports.extname = function(path) {
                    if (typeof path !== 'string') path = path + '';
                    var startDot = -1;
                    var startPart = 0;
                    var end = -1;
                    var matchedSlash = true;
                    // Track the state of characters (if any) we see before our first dot and
                    // after any path separator we find
                    var preDotState = 0;
                    for (var i = path.length - 1; i >= 0; --i) {
                        var code = path.charCodeAt(i);
                        if (code === 47 /*/*/) {
                            // If we reached a path separator that was not part of a set of path
                            // separators at the end of the string, stop now
                            if (!matchedSlash) {
                                startPart = i + 1;
                                break;
                            }
                            continue;
                        }
                        if (end === -1) {
                            // We saw the first non-path separator, mark this as the end of our
                            // extension
                            matchedSlash = false;
                            end = i + 1;
                        }
                        if (code === 46 /*.*/) {
                            // If this is our first dot, mark it as the start of our extension
                            if (startDot === -1)
                                startDot = i;
                            else if (preDotState !== 1)
                                preDotState = 1;
                        } else if (startDot !== -1) {
                            // We saw a non-dot and non-path separator before our dot, so we should
                            // have a good chance at having a non-empty extension
                            preDotState = -1;
                        }
                    }

                    if (startDot === -1 || end === -1 ||
                        // We saw a non-dot character immediately before the dot
                        preDotState === 0 ||
                        // The (right-most) trimmed path component is exactly '..'
                        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                        return '';
                    }
                    return path.slice(startDot, end);
                };

                function filter(xs, f) {
                    if (xs.filter) return xs.filter(f);
                    var res = [];
                    for (var i = 0; i < xs.length; i++) {
                        if (f(xs[i], i, xs)) res.push(xs[i]);
                    }
                    return res;
                }

// String.prototype.substr - negative index don't work in IE8
                var substr = 'ab'.substr(-1) === 'b'
                    ? function(str, start, len) {
                        return str.substr(start, len);
                    }
                    : function(str, start, len) {
                        if (start < 0) start = str.length + start;
                        return str.substr(start, len);
                    }
                ;

            }).call(this, require('_process'));
        }, { '_process': 141 }],
        135: [function(require, module, exports) {
            exports.pbkdf2 = require('./lib/async');
            exports.pbkdf2Sync = require('./lib/sync');

        }, { './lib/async': 136, './lib/sync': 139 }],
        136: [function(require, module, exports) {
            (function(process, global) {
                var checkParameters = require('./precondition');
                var defaultEncoding = require('./default-encoding');
                var sync = require('./sync');
                var Buffer = require('safe-buffer').Buffer;

                var ZERO_BUF;
                var subtle = global.crypto && global.crypto.subtle;
                var toBrowser = {
                    'sha': 'SHA-1',
                    'sha-1': 'SHA-1',
                    'sha1': 'SHA-1',
                    'sha256': 'SHA-256',
                    'sha-256': 'SHA-256',
                    'sha384': 'SHA-384',
                    'sha-384': 'SHA-384',
                    'sha-512': 'SHA-512',
                    'sha512': 'SHA-512'
                };
                var checks = [];

                function checkNative(algo) {
                    if (global.process && !global.process.browser) {
                        return Promise.resolve(false);
                    }
                    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
                        return Promise.resolve(false);
                    }
                    if (checks[algo] !== undefined) {
                        return checks[algo];
                    }
                    ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
                    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
                        .then(function() {
                            return true;
                        }).catch(function() {
                            return false;
                        });
                    checks[algo] = prom;
                    return prom;
                }

                function browserPbkdf2(password, salt, iterations, length, algo) {
                    return subtle.importKey(
                        'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
                    ).then(function(key) {
                        return subtle.deriveBits({
                            name: 'PBKDF2',
                            salt: salt,
                            iterations: iterations,
                            hash: {
                                name: algo
                            }
                        }, key, length << 3);
                    }).then(function(res) {
                        return Buffer.from(res);
                    });
                }

                function resolvePromise(promise, callback) {
                    promise.then(function(out) {
                        process.nextTick(function() {
                            callback(null, out);
                        });
                    }, function(e) {
                        process.nextTick(function() {
                            callback(e);
                        });
                    });
                }

                module.exports = function(password, salt, iterations, keylen, digest, callback) {
                    if (typeof digest === 'function') {
                        callback = digest;
                        digest = undefined;
                    }

                    digest = digest || 'sha1';
                    var algo = toBrowser[digest.toLowerCase()];

                    if (!algo || typeof global.Promise !== 'function') {
                        return process.nextTick(function() {
                            var out;
                            try {
                                out = sync(password, salt, iterations, keylen, digest);
                            } catch (e) {
                                return callback(e);
                            }
                            callback(null, out);
                        });
                    }

                    checkParameters(password, salt, iterations, keylen);
                    if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
                    if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
                    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);

                    resolvePromise(checkNative(algo).then(function(resp) {
                        if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);

                        return sync(password, salt, iterations, keylen, digest);
                    }), callback);
                };

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { './default-encoding': 137, './precondition': 138, './sync': 139, '_process': 141, 'safe-buffer': 169 }],
        137: [function(require, module, exports) {
            (function(process) {
                var defaultEncoding;
                /* istanbul ignore next */
                if (process.browser) {
                    defaultEncoding = 'utf-8';
                } else {
                    var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

                    defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
                }
                module.exports = defaultEncoding;

            }).call(this, require('_process'));
        }, { '_process': 141 }],
        138: [function(require, module, exports) {
            (function(Buffer) {
                var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

                function checkBuffer(buf, name) {
                    if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
                        throw new TypeError(name + ' must be a buffer or string');
                    }
                }

                module.exports = function(password, salt, iterations, keylen) {
                    checkBuffer(password, 'Password');
                    checkBuffer(salt, 'Salt');

                    if (typeof iterations !== 'number') {
                        throw new TypeError('Iterations not a number');
                    }

                    if (iterations < 0) {
                        throw new TypeError('Bad iterations');
                    }

                    if (typeof keylen !== 'number') {
                        throw new TypeError('Key length not a number');
                    }

                    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
                        throw new TypeError('Bad key length');
                    }
                };

            }).call(this, { 'isBuffer': require('../../is-buffer/index.js') });
        }, { '../../is-buffer/index.js': 117 }],
        139: [function(require, module, exports) {
            var md5 = require('create-hash/md5');
            var RIPEMD160 = require('ripemd160');
            var sha = require('sha.js');

            var checkParameters = require('./precondition');
            var defaultEncoding = require('./default-encoding');
            var Buffer = require('safe-buffer').Buffer;
            var ZEROS = Buffer.alloc(128);
            var sizes = {
                md5: 16,
                sha1: 20,
                sha224: 28,
                sha256: 32,
                sha384: 48,
                sha512: 64,
                rmd160: 20,
                ripemd160: 20
            };

            function Hmac(alg, key, saltLen) {
                var hash = getDigest(alg);
                var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

                if (key.length > blocksize) {
                    key = hash(key);
                } else if (key.length < blocksize) {
                    key = Buffer.concat([key, ZEROS], blocksize);
                }

                var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
                var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
                for (var i = 0; i < blocksize; i++) {
                    ipad[i] = key[i] ^ 0x36;
                    opad[i] = key[i] ^ 0x5C;
                }

                var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
                ipad.copy(ipad1, 0, 0, blocksize);
                this.ipad1 = ipad1;
                this.ipad2 = ipad;
                this.opad = opad;
                this.alg = alg;
                this.blocksize = blocksize;
                this.hash = hash;
                this.size = sizes[alg];
            }

            Hmac.prototype.run = function(data, ipad) {
                data.copy(ipad, this.blocksize);
                var h = this.hash(ipad);
                h.copy(this.opad, this.blocksize);
                return this.hash(this.opad);
            };

            function getDigest(alg) {
                function shaFunc(data) {
                    return sha(alg).update(data).digest();
                }

                function rmd160Func(data) {
                    return new RIPEMD160().update(data).digest();
                }

                if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
                if (alg === 'md5') return md5;
                return shaFunc;
            }

            function pbkdf2(password, salt, iterations, keylen, digest) {
                checkParameters(password, salt, iterations, keylen);

                if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
                if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);

                digest = digest || 'sha1';

                var hmac = new Hmac(digest, password, salt.length);

                var DK = Buffer.allocUnsafe(keylen);
                var block1 = Buffer.allocUnsafe(salt.length + 4);
                salt.copy(block1, 0, 0, salt.length);

                var destPos = 0;
                var hLen = sizes[digest];
                var l = Math.ceil(keylen / hLen);

                for (var i = 1; i <= l; i++) {
                    block1.writeUInt32BE(i, salt.length);

                    var T = hmac.run(block1, hmac.ipad1);
                    var U = T;

                    for (var j = 1; j < iterations; j++) {
                        U = hmac.run(U, hmac.ipad2);
                        for (var k = 0; k < hLen; k++) T[k] ^= U[k];
                    }

                    T.copy(DK, destPos);
                    destPos += hLen;
                }

                return DK;
            }

            module.exports = pbkdf2;

        }, {
            './default-encoding': 137,
            './precondition': 138,
            'create-hash/md5': 65,
            'ripemd160': 168,
            'safe-buffer': 169,
            'sha.js': 172
        }],
        140: [function(require, module, exports) {
            (function(process) {
                'use strict';

                if (!process.version ||
                    process.version.indexOf('v0.') === 0 ||
                    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
                    module.exports = { nextTick: nextTick };
                } else {
                    module.exports = process;
                }

                function nextTick(fn, arg1, arg2, arg3) {
                    if (typeof fn !== 'function') {
                        throw new TypeError('"callback" argument must be a function');
                    }
                    var len = arguments.length;
                    var args, i;
                    switch (len) {
                        case 0:
                        case 1:
                            return process.nextTick(fn);
                        case 2:
                            return process.nextTick(function afterTickOne() {
                                fn.call(null, arg1);
                            });
                        case 3:
                            return process.nextTick(function afterTickTwo() {
                                fn.call(null, arg1, arg2);
                            });
                        case 4:
                            return process.nextTick(function afterTickThree() {
                                fn.call(null, arg1, arg2, arg3);
                            });
                        default:
                            args = new Array(len - 1);
                            i = 0;
                            while (i < args.length) {
                                args[i++] = arguments[i];
                            }
                            return process.nextTick(function afterTick() {
                                fn.apply(null, args);
                            });
                    }
                }


            }).call(this, require('_process'));
        }, { '_process': 141 }],
        141: [function(require, module, exports) {
// shim for using process in browser
            var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }

            function defaultClearTimeout() {
                throw new Error('clearTimeout has not been defined');
            }

            (function() {
                try {
                    if (typeof setTimeout === 'function') {
                        cachedSetTimeout = setTimeout;
                    } else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === 'function') {
                        cachedClearTimeout = clearTimeout;
                    } else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }());

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }


            }

            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }


            }

            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }

            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            };

// v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }

            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {
            }

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;

            process.listeners = function(name) {
                return [];
            };

            process.binding = function(name) {
                throw new Error('process.binding is not supported');
            };

            process.cwd = function() {
                return '/';
            };
            process.chdir = function(dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function() {
                return 0;
            };

        }, {}],
        142: [function(require, module, exports) {
            exports.publicEncrypt = require('./publicEncrypt');
            exports.privateDecrypt = require('./privateDecrypt');

            exports.privateEncrypt = function privateEncrypt(key, buf) {
                return exports.publicEncrypt(key, buf, true);
            };

            exports.publicDecrypt = function publicDecrypt(key, buf) {
                return exports.privateDecrypt(key, buf, true);
            };

        }, { './privateDecrypt': 144, './publicEncrypt': 145 }],
        143: [function(require, module, exports) {
            var createHash = require('create-hash');
            var Buffer = require('safe-buffer').Buffer;

            module.exports = function(seed, len) {
                var t = Buffer.alloc(0);
                var i = 0;
                var c;
                while (t.length < len) {
                    c = i2ops(i++);
                    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
                }
                return t.slice(0, len);
            };

            function i2ops(c) {
                var out = Buffer.allocUnsafe(4);
                out.writeUInt32BE(c, 0);
                return out;
            }

        }, { 'create-hash': 64, 'safe-buffer': 169 }],
        144: [function(require, module, exports) {
            var parseKeys = require('parse-asn1');
            var mgf = require('./mgf');
            var xor = require('./xor');
            var BN = require('bn.js');
            var crt = require('browserify-rsa');
            var createHash = require('create-hash');
            var withPublic = require('./withPublic');
            var Buffer = require('safe-buffer').Buffer;

            module.exports = function privateDecrypt(privateKey, enc, reverse) {
                var padding;
                if (privateKey.padding) {
                    padding = privateKey.padding;
                } else if (reverse) {
                    padding = 1;
                } else {
                    padding = 4;
                }

                var key = parseKeys(privateKey);
                var k = key.modulus.byteLength();
                if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
                    throw new Error('decryption error');
                }
                var msg;
                if (reverse) {
                    msg = withPublic(new BN(enc), key);
                } else {
                    msg = crt(enc, key);
                }
                var zBuffer = Buffer.alloc(k - msg.length);
                msg = Buffer.concat([zBuffer, msg], k);
                if (padding === 4) {
                    return oaep(key, msg);
                } else if (padding === 1) {
                    return pkcs1(key, msg, reverse);
                } else if (padding === 3) {
                    return msg;
                } else {
                    throw new Error('unknown padding');
                }
            };

            function oaep(key, msg) {
                var k = key.modulus.byteLength();
                var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
                var hLen = iHash.length;
                if (msg[0] !== 0) {
                    throw new Error('decryption error');
                }
                var maskedSeed = msg.slice(1, hLen + 1);
                var maskedDb = msg.slice(hLen + 1);
                var seed = xor(maskedSeed, mgf(maskedDb, hLen));
                var db = xor(maskedDb, mgf(seed, k - hLen - 1));
                if (compare(iHash, db.slice(0, hLen))) {
                    throw new Error('decryption error');
                }
                var i = hLen;
                while (db[i] === 0) {
                    i++;
                }
                if (db[i++] !== 1) {
                    throw new Error('decryption error');
                }
                return db.slice(i);
            }

            function pkcs1(key, msg, reverse) {
                var p1 = msg.slice(0, 2);
                var i = 2;
                var status = 0;
                while (msg[i++] !== 0) {
                    if (i >= msg.length) {
                        status++;
                        break;
                    }
                }
                var ps = msg.slice(2, i - 1);

                if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
                    status++;
                }
                if (ps.length < 8) {
                    status++;
                }
                if (status) {
                    throw new Error('decryption error');
                }
                return msg.slice(i);
            }

            function compare(a, b) {
                a = Buffer.from(a);
                b = Buffer.from(b);
                var dif = 0;
                var len = a.length;
                if (a.length !== b.length) {
                    dif++;
                    len = Math.min(a.length, b.length);
                }
                var i = -1;
                while (++i < len) {
                    dif += (a[i] ^ b[i]);
                }
                return dif;
            }

        }, {
            './mgf': 143,
            './withPublic': 146,
            './xor': 147,
            'bn.js': 27,
            'browserify-rsa': 50,
            'create-hash': 64,
            'parse-asn1': 133,
            'safe-buffer': 169
        }],
        145: [function(require, module, exports) {
            var parseKeys = require('parse-asn1');
            var randomBytes = require('randombytes');
            var createHash = require('create-hash');
            var mgf = require('./mgf');
            var xor = require('./xor');
            var BN = require('bn.js');
            var withPublic = require('./withPublic');
            var crt = require('browserify-rsa');
            var Buffer = require('safe-buffer').Buffer;

            module.exports = function publicEncrypt(publicKey, msg, reverse) {
                var padding;
                if (publicKey.padding) {
                    padding = publicKey.padding;
                } else if (reverse) {
                    padding = 1;
                } else {
                    padding = 4;
                }
                var key = parseKeys(publicKey);
                var paddedMsg;
                if (padding === 4) {
                    paddedMsg = oaep(key, msg);
                } else if (padding === 1) {
                    paddedMsg = pkcs1(key, msg, reverse);
                } else if (padding === 3) {
                    paddedMsg = new BN(msg);
                    if (paddedMsg.cmp(key.modulus) >= 0) {
                        throw new Error('data too long for modulus');
                    }
                } else {
                    throw new Error('unknown padding');
                }
                if (reverse) {
                    return crt(paddedMsg, key);
                } else {
                    return withPublic(paddedMsg, key);
                }
            };

            function oaep(key, msg) {
                var k = key.modulus.byteLength();
                var mLen = msg.length;
                var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
                var hLen = iHash.length;
                var hLen2 = 2 * hLen;
                if (mLen > k - hLen2 - 2) {
                    throw new Error('message too long');
                }
                var ps = Buffer.alloc(k - mLen - hLen2 - 2);
                var dblen = k - hLen - 1;
                var seed = randomBytes(hLen);
                var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
                var maskedSeed = xor(seed, mgf(maskedDb, hLen));
                return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
            }

            function pkcs1(key, msg, reverse) {
                var mLen = msg.length;
                var k = key.modulus.byteLength();
                if (mLen > k - 11) {
                    throw new Error('message too long');
                }
                var ps;
                if (reverse) {
                    ps = Buffer.alloc(k - mLen - 3, 0xff);
                } else {
                    ps = nonZero(k - mLen - 3);
                }
                return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
            }

            function nonZero(len) {
                var out = Buffer.allocUnsafe(len);
                var i = 0;
                var cache = randomBytes(len * 2);
                var cur = 0;
                var num;
                while (i < len) {
                    if (cur === cache.length) {
                        cache = randomBytes(len * 2);
                        cur = 0;
                    }
                    num = cache[cur++];
                    if (num) {
                        out[i++] = num;
                    }
                }
                return out;
            }

        }, {
            './mgf': 143,
            './withPublic': 146,
            './xor': 147,
            'bn.js': 27,
            'browserify-rsa': 50,
            'create-hash': 64,
            'parse-asn1': 133,
            'randombytes': 152,
            'safe-buffer': 169
        }],
        146: [function(require, module, exports) {
            var BN = require('bn.js');
            var Buffer = require('safe-buffer').Buffer;

            function withPublic(paddedMsg, key) {
                return Buffer.from(paddedMsg
                    .toRed(BN.mont(key.modulus))
                    .redPow(new BN(key.publicExponent))
                    .fromRed()
                    .toArray());
            }

            module.exports = withPublic;

        }, { 'bn.js': 27, 'safe-buffer': 169 }],
        147: [function(require, module, exports) {
            module.exports = function xor(a, b) {
                var len = a.length;
                var i = -1;
                while (++i < len) {
                    a[i] ^= b[i];
                }
                return a;
            };

        }, {}],
        148: [function(require, module, exports) {
            (function(global) {
                /*! https://mths.be/punycode v1.4.1 by @mathias */
                ;(function(root) {

                    /** Detect free variables */
                    var freeExports = typeof exports == 'object' && exports &&
                        !exports.nodeType && exports;
                    var freeModule = typeof module == 'object' && module &&
                        !module.nodeType && module;
                    var freeGlobal = typeof global == 'object' && global;
                    if (
                        freeGlobal.global === freeGlobal ||
                        freeGlobal.window === freeGlobal ||
                        freeGlobal.self === freeGlobal
                    ) {
                        root = freeGlobal;
                    }

                    /**
                     * The `punycode` object.
                     * @name punycode
                     * @type Object
                     */
                    var punycode,

                        /** Highest positive signed 32-bit float value */
                        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

                        /** Bootstring parameters */
                        base = 36,
                        tMin = 1,
                        tMax = 26,
                        skew = 38,
                        damp = 700,
                        initialBias = 72,
                        initialN = 128, // 0x80
                        delimiter = '-', // '\x2D'

                        /** Regular expressions */
                        regexPunycode = /^xn--/,
                        regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

                        /** Error messages */
                        errors = {
                            'overflow': 'Overflow: input needs wider integers to process',
                            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                            'invalid-input': 'Invalid input'
                        },

                        /** Convenience shortcuts */
                        baseMinusTMin = base - tMin,
                        floor = Math.floor,
                        stringFromCharCode = String.fromCharCode,

                        /** Temporary variable */
                        key;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * A generic error utility function.
                     * @private
                     * @param {String} type The error type.
                     * @returns {Error} Throws a `RangeError` with the applicable error message.
                     */
                    function error(type) {
                        throw new RangeError(errors[type]);
                    }

                    /**
                     * A generic `Array#map` utility function.
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} callback The function that gets called for every array
                     * item.
                     * @returns {Array} A new array of values returned by the callback function.
                     */
                    function map(array, fn) {
                        var length = array.length;
                        var result = [];
                        while (length--) {
                            result[length] = fn(array[length]);
                        }
                        return result;
                    }

                    /**
                     * A simple `Array#map`-like wrapper to work with domain name strings or email
                     * addresses.
                     * @private
                     * @param {String} domain The domain name or email address.
                     * @param {Function} callback The function that gets called for every
                     * character.
                     * @returns {Array} A new string of characters returned by the callback
                     * function.
                     */
                    function mapDomain(string, fn) {
                        var parts = string.split('@');
                        var result = '';
                        if (parts.length > 1) {
                            // In email addresses, only the domain name should be punycoded. Leave
                            // the local part (i.e. everything up to `@`) intact.
                            result = parts[0] + '@';
                            string = parts[1];
                        }
                        // Avoid `split(regex)` for IE8 compatibility. See #17.
                        string = string.replace(regexSeparators, '\x2E');
                        var labels = string.split('.');
                        var encoded = map(labels, fn).join('.');
                        return result + encoded;
                    }

                    /**
                     * Creates an array containing the numeric code points of each Unicode
                     * character in the string. While JavaScript uses UCS-2 internally,
                     * this function will convert a pair of surrogate halves (each of which
                     * UCS-2 exposes as separate characters) into a single code point,
                     * matching UTF-16.
                     * @see `punycode.ucs2.encode`
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode.ucs2
                     * @name decode
                     * @param {String} string The Unicode input string (UCS-2).
                     * @returns {Array} The new array of code points.
                     */
                    function ucs2decode(string) {
                        var output = [],
                            counter = 0,
                            length = string.length,
                            value,
                            extra;
                        while (counter < length) {
                            value = string.charCodeAt(counter++);
                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                // high surrogate, and there is a next character
                                extra = string.charCodeAt(counter++);
                                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                } else {
                                    // unmatched surrogate; only append this code unit, in case the next
                                    // code unit is the high surrogate of a surrogate pair
                                    output.push(value);
                                    counter--;
                                }
                            } else {
                                output.push(value);
                            }
                        }
                        return output;
                    }

                    /**
                     * Creates a string based on an array of numeric code points.
                     * @see `punycode.ucs2.decode`
                     * @memberOf punycode.ucs2
                     * @name encode
                     * @param {Array} codePoints The array of numeric code points.
                     * @returns {String} The new Unicode string (UCS-2).
                     */
                    function ucs2encode(array) {
                        return map(array, function(value) {
                            var output = '';
                            if (value > 0xFFFF) {
                                value -= 0x10000;
                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                value = 0xDC00 | value & 0x3FF;
                            }
                            output += stringFromCharCode(value);
                            return output;
                        }).join('');
                    }

                    /**
                     * Converts a basic code point into a digit/integer.
                     * @see `digitToBasic()`
                     * @private
                     * @param {Number} codePoint The basic numeric code point value.
                     * @returns {Number} The numeric value of a basic code point (for use in
                     * representing integers) in the range `0` to `base - 1`, or `base` if
                     * the code point does not represent a value.
                     */
                    function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) {
                            return codePoint - 22;
                        }
                        if (codePoint - 65 < 26) {
                            return codePoint - 65;
                        }
                        if (codePoint - 97 < 26) {
                            return codePoint - 97;
                        }
                        return base;
                    }

                    /**
                     * Converts a digit/integer into a basic code point.
                     * @see `basicToDigit()`
                     * @private
                     * @param {Number} digit The numeric value of a basic code point.
                     * @returns {Number} The basic code point whose value (when used for
                     * representing integers) is `digit`, which needs to be in the range
                     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                     * used; else, the lowercase form is used. The behavior is undefined
                     * if `flag` is non-zero and `digit` has no uppercase form.
                     */
                    function digitToBasic(digit, flag) {
                        //  0..25 map to ASCII a..z or A..Z
                        // 26..35 map to ASCII 0..9
                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                    }

                    /**
                     * Bias adaptation function as per section 3.4 of RFC 3492.
                     * https://tools.ietf.org/html/rfc3492#section-3.4
                     * @private
                     */
                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
                            delta = floor(delta / baseMinusTMin);
                        }
                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                    }

                    /**
                     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                     * symbols.
                     * @memberOf punycode
                     * @param {String} input The Punycode string of ASCII-only symbols.
                     * @returns {String} The resulting string of Unicode symbols.
                     */
                    function decode(input) {
                        // Don't use UCS-2
                        var output = [],
                            inputLength = input.length,
                            out,
                            i = 0,
                            n = initialN,
                            bias = initialBias,
                            basic,
                            j,
                            index,
                            oldi,
                            w,
                            k,
                            digit,
                            t,
                            /** Cached calculation results */
                            baseMinusT;

                        // Handle the basic code points: let `basic` be the number of input code
                        // points before the last delimiter, or `0` if there is none, then copy
                        // the first basic code points to the output.

                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) {
                            basic = 0;
                        }

                        for (j = 0; j < basic; ++j) {
                            // if it's not a basic code point
                            if (input.charCodeAt(j) >= 0x80) {
                                error('not-basic');
                            }
                            output.push(input.charCodeAt(j));
                        }

                        // Main decoding loop: start just after the last delimiter if any basic code
                        // points were copied; start at the beginning otherwise.

                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

                            // `index` is the index of the next character to be consumed.
                            // Decode a generalized variable-length integer into `delta`,
                            // which gets added to `i`. The overflow checking is easier
                            // if we increase `i` as we go, then subtract off its starting
                            // value at the end to obtain `delta`.
                            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                                if (index >= inputLength) {
                                    error('invalid-input');
                                }

                                digit = basicToDigit(input.charCodeAt(index++));

                                if (digit >= base || digit > floor((maxInt - i) / w)) {
                                    error('overflow');
                                }

                                i += digit * w;
                                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                                if (digit < t) {
                                    break;
                                }

                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) {
                                    error('overflow');
                                }

                                w *= baseMinusT;

                            }

                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);

                            // `i` was supposed to wrap around from `out` to `0`,
                            // incrementing `n` each time, so we'll fix that now:
                            if (floor(i / out) > maxInt - n) {
                                error('overflow');
                            }

                            n += floor(i / out);
                            i %= out;

                            // Insert `n` at position `i` of the output
                            output.splice(i++, 0, n);

                        }

                        return ucs2encode(output);
                    }

                    /**
                     * Converts a string of Unicode symbols (e.g. a domain name label) to a
                     * Punycode string of ASCII-only symbols.
                     * @memberOf punycode
                     * @param {String} input The string of Unicode symbols.
                     * @returns {String} The resulting Punycode string of ASCII-only symbols.
                     */
                    function encode(input) {
                        var n,
                            delta,
                            handledCPCount,
                            basicLength,
                            bias,
                            j,
                            m,
                            q,
                            k,
                            t,
                            currentValue,
                            output = [],
                            /** `inputLength` will hold the number of code points in `input`. */
                            inputLength,
                            /** Cached calculation results */
                            handledCPCountPlusOne,
                            baseMinusT,
                            qMinusT;

                        // Convert the input in UCS-2 to Unicode
                        input = ucs2decode(input);

                        // Cache the length
                        inputLength = input.length;

                        // Initialize the state
                        n = initialN;
                        delta = 0;
                        bias = initialBias;

                        // Handle the basic code points
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < 0x80) {
                                output.push(stringFromCharCode(currentValue));
                            }
                        }

                        handledCPCount = basicLength = output.length;

                        // `handledCPCount` is the number of code points that have been handled;
                        // `basicLength` is the number of basic code points.

                        // Finish the basic string - if it is not empty - with a delimiter
                        if (basicLength) {
                            output.push(delimiter);
                        }

                        // Main encoding loop:
                        while (handledCPCount < inputLength) {

                            // All non-basic code points < n have been handled already. Find the next
                            // larger one:
                            for (m = maxInt, j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }

                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                error('overflow');
                            }

                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;

                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];

                                if (currentValue < n && ++delta > maxInt) {
                                    error('overflow');
                                }

                                if (currentValue == n) {
                                    // Represent delta as a generalized variable-length integer
                                    for (q = delta, k = base; /* no condition */; k += base) {
                                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                        if (q < t) {
                                            break;
                                        }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(
                                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                                        );
                                        q = floor(qMinusT / baseMinusT);
                                    }

                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }

                            ++delta;
                            ++n;

                        }
                        return output.join('');
                    }

                    /**
                     * Converts a Punycode string representing a domain name or an email address
                     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                     * it doesn't matter if you call it on a string that has already been
                     * converted to Unicode.
                     * @memberOf punycode
                     * @param {String} input The Punycoded domain name or email address to
                     * convert to Unicode.
                     * @returns {String} The Unicode representation of the given Punycode
                     * string.
                     */
                    function toUnicode(input) {
                        return mapDomain(input, function(string) {
                            return regexPunycode.test(string)
                                ? decode(string.slice(4).toLowerCase())
                                : string;
                        });
                    }

                    /**
                     * Converts a Unicode string representing a domain name or an email address to
                     * Punycode. Only the non-ASCII parts of the domain name will be converted,
                     * i.e. it doesn't matter if you call it with a domain that's already in
                     * ASCII.
                     * @memberOf punycode
                     * @param {String} input The domain name or email address to convert, as a
                     * Unicode string.
                     * @returns {String} The Punycode representation of the given domain name or
                     * email address.
                     */
                    function toASCII(input) {
                        return mapDomain(input, function(string) {
                            return regexNonASCII.test(string)
                                ? 'xn--' + encode(string)
                                : string;
                        });
                    }

                    /*--------------------------------------------------------------------------*/

                    /** Define the public API */
                    punycode = {
                        /**
                         * A string representing the current Punycode.js version number.
                         * @memberOf punycode
                         * @type String
                         */
                        'version': '1.4.1',
                        /**
                         * An object of methods to convert from JavaScript's internal character
                         * representation (UCS-2) to Unicode code points, and back.
                         * @see <https://mathiasbynens.be/notes/javascript-encoding>
                         * @memberOf punycode
                         * @type Object
                         */
                        'ucs2': {
                            'decode': ucs2decode,
                            'encode': ucs2encode
                        },
                        'decode': decode,
                        'encode': encode,
                        'toASCII': toASCII,
                        'toUnicode': toUnicode
                    };

                    /** Expose `punycode` */
                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (
                        typeof define == 'function' &&
                        typeof define.amd == 'object' &&
                        define.amd
                    ) {
                        define('punycode', function() {
                            return punycode;
                        });
                    } else if (freeExports && freeModule) {
                        if (module.exports == freeExports) {
                            // in Node.js, io.js, or RingoJS v0.8.0+
                            freeModule.exports = punycode;
                        } else {
                            // in Narwhal or RingoJS v0.7.0-
                            for (key in punycode) {
                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                            }
                        }
                    } else {
                        // in Rhino or a web browser
                        root.punycode = punycode;
                    }

                }(this));

            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, {}],
        149: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }

            module.exports = function(qs, sep, eq, options) {
                sep = sep || '&';
                eq = eq || '=';
                var obj = {};

                if (typeof qs !== 'string' || qs.length === 0) {
                    return obj;
                }

                var regexp = /\+/g;
                qs = qs.split(sep);

                var maxKeys = 1000;
                if (options && typeof options.maxKeys === 'number') {
                    maxKeys = options.maxKeys;
                }

                var len = qs.length;
                // maxKeys <= 0 means that we should not limit keys count
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                }

                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, '%20'),
                        idx = x.indexOf(eq),
                        kstr, vstr, k, v;

                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1);
                    } else {
                        kstr = x;
                        vstr = '';
                    }

                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);

                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v;
                    } else if (isArray(obj[k])) {
                        obj[k].push(v);
                    } else {
                        obj[k] = [obj[k], v];
                    }
                }

                return obj;
            };

            var isArray = Array.isArray || function(xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };

        }, {}],
        150: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            var stringifyPrimitive = function(v) {
                switch (typeof v) {
                    case 'string':
                        return v;

                    case 'boolean':
                        return v ? 'true' : 'false';

                    case 'number':
                        return isFinite(v) ? v : '';

                    default:
                        return '';
                }
            };

            module.exports = function(obj, sep, eq, name) {
                sep = sep || '&';
                eq = eq || '=';
                if (obj === null) {
                    obj = undefined;
                }

                if (typeof obj === 'object') {
                    return map(objectKeys(obj), function(k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (isArray(obj[k])) {
                            return map(obj[k], function(v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v));
                            }).join(sep);
                        } else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                        }
                    }).join(sep);

                }

                if (!name) return '';
                return encodeURIComponent(stringifyPrimitive(name)) + eq +
                    encodeURIComponent(stringifyPrimitive(obj));
            };

            var isArray = Array.isArray || function(xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };

            function map(xs, f) {
                if (xs.map) return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    res.push(f(xs[i], i));
                }
                return res;
            }

            var objectKeys = Object.keys || function(obj) {
                var res = [];
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
                }
                return res;
            };

        }, {}],
        151: [function(require, module, exports) {
            'use strict';

            exports.decode = exports.parse = require('./decode');
            exports.encode = exports.stringify = require('./encode');

        }, { './decode': 149, './encode': 150 }],
        152: [function(require, module, exports) {
            (function(process, global) {
                'use strict';

                function oldBrowser() {
                    throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11');
                }

                var Buffer = require('safe-buffer').Buffer;
                var crypto = global.crypto || global.msCrypto;

                if (crypto && crypto.getRandomValues) {
                    module.exports = randomBytes;
                } else {
                    module.exports = oldBrowser;
                }

                function randomBytes(size, cb) {
                    // phantomjs needs to throw
                    if (size > 65536) throw new Error('requested too many random bytes');
                    // in case browserify  isn't using the Uint8Array version
                    var rawBytes = new global.Uint8Array(size);

                    // This will not work in older browsers.
                    // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
                    if (size > 0) {  // getRandomValues fails on IE if size == 0
                        crypto.getRandomValues(rawBytes);
                    }

                    // XXX: phantomjs doesn't like a buffer being passed here
                    var bytes = Buffer.from(rawBytes.buffer);

                    if (typeof cb === 'function') {
                        return process.nextTick(function() {
                            cb(null, bytes);
                        });
                    }

                    return bytes;
                }

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { '_process': 141, 'safe-buffer': 169 }],
        153: [function(require, module, exports) {
            (function(process, global) {
                'use strict';

                function oldBrowser() {
                    throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
                }

                var safeBuffer = require('safe-buffer');
                var randombytes = require('randombytes');
                var Buffer = safeBuffer.Buffer;
                var kBufferMaxLength = safeBuffer.kMaxLength;
                var crypto = global.crypto || global.msCrypto;
                var kMaxUint32 = Math.pow(2, 32) - 1;

                function assertOffset(offset, length) {
                    if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
                        throw new TypeError('offset must be a number');
                    }

                    if (offset > kMaxUint32 || offset < 0) {
                        throw new TypeError('offset must be a uint32');
                    }

                    if (offset > kBufferMaxLength || offset > length) {
                        throw new RangeError('offset out of range');
                    }
                }

                function assertSize(size, offset, length) {
                    if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
                        throw new TypeError('size must be a number');
                    }

                    if (size > kMaxUint32 || size < 0) {
                        throw new TypeError('size must be a uint32');
                    }

                    if (size + offset > length || size > kBufferMaxLength) {
                        throw new RangeError('buffer too small');
                    }
                }

                if ((crypto && crypto.getRandomValues) || !process.browser) {
                    exports.randomFill = randomFill;
                    exports.randomFillSync = randomFillSync;
                } else {
                    exports.randomFill = oldBrowser;
                    exports.randomFillSync = oldBrowser;
                }

                function randomFill(buf, offset, size, cb) {
                    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
                        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
                    }

                    if (typeof offset === 'function') {
                        cb = offset;
                        offset = 0;
                        size = buf.length;
                    } else if (typeof size === 'function') {
                        cb = size;
                        size = buf.length - offset;
                    } else if (typeof cb !== 'function') {
                        throw new TypeError('"cb" argument must be a function');
                    }
                    assertOffset(offset, buf.length);
                    assertSize(size, offset, buf.length);
                    return actualFill(buf, offset, size, cb);
                }

                function actualFill(buf, offset, size, cb) {
                    if (process.browser) {
                        var ourBuf = buf.buffer;
                        var uint = new Uint8Array(ourBuf, offset, size);
                        crypto.getRandomValues(uint);
                        if (cb) {
                            process.nextTick(function() {
                                cb(null, buf);
                            });
                            return;
                        }
                        return buf;
                    }
                    if (cb) {
                        randombytes(size, function(err, bytes) {
                            if (err) {
                                return cb(err);
                            }
                            bytes.copy(buf, offset);
                            cb(null, buf);
                        });
                        return;
                    }
                    var bytes = randombytes(size);
                    bytes.copy(buf, offset);
                    return buf;
                }

                function randomFillSync(buf, offset, size) {
                    if (typeof offset === 'undefined') {
                        offset = 0;
                    }
                    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
                        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
                    }

                    assertOffset(offset, buf.length);

                    if (size === undefined) size = buf.length - offset;

                    assertSize(size, offset, buf.length);

                    return actualFill(buf, offset, size);
                }

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { '_process': 141, 'randombytes': 152, 'safe-buffer': 169 }],
        154: [function(require, module, exports) {
            module.exports = require('./lib/_stream_duplex.js');

        }, { './lib/_stream_duplex.js': 155 }],
        155: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

            'use strict';

            /*<replacement>*/

            var pna = require('process-nextick-args');
            /*</replacement>*/

            /*<replacement>*/
            var objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) {
                    keys.push(key);
                }
                return keys;
            };
            /*</replacement>*/

            module.exports = Duplex;

            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            var Readable = require('./_stream_readable');
            var Writable = require('./_stream_writable');

            util.inherits(Duplex, Readable);

            {
                // avoid scope creep, the keys array can then be collected
                var keys = objectKeys(Writable.prototype);
                for (var v = 0; v < keys.length; v++) {
                    var method = keys[v];
                    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
                }
            }

            function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);

                Readable.call(this, options);
                Writable.call(this, options);

                if (options && options.readable === false) this.readable = false;

                if (options && options.writable === false) this.writable = false;

                this.allowHalfOpen = true;
                if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

                this.once('end', onend);
            }

            Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function() {
                    return this._writableState.highWaterMark;
                }
            });

// the no-half-open enforcer
            function onend() {
                // if we allow half-open state, or if the writable side ended,
                // then we're ok.
                if (this.allowHalfOpen || this._writableState.ended) return;

                // no more data can be written.
                // But allow more writes to happen in this tick.
                pna.nextTick(onEndNT, this);
            }

            function onEndNT(self) {
                self.end();
            }

            Object.defineProperty(Duplex.prototype, 'destroyed', {
                get: function() {
                    if (this._readableState === undefined || this._writableState === undefined) {
                        return false;
                    }
                    return this._readableState.destroyed && this._writableState.destroyed;
                },
                set: function(value) {
                    // we ignore the value if the stream
                    // has not been initialized yet
                    if (this._readableState === undefined || this._writableState === undefined) {
                        return;
                    }

                    // backward compatibility, the user is explicitly
                    // managing destroyed
                    this._readableState.destroyed = value;
                    this._writableState.destroyed = value;
                }
            });

            Duplex.prototype._destroy = function(err, cb) {
                this.push(null);
                this.end();

                pna.nextTick(cb, err);
            };
        }, {
            './_stream_readable': 157,
            './_stream_writable': 159,
            'core-util-is': 62,
            'inherits': 116,
            'process-nextick-args': 140
        }],
        156: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

            'use strict';

            module.exports = PassThrough;

            var Transform = require('./_stream_transform');

            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            util.inherits(PassThrough, Transform);

            function PassThrough(options) {
                if (!(this instanceof PassThrough)) return new PassThrough(options);

                Transform.call(this, options);
            }

            PassThrough.prototype._transform = function(chunk, encoding, cb) {
                cb(null, chunk);
            };
        }, { './_stream_transform': 158, 'core-util-is': 62, 'inherits': 116 }],
        157: [function(require, module, exports) {
            (function(process, global) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

                'use strict';

                /*<replacement>*/

                var pna = require('process-nextick-args');
                /*</replacement>*/

                module.exports = Readable;

                /*<replacement>*/
                var isArray = require('isarray');
                /*</replacement>*/

                /*<replacement>*/
                var Duplex;
                /*</replacement>*/

                Readable.ReadableState = ReadableState;

                /*<replacement>*/
                var EE = require('events').EventEmitter;

                var EElistenerCount = function(emitter, type) {
                    return emitter.listeners(type).length;
                };
                /*</replacement>*/

                /*<replacement>*/
                var Stream = require('./internal/streams/stream');
                /*</replacement>*/

                /*<replacement>*/

                var Buffer = require('safe-buffer').Buffer;
                var OurUint8Array = global.Uint8Array || function() {
                };

                function _uint8ArrayToBuffer(chunk) {
                    return Buffer.from(chunk);
                }

                function _isUint8Array(obj) {
                    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }

                /*</replacement>*/

                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/

                /*<replacement>*/
                var debugUtil = require('util');
                var debug = void 0;
                if (debugUtil && debugUtil.debuglog) {
                    debug = debugUtil.debuglog('stream');
                } else {
                    debug = function() {
                    };
                }
                /*</replacement>*/

                var BufferList = require('./internal/streams/BufferList');
                var destroyImpl = require('./internal/streams/destroy');
                var StringDecoder;

                util.inherits(Readable, Stream);

                var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

                function prependListener(emitter, event, fn) {
                    // Sadly this is not cacheable as some libraries bundle their own
                    // event emitter implementation with them.
                    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

                    // This is a hack to make sure that our error handler is attached before any
                    // userland ones.  NEVER DO THIS. This is here only because this code needs
                    // to continue to work with older versions of Node.js that do not include
                    // the prependListener() method. The goal is to eventually remove this hack.
                    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]];
                }

                function ReadableState(options, stream) {
                    Duplex = Duplex || require('./_stream_duplex');

                    options = options || {};

                    // Duplex streams are both readable and writable, but share
                    // the same options object.
                    // However, some cases require setting options to different
                    // values for the readable and the writable sides of the duplex stream.
                    // These options can be provided separately as readableXXX and writableXXX.
                    var isDuplex = stream instanceof Duplex;

                    // object stream flag. Used to make read(n) ignore n and to
                    // make all the buffer merging and length checks go away
                    this.objectMode = !!options.objectMode;

                    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

                    // the point at which it stops calling _read() to fill the buffer
                    // Note: 0 is a valid value, means "don't call _read preemptively ever"
                    var hwm = options.highWaterMark;
                    var readableHwm = options.readableHighWaterMark;
                    var defaultHwm = this.objectMode ? 16 : 16 * 1024;

                    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm;

                    // cast to ints.
                    this.highWaterMark = Math.floor(this.highWaterMark);

                    // A linked list is used to store data chunks instead of an array because the
                    // linked list can remove elements from the beginning faster than
                    // array.shift()
                    this.buffer = new BufferList();
                    this.length = 0;
                    this.pipes = null;
                    this.pipesCount = 0;
                    this.flowing = null;
                    this.ended = false;
                    this.endEmitted = false;
                    this.reading = false;

                    // a flag to be able to tell if the event 'readable'/'data' is emitted
                    // immediately, or on a later tick.  We set this to true at first, because
                    // any actions that shouldn't happen until "later" should generally also
                    // not happen before the first read call.
                    this.sync = true;

                    // whenever we return null, then we set a flag to say
                    // that we're awaiting a 'readable' event emission.
                    this.needReadable = false;
                    this.emittedReadable = false;
                    this.readableListening = false;
                    this.resumeScheduled = false;

                    // has it been destroyed
                    this.destroyed = false;

                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';

                    // the number of writers that are awaiting a drain event in .pipe()s
                    this.awaitDrain = 0;

                    // if true, a maybeReadMore has been scheduled
                    this.readingMore = false;

                    this.decoder = null;
                    this.encoding = null;
                    if (options.encoding) {
                        if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
                        this.decoder = new StringDecoder(options.encoding);
                        this.encoding = options.encoding;
                    }
                }

                function Readable(options) {
                    Duplex = Duplex || require('./_stream_duplex');

                    if (!(this instanceof Readable)) return new Readable(options);

                    this._readableState = new ReadableState(options, this);

                    // legacy
                    this.readable = true;

                    if (options) {
                        if (typeof options.read === 'function') this._read = options.read;

                        if (typeof options.destroy === 'function') this._destroy = options.destroy;
                    }

                    Stream.call(this);
                }

                Object.defineProperty(Readable.prototype, 'destroyed', {
                    get: function() {
                        if (this._readableState === undefined) {
                            return false;
                        }
                        return this._readableState.destroyed;
                    },
                    set: function(value) {
                        // we ignore the value if the stream
                        // has not been initialized yet
                        if (!this._readableState) {
                            return;
                        }

                        // backward compatibility, the user is explicitly
                        // managing destroyed
                        this._readableState.destroyed = value;
                    }
                });

                Readable.prototype.destroy = destroyImpl.destroy;
                Readable.prototype._undestroy = destroyImpl.undestroy;
                Readable.prototype._destroy = function(err, cb) {
                    this.push(null);
                    cb(err);
                };

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
                Readable.prototype.push = function(chunk, encoding) {
                    var state = this._readableState;
                    var skipChunkCheck;

                    if (!state.objectMode) {
                        if (typeof chunk === 'string') {
                            encoding = encoding || state.defaultEncoding;
                            if (encoding !== state.encoding) {
                                chunk = Buffer.from(chunk, encoding);
                                encoding = '';
                            }
                            skipChunkCheck = true;
                        }
                    } else {
                        skipChunkCheck = true;
                    }

                    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
                };

// Unshift should *always* be something directly out of read()
                Readable.prototype.unshift = function(chunk) {
                    return readableAddChunk(this, chunk, null, true, false);
                };

                function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                    var state = stream._readableState;
                    if (chunk === null) {
                        state.reading = false;
                        onEofChunk(stream, state);
                    } else {
                        var er;
                        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                        if (er) {
                            stream.emit('error', er);
                        } else if (state.objectMode || chunk && chunk.length > 0) {
                            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                                chunk = _uint8ArrayToBuffer(chunk);
                            }

                            if (addToFront) {
                                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event')); else addChunk(stream, state, chunk, true);
                            } else if (state.ended) {
                                stream.emit('error', new Error('stream.push() after EOF'));
                            } else {
                                state.reading = false;
                                if (state.decoder && !encoding) {
                                    chunk = state.decoder.write(chunk);
                                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                                } else {
                                    addChunk(stream, state, chunk, false);
                                }
                            }
                        } else if (!addToFront) {
                            state.reading = false;
                        }
                    }

                    return needMoreData(state);
                }

                function addChunk(stream, state, chunk, addToFront) {
                    if (state.flowing && state.length === 0 && !state.sync) {
                        stream.emit('data', chunk);
                        stream.read(0);
                    } else {
                        // update the buffer info.
                        state.length += state.objectMode ? 1 : chunk.length;
                        if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);

                        if (state.needReadable) emitReadable(stream);
                    }
                    maybeReadMore(stream, state);
                }

                function chunkInvalid(state, chunk) {
                    var er;
                    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
                        er = new TypeError('Invalid non-string/buffer chunk');
                    }
                    return er;
                }

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
                function needMoreData(state) {
                    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
                }

                Readable.prototype.isPaused = function() {
                    return this._readableState.flowing === false;
                };

// backwards compatibility.
                Readable.prototype.setEncoding = function(enc) {
                    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
                    this._readableState.decoder = new StringDecoder(enc);
                    this._readableState.encoding = enc;
                    return this;
                };

// Don't raise the hwm > 8MB
                var MAX_HWM = 0x800000;

                function computeNewHighWaterMark(n) {
                    if (n >= MAX_HWM) {
                        n = MAX_HWM;
                    } else {
                        // Get the next highest power of 2 to prevent increasing hwm excessively in
                        // tiny amounts
                        n--;
                        n |= n >>> 1;
                        n |= n >>> 2;
                        n |= n >>> 4;
                        n |= n >>> 8;
                        n |= n >>> 16;
                        n++;
                    }
                    return n;
                }

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
                function howMuchToRead(n, state) {
                    if (n <= 0 || state.length === 0 && state.ended) return 0;
                    if (state.objectMode) return 1;
                    if (n !== n) {
                        // Only flow one buffer at a time
                        if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
                    }
                    // If we're asking for more than the current hwm, then raise the hwm.
                    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
                    if (n <= state.length) return n;
                    // Don't have enough
                    if (!state.ended) {
                        state.needReadable = true;
                        return 0;
                    }
                    return state.length;
                }

// you can override either this method, or the async _read(n) below.
                Readable.prototype.read = function(n) {
                    debug('read', n);
                    n = parseInt(n, 10);
                    var state = this._readableState;
                    var nOrig = n;

                    if (n !== 0) state.emittedReadable = false;

                    // if we're doing read(0) to trigger a readable event, but we
                    // already have a bunch of data in the buffer, then just trigger
                    // the 'readable' event and move on.
                    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                        debug('read: emitReadable', state.length, state.ended);
                        if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
                        return null;
                    }

                    n = howMuchToRead(n, state);

                    // if we've ended, and we're now clear, then finish it up.
                    if (n === 0 && state.ended) {
                        if (state.length === 0) endReadable(this);
                        return null;
                    }

                    // All the actual chunk generation logic needs to be
                    // *below* the call to _read.  The reason is that in certain
                    // synthetic stream cases, such as passthrough streams, _read
                    // may be a completely synchronous operation which may change
                    // the state of the read buffer, providing enough data when
                    // before there was *not* enough.
                    //
                    // So, the steps are:
                    // 1. Figure out what the state of things will be after we do
                    // a read from the buffer.
                    //
                    // 2. If that resulting state will trigger a _read, then call _read.
                    // Note that this may be asynchronous, or synchronous.  Yes, it is
                    // deeply ugly to write APIs this way, but that still doesn't mean
                    // that the Readable class should behave improperly, as streams are
                    // designed to be sync/async agnostic.
                    // Take note if the _read call is sync or async (ie, if the read call
                    // has returned yet), so that we know whether or not it's safe to emit
                    // 'readable' etc.
                    //
                    // 3. Actually pull the requested chunks out of the buffer and return.

                    // if we need a readable event, then we need to do some reading.
                    var doRead = state.needReadable;
                    debug('need readable', doRead);

                    // if we currently have less than the highWaterMark, then also read some
                    if (state.length === 0 || state.length - n < state.highWaterMark) {
                        doRead = true;
                        debug('length less than watermark', doRead);
                    }

                    // however, if we've ended, then there's no point, and if we're already
                    // reading, then it's unnecessary.
                    if (state.ended || state.reading) {
                        doRead = false;
                        debug('reading or ended', doRead);
                    } else if (doRead) {
                        debug('do read');
                        state.reading = true;
                        state.sync = true;
                        // if the length is currently zero, then we *need* a readable event.
                        if (state.length === 0) state.needReadable = true;
                        // call internal read method
                        this._read(state.highWaterMark);
                        state.sync = false;
                        // If _read pushed data synchronously, then `reading` will be false,
                        // and we need to re-evaluate how much data we can return to the user.
                        if (!state.reading) n = howMuchToRead(nOrig, state);
                    }

                    var ret;
                    if (n > 0) ret = fromList(n, state); else ret = null;

                    if (ret === null) {
                        state.needReadable = true;
                        n = 0;
                    } else {
                        state.length -= n;
                    }

                    if (state.length === 0) {
                        // If we have nothing in the buffer, then we want to know
                        // as soon as we *do* get something into the buffer.
                        if (!state.ended) state.needReadable = true;

                        // If we tried to read() past the EOF, then emit end on the next tick.
                        if (nOrig !== n && state.ended) endReadable(this);
                    }

                    if (ret !== null) this.emit('data', ret);

                    return ret;
                };

                function onEofChunk(stream, state) {
                    if (state.ended) return;
                    if (state.decoder) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length) {
                            state.buffer.push(chunk);
                            state.length += state.objectMode ? 1 : chunk.length;
                        }
                    }
                    state.ended = true;

                    // emit 'readable' now to make sure it gets picked up.
                    emitReadable(stream);
                }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
                function emitReadable(stream) {
                    var state = stream._readableState;
                    state.needReadable = false;
                    if (!state.emittedReadable) {
                        debug('emitReadable', state.flowing);
                        state.emittedReadable = true;
                        if (state.sync) pna.nextTick(emitReadable_, stream); else emitReadable_(stream);
                    }
                }

                function emitReadable_(stream) {
                    debug('emit readable');
                    stream.emit('readable');
                    flow(stream);
                }

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
                function maybeReadMore(stream, state) {
                    if (!state.readingMore) {
                        state.readingMore = true;
                        pna.nextTick(maybeReadMore_, stream, state);
                    }
                }

                function maybeReadMore_(stream, state) {
                    var len = state.length;
                    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                        debug('maybeReadMore read 0');
                        stream.read(0);
                        if (len === state.length)
                            // didn't get any data, stop spinning.
                            break; else len = state.length;
                    }
                    state.readingMore = false;
                }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
                Readable.prototype._read = function(n) {
                    this.emit('error', new Error('_read() is not implemented'));
                };

                Readable.prototype.pipe = function(dest, pipeOpts) {
                    var src = this;
                    var state = this._readableState;

                    switch (state.pipesCount) {
                        case 0:
                            state.pipes = dest;
                            break;
                        case 1:
                            state.pipes = [state.pipes, dest];
                            break;
                        default:
                            state.pipes.push(dest);
                            break;
                    }
                    state.pipesCount += 1;
                    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

                    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

                    var endFn = doEnd ? onend : unpipe;
                    if (state.endEmitted) pna.nextTick(endFn); else src.once('end', endFn);

                    dest.on('unpipe', onunpipe);

                    function onunpipe(readable, unpipeInfo) {
                        debug('onunpipe');
                        if (readable === src) {
                            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                                unpipeInfo.hasUnpiped = true;
                                cleanup();
                            }
                        }
                    }

                    function onend() {
                        debug('onend');
                        dest.end();
                    }

                    // when the dest drains, it reduces the awaitDrain counter
                    // on the source.  This would be more elegant with a .once()
                    // handler in flow(), but adding and removing repeatedly is
                    // too slow.
                    var ondrain = pipeOnDrain(src);
                    dest.on('drain', ondrain);

                    var cleanedUp = false;

                    function cleanup() {
                        debug('cleanup');
                        // cleanup event handlers once the pipe is broken
                        dest.removeListener('close', onclose);
                        dest.removeListener('finish', onfinish);
                        dest.removeListener('drain', ondrain);
                        dest.removeListener('error', onerror);
                        dest.removeListener('unpipe', onunpipe);
                        src.removeListener('end', onend);
                        src.removeListener('end', unpipe);
                        src.removeListener('data', ondata);

                        cleanedUp = true;

                        // if the reader is waiting for a drain event from this
                        // specific writer, then it would cause it to never start
                        // flowing again.
                        // So, if this is awaiting a drain, then we just call it now.
                        // If we don't know, then assume that we are waiting for one.
                        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                    }

                    // If the user pushes more data while we're writing to dest then we'll end up
                    // in ondata again. However, we only want to increase awaitDrain once because
                    // dest will only emit one 'drain' event for the multiple writes.
                    // => Introduce a guard on increasing awaitDrain.
                    var increasedAwaitDrain = false;
                    src.on('data', ondata);

                    function ondata(chunk) {
                        debug('ondata');
                        increasedAwaitDrain = false;
                        var ret = dest.write(chunk);
                        if (false === ret && !increasedAwaitDrain) {
                            // If the user unpiped during `dest.write()`, it is possible
                            // to get stuck in a permanently paused state if that write
                            // also returned false.
                            // => Check whether `dest` is still a piping destination.
                            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                                debug('false write response, pause', src._readableState.awaitDrain);
                                src._readableState.awaitDrain++;
                                increasedAwaitDrain = true;
                            }
                            src.pause();
                        }
                    }

                    // if the dest has an error, then stop piping into it.
                    // however, don't suppress the throwing behavior for this.
                    function onerror(er) {
                        debug('onerror', er);
                        unpipe();
                        dest.removeListener('error', onerror);
                        if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
                    }

                    // Make sure our error handler is attached before userland ones.
                    prependListener(dest, 'error', onerror);

                    // Both close and finish should trigger unpipe, but only once.
                    function onclose() {
                        dest.removeListener('finish', onfinish);
                        unpipe();
                    }

                    dest.once('close', onclose);

                    function onfinish() {
                        debug('onfinish');
                        dest.removeListener('close', onclose);
                        unpipe();
                    }

                    dest.once('finish', onfinish);

                    function unpipe() {
                        debug('unpipe');
                        src.unpipe(dest);
                    }

                    // tell the dest that it's being piped to
                    dest.emit('pipe', src);

                    // start the flow if it hasn't been started already.
                    if (!state.flowing) {
                        debug('pipe resume');
                        src.resume();
                    }

                    return dest;
                };

                function pipeOnDrain(src) {
                    return function() {
                        var state = src._readableState;
                        debug('pipeOnDrain', state.awaitDrain);
                        if (state.awaitDrain) state.awaitDrain--;
                        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                            state.flowing = true;
                            flow(src);
                        }
                    };
                }

                Readable.prototype.unpipe = function(dest) {
                    var state = this._readableState;
                    var unpipeInfo = { hasUnpiped: false };

                    // if we're not piping anywhere, then do nothing.
                    if (state.pipesCount === 0) return this;

                    // just one destination.  most common case.
                    if (state.pipesCount === 1) {
                        // passed in one, but it's not the right one.
                        if (dest && dest !== state.pipes) return this;

                        if (!dest) dest = state.pipes;

                        // got a match.
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;
                        if (dest) dest.emit('unpipe', this, unpipeInfo);
                        return this;
                    }

                    // slow case. multiple pipe destinations.

                    if (!dest) {
                        // remove all.
                        var dests = state.pipes;
                        var len = state.pipesCount;
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;

                        for (var i = 0; i < len; i++) {
                            dests[i].emit('unpipe', this, unpipeInfo);
                        }
                        return this;
                    }

                    // try to find the right one.
                    var index = indexOf(state.pipes, dest);
                    if (index === -1) return this;

                    state.pipes.splice(index, 1);
                    state.pipesCount -= 1;
                    if (state.pipesCount === 1) state.pipes = state.pipes[0];

                    dest.emit('unpipe', this, unpipeInfo);

                    return this;
                };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
                Readable.prototype.on = function(ev, fn) {
                    var res = Stream.prototype.on.call(this, ev, fn);

                    if (ev === 'data') {
                        // Start flowing on next tick if stream isn't explicitly paused
                        if (this._readableState.flowing !== false) this.resume();
                    } else if (ev === 'readable') {
                        var state = this._readableState;
                        if (!state.endEmitted && !state.readableListening) {
                            state.readableListening = state.needReadable = true;
                            state.emittedReadable = false;
                            if (!state.reading) {
                                pna.nextTick(nReadingNextTick, this);
                            } else if (state.length) {
                                emitReadable(this);
                            }
                        }
                    }

                    return res;
                };
                Readable.prototype.addListener = Readable.prototype.on;

                function nReadingNextTick(self) {
                    debug('readable nexttick read 0');
                    self.read(0);
                }

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
                Readable.prototype.resume = function() {
                    var state = this._readableState;
                    if (!state.flowing) {
                        debug('resume');
                        state.flowing = true;
                        resume(this, state);
                    }
                    return this;
                };

                function resume(stream, state) {
                    if (!state.resumeScheduled) {
                        state.resumeScheduled = true;
                        pna.nextTick(resume_, stream, state);
                    }
                }

                function resume_(stream, state) {
                    if (!state.reading) {
                        debug('resume read 0');
                        stream.read(0);
                    }

                    state.resumeScheduled = false;
                    state.awaitDrain = 0;
                    stream.emit('resume');
                    flow(stream);
                    if (state.flowing && !state.reading) stream.read(0);
                }

                Readable.prototype.pause = function() {
                    debug('call pause flowing=%j', this._readableState.flowing);
                    if (false !== this._readableState.flowing) {
                        debug('pause');
                        this._readableState.flowing = false;
                        this.emit('pause');
                    }
                    return this;
                };

                function flow(stream) {
                    var state = stream._readableState;
                    debug('flow', state.flowing);
                    while (state.flowing && stream.read() !== null) {
                    }
                }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
                Readable.prototype.wrap = function(stream) {
                    var _this = this;

                    var state = this._readableState;
                    var paused = false;

                    stream.on('end', function() {
                        debug('wrapped end');
                        if (state.decoder && !state.ended) {
                            var chunk = state.decoder.end();
                            if (chunk && chunk.length) _this.push(chunk);
                        }

                        _this.push(null);
                    });

                    stream.on('data', function(chunk) {
                        debug('wrapped data');
                        if (state.decoder) chunk = state.decoder.write(chunk);

                        // don't skip over falsy values in objectMode
                        if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;

                        var ret = _this.push(chunk);
                        if (!ret) {
                            paused = true;
                            stream.pause();
                        }
                    });

                    // proxy all the other methods.
                    // important when wrapping filters and duplexes.
                    for (var i in stream) {
                        if (this[i] === undefined && typeof stream[i] === 'function') {
                            this[i] = function(method) {
                                return function() {
                                    return stream[method].apply(stream, arguments);
                                };
                            }(i);
                        }
                    }

                    // proxy certain important events.
                    for (var n = 0; n < kProxyEvents.length; n++) {
                        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                    }

                    // when we try to consume some more bytes, simply unpause the
                    // underlying stream.
                    this._read = function(n) {
                        debug('wrapped _read', n);
                        if (paused) {
                            paused = false;
                            stream.resume();
                        }
                    };

                    return this;
                };

                Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
                    // making it explicit this property is not enumerable
                    // because otherwise some prototype manipulation in
                    // userland will fail
                    enumerable: false,
                    get: function() {
                        return this._readableState.highWaterMark;
                    }
                });

// exposed for testing purposes only.
                Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
                function fromList(n, state) {
                    // nothing buffered
                    if (state.length === 0) return null;

                    var ret;
                    if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
                        // read it all, truncate the list
                        if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
                        state.buffer.clear();
                    } else {
                        // read part of list
                        ret = fromListPartial(n, state.buffer, state.decoder);
                    }

                    return ret;
                }

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
                function fromListPartial(n, list, hasStrings) {
                    var ret;
                    if (n < list.head.data.length) {
                        // slice is the same for buffers and strings
                        ret = list.head.data.slice(0, n);
                        list.head.data = list.head.data.slice(n);
                    } else if (n === list.head.data.length) {
                        // first chunk is a perfect match
                        ret = list.shift();
                    } else {
                        // result spans more than one buffer
                        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
                    }
                    return ret;
                }

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
                function copyFromBufferString(n, list) {
                    var p = list.head;
                    var c = 1;
                    var ret = p.data;
                    n -= ret.length;
                    while (p = p.next) {
                        var str = p.data;
                        var nb = n > str.length ? str.length : n;
                        if (nb === str.length) ret += str; else ret += str.slice(0, n);
                        n -= nb;
                        if (n === 0) {
                            if (nb === str.length) {
                                ++c;
                                if (p.next) list.head = p.next; else list.head = list.tail = null;
                            } else {
                                list.head = p;
                                p.dialogData = str.slice(nb);
                            }
                            break;
                        }
                        ++c;
                    }
                    list.length -= c;
                    return ret;
                }

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
                function copyFromBuffer(n, list) {
                    var ret = Buffer.allocUnsafe(n);
                    var p = list.head;
                    var c = 1;
                    p.data.copy(ret);
                    n -= p.data.length;
                    while (p = p.next) {
                        var buf = p.data;
                        var nb = n > buf.length ? buf.length : n;
                        buf.copy(ret, ret.length - n, 0, nb);
                        n -= nb;
                        if (n === 0) {
                            if (nb === buf.length) {
                                ++c;
                                if (p.next) list.head = p.next; else list.head = list.tail = null;
                            } else {
                                list.head = p;
                                p.dialogData = buf.slice(nb);
                            }
                            break;
                        }
                        ++c;
                    }
                    list.length -= c;
                    return ret;
                }

                function endReadable(stream) {
                    var state = stream._readableState;

                    // If we get here before consuming all the bytes, then that is a
                    // bug in node.  Should never happen.
                    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

                    if (!state.endEmitted) {
                        state.ended = true;
                        pna.nextTick(endReadableNT, state, stream);
                    }
                }

                function endReadableNT(state, stream) {
                    // Check that we didn't get one last unshift.
                    if (!state.endEmitted && state.length === 0) {
                        state.endEmitted = true;
                        stream.readable = false;
                        stream.emit('end');
                    }
                }

                function indexOf(xs, x) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        if (xs[i] === x) return i;
                    }
                    return -1;
                }
            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, {
            './_stream_duplex': 155,
            './internal/streams/BufferList': 160,
            './internal/streams/destroy': 161,
            './internal/streams/stream': 162,
            '_process': 141,
            'core-util-is': 62,
            'events': 97,
            'inherits': 116,
            'isarray': 118,
            'process-nextick-args': 140,
            'safe-buffer': 169,
            'string_decoder/': 163,
            'util': 29
        }],
        158: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

            'use strict';

            module.exports = Transform;

            var Duplex = require('./_stream_duplex');

            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            util.inherits(Transform, Duplex);

            function afterTransform(er, data) {
                var ts = this._transformState;
                ts.transforming = false;

                var cb = ts.writecb;

                if (!cb) {
                    return this.emit('error', new Error('write callback called multiple times'));
                }

                ts.writechunk = null;
                ts.writecb = null;

                if (data != null) // single equals check for both `null` and `undefined`
                    this.push(data);

                cb(er);

                var rs = this._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                    this._read(rs.highWaterMark);
                }
            }

            function Transform(options) {
                if (!(this instanceof Transform)) return new Transform(options);

                Duplex.call(this, options);

                this._transformState = {
                    afterTransform: afterTransform.bind(this),
                    needTransform: false,
                    transforming: false,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                };

                // start out asking for a readable event once data is transformed.
                this._readableState.needReadable = true;

                // we have implemented the _read method, and done the other things
                // that Readable wants before the first _read call, so unset the
                // sync guard flag.
                this._readableState.sync = false;

                if (options) {
                    if (typeof options.transform === 'function') this._transform = options.transform;

                    if (typeof options.flush === 'function') this._flush = options.flush;
                }

                // When the writable side finishes, then flush out anything remaining.
                this.on('prefinish', prefinish);
            }

            function prefinish() {
                var _this = this;

                if (typeof this._flush === 'function') {
                    this._flush(function(er, data) {
                        done(_this, er, data);
                    });
                } else {
                    done(this, null, null);
                }
            }

            Transform.prototype.push = function(chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
            };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
            Transform.prototype._transform = function(chunk, encoding, cb) {
                throw new Error('_transform() is not implemented');
            };

            Transform.prototype._write = function(chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
                }
            };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
            Transform.prototype._read = function(n) {
                var ts = this._transformState;

                if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                    // mark that we need a transform, so that any data that comes in
                    // will get processed, now that we've asked for it.
                    ts.needTransform = true;
                }
            };

            Transform.prototype._destroy = function(err, cb) {
                var _this2 = this;

                Duplex.prototype._destroy.call(this, err, function(err2) {
                    cb(err2);
                    _this2.emit('close');
                });
            };

            function done(stream, er, data) {
                if (er) return stream.emit('error', er);

                if (data != null) // single equals check for both `null` and `undefined`
                    stream.push(data);

                // if there's nothing in the write buffer, then that means
                // that nothing more will ever be provided
                if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

                if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

                return stream.push(null);
            }
        }, { './_stream_duplex': 155, 'core-util-is': 62, 'inherits': 116 }],
        159: [function(require, module, exports) {
            (function(process, global, setImmediate) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

                'use strict';

                /*<replacement>*/

                var pna = require('process-nextick-args');
                /*</replacement>*/

                module.exports = Writable;

                /* <replacement> */
                function WriteReq(chunk, encoding, cb) {
                    this.chunk = chunk;
                    this.encoding = encoding;
                    this.callback = cb;
                    this.next = null;
                }

// It seems a linked list but it is not
// there will be only 2 of these for each stream
                function CorkedRequest(state) {
                    var _this = this;

                    this.next = null;
                    this.entry = null;
                    this.finish = function() {
                        onCorkedFinish(_this, state);
                    };
                }

                /* </replacement> */

                /*<replacement>*/
                var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
                /*</replacement>*/

                /*<replacement>*/
                var Duplex;
                /*</replacement>*/

                Writable.WritableState = WritableState;

                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/

                /*<replacement>*/
                var internalUtil = {
                    deprecate: require('util-deprecate')
                };
                /*</replacement>*/

                /*<replacement>*/
                var Stream = require('./internal/streams/stream');
                /*</replacement>*/

                /*<replacement>*/

                var Buffer = require('safe-buffer').Buffer;
                var OurUint8Array = global.Uint8Array || function() {
                };

                function _uint8ArrayToBuffer(chunk) {
                    return Buffer.from(chunk);
                }

                function _isUint8Array(obj) {
                    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }

                /*</replacement>*/

                var destroyImpl = require('./internal/streams/destroy');

                util.inherits(Writable, Stream);

                function nop() {
                }

                function WritableState(options, stream) {
                    Duplex = Duplex || require('./_stream_duplex');

                    options = options || {};

                    // Duplex streams are both readable and writable, but share
                    // the same options object.
                    // However, some cases require setting options to different
                    // values for the readable and the writable sides of the duplex stream.
                    // These options can be provided separately as readableXXX and writableXXX.
                    var isDuplex = stream instanceof Duplex;

                    // object stream flag to indicate whether or not this stream
                    // contains buffers or objects.
                    this.objectMode = !!options.objectMode;

                    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

                    // the point at which write() starts returning false
                    // Note: 0 is a valid value, means that we always return false if
                    // the entire buffer is not flushed immediately on write()
                    var hwm = options.highWaterMark;
                    var writableHwm = options.writableHighWaterMark;
                    var defaultHwm = this.objectMode ? 16 : 16 * 1024;

                    if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm;

                    // cast to ints.
                    this.highWaterMark = Math.floor(this.highWaterMark);

                    // if _final has been called
                    this.finalCalled = false;

                    // drain event flag.
                    this.needDrain = false;
                    // at the start of calling end()
                    this.ending = false;
                    // when end() has been called, and returned
                    this.ended = false;
                    // when 'finish' is emitted
                    this.finished = false;

                    // has it been destroyed
                    this.destroyed = false;

                    // should we decode strings into buffers before passing to _write?
                    // this is here so that some node-core streams can optimize string
                    // handling at a lower level.
                    var noDecode = options.decodeStrings === false;
                    this.decodeStrings = !noDecode;

                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';

                    // not an actual buffer we keep track of, but a measurement
                    // of how much we're waiting to get pushed to some underlying
                    // socket or file.
                    this.length = 0;

                    // a flag to see when we're in the middle of a write.
                    this.writing = false;

                    // when true all writes will be buffered until .uncork() call
                    this.corked = 0;

                    // a flag to be able to tell if the onwrite cb is called immediately,
                    // or on a later tick.  We set this to true at first, because any
                    // actions that shouldn't happen until "later" should generally also
                    // not happen before the first write call.
                    this.sync = true;

                    // a flag to know if we're processing previously buffered items, which
                    // may call the _write() callback in the same tick, so that we don't
                    // end up in an overlapped onwrite situation.
                    this.bufferProcessing = false;

                    // the callback that's passed to _write(chunk,cb)
                    this.onwrite = function(er) {
                        onwrite(stream, er);
                    };

                    // the callback that the user supplies to write(chunk,encoding,cb)
                    this.writecb = null;

                    // the amount that is being written when _write is called.
                    this.writelen = 0;

                    this.bufferedRequest = null;
                    this.lastBufferedRequest = null;

                    // number of pending user-supplied write callbacks
                    // this must be 0 before 'finish' can be emitted
                    this.pendingcb = 0;

                    // emit prefinish if the only thing we're waiting for is _write cbs
                    // This is relevant for synchronous Transform streams
                    this.prefinished = false;

                    // True if the error was already emitted and should not be thrown again
                    this.errorEmitted = false;

                    // count buffered requests
                    this.bufferedRequestCount = 0;

                    // allocate the first CorkedRequest, there is always
                    // one allocated and free to use, and we maintain at most two
                    this.corkedRequestsFree = new CorkedRequest(this);
                }

                WritableState.prototype.getBuffer = function getBuffer() {
                    var current = this.bufferedRequest;
                    var out = [];
                    while (current) {
                        out.push(current);
                        current = current.next;
                    }
                    return out;
                };

                (function() {
                    try {
                        Object.defineProperty(WritableState.prototype, 'buffer', {
                            get: internalUtil.deprecate(function() {
                                return this.getBuffer();
                            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
                        });
                    } catch (_) {
                    }
                })();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
                var realHasInstance;
                if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
                    realHasInstance = Function.prototype[Symbol.hasInstance];
                    Object.defineProperty(Writable, Symbol.hasInstance, {
                        value: function(object) {
                            if (realHasInstance.call(this, object)) return true;
                            if (this !== Writable) return false;

                            return object && object._writableState instanceof WritableState;
                        }
                    });
                } else {
                    realHasInstance = function(object) {
                        return object instanceof this;
                    };
                }

                function Writable(options) {
                    Duplex = Duplex || require('./_stream_duplex');

                    // Writable ctor is applied to Duplexes, too.
                    // `realHasInstance` is necessary because using plain `instanceof`
                    // would return false, as no `_writableState` property is attached.

                    // Trying to use the custom `instanceof` for Writable here will also break the
                    // Node.js LazyTransform implementation, which has a non-trivial getter for
                    // `_writableState` that would lead to infinite recursion.
                    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                        return new Writable(options);
                    }

                    this._writableState = new WritableState(options, this);

                    // legacy.
                    this.writable = true;

                    if (options) {
                        if (typeof options.write === 'function') this._write = options.write;

                        if (typeof options.writev === 'function') this._writev = options.writev;

                        if (typeof options.destroy === 'function') this._destroy = options.destroy;

                        if (typeof options.final === 'function') this._final = options.final;
                    }

                    Stream.call(this);
                }

// Otherwise people can pipe Writable streams, which is just wrong.
                Writable.prototype.pipe = function() {
                    this.emit('error', new Error('Cannot pipe, not readable'));
                };

                function writeAfterEnd(stream, cb) {
                    var er = new Error('write after end');
                    // TODO: defer error events consistently everywhere, not just the cb
                    stream.emit('error', er);
                    pna.nextTick(cb, er);
                }

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
                function validChunk(stream, state, chunk, cb) {
                    var valid = true;
                    var er = false;

                    if (chunk === null) {
                        er = new TypeError('May not write null values to stream');
                    } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
                        er = new TypeError('Invalid non-string/buffer chunk');
                    }
                    if (er) {
                        stream.emit('error', er);
                        pna.nextTick(cb, er);
                        valid = false;
                    }
                    return valid;
                }

                Writable.prototype.write = function(chunk, encoding, cb) {
                    var state = this._writableState;
                    var ret = false;
                    var isBuf = !state.objectMode && _isUint8Array(chunk);

                    if (isBuf && !Buffer.isBuffer(chunk)) {
                        chunk = _uint8ArrayToBuffer(chunk);
                    }

                    if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = null;
                    }

                    if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding;

                    if (typeof cb !== 'function') cb = nop;

                    if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
                        state.pendingcb++;
                        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                    }

                    return ret;
                };

                Writable.prototype.cork = function() {
                    var state = this._writableState;

                    state.corked++;
                };

                Writable.prototype.uncork = function() {
                    var state = this._writableState;

                    if (state.corked) {
                        state.corked--;

                        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
                    }
                };

                Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                    // node::ParseEncoding() requires lower case.
                    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
                    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
                    this._writableState.defaultEncoding = encoding;
                    return this;
                };

                function decodeChunk(state, chunk, encoding) {
                    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
                        chunk = Buffer.from(chunk, encoding);
                    }
                    return chunk;
                }

                Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
                    // making it explicit this property is not enumerable
                    // because otherwise some prototype manipulation in
                    // userland will fail
                    enumerable: false,
                    get: function() {
                        return this._writableState.highWaterMark;
                    }
                });

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
                function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                    if (!isBuf) {
                        var newChunk = decodeChunk(state, chunk, encoding);
                        if (chunk !== newChunk) {
                            isBuf = true;
                            encoding = 'buffer';
                            chunk = newChunk;
                        }
                    }
                    var len = state.objectMode ? 1 : chunk.length;

                    state.length += len;

                    var ret = state.length < state.highWaterMark;
                    // we must ensure that previous needDrain will not be reset to false.
                    if (!ret) state.needDrain = true;

                    if (state.writing || state.corked) {
                        var last = state.lastBufferedRequest;
                        state.lastBufferedRequest = {
                            chunk: chunk,
                            encoding: encoding,
                            isBuf: isBuf,
                            callback: cb,
                            next: null
                        };
                        if (last) {
                            last.next = state.lastBufferedRequest;
                        } else {
                            state.bufferedRequest = state.lastBufferedRequest;
                        }
                        state.bufferedRequestCount += 1;
                    } else {
                        doWrite(stream, state, false, len, chunk, encoding, cb);
                    }

                    return ret;
                }

                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                    state.writelen = len;
                    state.writecb = cb;
                    state.writing = true;
                    state.sync = true;
                    if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
                    state.sync = false;
                }

                function onwriteError(stream, state, sync, er, cb) {
                    --state.pendingcb;

                    if (sync) {
                        // defer the callback if we are being called synchronously
                        // to avoid piling up things on the stack
                        pna.nextTick(cb, er);
                        // this can emit finish, and it will always happen
                        // after error
                        pna.nextTick(finishMaybe, stream, state);
                        stream._writableState.errorEmitted = true;
                        stream.emit('error', er);
                    } else {
                        // the caller expect this to happen before if
                        // it is async
                        cb(er);
                        stream._writableState.errorEmitted = true;
                        stream.emit('error', er);
                        // this can emit finish, but finish must
                        // always follow error
                        finishMaybe(stream, state);
                    }
                }

                function onwriteStateUpdate(state) {
                    state.writing = false;
                    state.writecb = null;
                    state.length -= state.writelen;
                    state.writelen = 0;
                }

                function onwrite(stream, er) {
                    var state = stream._writableState;
                    var sync = state.sync;
                    var cb = state.writecb;

                    onwriteStateUpdate(state);

                    if (er) onwriteError(stream, state, sync, er, cb); else {
                        // Check if we're actually ready to finish, but don't emit yet
                        var finished = needFinish(state);

                        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                            clearBuffer(stream, state);
                        }

                        if (sync) {
                            /*<replacement>*/
                            asyncWrite(afterWrite, stream, state, finished, cb);
                            /*</replacement>*/
                        } else {
                            afterWrite(stream, state, finished, cb);
                        }
                    }
                }

                function afterWrite(stream, state, finished, cb) {
                    if (!finished) onwriteDrain(stream, state);
                    state.pendingcb--;
                    cb();
                    finishMaybe(stream, state);
                }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
                function onwriteDrain(stream, state) {
                    if (state.length === 0 && state.needDrain) {
                        state.needDrain = false;
                        stream.emit('drain');
                    }
                }

// if there's something in the buffer waiting, then process it
                function clearBuffer(stream, state) {
                    state.bufferProcessing = true;
                    var entry = state.bufferedRequest;

                    if (stream._writev && entry && entry.next) {
                        // Fast case, write everything using _writev()
                        var l = state.bufferedRequestCount;
                        var buffer = new Array(l);
                        var holder = state.corkedRequestsFree;
                        holder.entry = entry;

                        var count = 0;
                        var allBuffers = true;
                        while (entry) {
                            buffer[count] = entry;
                            if (!entry.isBuf) allBuffers = false;
                            entry = entry.next;
                            count += 1;
                        }
                        buffer.allBuffers = allBuffers;

                        doWrite(stream, state, true, state.length, buffer, '', holder.finish);

                        // doWrite is almost always async, defer these to save a bit of time
                        // as the hot path ends with doWrite
                        state.pendingcb++;
                        state.lastBufferedRequest = null;
                        if (holder.next) {
                            state.corkedRequestsFree = holder.next;
                            holder.next = null;
                        } else {
                            state.corkedRequestsFree = new CorkedRequest(state);
                        }
                        state.bufferedRequestCount = 0;
                    } else {
                        // Slow case, write chunks one-by-one
                        while (entry) {
                            var chunk = entry.chunk;
                            var encoding = entry.encoding;
                            var cb = entry.callback;
                            var len = state.objectMode ? 1 : chunk.length;

                            doWrite(stream, state, false, len, chunk, encoding, cb);
                            entry = entry.next;
                            state.bufferedRequestCount--;
                            // if we didn't call the onwrite immediately, then
                            // it means that we need to wait until it does.
                            // also, that means that the chunk and cb are currently
                            // being processed, so move the buffer counter past them.
                            if (state.writing) {
                                break;
                            }
                        }

                        if (entry === null) state.lastBufferedRequest = null;
                    }

                    state.bufferedRequest = entry;
                    state.bufferProcessing = false;
                }

                Writable.prototype._write = function(chunk, encoding, cb) {
                    cb(new Error('_write() is not implemented'));
                };

                Writable.prototype._writev = null;

                Writable.prototype.end = function(chunk, encoding, cb) {
                    var state = this._writableState;

                    if (typeof chunk === 'function') {
                        cb = chunk;
                        chunk = null;
                        encoding = null;
                    } else if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = null;
                    }

                    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

                    // .end() fully uncorks
                    if (state.corked) {
                        state.corked = 1;
                        this.uncork();
                    }

                    // ignore unnecessary end() calls.
                    if (!state.ending && !state.finished) endWritable(this, state, cb);
                };

                function needFinish(state) {
                    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
                }

                function callFinal(stream, state) {
                    stream._final(function(err) {
                        state.pendingcb--;
                        if (err) {
                            stream.emit('error', err);
                        }
                        state.prefinished = true;
                        stream.emit('prefinish');
                        finishMaybe(stream, state);
                    });
                }

                function prefinish(stream, state) {
                    if (!state.prefinished && !state.finalCalled) {
                        if (typeof stream._final === 'function') {
                            state.pendingcb++;
                            state.finalCalled = true;
                            pna.nextTick(callFinal, stream, state);
                        } else {
                            state.prefinished = true;
                            stream.emit('prefinish');
                        }
                    }
                }

                function finishMaybe(stream, state) {
                    var need = needFinish(state);
                    if (need) {
                        prefinish(stream, state);
                        if (state.pendingcb === 0) {
                            state.finished = true;
                            stream.emit('finish');
                        }
                    }
                    return need;
                }

                function endWritable(stream, state, cb) {
                    state.ending = true;
                    finishMaybe(stream, state);
                    if (cb) {
                        if (state.finished) pna.nextTick(cb); else stream.once('finish', cb);
                    }
                    state.ended = true;
                    stream.writable = false;
                }

                function onCorkedFinish(corkReq, state, err) {
                    var entry = corkReq.entry;
                    corkReq.entry = null;
                    while (entry) {
                        var cb = entry.callback;
                        state.pendingcb--;
                        cb(err);
                        entry = entry.next;
                    }
                    if (state.corkedRequestsFree) {
                        state.corkedRequestsFree.next = corkReq;
                    } else {
                        state.corkedRequestsFree = corkReq;
                    }
                }

                Object.defineProperty(Writable.prototype, 'destroyed', {
                    get: function() {
                        if (this._writableState === undefined) {
                            return false;
                        }
                        return this._writableState.destroyed;
                    },
                    set: function(value) {
                        // we ignore the value if the stream
                        // has not been initialized yet
                        if (!this._writableState) {
                            return;
                        }

                        // backward compatibility, the user is explicitly
                        // managing destroyed
                        this._writableState.destroyed = value;
                    }
                });

                Writable.prototype.destroy = destroyImpl.destroy;
                Writable.prototype._undestroy = destroyImpl.undestroy;
                Writable.prototype._destroy = function(err, cb) {
                    this.end();
                    cb(err);
                };
            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('timers').setImmediate);
        }, {
            './_stream_duplex': 155,
            './internal/streams/destroy': 161,
            './internal/streams/stream': 162,
            '_process': 141,
            'core-util-is': 62,
            'inherits': 116,
            'process-nextick-args': 140,
            'safe-buffer': 169,
            'timers': 192,
            'util-deprecate': 196
        }],
        160: [function(require, module, exports) {
            'use strict';

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError('Cannot call a class as a function');
                }
            }

            var Buffer = require('safe-buffer').Buffer;
            var util = require('util');

            function copyBuffer(src, target, offset) {
                src.copy(target, offset);
            }

            module.exports = function() {
                function BufferList() {
                    _classCallCheck(this, BufferList);

                    this.head = null;
                    this.tail = null;
                    this.length = 0;
                }

                BufferList.prototype.push = function push(v) {
                    var entry = { data: v, next: null };
                    if (this.length > 0) this.tail.next = entry; else this.head = entry;
                    this.tail = entry;
                    ++this.length;
                };

                BufferList.prototype.unshift = function unshift(v) {
                    var entry = { data: v, next: this.head };
                    if (this.length === 0) this.tail = entry;
                    this.head = entry;
                    ++this.length;
                };

                BufferList.prototype.shift = function shift() {
                    if (this.length === 0) return;
                    var ret = this.head.data;
                    if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
                    --this.length;
                    return ret;
                };

                BufferList.prototype.clear = function clear() {
                    this.head = this.tail = null;
                    this.length = 0;
                };

                BufferList.prototype.join = function join(s) {
                    if (this.length === 0) return '';
                    var p = this.head;
                    var ret = '' + p.data;
                    while (p = p.next) {
                        ret += s + p.data;
                    }
                    return ret;
                };

                BufferList.prototype.concat = function concat(n) {
                    if (this.length === 0) return Buffer.alloc(0);
                    if (this.length === 1) return this.head.data;
                    var ret = Buffer.allocUnsafe(n >>> 0);
                    var p = this.head;
                    var i = 0;
                    while (p) {
                        copyBuffer(p.data, ret, i);
                        i += p.data.length;
                        p = p.next;
                    }
                    return ret;
                };

                return BufferList;
            }();

            if (util && util.inspect && util.inspect.custom) {
                module.exports.prototype[util.inspect.custom] = function() {
                    var obj = util.inspect({ length: this.length });
                    return this.constructor.name + ' ' + obj;
                };
            }
        }, { 'safe-buffer': 169, 'util': 29 }],
        161: [function(require, module, exports) {
            'use strict';

            /*<replacement>*/

            var pna = require('process-nextick-args');
            /*</replacement>*/

// undocumented cb() API, needed for core, not for public API
            function destroy(err, cb) {
                var _this = this;

                var readableDestroyed = this._readableState && this._readableState.destroyed;
                var writableDestroyed = this._writableState && this._writableState.destroyed;

                if (readableDestroyed || writableDestroyed) {
                    if (cb) {
                        cb(err);
                    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                        pna.nextTick(emitErrorNT, this, err);
                    }
                    return this;
                }

                // we set destroyed to true before firing error callbacks in order
                // to make it re-entrance safe in case destroy() is called within callbacks

                if (this._readableState) {
                    this._readableState.destroyed = true;
                }

                // if this is a duplex stream mark the writable part as destroyed as well
                if (this._writableState) {
                    this._writableState.destroyed = true;
                }

                this._destroy(err || null, function(err) {
                    if (!cb && err) {
                        pna.nextTick(emitErrorNT, _this, err);
                        if (_this._writableState) {
                            _this._writableState.errorEmitted = true;
                        }
                    } else if (cb) {
                        cb(err);
                    }
                });

                return this;
            }

            function undestroy() {
                if (this._readableState) {
                    this._readableState.destroyed = false;
                    this._readableState.reading = false;
                    this._readableState.ended = false;
                    this._readableState.endEmitted = false;
                }

                if (this._writableState) {
                    this._writableState.destroyed = false;
                    this._writableState.ended = false;
                    this._writableState.ending = false;
                    this._writableState.finished = false;
                    this._writableState.errorEmitted = false;
                }
            }

            function emitErrorNT(self, err) {
                self.emit('error', err);
            }

            module.exports = {
                destroy: destroy,
                undestroy: undestroy
            };
        }, { 'process-nextick-args': 140 }],
        162: [function(require, module, exports) {
            module.exports = require('events').EventEmitter;

        }, { 'events': 97 }],
        163: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            /*<replacement>*/

            var Buffer = require('safe-buffer').Buffer;
            /*</replacement>*/

            var isEncoding = Buffer.isEncoding || function(encoding) {
                encoding = '' + encoding;
                switch (encoding && encoding.toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                    case 'raw':
                        return true;
                    default:
                        return false;
                }
            };

            function _normalizeEncoding(enc) {
                if (!enc) return 'utf8';
                var retried;
                while (true) {
                    switch (enc) {
                        case 'utf8':
                        case 'utf-8':
                            return 'utf8';
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return 'utf16le';
                        case 'latin1':
                        case 'binary':
                            return 'latin1';
                        case 'base64':
                        case 'ascii':
                        case 'hex':
                            return enc;
                        default:
                            if (retried) return; // undefined
                            enc = ('' + enc).toLowerCase();
                            retried = true;
                    }
                }
            }

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
            function normalizeEncoding(enc) {
                var nenc = _normalizeEncoding(enc);
                if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
                return nenc || enc;
            }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
            exports.StringDecoder = StringDecoder;

            function StringDecoder(encoding) {
                this.encoding = normalizeEncoding(encoding);
                var nb;
                switch (this.encoding) {
                    case 'utf16le':
                        this.text = utf16Text;
                        this.end = utf16End;
                        nb = 4;
                        break;
                    case 'utf8':
                        this.fillLast = utf8FillLast;
                        nb = 4;
                        break;
                    case 'base64':
                        this.text = base64Text;
                        this.end = base64End;
                        nb = 3;
                        break;
                    default:
                        this.write = simpleWrite;
                        this.end = simpleEnd;
                        return;
                }
                this.lastNeed = 0;
                this.lastTotal = 0;
                this.lastChar = Buffer.allocUnsafe(nb);
            }

            StringDecoder.prototype.write = function(buf) {
                if (buf.length === 0) return '';
                var r;
                var i;
                if (this.lastNeed) {
                    r = this.fillLast(buf);
                    if (r === undefined) return '';
                    i = this.lastNeed;
                    this.lastNeed = 0;
                } else {
                    i = 0;
                }
                if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
                return r || '';
            };

            StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
            StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
            StringDecoder.prototype.fillLast = function(buf) {
                if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                }
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
                this.lastNeed -= buf.length;
            };

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
            function utf8CheckByte(byte) {
                if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
                return byte >> 6 === 0x02 ? -1 : -2;
            }

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
            function utf8CheckIncomplete(self, buf, i) {
                var j = buf.length - 1;
                if (j < i) return 0;
                var nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                    if (nb > 0) self.lastNeed = nb - 1;
                    return nb;
                }
                if (--j < i || nb === -2) return 0;
                nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                    if (nb > 0) self.lastNeed = nb - 2;
                    return nb;
                }
                if (--j < i || nb === -2) return 0;
                nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                    if (nb > 0) {
                        if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
                    }
                    return nb;
                }
                return 0;
            }

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
            function utf8CheckExtraBytes(self, buf, p) {
                if ((buf[0] & 0xC0) !== 0x80) {
                    self.lastNeed = 0;
                    return '\ufffd';
                }
                if (self.lastNeed > 1 && buf.length > 1) {
                    if ((buf[1] & 0xC0) !== 0x80) {
                        self.lastNeed = 1;
                        return '\ufffd';
                    }
                    if (self.lastNeed > 2 && buf.length > 2) {
                        if ((buf[2] & 0xC0) !== 0x80) {
                            self.lastNeed = 2;
                            return '\ufffd';
                        }
                    }
                }
            }

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
            function utf8FillLast(buf) {
                var p = this.lastTotal - this.lastNeed;
                var r = utf8CheckExtraBytes(this, buf, p);
                if (r !== undefined) return r;
                if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, p, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                }
                buf.copy(this.lastChar, p, 0, buf.length);
                this.lastNeed -= buf.length;
            }

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
            function utf8Text(buf, i) {
                var total = utf8CheckIncomplete(this, buf, i);
                if (!this.lastNeed) return buf.toString('utf8', i);
                this.lastTotal = total;
                var end = buf.length - (total - this.lastNeed);
                buf.copy(this.lastChar, 0, end);
                return buf.toString('utf8', i, end);
            }

// For UTF-8, a replacement character is added when ending on a partial
// character.
            function utf8End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                if (this.lastNeed) return r + '\ufffd';
                return r;
            }

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
            function utf16Text(buf, i) {
                if ((buf.length - i) % 2 === 0) {
                    var r = buf.toString('utf16le', i);
                    if (r) {
                        var c = r.charCodeAt(r.length - 1);
                        if (c >= 0xD800 && c <= 0xDBFF) {
                            this.lastNeed = 2;
                            this.lastTotal = 4;
                            this.lastChar[0] = buf[buf.length - 2];
                            this.lastChar[1] = buf[buf.length - 1];
                            return r.slice(0, -1);
                        }
                    }
                    return r;
                }
                this.lastNeed = 1;
                this.lastTotal = 2;
                this.lastChar[0] = buf[buf.length - 1];
                return buf.toString('utf16le', i, buf.length - 1);
            }

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
            function utf16End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                if (this.lastNeed) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString('utf16le', 0, end);
                }
                return r;
            }

            function base64Text(buf, i) {
                var n = (buf.length - i) % 3;
                if (n === 0) return buf.toString('base64', i);
                this.lastNeed = 3 - n;
                this.lastTotal = 3;
                if (n === 1) {
                    this.lastChar[0] = buf[buf.length - 1];
                } else {
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                }
                return buf.toString('base64', i, buf.length - n);
            }

            function base64End(buf) {
                var r = buf && buf.length ? this.write(buf) : '';
                if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
                return r;
            }

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
            function simpleWrite(buf) {
                return buf.toString(this.encoding);
            }

            function simpleEnd(buf) {
                return buf && buf.length ? this.write(buf) : '';
            }
        }, { 'safe-buffer': 169 }],
        164: [function(require, module, exports) {
            module.exports = require('./readable').PassThrough;

        }, { './readable': 165 }],
        165: [function(require, module, exports) {
            exports = module.exports = require('./lib/_stream_readable.js');
            exports.Stream = exports;
            exports.Readable = exports;
            exports.Writable = require('./lib/_stream_writable.js');
            exports.Duplex = require('./lib/_stream_duplex.js');
            exports.Transform = require('./lib/_stream_transform.js');
            exports.PassThrough = require('./lib/_stream_passthrough.js');

        }, {
            './lib/_stream_duplex.js': 155,
            './lib/_stream_passthrough.js': 156,
            './lib/_stream_readable.js': 157,
            './lib/_stream_transform.js': 158,
            './lib/_stream_writable.js': 159
        }],
        166: [function(require, module, exports) {
            module.exports = require('./readable').Transform;

        }, { './readable': 165 }],
        167: [function(require, module, exports) {
            module.exports = require('./lib/_stream_writable.js');

        }, { './lib/_stream_writable.js': 159 }],
        168: [function(require, module, exports) {
            'use strict';
            var Buffer = require('buffer').Buffer;
            var inherits = require('inherits');
            var HashBase = require('hash-base');

            var ARRAY16 = new Array(16);

            var zl = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
            ];

            var zr = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
            ];

            var sl = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
            ];

            var sr = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
            ];

            var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
            var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

            function RIPEMD160() {
                HashBase.call(this, 64);

                // state
                this._a = 0x67452301;
                this._b = 0xefcdab89;
                this._c = 0x98badcfe;
                this._d = 0x10325476;
                this._e = 0xc3d2e1f0;
            }

            inherits(RIPEMD160, HashBase);

            RIPEMD160.prototype._update = function() {
                var words = ARRAY16;
                for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

                var al = this._a | 0;
                var bl = this._b | 0;
                var cl = this._c | 0;
                var dl = this._d | 0;
                var el = this._e | 0;

                var ar = this._a | 0;
                var br = this._b | 0;
                var cr = this._c | 0;
                var dr = this._d | 0;
                var er = this._e | 0;

                // computation
                for (var i = 0; i < 80; i += 1) {
                    var tl;
                    var tr;
                    if (i < 16) {
                        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
                        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
                    } else if (i < 32) {
                        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
                        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
                    } else if (i < 48) {
                        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
                        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
                    } else if (i < 64) {
                        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
                        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
                    } else { // if (i<80) {
                        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
                        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
                    }

                    al = el;
                    el = dl;
                    dl = rotl(cl, 10);
                    cl = bl;
                    bl = tl;

                    ar = er;
                    er = dr;
                    dr = rotl(cr, 10);
                    cr = br;
                    br = tr;
                }

                // update state
                var t = (this._b + cl + dr) | 0;
                this._b = (this._c + dl + er) | 0;
                this._c = (this._d + el + ar) | 0;
                this._d = (this._e + al + br) | 0;
                this._e = (this._a + bl + cr) | 0;
                this._a = t;
            };

            RIPEMD160.prototype._digest = function() {
                // create padding and handle blocks
                this._block[this._blockOffset++] = 0x80;
                if (this._blockOffset > 56) {
                    this._block.fill(0, this._blockOffset, 64);
                    this._update();
                    this._blockOffset = 0;
                }

                this._block.fill(0, this._blockOffset, 56);
                this._block.writeUInt32LE(this._length[0], 56);
                this._block.writeUInt32LE(this._length[1], 60);
                this._update();

                // produce result
                var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
                buffer.writeInt32LE(this._a, 0);
                buffer.writeInt32LE(this._b, 4);
                buffer.writeInt32LE(this._c, 8);
                buffer.writeInt32LE(this._d, 12);
                buffer.writeInt32LE(this._e, 16);
                return buffer;
            };

            function rotl(x, n) {
                return (x << n) | (x >>> (32 - n));
            }

            function fn1(a, b, c, d, e, m, k, s) {
                return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0;
            }

            function fn2(a, b, c, d, e, m, k, s) {
                return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0;
            }

            function fn3(a, b, c, d, e, m, k, s) {
                return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0;
            }

            function fn4(a, b, c, d, e, m, k, s) {
                return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0;
            }

            function fn5(a, b, c, d, e, m, k, s) {
                return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0;
            }

            module.exports = RIPEMD160;

        }, { 'buffer': 59, 'hash-base': 99, 'inherits': 116 }],
        169: [function(require, module, exports) {
            /* eslint-disable node/no-deprecated-api */
            var buffer = require('buffer');
            var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
            function copyProps(src, dst) {
                for (var key in src) {
                    dst[key] = src[key];
                }
            }

            if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                module.exports = buffer;
            } else {
                // Copy properties from require('buffer')
                copyProps(buffer, exports);
                exports.Buffer = SafeBuffer;
            }

            function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
            }

// Copy static methods from Buffer
            copyProps(Buffer, SafeBuffer);

            SafeBuffer.from = function(arg, encodingOrOffset, length) {
                if (typeof arg === 'number') {
                    throw new TypeError('Argument must not be a number');
                }
                return Buffer(arg, encodingOrOffset, length);
            };

            SafeBuffer.alloc = function(size, fill, encoding) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                var buf = Buffer(size);
                if (fill !== undefined) {
                    if (typeof encoding === 'string') {
                        buf.fill(fill, encoding);
                    } else {
                        buf.fill(fill);
                    }
                } else {
                    buf.fill(0);
                }
                return buf;
            };

            SafeBuffer.allocUnsafe = function(size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return Buffer(size);
            };

            SafeBuffer.allocUnsafeSlow = function(size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return buffer.SlowBuffer(size);
            };

        }, { 'buffer': 59 }],
        170: [function(require, module, exports) {
            (function(Buffer) {
                ;(function(sax) { // wrapper for non-node envs
                    sax.parser = function(strict, opt) {
                        return new SAXParser(strict, opt);
                    };
                    sax.SAXParser = SAXParser;
                    sax.SAXStream = SAXStream;
                    sax.createStream = createStream;

                    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
                    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
                    // since that's the earliest that a buffer overrun could occur.  This way, checks are
                    // as rare as required, but as often as necessary to ensure never crossing this bound.
                    // Furthermore, buffers are only tested at most once per write(), so passing a very
                    // large string into write() might have undesirable effects, but this is manageable by
                    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
                    // edge case, result in creating at most one complete copy of the string passed in.
                    // Set to Infinity to have unlimited buffers.
                    sax.MAX_BUFFER_LENGTH = 64 * 1024;

                    var buffers = [
                        'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
                        'procInstName', 'procInstBody', 'entity', 'attribName',
                        'attribValue', 'cdata', 'script'
                    ];

                    sax.EVENTS = [
                        'text',
                        'processinginstruction',
                        'sgmldeclaration',
                        'doctype',
                        'comment',
                        'opentagstart',
                        'attribute',
                        'opentag',
                        'closetag',
                        'opencdata',
                        'cdata',
                        'closecdata',
                        'error',
                        'end',
                        'ready',
                        'script',
                        'opennamespace',
                        'closenamespace'
                    ];

                    function SAXParser(strict, opt) {
                        if (!(this instanceof SAXParser)) {
                            return new SAXParser(strict, opt);
                        }

                        var parser = this;
                        clearBuffers(parser);
                        parser.q = parser.c = '';
                        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                        parser.opt = opt || {};
                        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
                        parser.tags = [];
                        parser.closed = parser.closedRoot = parser.sawRoot = false;
                        parser.tag = parser.error = null;
                        parser.strict = !!strict;
                        parser.noscript = !!(strict || parser.opt.noscript);
                        parser.state = S.BEGIN;
                        parser.strictEntities = parser.opt.strictEntities;
                        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                        parser.attribList = [];

                        // namespaces form a prototype chain.
                        // it always points at the current tag,
                        // which protos to its parent tag.
                        if (parser.opt.xmlns) {
                            parser.ns = Object.create(rootNS);
                        }

                        // mostly just for error reporting
                        parser.trackPosition = parser.opt.position !== false;
                        if (parser.trackPosition) {
                            parser.position = parser.line = parser.column = 0;
                        }
                        emit(parser, 'onready');
                    }

                    if (!Object.create) {
                        Object.create = function(o) {
                            function F() {
                            }

                            F.prototype = o;
                            var newf = new F();
                            return newf;
                        };
                    }

                    if (!Object.keys) {
                        Object.keys = function(o) {
                            var a = [];
                            for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
                            return a;
                        };
                    }

                    function checkBufferLength(parser) {
                        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                        var maxActual = 0;
                        for (var i = 0, l = buffers.length; i < l; i++) {
                            var len = parser[buffers[i]].length;
                            if (len > maxAllowed) {
                                // Text/cdata nodes can get big, and since they're buffered,
                                // we can get here under normal conditions.
                                // Avoid issues by emitting the text node now,
                                // so at least it won't get any bigger.
                                switch (buffers[i]) {
                                    case 'textNode':
                                        closeText(parser);
                                        break;

                                    case 'cdata':
                                        emitNode(parser, 'oncdata', parser.cdata);
                                        parser.cdata = '';
                                        break;

                                    case 'script':
                                        emitNode(parser, 'onscript', parser.script);
                                        parser.script = '';
                                        break;

                                    default:
                                        error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                                }
                            }
                            maxActual = Math.max(maxActual, len);
                        }
                        // schedule the next check for the earliest possible buffer overrun.
                        var m = sax.MAX_BUFFER_LENGTH - maxActual;
                        parser.bufferCheckPosition = m + parser.position;
                    }

                    function clearBuffers(parser) {
                        for (var i = 0, l = buffers.length; i < l; i++) {
                            parser[buffers[i]] = '';
                        }
                    }

                    function flushBuffers(parser) {
                        closeText(parser);
                        if (parser.cdata !== '') {
                            emitNode(parser, 'oncdata', parser.cdata);
                            parser.cdata = '';
                        }
                        if (parser.script !== '') {
                            emitNode(parser, 'onscript', parser.script);
                            parser.script = '';
                        }
                    }

                    SAXParser.prototype = {
                        end: function() {
                            end(this);
                        },
                        write: write,
                        resume: function() {
                            this.error = null;
                            return this;
                        },
                        close: function() {
                            return this.write(null);
                        },
                        flush: function() {
                            flushBuffers(this);
                        }
                    };

                    var Stream;
                    try {
                        Stream = require('stream').Stream;
                    } catch (ex) {
                        Stream = function() {
                        };
                    }

                    var streamWraps = sax.EVENTS.filter(function(ev) {
                        return ev !== 'error' && ev !== 'end';
                    });

                    function createStream(strict, opt) {
                        return new SAXStream(strict, opt);
                    }

                    function SAXStream(strict, opt) {
                        if (!(this instanceof SAXStream)) {
                            return new SAXStream(strict, opt);
                        }

                        Stream.apply(this);

                        this._parser = new SAXParser(strict, opt);
                        this.writable = true;
                        this.readable = true;

                        var me = this;

                        this._parser.onend = function() {
                            me.emit('end');
                        };

                        this._parser.onerror = function(er) {
                            me.emit('error', er);

                            // if didn't throw, then means error was handled.
                            // go ahead and clear error, so we can write again.
                            me._parser.error = null;
                        };

                        this._decoder = null;

                        streamWraps.forEach(function(ev) {
                            Object.defineProperty(me, 'on' + ev, {
                                get: function() {
                                    return me._parser['on' + ev];
                                },
                                set: function(h) {
                                    if (!h) {
                                        me.removeAllListeners(ev);
                                        me._parser['on' + ev] = h;
                                        return h;
                                    }
                                    me.on(ev, h);
                                },
                                enumerable: true,
                                configurable: false
                            });
                        });
                    }

                    SAXStream.prototype = Object.create(Stream.prototype, {
                        constructor: {
                            value: SAXStream
                        }
                    });

                    SAXStream.prototype.write = function(data) {
                        if (typeof Buffer === 'function' &&
                            typeof Buffer.isBuffer === 'function' &&
                            Buffer.isBuffer(data)) {
                            if (!this._decoder) {
                                var SD = require('string_decoder').StringDecoder;
                                this._decoder = new SD('utf8');
                            }
                            data = this._decoder.write(data);
                        }

                        this._parser.write(data.toString());
                        this.emit('data', data);
                        return true;
                    };

                    SAXStream.prototype.end = function(chunk) {
                        if (chunk && chunk.length) {
                            this.write(chunk);
                        }
                        this._parser.end();
                        return true;
                    };

                    SAXStream.prototype.on = function(ev, handler) {
                        var me = this;
                        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
                            me._parser['on' + ev] = function() {
                                var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                                args.splice(0, 0, ev);
                                me.emit.apply(me, args);
                            };
                        }

                        return Stream.prototype.on.call(me, ev, handler);
                    };

                    // this really needs to be replaced with character classes.
                    // XML allows all manner of ridiculous numbers and digits.
                    var CDATA = '[CDATA[';
                    var DOCTYPE = 'DOCTYPE';
                    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
                    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
                    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

                    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
                    // This implementation works on strings, a single character at a time
                    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
                    // without a significant breaking change to either this  parser, or the
                    // JavaScript language.  Implementation of an emoji-capable xml parser
                    // is left as an exercise for the reader.
                    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

                    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

                    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

                    function isWhitespace(c) {
                        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
                    }

                    function isQuote(c) {
                        return c === '"' || c === '\'';
                    }

                    function isAttribEnd(c) {
                        return c === '>' || isWhitespace(c);
                    }

                    function isMatch(regex, c) {
                        return regex.test(c);
                    }

                    function notMatch(regex, c) {
                        return !isMatch(regex, c);
                    }

                    var S = 0;
                    sax.STATE = {
                        BEGIN: S++, // leading byte order mark or whitespace
                        BEGIN_WHITESPACE: S++, // leading whitespace
                        TEXT: S++, // general stuff
                        TEXT_ENTITY: S++, // &amp and such.
                        OPEN_WAKA: S++, // <
                        SGML_DECL: S++, // <!BLARG
                        SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
                        DOCTYPE: S++, // <!DOCTYPE
                        DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
                        DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
                        DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
                        COMMENT_STARTING: S++, // <!-
                        COMMENT: S++, // <!--
                        COMMENT_ENDING: S++, // <!-- blah -
                        COMMENT_ENDED: S++, // <!-- blah --
                        CDATA: S++, // <![CDATA[ something
                        CDATA_ENDING: S++, // ]
                        CDATA_ENDING_2: S++, // ]]
                        PROC_INST: S++, // <?hi
                        PROC_INST_BODY: S++, // <?hi there
                        PROC_INST_ENDING: S++, // <?hi "there" ?
                        OPEN_TAG: S++, // <strong
                        OPEN_TAG_SLASH: S++, // <strong /
                        ATTRIB: S++, // <a
                        ATTRIB_NAME: S++, // <a foo
                        ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
                        ATTRIB_VALUE: S++, // <a foo=
                        ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
                        ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
                        ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
                        ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
                        ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
                        CLOSE_TAG: S++, // </a
                        CLOSE_TAG_SAW_WHITE: S++, // </a   >
                        SCRIPT: S++, // <script> ...
                        SCRIPT_ENDING: S++ // <script> ... <
                    };

                    sax.XML_ENTITIES = {
                        'amp': '&',
                        'gt': '>',
                        'lt': '<',
                        'quot': '"',
                        'apos': '\''
                    };

                    sax.ENTITIES = {
                        'amp': '&',
                        'gt': '>',
                        'lt': '<',
                        'quot': '"',
                        'apos': '\'',
                        'AElig': 198,
                        'Aacute': 193,
                        'Acirc': 194,
                        'Agrave': 192,
                        'Aring': 197,
                        'Atilde': 195,
                        'Auml': 196,
                        'Ccedil': 199,
                        'ETH': 208,
                        'Eacute': 201,
                        'Ecirc': 202,
                        'Egrave': 200,
                        'Euml': 203,
                        'Iacute': 205,
                        'Icirc': 206,
                        'Igrave': 204,
                        'Iuml': 207,
                        'Ntilde': 209,
                        'Oacute': 211,
                        'Ocirc': 212,
                        'Ograve': 210,
                        'Oslash': 216,
                        'Otilde': 213,
                        'Ouml': 214,
                        'THORN': 222,
                        'Uacute': 218,
                        'Ucirc': 219,
                        'Ugrave': 217,
                        'Uuml': 220,
                        'Yacute': 221,
                        'aacute': 225,
                        'acirc': 226,
                        'aelig': 230,
                        'agrave': 224,
                        'aring': 229,
                        'atilde': 227,
                        'auml': 228,
                        'ccedil': 231,
                        'eacute': 233,
                        'ecirc': 234,
                        'egrave': 232,
                        'eth': 240,
                        'euml': 235,
                        'iacute': 237,
                        'icirc': 238,
                        'igrave': 236,
                        'iuml': 239,
                        'ntilde': 241,
                        'oacute': 243,
                        'ocirc': 244,
                        'ograve': 242,
                        'oslash': 248,
                        'otilde': 245,
                        'ouml': 246,
                        'szlig': 223,
                        'thorn': 254,
                        'uacute': 250,
                        'ucirc': 251,
                        'ugrave': 249,
                        'uuml': 252,
                        'yacute': 253,
                        'yuml': 255,
                        'copy': 169,
                        'reg': 174,
                        'nbsp': 160,
                        'iexcl': 161,
                        'cent': 162,
                        'pound': 163,
                        'curren': 164,
                        'yen': 165,
                        'brvbar': 166,
                        'sect': 167,
                        'uml': 168,
                        'ordf': 170,
                        'laquo': 171,
                        'not': 172,
                        'shy': 173,
                        'macr': 175,
                        'deg': 176,
                        'plusmn': 177,
                        'sup1': 185,
                        'sup2': 178,
                        'sup3': 179,
                        'acute': 180,
                        'micro': 181,
                        'para': 182,
                        'middot': 183,
                        'cedil': 184,
                        'ordm': 186,
                        'raquo': 187,
                        'frac14': 188,
                        'frac12': 189,
                        'frac34': 190,
                        'iquest': 191,
                        'times': 215,
                        'divide': 247,
                        'OElig': 338,
                        'oelig': 339,
                        'Scaron': 352,
                        'scaron': 353,
                        'Yuml': 376,
                        'fnof': 402,
                        'circ': 710,
                        'tilde': 732,
                        'Alpha': 913,
                        'Beta': 914,
                        'Gamma': 915,
                        'Delta': 916,
                        'Epsilon': 917,
                        'Zeta': 918,
                        'Eta': 919,
                        'Theta': 920,
                        'Iota': 921,
                        'Kappa': 922,
                        'Lambda': 923,
                        'Mu': 924,
                        'Nu': 925,
                        'Xi': 926,
                        'Omicron': 927,
                        'Pi': 928,
                        'Rho': 929,
                        'Sigma': 931,
                        'Tau': 932,
                        'Upsilon': 933,
                        'Phi': 934,
                        'Chi': 935,
                        'Psi': 936,
                        'Omega': 937,
                        'alpha': 945,
                        'beta': 946,
                        'gamma': 947,
                        'delta': 948,
                        'epsilon': 949,
                        'zeta': 950,
                        'eta': 951,
                        'theta': 952,
                        'iota': 953,
                        'kappa': 954,
                        'lambda': 955,
                        'mu': 956,
                        'nu': 957,
                        'xi': 958,
                        'omicron': 959,
                        'pi': 960,
                        'rho': 961,
                        'sigmaf': 962,
                        'sigma': 963,
                        'tau': 964,
                        'upsilon': 965,
                        'phi': 966,
                        'chi': 967,
                        'psi': 968,
                        'omega': 969,
                        'thetasym': 977,
                        'upsih': 978,
                        'piv': 982,
                        'ensp': 8194,
                        'emsp': 8195,
                        'thinsp': 8201,
                        'zwnj': 8204,
                        'zwj': 8205,
                        'lrm': 8206,
                        'rlm': 8207,
                        'ndash': 8211,
                        'mdash': 8212,
                        'lsquo': 8216,
                        'rsquo': 8217,
                        'sbquo': 8218,
                        'ldquo': 8220,
                        'rdquo': 8221,
                        'bdquo': 8222,
                        'dagger': 8224,
                        'Dagger': 8225,
                        'bull': 8226,
                        'hellip': 8230,
                        'permil': 8240,
                        'prime': 8242,
                        'Prime': 8243,
                        'lsaquo': 8249,
                        'rsaquo': 8250,
                        'oline': 8254,
                        'frasl': 8260,
                        'euro': 8364,
                        'image': 8465,
                        'weierp': 8472,
                        'real': 8476,
                        'trade': 8482,
                        'alefsym': 8501,
                        'larr': 8592,
                        'uarr': 8593,
                        'rarr': 8594,
                        'darr': 8595,
                        'harr': 8596,
                        'crarr': 8629,
                        'lArr': 8656,
                        'uArr': 8657,
                        'rArr': 8658,
                        'dArr': 8659,
                        'hArr': 8660,
                        'forall': 8704,
                        'part': 8706,
                        'exist': 8707,
                        'empty': 8709,
                        'nabla': 8711,
                        'isin': 8712,
                        'notin': 8713,
                        'ni': 8715,
                        'prod': 8719,
                        'sum': 8721,
                        'minus': 8722,
                        'lowast': 8727,
                        'radic': 8730,
                        'prop': 8733,
                        'infin': 8734,
                        'ang': 8736,
                        'and': 8743,
                        'or': 8744,
                        'cap': 8745,
                        'cup': 8746,
                        'int': 8747,
                        'there4': 8756,
                        'sim': 8764,
                        'cong': 8773,
                        'asymp': 8776,
                        'ne': 8800,
                        'equiv': 8801,
                        'le': 8804,
                        'ge': 8805,
                        'sub': 8834,
                        'sup': 8835,
                        'nsub': 8836,
                        'sube': 8838,
                        'supe': 8839,
                        'oplus': 8853,
                        'otimes': 8855,
                        'perp': 8869,
                        'sdot': 8901,
                        'lceil': 8968,
                        'rceil': 8969,
                        'lfloor': 8970,
                        'rfloor': 8971,
                        'lang': 9001,
                        'rang': 9002,
                        'loz': 9674,
                        'spades': 9824,
                        'clubs': 9827,
                        'hearts': 9829,
                        'diams': 9830
                    };

                    Object.keys(sax.ENTITIES).forEach(function(key) {
                        var e = sax.ENTITIES[key];
                        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
                        sax.ENTITIES[key] = s;
                    });

                    for (var s in sax.STATE) {
                        sax.STATE[sax.STATE[s]] = s;
                    }

                    // shorthand
                    S = sax.STATE;

                    function emit(parser, event, data) {
                        parser[event] && parser[event](data);
                    }

                    function emitNode(parser, nodeType, data) {
                        if (parser.textNode) closeText(parser);
                        emit(parser, nodeType, data);
                    }

                    function closeText(parser) {
                        parser.textNode = textopts(parser.opt, parser.textNode);
                        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
                        parser.textNode = '';
                    }

                    function textopts(opt, text) {
                        if (opt.trim) text = text.trim();
                        if (opt.normalize) text = text.replace(/\s+/g, ' ');
                        return text;
                    }

                    function error(parser, er) {
                        closeText(parser);
                        if (parser.trackPosition) {
                            er += '\nLine: ' + parser.line +
                                '\nColumn: ' + parser.column +
                                '\nChar: ' + parser.c;
                        }
                        er = new Error(er);
                        parser.error = er;
                        emit(parser, 'onerror', er);
                        return parser;
                    }

                    function end(parser) {
                        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
                        if ((parser.state !== S.BEGIN) &&
                            (parser.state !== S.BEGIN_WHITESPACE) &&
                            (parser.state !== S.TEXT)) {
                            error(parser, 'Unexpected end');
                        }
                        closeText(parser);
                        parser.c = '';
                        parser.closed = true;
                        emit(parser, 'onend');
                        SAXParser.call(parser, parser.strict, parser.opt);
                        return parser;
                    }

                    function strictFail(parser, message) {
                        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
                            throw new Error('bad call to strictFail');
                        }
                        if (parser.strict) {
                            error(parser, message);
                        }
                    }

                    function newTag(parser) {
                        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        var tag = parser.tag = { name: parser.tagName, attributes: {} };

                        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
                        if (parser.opt.xmlns) {
                            tag.ns = parent.ns;
                        }
                        parser.attribList.length = 0;
                        emitNode(parser, 'onopentagstart', tag);
                    }

                    function qname(name, attribute) {
                        var i = name.indexOf(':');
                        var qualName = i < 0 ? ['', name] : name.split(':');
                        var prefix = qualName[0];
                        var local = qualName[1];

                        // <x "xmlns"="http://foo">
                        if (attribute && name === 'xmlns') {
                            prefix = 'xmlns';
                            local = '';
                        }

                        return { prefix: prefix, local: local };
                    }

                    function attrib(parser) {
                        if (!parser.strict) {
                            parser.attribName = parser.attribName[parser.looseCase]();
                        }

                        if (parser.attribList.indexOf(parser.attribName) !== -1 ||
                            parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                            parser.attribName = parser.attribValue = '';
                            return;
                        }

                        if (parser.opt.xmlns) {
                            var qn = qname(parser.attribName, true);
                            var prefix = qn.prefix;
                            var local = qn.local;

                            if (prefix === 'xmlns') {
                                // namespace binding attribute. push the binding into scope
                                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                                    strictFail(parser,
                                        'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
                                        'Actual: ' + parser.attribValue);
                                } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                                    strictFail(parser,
                                        'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
                                        'Actual: ' + parser.attribValue);
                                } else {
                                    var tag = parser.tag;
                                    var parent = parser.tags[parser.tags.length - 1] || parser;
                                    if (tag.ns === parent.ns) {
                                        tag.ns = Object.create(parent.ns);
                                    }
                                    tag.ns[local] = parser.attribValue;
                                }
                            }

                            // defer onattribute events until all attributes have been seen
                            // so any new bindings can take effect. preserve attribute order
                            // so deferred events can be emitted in document order
                            parser.attribList.push([parser.attribName, parser.attribValue]);
                        } else {
                            // in non-xmlns mode, we can emit the event right away
                            parser.tag.attributes[parser.attribName] = parser.attribValue;
                            emitNode(parser, 'onattribute', {
                                name: parser.attribName,
                                value: parser.attribValue
                            });
                        }

                        parser.attribName = parser.attribValue = '';
                    }

                    function openTag(parser, selfClosing) {
                        if (parser.opt.xmlns) {
                            // emit namespace binding events
                            var tag = parser.tag;

                            // add namespace info to tag
                            var qn = qname(parser.tagName);
                            tag.prefix = qn.prefix;
                            tag.local = qn.local;
                            tag.uri = tag.ns[qn.prefix] || '';

                            if (tag.prefix && !tag.uri) {
                                strictFail(parser, 'Unbound namespace prefix: ' +
                                    JSON.stringify(parser.tagName));
                                tag.uri = qn.prefix;
                            }

                            var parent = parser.tags[parser.tags.length - 1] || parser;
                            if (tag.ns && parent.ns !== tag.ns) {
                                Object.keys(tag.ns).forEach(function(p) {
                                    emitNode(parser, 'onopennamespace', {
                                        prefix: p,
                                        uri: tag.ns[p]
                                    });
                                });
                            }

                            // handle deferred onattribute events
                            // Note: do not apply default ns to attributes:
                            //   http://www.w3.org/TR/REC-xml-names/#defaulting
                            for (var i = 0, l = parser.attribList.length; i < l; i++) {
                                var nv = parser.attribList[i];
                                var name = nv[0];
                                var value = nv[1];
                                var qualName = qname(name, true);
                                var prefix = qualName.prefix;
                                var local = qualName.local;
                                var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
                                var a = {
                                    name: name,
                                    value: value,
                                    prefix: prefix,
                                    local: local,
                                    uri: uri
                                };

                                // if there's any attributes with an undefined namespace,
                                // then fail on them now.
                                if (prefix && prefix !== 'xmlns' && !uri) {
                                    strictFail(parser, 'Unbound namespace prefix: ' +
                                        JSON.stringify(prefix));
                                    a.uri = prefix;
                                }
                                parser.tag.attributes[name] = a;
                                emitNode(parser, 'onattribute', a);
                            }
                            parser.attribList.length = 0;
                        }

                        parser.tag.isSelfClosing = !!selfClosing;

                        // process the tag
                        parser.sawRoot = true;
                        parser.tags.push(parser.tag);
                        emitNode(parser, 'onopentag', parser.tag);
                        if (!selfClosing) {
                            // special case for <script> in non-strict mode.
                            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                                parser.state = S.SCRIPT;
                            } else {
                                parser.state = S.TEXT;
                            }
                            parser.tag = null;
                            parser.tagName = '';
                        }
                        parser.attribName = parser.attribValue = '';
                        parser.attribList.length = 0;
                    }

                    function closeTag(parser) {
                        if (!parser.tagName) {
                            strictFail(parser, 'Weird empty close tag.');
                            parser.textNode += '</>';
                            parser.state = S.TEXT;
                            return;
                        }

                        if (parser.script) {
                            if (parser.tagName !== 'script') {
                                parser.script += '</' + parser.tagName + '>';
                                parser.tagName = '';
                                parser.state = S.SCRIPT;
                                return;
                            }
                            emitNode(parser, 'onscript', parser.script);
                            parser.script = '';
                        }

                        // first make sure that the closing tag actually exists.
                        // <a><b></c></b></a> will close everything, otherwise.
                        var t = parser.tags.length;
                        var tagName = parser.tagName;
                        if (!parser.strict) {
                            tagName = tagName[parser.looseCase]();
                        }
                        var closeTo = tagName;
                        while (t--) {
                            var close = parser.tags[t];
                            if (close.name !== closeTo) {
                                // fail the first time in strict mode
                                strictFail(parser, 'Unexpected close tag');
                            } else {
                                break;
                            }
                        }

                        // didn't find it.  we already failed for strict, so just abort.
                        if (t < 0) {
                            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
                            parser.textNode += '</' + parser.tagName + '>';
                            parser.state = S.TEXT;
                            return;
                        }
                        parser.tagName = tagName;
                        var s = parser.tags.length;
                        while (s-- > t) {
                            var tag = parser.tag = parser.tags.pop();
                            parser.tagName = parser.tag.name;
                            emitNode(parser, 'onclosetag', parser.tagName);

                            var x = {};
                            for (var i in tag.ns) {
                                x[i] = tag.ns[i];
                            }

                            var parent = parser.tags[parser.tags.length - 1] || parser;
                            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                                // remove namespace bindings introduced by tag
                                Object.keys(tag.ns).forEach(function(p) {
                                    var n = tag.ns[p];
                                    emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
                                });
                            }
                        }
                        if (t === 0) parser.closedRoot = true;
                        parser.tagName = parser.attribValue = parser.attribName = '';
                        parser.attribList.length = 0;
                        parser.state = S.TEXT;
                    }

                    function parseEntity(parser) {
                        var entity = parser.entity;
                        var entityLC = entity.toLowerCase();
                        var num;
                        var numStr = '';

                        if (parser.ENTITIES[entity]) {
                            return parser.ENTITIES[entity];
                        }
                        if (parser.ENTITIES[entityLC]) {
                            return parser.ENTITIES[entityLC];
                        }
                        entity = entityLC;
                        if (entity.charAt(0) === '#') {
                            if (entity.charAt(1) === 'x') {
                                entity = entity.slice(2);
                                num = parseInt(entity, 16);
                                numStr = num.toString(16);
                            } else {
                                entity = entity.slice(1);
                                num = parseInt(entity, 10);
                                numStr = num.toString(10);
                            }
                        }
                        entity = entity.replace(/^0+/, '');
                        if (isNaN(num) || numStr.toLowerCase() !== entity) {
                            strictFail(parser, 'Invalid character entity');
                            return '&' + parser.entity + ';';
                        }

                        return String.fromCodePoint(num);
                    }

                    function beginWhiteSpace(parser, c) {
                        if (c === '<') {
                            parser.state = S.OPEN_WAKA;
                            parser.startTagPosition = parser.position;
                        } else if (!isWhitespace(c)) {
                            // have to process this as a text node.
                            // weird, but happens.
                            strictFail(parser, 'Non-whitespace before first tag.');
                            parser.textNode = c;
                            parser.state = S.TEXT;
                        }
                    }

                    function charAt(chunk, i) {
                        var result = '';
                        if (i < chunk.length) {
                            result = chunk.charAt(i);
                        }
                        return result;
                    }

                    function write(chunk) {
                        var parser = this;
                        if (this.error) {
                            throw this.error;
                        }
                        if (parser.closed) {
                            return error(parser,
                                'Cannot write after close. Assign an onready handler.');
                        }
                        if (chunk === null) {
                            return end(parser);
                        }
                        if (typeof chunk === 'object') {
                            chunk = chunk.toString();
                        }
                        var i = 0;
                        var c = '';
                        while (true) {
                            c = charAt(chunk, i++);
                            parser.c = c;

                            if (!c) {
                                break;
                            }

                            if (parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else {
                                    parser.column++;
                                }
                            }

                            switch (parser.state) {
                                case S.BEGIN:
                                    parser.state = S.BEGIN_WHITESPACE;
                                    if (c === '\uFEFF') {
                                        continue;
                                    }
                                    beginWhiteSpace(parser, c);
                                    continue;

                                case S.BEGIN_WHITESPACE:
                                    beginWhiteSpace(parser, c);
                                    continue;

                                case S.TEXT:
                                    if (parser.sawRoot && !parser.closedRoot) {
                                        var starti = i - 1;
                                        while (c && c !== '<' && c !== '&') {
                                            c = charAt(chunk, i++);
                                            if (c && parser.trackPosition) {
                                                parser.position++;
                                                if (c === '\n') {
                                                    parser.line++;
                                                    parser.column = 0;
                                                } else {
                                                    parser.column++;
                                                }
                                            }
                                        }
                                        parser.textNode += chunk.substring(starti, i - 1);
                                    }
                                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                                        parser.state = S.OPEN_WAKA;
                                        parser.startTagPosition = parser.position;
                                    } else {
                                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                                            strictFail(parser, 'Text data outside of root node.');
                                        }
                                        if (c === '&') {
                                            parser.state = S.TEXT_ENTITY;
                                        } else {
                                            parser.textNode += c;
                                        }
                                    }
                                    continue;

                                case S.SCRIPT:
                                    // only non-strict
                                    if (c === '<') {
                                        parser.state = S.SCRIPT_ENDING;
                                    } else {
                                        parser.script += c;
                                    }
                                    continue;

                                case S.SCRIPT_ENDING:
                                    if (c === '/') {
                                        parser.state = S.CLOSE_TAG;
                                    } else {
                                        parser.script += '<' + c;
                                        parser.state = S.SCRIPT;
                                    }
                                    continue;

                                case S.OPEN_WAKA:
                                    // either a /, ?, !, or text is coming next.
                                    if (c === '!') {
                                        parser.state = S.SGML_DECL;
                                        parser.sgmlDecl = '';
                                    } else if (isWhitespace(c)) {
                                        // wait for it...
                                    } else if (isMatch(nameStart, c)) {
                                        parser.state = S.OPEN_TAG;
                                        parser.tagName = c;
                                    } else if (c === '/') {
                                        parser.state = S.CLOSE_TAG;
                                        parser.tagName = '';
                                    } else if (c === '?') {
                                        parser.state = S.PROC_INST;
                                        parser.procInstName = parser.procInstBody = '';
                                    } else {
                                        strictFail(parser, 'Unencoded <');
                                        // if there was some whitespace, then add that in.
                                        if (parser.startTagPosition + 1 < parser.position) {
                                            var pad = parser.position - parser.startTagPosition;
                                            c = new Array(pad).join(' ') + c;
                                        }
                                        parser.textNode += '<' + c;
                                        parser.state = S.TEXT;
                                    }
                                    continue;

                                case S.SGML_DECL:
                                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                                        emitNode(parser, 'onopencdata');
                                        parser.state = S.CDATA;
                                        parser.sgmlDecl = '';
                                        parser.cdata = '';
                                    } else if (parser.sgmlDecl + c === '--') {
                                        parser.state = S.COMMENT;
                                        parser.comment = '';
                                        parser.sgmlDecl = '';
                                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                        parser.state = S.DOCTYPE;
                                        if (parser.doctype || parser.sawRoot) {
                                            strictFail(parser,
                                                'Inappropriately located doctype declaration');
                                        }
                                        parser.doctype = '';
                                        parser.sgmlDecl = '';
                                    } else if (c === '>') {
                                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                                        parser.sgmlDecl = '';
                                        parser.state = S.TEXT;
                                    } else if (isQuote(c)) {
                                        parser.state = S.SGML_DECL_QUOTED;
                                        parser.sgmlDecl += c;
                                    } else {
                                        parser.sgmlDecl += c;
                                    }
                                    continue;

                                case S.SGML_DECL_QUOTED:
                                    if (c === parser.q) {
                                        parser.state = S.SGML_DECL;
                                        parser.q = '';
                                    }
                                    parser.sgmlDecl += c;
                                    continue;

                                case S.DOCTYPE:
                                    if (c === '>') {
                                        parser.state = S.TEXT;
                                        emitNode(parser, 'ondoctype', parser.doctype);
                                        parser.doctype = true; // just remember that we saw it.
                                    } else {
                                        parser.doctype += c;
                                        if (c === '[') {
                                            parser.state = S.DOCTYPE_DTD;
                                        } else if (isQuote(c)) {
                                            parser.state = S.DOCTYPE_QUOTED;
                                            parser.q = c;
                                        }
                                    }
                                    continue;

                                case S.DOCTYPE_QUOTED:
                                    parser.doctype += c;
                                    if (c === parser.q) {
                                        parser.q = '';
                                        parser.state = S.DOCTYPE;
                                    }
                                    continue;

                                case S.DOCTYPE_DTD:
                                    parser.doctype += c;
                                    if (c === ']') {
                                        parser.state = S.DOCTYPE;
                                    } else if (isQuote(c)) {
                                        parser.state = S.DOCTYPE_DTD_QUOTED;
                                        parser.q = c;
                                    }
                                    continue;

                                case S.DOCTYPE_DTD_QUOTED:
                                    parser.doctype += c;
                                    if (c === parser.q) {
                                        parser.state = S.DOCTYPE_DTD;
                                        parser.q = '';
                                    }
                                    continue;

                                case S.COMMENT:
                                    if (c === '-') {
                                        parser.state = S.COMMENT_ENDING;
                                    } else {
                                        parser.comment += c;
                                    }
                                    continue;

                                case S.COMMENT_ENDING:
                                    if (c === '-') {
                                        parser.state = S.COMMENT_ENDED;
                                        parser.comment = textopts(parser.opt, parser.comment);
                                        if (parser.comment) {
                                            emitNode(parser, 'oncomment', parser.comment);
                                        }
                                        parser.comment = '';
                                    } else {
                                        parser.comment += '-' + c;
                                        parser.state = S.COMMENT;
                                    }
                                    continue;

                                case S.COMMENT_ENDED:
                                    if (c !== '>') {
                                        strictFail(parser, 'Malformed comment');
                                        // allow <!-- blah -- bloo --> in non-strict mode,
                                        // which is a comment of " blah -- bloo "
                                        parser.comment += '--' + c;
                                        parser.state = S.COMMENT;
                                    } else {
                                        parser.state = S.TEXT;
                                    }
                                    continue;

                                case S.CDATA:
                                    if (c === ']') {
                                        parser.state = S.CDATA_ENDING;
                                    } else {
                                        parser.cdata += c;
                                    }
                                    continue;

                                case S.CDATA_ENDING:
                                    if (c === ']') {
                                        parser.state = S.CDATA_ENDING_2;
                                    } else {
                                        parser.cdata += ']' + c;
                                        parser.state = S.CDATA;
                                    }
                                    continue;

                                case S.CDATA_ENDING_2:
                                    if (c === '>') {
                                        if (parser.cdata) {
                                            emitNode(parser, 'oncdata', parser.cdata);
                                        }
                                        emitNode(parser, 'onclosecdata');
                                        parser.cdata = '';
                                        parser.state = S.TEXT;
                                    } else if (c === ']') {
                                        parser.cdata += ']';
                                    } else {
                                        parser.cdata += ']]' + c;
                                        parser.state = S.CDATA;
                                    }
                                    continue;

                                case S.PROC_INST:
                                    if (c === '?') {
                                        parser.state = S.PROC_INST_ENDING;
                                    } else if (isWhitespace(c)) {
                                        parser.state = S.PROC_INST_BODY;
                                    } else {
                                        parser.procInstName += c;
                                    }
                                    continue;

                                case S.PROC_INST_BODY:
                                    if (!parser.procInstBody && isWhitespace(c)) {
                                        continue;
                                    } else if (c === '?') {
                                        parser.state = S.PROC_INST_ENDING;
                                    } else {
                                        parser.procInstBody += c;
                                    }
                                    continue;

                                case S.PROC_INST_ENDING:
                                    if (c === '>') {
                                        emitNode(parser, 'onprocessinginstruction', {
                                            name: parser.procInstName,
                                            body: parser.procInstBody
                                        });
                                        parser.procInstName = parser.procInstBody = '';
                                        parser.state = S.TEXT;
                                    } else {
                                        parser.procInstBody += '?' + c;
                                        parser.state = S.PROC_INST_BODY;
                                    }
                                    continue;

                                case S.OPEN_TAG:
                                    if (isMatch(nameBody, c)) {
                                        parser.tagName += c;
                                    } else {
                                        newTag(parser);
                                        if (c === '>') {
                                            openTag(parser);
                                        } else if (c === '/') {
                                            parser.state = S.OPEN_TAG_SLASH;
                                        } else {
                                            if (!isWhitespace(c)) {
                                                strictFail(parser, 'Invalid character in tag name');
                                            }
                                            parser.state = S.ATTRIB;
                                        }
                                    }
                                    continue;

                                case S.OPEN_TAG_SLASH:
                                    if (c === '>') {
                                        openTag(parser, true);
                                        closeTag(parser);
                                    } else {
                                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                                        parser.state = S.ATTRIB;
                                    }
                                    continue;

                                case S.ATTRIB:
                                    // haven't read the attribute name yet.
                                    if (isWhitespace(c)) {
                                        continue;
                                    } else if (c === '>') {
                                        openTag(parser);
                                    } else if (c === '/') {
                                        parser.state = S.OPEN_TAG_SLASH;
                                    } else if (isMatch(nameStart, c)) {
                                        parser.attribName = c;
                                        parser.attribValue = '';
                                        parser.state = S.ATTRIB_NAME;
                                    } else {
                                        strictFail(parser, 'Invalid attribute name');
                                    }
                                    continue;

                                case S.ATTRIB_NAME:
                                    if (c === '=') {
                                        parser.state = S.ATTRIB_VALUE;
                                    } else if (c === '>') {
                                        strictFail(parser, 'Attribute without value');
                                        parser.attribValue = parser.attribName;
                                        attrib(parser);
                                        openTag(parser);
                                    } else if (isWhitespace(c)) {
                                        parser.state = S.ATTRIB_NAME_SAW_WHITE;
                                    } else if (isMatch(nameBody, c)) {
                                        parser.attribName += c;
                                    } else {
                                        strictFail(parser, 'Invalid attribute name');
                                    }
                                    continue;

                                case S.ATTRIB_NAME_SAW_WHITE:
                                    if (c === '=') {
                                        parser.state = S.ATTRIB_VALUE;
                                    } else if (isWhitespace(c)) {
                                        continue;
                                    } else {
                                        strictFail(parser, 'Attribute without value');
                                        parser.tag.attributes[parser.attribName] = '';
                                        parser.attribValue = '';
                                        emitNode(parser, 'onattribute', {
                                            name: parser.attribName,
                                            value: ''
                                        });
                                        parser.attribName = '';
                                        if (c === '>') {
                                            openTag(parser);
                                        } else if (isMatch(nameStart, c)) {
                                            parser.attribName = c;
                                            parser.state = S.ATTRIB_NAME;
                                        } else {
                                            strictFail(parser, 'Invalid attribute name');
                                            parser.state = S.ATTRIB;
                                        }
                                    }
                                    continue;

                                case S.ATTRIB_VALUE:
                                    if (isWhitespace(c)) {
                                        continue;
                                    } else if (isQuote(c)) {
                                        parser.q = c;
                                        parser.state = S.ATTRIB_VALUE_QUOTED;
                                    } else {
                                        strictFail(parser, 'Unquoted attribute value');
                                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                                        parser.attribValue = c;
                                    }
                                    continue;

                                case S.ATTRIB_VALUE_QUOTED:
                                    if (c !== parser.q) {
                                        if (c === '&') {
                                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                                        } else {
                                            parser.attribValue += c;
                                        }
                                        continue;
                                    }
                                    attrib(parser);
                                    parser.q = '';
                                    parser.state = S.ATTRIB_VALUE_CLOSED;
                                    continue;

                                case S.ATTRIB_VALUE_CLOSED:
                                    if (isWhitespace(c)) {
                                        parser.state = S.ATTRIB;
                                    } else if (c === '>') {
                                        openTag(parser);
                                    } else if (c === '/') {
                                        parser.state = S.OPEN_TAG_SLASH;
                                    } else if (isMatch(nameStart, c)) {
                                        strictFail(parser, 'No whitespace between attributes');
                                        parser.attribName = c;
                                        parser.attribValue = '';
                                        parser.state = S.ATTRIB_NAME;
                                    } else {
                                        strictFail(parser, 'Invalid attribute name');
                                    }
                                    continue;

                                case S.ATTRIB_VALUE_UNQUOTED:
                                    if (!isAttribEnd(c)) {
                                        if (c === '&') {
                                            parser.state = S.ATTRIB_VALUE_ENTITY_U;
                                        } else {
                                            parser.attribValue += c;
                                        }
                                        continue;
                                    }
                                    attrib(parser);
                                    if (c === '>') {
                                        openTag(parser);
                                    } else {
                                        parser.state = S.ATTRIB;
                                    }
                                    continue;

                                case S.CLOSE_TAG:
                                    if (!parser.tagName) {
                                        if (isWhitespace(c)) {
                                            continue;
                                        } else if (notMatch(nameStart, c)) {
                                            if (parser.script) {
                                                parser.script += '</' + c;
                                                parser.state = S.SCRIPT;
                                            } else {
                                                strictFail(parser, 'Invalid tagname in closing tag.');
                                            }
                                        } else {
                                            parser.tagName = c;
                                        }
                                    } else if (c === '>') {
                                        closeTag(parser);
                                    } else if (isMatch(nameBody, c)) {
                                        parser.tagName += c;
                                    } else if (parser.script) {
                                        parser.script += '</' + parser.tagName;
                                        parser.tagName = '';
                                        parser.state = S.SCRIPT;
                                    } else {
                                        if (!isWhitespace(c)) {
                                            strictFail(parser, 'Invalid tagname in closing tag');
                                        }
                                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                                    }
                                    continue;

                                case S.CLOSE_TAG_SAW_WHITE:
                                    if (isWhitespace(c)) {
                                        continue;
                                    }
                                    if (c === '>') {
                                        closeTag(parser);
                                    } else {
                                        strictFail(parser, 'Invalid characters in closing tag');
                                    }
                                    continue;

                                case S.TEXT_ENTITY:
                                case S.ATTRIB_VALUE_ENTITY_Q:
                                case S.ATTRIB_VALUE_ENTITY_U:
                                    var returnState;
                                    var buffer;
                                    switch (parser.state) {
                                        case S.TEXT_ENTITY:
                                            returnState = S.TEXT;
                                            buffer = 'textNode';
                                            break;

                                        case S.ATTRIB_VALUE_ENTITY_Q:
                                            returnState = S.ATTRIB_VALUE_QUOTED;
                                            buffer = 'attribValue';
                                            break;

                                        case S.ATTRIB_VALUE_ENTITY_U:
                                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                                            buffer = 'attribValue';
                                            break;
                                    }

                                    if (c === ';') {
                                        parser[buffer] += parseEntity(parser);
                                        parser.entity = '';
                                        parser.state = returnState;
                                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                                        parser.entity += c;
                                    } else {
                                        strictFail(parser, 'Invalid character in entity name');
                                        parser[buffer] += '&' + parser.entity + c;
                                        parser.entity = '';
                                        parser.state = returnState;
                                    }

                                    continue;

                                default:
                                    throw new Error(parser, 'Unknown state: ' + parser.state);
                            }
                        } // while

                        if (parser.position >= parser.bufferCheckPosition) {
                            checkBufferLength(parser);
                        }
                        return parser;
                    }

                    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
                    /* istanbul ignore next */
                    if (!String.fromCodePoint) {
                        (function() {
                            var stringFromCharCode = String.fromCharCode;
                            var floor = Math.floor;
                            var fromCodePoint = function() {
                                var MAX_SIZE = 0x4000;
                                var codeUnits = [];
                                var highSurrogate;
                                var lowSurrogate;
                                var index = -1;
                                var length = arguments.length;
                                if (!length) {
                                    return '';
                                }
                                var result = '';
                                while (++index < length) {
                                    var codePoint = Number(arguments[index]);
                                    if (
                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                        codePoint < 0 || // not a valid Unicode code point
                                        codePoint > 0x10FFFF || // not a valid Unicode code point
                                        floor(codePoint) !== codePoint // not an integer
                                    ) {
                                        throw RangeError('Invalid code point: ' + codePoint);
                                    }
                                    if (codePoint <= 0xFFFF) { // BMP code point
                                        codeUnits.push(codePoint);
                                    } else { // Astral code point; split in surrogate halves
                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                        codePoint -= 0x10000;
                                        highSurrogate = (codePoint >> 10) + 0xD800;
                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                        codeUnits.push(highSurrogate, lowSurrogate);
                                    }
                                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                                        result += stringFromCharCode.apply(null, codeUnits);
                                        codeUnits.length = 0;
                                    }
                                }
                                return result;
                            };
                            /* istanbul ignore next */
                            if (Object.defineProperty) {
                                Object.defineProperty(String, 'fromCodePoint', {
                                    value: fromCodePoint,
                                    configurable: true,
                                    writable: true
                                });
                            } else {
                                String.fromCodePoint = fromCodePoint;
                            }
                        }());
                    }
                })(typeof exports === 'undefined' ? this.sax = {} : exports);

            }).call(this, require('buffer').Buffer);
        }, { 'buffer': 59, 'stream': 179, 'string_decoder': 184 }],
        171: [function(require, module, exports) {
            var Buffer = require('safe-buffer').Buffer;

// prototype class for hash functions
            function Hash(blockSize, finalSize) {
                this._block = Buffer.alloc(blockSize);
                this._finalSize = finalSize;
                this._blockSize = blockSize;
                this._len = 0;
            }

            Hash.prototype.update = function(data, enc) {
                if (typeof data === 'string') {
                    enc = enc || 'utf8';
                    data = Buffer.from(data, enc);
                }

                var block = this._block;
                var blockSize = this._blockSize;
                var length = data.length;
                var accum = this._len;

                for (var offset = 0; offset < length;) {
                    var assigned = accum % blockSize;
                    var remainder = Math.min(length - offset, blockSize - assigned);

                    for (var i = 0; i < remainder; i++) {
                        block[assigned + i] = data[offset + i];
                    }

                    accum += remainder;
                    offset += remainder;

                    if ((accum % blockSize) === 0) {
                        this._update(block);
                    }
                }

                this._len += length;
                return this;
            };

            Hash.prototype.digest = function(enc) {
                var rem = this._len % this._blockSize;

                this._block[rem] = 0x80;

                // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
                // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
                this._block.fill(0, rem + 1);

                if (rem >= this._finalSize) {
                    this._update(this._block);
                    this._block.fill(0);
                }

                var bits = this._len * 8;

                // uint32
                if (bits <= 0xffffffff) {
                    this._block.writeUInt32BE(bits, this._blockSize - 4);

                    // uint64
                } else {
                    var lowBits = (bits & 0xffffffff) >>> 0;
                    var highBits = (bits - lowBits) / 0x100000000;

                    this._block.writeUInt32BE(highBits, this._blockSize - 8);
                    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
                }

                this._update(this._block);
                var hash = this._hash();

                return enc ? hash.toString(enc) : hash;
            };

            Hash.prototype._update = function() {
                throw new Error('_update must be implemented by subclass');
            };

            module.exports = Hash;

        }, { 'safe-buffer': 169 }],
        172: [function(require, module, exports) {
            var exports = module.exports = function SHA(algorithm) {
                algorithm = algorithm.toLowerCase();

                var Algorithm = exports[algorithm];
                if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');

                return new Algorithm();
            };

            exports.sha = require('./sha');
            exports.sha1 = require('./sha1');
            exports.sha224 = require('./sha224');
            exports.sha256 = require('./sha256');
            exports.sha384 = require('./sha384');
            exports.sha512 = require('./sha512');

        }, { './sha': 173, './sha1': 174, './sha224': 175, './sha256': 176, './sha384': 177, './sha512': 178 }],
        173: [function(require, module, exports) {
            /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

            var inherits = require('inherits');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var K = [
                0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
            ];

            var W = new Array(80);

            function Sha() {
                this.init();
                this._w = W;

                Hash.call(this, 64, 56);
            }

            inherits(Sha, Hash);

            Sha.prototype.init = function() {
                this._a = 0x67452301;
                this._b = 0xefcdab89;
                this._c = 0x98badcfe;
                this._d = 0x10325476;
                this._e = 0xc3d2e1f0;

                return this;
            };

            function rotl5(num) {
                return (num << 5) | (num >>> 27);
            }

            function rotl30(num) {
                return (num << 30) | (num >>> 2);
            }

            function ft(s, b, c, d) {
                if (s === 0) return (b & c) | ((~b) & d);
                if (s === 2) return (b & c) | (b & d) | (c & d);
                return b ^ c ^ d;
            }

            Sha.prototype._update = function(M) {
                var W = this._w;

                var a = this._a | 0;
                var b = this._b | 0;
                var c = this._c | 0;
                var d = this._d | 0;
                var e = this._e | 0;

                for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
                for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

                for (var j = 0; j < 80; ++j) {
                    var s = ~~(j / 20);
                    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

                    e = d;
                    d = c;
                    c = rotl30(b);
                    b = a;
                    a = t;
                }

                this._a = (a + this._a) | 0;
                this._b = (b + this._b) | 0;
                this._c = (c + this._c) | 0;
                this._d = (d + this._d) | 0;
                this._e = (e + this._e) | 0;
            };

            Sha.prototype._hash = function() {
                var H = Buffer.allocUnsafe(20);

                H.writeInt32BE(this._a | 0, 0);
                H.writeInt32BE(this._b | 0, 4);
                H.writeInt32BE(this._c | 0, 8);
                H.writeInt32BE(this._d | 0, 12);
                H.writeInt32BE(this._e | 0, 16);

                return H;
            };

            module.exports = Sha;

        }, { './hash': 171, 'inherits': 116, 'safe-buffer': 169 }],
        174: [function(require, module, exports) {
            /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

            var inherits = require('inherits');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var K = [
                0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
            ];

            var W = new Array(80);

            function Sha1() {
                this.init();
                this._w = W;

                Hash.call(this, 64, 56);
            }

            inherits(Sha1, Hash);

            Sha1.prototype.init = function() {
                this._a = 0x67452301;
                this._b = 0xefcdab89;
                this._c = 0x98badcfe;
                this._d = 0x10325476;
                this._e = 0xc3d2e1f0;

                return this;
            };

            function rotl1(num) {
                return (num << 1) | (num >>> 31);
            }

            function rotl5(num) {
                return (num << 5) | (num >>> 27);
            }

            function rotl30(num) {
                return (num << 30) | (num >>> 2);
            }

            function ft(s, b, c, d) {
                if (s === 0) return (b & c) | ((~b) & d);
                if (s === 2) return (b & c) | (b & d) | (c & d);
                return b ^ c ^ d;
            }

            Sha1.prototype._update = function(M) {
                var W = this._w;

                var a = this._a | 0;
                var b = this._b | 0;
                var c = this._c | 0;
                var d = this._d | 0;
                var e = this._e | 0;

                for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
                for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

                for (var j = 0; j < 80; ++j) {
                    var s = ~~(j / 20);
                    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

                    e = d;
                    d = c;
                    c = rotl30(b);
                    b = a;
                    a = t;
                }

                this._a = (a + this._a) | 0;
                this._b = (b + this._b) | 0;
                this._c = (c + this._c) | 0;
                this._d = (d + this._d) | 0;
                this._e = (e + this._e) | 0;
            };

            Sha1.prototype._hash = function() {
                var H = Buffer.allocUnsafe(20);

                H.writeInt32BE(this._a | 0, 0);
                H.writeInt32BE(this._b | 0, 4);
                H.writeInt32BE(this._c | 0, 8);
                H.writeInt32BE(this._d | 0, 12);
                H.writeInt32BE(this._e | 0, 16);

                return H;
            };

            module.exports = Sha1;

        }, { './hash': 171, 'inherits': 116, 'safe-buffer': 169 }],
        175: [function(require, module, exports) {
            /**
             * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
             * in FIPS 180-2
             * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
             * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
             *
             */

            var inherits = require('inherits');
            var Sha256 = require('./sha256');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var W = new Array(64);

            function Sha224() {
                this.init();

                this._w = W; // new Array(64)

                Hash.call(this, 64, 56);
            }

            inherits(Sha224, Sha256);

            Sha224.prototype.init = function() {
                this._a = 0xc1059ed8;
                this._b = 0x367cd507;
                this._c = 0x3070dd17;
                this._d = 0xf70e5939;
                this._e = 0xffc00b31;
                this._f = 0x68581511;
                this._g = 0x64f98fa7;
                this._h = 0xbefa4fa4;

                return this;
            };

            Sha224.prototype._hash = function() {
                var H = Buffer.allocUnsafe(28);

                H.writeInt32BE(this._a, 0);
                H.writeInt32BE(this._b, 4);
                H.writeInt32BE(this._c, 8);
                H.writeInt32BE(this._d, 12);
                H.writeInt32BE(this._e, 16);
                H.writeInt32BE(this._f, 20);
                H.writeInt32BE(this._g, 24);

                return H;
            };

            module.exports = Sha224;

        }, { './hash': 171, './sha256': 176, 'inherits': 116, 'safe-buffer': 169 }],
        176: [function(require, module, exports) {
            /**
             * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
             * in FIPS 180-2
             * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
             * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
             *
             */

            var inherits = require('inherits');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var K = [
                0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
                0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
                0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
                0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
                0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
                0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
                0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
                0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
                0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
                0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
                0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
                0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
                0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
                0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
                0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
                0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
            ];

            var W = new Array(64);

            function Sha256() {
                this.init();

                this._w = W; // new Array(64)

                Hash.call(this, 64, 56);
            }

            inherits(Sha256, Hash);

            Sha256.prototype.init = function() {
                this._a = 0x6a09e667;
                this._b = 0xbb67ae85;
                this._c = 0x3c6ef372;
                this._d = 0xa54ff53a;
                this._e = 0x510e527f;
                this._f = 0x9b05688c;
                this._g = 0x1f83d9ab;
                this._h = 0x5be0cd19;

                return this;
            };

            function ch(x, y, z) {
                return z ^ (x & (y ^ z));
            }

            function maj(x, y, z) {
                return (x & y) | (z & (x | y));
            }

            function sigma0(x) {
                return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
            }

            function sigma1(x) {
                return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
            }

            function gamma0(x) {
                return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
            }

            function gamma1(x) {
                return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
            }

            Sha256.prototype._update = function(M) {
                var W = this._w;

                var a = this._a | 0;
                var b = this._b | 0;
                var c = this._c | 0;
                var d = this._d | 0;
                var e = this._e | 0;
                var f = this._f | 0;
                var g = this._g | 0;
                var h = this._h | 0;

                for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
                for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

                for (var j = 0; j < 64; ++j) {
                    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0;
                    var T2 = (sigma0(a) + maj(a, b, c)) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + T1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (T1 + T2) | 0;
                }

                this._a = (a + this._a) | 0;
                this._b = (b + this._b) | 0;
                this._c = (c + this._c) | 0;
                this._d = (d + this._d) | 0;
                this._e = (e + this._e) | 0;
                this._f = (f + this._f) | 0;
                this._g = (g + this._g) | 0;
                this._h = (h + this._h) | 0;
            };

            Sha256.prototype._hash = function() {
                var H = Buffer.allocUnsafe(32);

                H.writeInt32BE(this._a, 0);
                H.writeInt32BE(this._b, 4);
                H.writeInt32BE(this._c, 8);
                H.writeInt32BE(this._d, 12);
                H.writeInt32BE(this._e, 16);
                H.writeInt32BE(this._f, 20);
                H.writeInt32BE(this._g, 24);
                H.writeInt32BE(this._h, 28);

                return H;
            };

            module.exports = Sha256;

        }, { './hash': 171, 'inherits': 116, 'safe-buffer': 169 }],
        177: [function(require, module, exports) {
            var inherits = require('inherits');
            var SHA512 = require('./sha512');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var W = new Array(160);

            function Sha384() {
                this.init();
                this._w = W;

                Hash.call(this, 128, 112);
            }

            inherits(Sha384, SHA512);

            Sha384.prototype.init = function() {
                this._ah = 0xcbbb9d5d;
                this._bh = 0x629a292a;
                this._ch = 0x9159015a;
                this._dh = 0x152fecd8;
                this._eh = 0x67332667;
                this._fh = 0x8eb44a87;
                this._gh = 0xdb0c2e0d;
                this._hh = 0x47b5481d;

                this._al = 0xc1059ed8;
                this._bl = 0x367cd507;
                this._cl = 0x3070dd17;
                this._dl = 0xf70e5939;
                this._el = 0xffc00b31;
                this._fl = 0x68581511;
                this._gl = 0x64f98fa7;
                this._hl = 0xbefa4fa4;

                return this;
            };

            Sha384.prototype._hash = function() {
                var H = Buffer.allocUnsafe(48);

                function writeInt64BE(h, l, offset) {
                    H.writeInt32BE(h, offset);
                    H.writeInt32BE(l, offset + 4);
                }

                writeInt64BE(this._ah, this._al, 0);
                writeInt64BE(this._bh, this._bl, 8);
                writeInt64BE(this._ch, this._cl, 16);
                writeInt64BE(this._dh, this._dl, 24);
                writeInt64BE(this._eh, this._el, 32);
                writeInt64BE(this._fh, this._fl, 40);

                return H;
            };

            module.exports = Sha384;

        }, { './hash': 171, './sha512': 178, 'inherits': 116, 'safe-buffer': 169 }],
        178: [function(require, module, exports) {
            var inherits = require('inherits');
            var Hash = require('./hash');
            var Buffer = require('safe-buffer').Buffer;

            var K = [
                0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
                0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
                0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
                0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
                0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
                0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
                0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
                0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
                0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
                0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
                0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
                0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
                0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
                0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
                0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
                0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
                0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
                0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
                0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
                0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
                0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
                0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
                0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
                0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
                0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
                0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
                0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
                0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
                0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
                0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
                0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
                0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
                0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
                0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
                0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
                0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
            ];

            var W = new Array(160);

            function Sha512() {
                this.init();
                this._w = W;

                Hash.call(this, 128, 112);
            }

            inherits(Sha512, Hash);

            Sha512.prototype.init = function() {
                this._ah = 0x6a09e667;
                this._bh = 0xbb67ae85;
                this._ch = 0x3c6ef372;
                this._dh = 0xa54ff53a;
                this._eh = 0x510e527f;
                this._fh = 0x9b05688c;
                this._gh = 0x1f83d9ab;
                this._hh = 0x5be0cd19;

                this._al = 0xf3bcc908;
                this._bl = 0x84caa73b;
                this._cl = 0xfe94f82b;
                this._dl = 0x5f1d36f1;
                this._el = 0xade682d1;
                this._fl = 0x2b3e6c1f;
                this._gl = 0xfb41bd6b;
                this._hl = 0x137e2179;

                return this;
            };

            function Ch(x, y, z) {
                return z ^ (x & (y ^ z));
            }

            function maj(x, y, z) {
                return (x & y) | (z & (x | y));
            }

            function sigma0(x, xl) {
                return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
            }

            function sigma1(x, xl) {
                return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
            }

            function Gamma0(x, xl) {
                return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7);
            }

            function Gamma0l(x, xl) {
                return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
            }

            function Gamma1(x, xl) {
                return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6);
            }

            function Gamma1l(x, xl) {
                return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
            }

            function getCarry(a, b) {
                return (a >>> 0) < (b >>> 0) ? 1 : 0;
            }

            Sha512.prototype._update = function(M) {
                var W = this._w;

                var ah = this._ah | 0;
                var bh = this._bh | 0;
                var ch = this._ch | 0;
                var dh = this._dh | 0;
                var eh = this._eh | 0;
                var fh = this._fh | 0;
                var gh = this._gh | 0;
                var hh = this._hh | 0;

                var al = this._al | 0;
                var bl = this._bl | 0;
                var cl = this._cl | 0;
                var dl = this._dl | 0;
                var el = this._el | 0;
                var fl = this._fl | 0;
                var gl = this._gl | 0;
                var hl = this._hl | 0;

                for (var i = 0; i < 32; i += 2) {
                    W[i] = M.readInt32BE(i * 4);
                    W[i + 1] = M.readInt32BE(i * 4 + 4);
                }
                for (; i < 160; i += 2) {
                    var xh = W[i - 15 * 2];
                    var xl = W[i - 15 * 2 + 1];
                    var gamma0 = Gamma0(xh, xl);
                    var gamma0l = Gamma0l(xl, xh);

                    xh = W[i - 2 * 2];
                    xl = W[i - 2 * 2 + 1];
                    var gamma1 = Gamma1(xh, xl);
                    var gamma1l = Gamma1l(xl, xh);

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7h = W[i - 7 * 2];
                    var Wi7l = W[i - 7 * 2 + 1];

                    var Wi16h = W[i - 16 * 2];
                    var Wi16l = W[i - 16 * 2 + 1];

                    var Wil = (gamma0l + Wi7l) | 0;
                    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
                    Wil = (Wil + gamma1l) | 0;
                    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
                    Wil = (Wil + Wi16l) | 0;
                    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

                    W[i] = Wih;
                    W[i + 1] = Wil;
                }

                for (var j = 0; j < 160; j += 2) {
                    Wih = W[j];
                    Wil = W[j + 1];

                    var majh = maj(ah, bh, ch);
                    var majl = maj(al, bl, cl);

                    var sigma0h = sigma0(ah, al);
                    var sigma0l = sigma0(al, ah);
                    var sigma1h = sigma1(eh, el);
                    var sigma1l = sigma1(el, eh);

                    // t1 = h + sigma1 + ch + K[j] + W[j]
                    var Kih = K[j];
                    var Kil = K[j + 1];

                    var chh = Ch(eh, fh, gh);
                    var chl = Ch(el, fl, gl);

                    var t1l = (hl + sigma1l) | 0;
                    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
                    t1l = (t1l + chl) | 0;
                    t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
                    t1l = (t1l + Kil) | 0;
                    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
                    t1l = (t1l + Wil) | 0;
                    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

                    // t2 = sigma0 + maj
                    var t2l = (sigma0l + majl) | 0;
                    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

                    hh = gh;
                    hl = gl;
                    gh = fh;
                    gl = fl;
                    fh = eh;
                    fl = el;
                    el = (dl + t1l) | 0;
                    eh = (dh + t1h + getCarry(el, dl)) | 0;
                    dh = ch;
                    dl = cl;
                    ch = bh;
                    cl = bl;
                    bh = ah;
                    bl = al;
                    al = (t1l + t2l) | 0;
                    ah = (t1h + t2h + getCarry(al, t1l)) | 0;
                }

                this._al = (this._al + al) | 0;
                this._bl = (this._bl + bl) | 0;
                this._cl = (this._cl + cl) | 0;
                this._dl = (this._dl + dl) | 0;
                this._el = (this._el + el) | 0;
                this._fl = (this._fl + fl) | 0;
                this._gl = (this._gl + gl) | 0;
                this._hl = (this._hl + hl) | 0;

                this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
                this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
                this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
                this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
                this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
                this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
                this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
                this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
            };

            Sha512.prototype._hash = function() {
                var H = Buffer.allocUnsafe(64);

                function writeInt64BE(h, l, offset) {
                    H.writeInt32BE(h, offset);
                    H.writeInt32BE(l, offset + 4);
                }

                writeInt64BE(this._ah, this._al, 0);
                writeInt64BE(this._bh, this._bl, 8);
                writeInt64BE(this._ch, this._cl, 16);
                writeInt64BE(this._dh, this._dl, 24);
                writeInt64BE(this._eh, this._el, 32);
                writeInt64BE(this._fh, this._fl, 40);
                writeInt64BE(this._gh, this._gl, 48);
                writeInt64BE(this._hh, this._hl, 56);

                return H;
            };

            module.exports = Sha512;

        }, { './hash': 171, 'inherits': 116, 'safe-buffer': 169 }],
        179: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            module.exports = Stream;

            var EE = require('events').EventEmitter;
            var inherits = require('inherits');

            inherits(Stream, EE);
            Stream.Readable = require('readable-stream/readable.js');
            Stream.Writable = require('readable-stream/writable.js');
            Stream.Duplex = require('readable-stream/duplex.js');
            Stream.Transform = require('readable-stream/transform.js');
            Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
            Stream.Stream = Stream;


// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

            function Stream() {
                EE.call(this);
            }

            Stream.prototype.pipe = function(dest, options) {
                var source = this;

                function ondata(chunk) {
                    if (dest.writable) {
                        if (false === dest.write(chunk) && source.pause) {
                            source.pause();
                        }
                    }
                }

                source.on('data', ondata);

                function ondrain() {
                    if (source.readable && source.resume) {
                        source.resume();
                    }
                }

                dest.on('drain', ondrain);

                // If the 'end' option is not supplied, dest.end() will be called when
                // source gets the 'end' or 'close' events.  Only dest.end() once.
                if (!dest._isStdio && (!options || options.end !== false)) {
                    source.on('end', onend);
                    source.on('close', onclose);
                }

                var didOnEnd = false;

                function onend() {
                    if (didOnEnd) return;
                    didOnEnd = true;

                    dest.end();
                }


                function onclose() {
                    if (didOnEnd) return;
                    didOnEnd = true;

                    if (typeof dest.destroy === 'function') dest.destroy();
                }

                // don't leave dangling pipes when there are errors.
                function onerror(er) {
                    cleanup();
                    if (EE.listenerCount(this, 'error') === 0) {
                        throw er; // Unhandled stream error in pipe.
                    }
                }

                source.on('error', onerror);
                dest.on('error', onerror);

                // remove all the event listeners that were added.
                function cleanup() {
                    source.removeListener('data', ondata);
                    dest.removeListener('drain', ondrain);

                    source.removeListener('end', onend);
                    source.removeListener('close', onclose);

                    source.removeListener('error', onerror);
                    dest.removeListener('error', onerror);

                    source.removeListener('end', cleanup);
                    source.removeListener('close', cleanup);

                    dest.removeListener('close', cleanup);
                }

                source.on('end', cleanup);
                source.on('close', cleanup);

                dest.on('close', cleanup);

                dest.emit('pipe', source);

                // Allow for unix-like usage: A.pipe(B).pipe(C)
                return dest;
            };

        }, {
            'events': 97,
            'inherits': 116,
            'readable-stream/duplex.js': 154,
            'readable-stream/passthrough.js': 164,
            'readable-stream/readable.js': 165,
            'readable-stream/transform.js': 166,
            'readable-stream/writable.js': 167
        }],
        180: [function(require, module, exports) {
            (function(global) {
                var ClientRequest = require('./lib/request');
                var response = require('./lib/response');
                var extend = require('xtend');
                var statusCodes = require('builtin-status-codes');
                var url = require('url');

                var http = exports;

                http.request = function(opts, cb) {
                    if (typeof opts === 'string')
                        opts = url.parse(opts);
                    else
                        opts = extend(opts);

                    // Normally, the page is loaded from http or https, so not specifying a protocol
                    // will result in a (valid) protocol-relative url. However, this won't work if
                    // the protocol is something else, like 'file:'
                    var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';

                    var protocol = opts.protocol || defaultProtocol;
                    var host = opts.hostname || opts.host;
                    var port = opts.port;
                    var path = opts.path || '/';

                    // Necessary for IPv6 addresses
                    if (host && host.indexOf(':') !== -1)
                        host = '[' + host + ']';

                    // This may be a relative url. The browser should always be able to interpret it correctly.
                    opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path;
                    opts.method = (opts.method || 'GET').toUpperCase();
                    opts.headers = opts.headers || {};

                    // Also valid opts.auth, opts.mode

                    var req = new ClientRequest(opts);
                    if (cb)
                        req.on('response', cb);
                    return req;
                };

                http.get = function get(opts, cb) {
                    var req = http.request(opts, cb);
                    req.end();
                    return req;
                };

                http.ClientRequest = ClientRequest;
                http.IncomingMessage = response.IncomingMessage;

                http.Agent = function() {
                };
                http.Agent.defaultMaxSockets = 4;

                http.globalAgent = new http.Agent();

                http.STATUS_CODES = statusCodes;

                http.METHODS = [
                    'CHECKOUT',
                    'CONNECT',
                    'COPY',
                    'DELETE',
                    'GET',
                    'HEAD',
                    'LOCK',
                    'M-SEARCH',
                    'MERGE',
                    'MKACTIVITY',
                    'MKCOL',
                    'MOVE',
                    'NOTIFY',
                    'OPTIONS',
                    'PATCH',
                    'POST',
                    'PROPFIND',
                    'PROPPATCH',
                    'PURGE',
                    'PUT',
                    'REPORT',
                    'SEARCH',
                    'SUBSCRIBE',
                    'TRACE',
                    'UNLOCK',
                    'UNSUBSCRIBE'
                ];
            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { './lib/request': 182, './lib/response': 183, 'builtin-status-codes': 60, 'url': 194, 'xtend': 230 }],
        181: [function(require, module, exports) {
            (function(global) {
                exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);

                exports.writableStream = isFunction(global.WritableStream);

                exports.abortController = isFunction(global.AbortController);

                exports.blobConstructor = false;
                try {
                    new Blob([new ArrayBuffer(1)]);
                    exports.blobConstructor = true;
                } catch (e) {
                }

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
                var xhr;

                function getXHR() {
                    // Cache the xhr value
                    if (xhr !== undefined) return xhr;

                    if (global.XMLHttpRequest) {
                        xhr = new global.XMLHttpRequest();
                        // If XDomainRequest is available (ie only, where xhr might not work
                        // cross domain), use the page location. Otherwise use example.com
                        // Note: this doesn't actually make an http request.
                        try {
                            xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');
                        } catch (e) {
                            xhr = null;
                        }
                    } else {
                        // Service workers don't have XHR
                        xhr = null;
                    }
                    return xhr;
                }

                function checkTypeSupport(type) {
                    var xhr = getXHR();
                    if (!xhr) return false;
                    try {
                        xhr.responseType = type;
                        return xhr.responseType === type;
                    } catch (e) {
                    }
                    return false;
                }

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
                var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
                var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
                exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'));

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
                exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
                exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
                    checkTypeSupport('moz-chunked-arraybuffer');

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
                exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

                exports.vbArray = isFunction(global.VBArray);

                function isFunction(value) {
                    return typeof value === 'function';
                }

                xhr = null; // Help gc

            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, {}],
        182: [function(require, module, exports) {
            (function(process, global, Buffer) {
                var capability = require('./capability');
                var inherits = require('inherits');
                var response = require('./response');
                var stream = require('readable-stream');
                var toArrayBuffer = require('to-arraybuffer');

                var IncomingMessage = response.IncomingMessage;
                var rStates = response.readyStates;

                function decideMode(preferBinary, useFetch) {
                    if (capability.fetch && useFetch) {
                        return 'fetch';
                    } else if (capability.mozchunkedarraybuffer) {
                        return 'moz-chunked-arraybuffer';
                    } else if (capability.msstream) {
                        return 'ms-stream';
                    } else if (capability.arraybuffer && preferBinary) {
                        return 'arraybuffer';
                    } else if (capability.vbArray && preferBinary) {
                        return 'text:vbarray';
                    } else {
                        return 'text';
                    }
                }

                var ClientRequest = module.exports = function(opts) {
                    var self = this;
                    stream.Writable.call(self);

                    self._opts = opts;
                    self._body = [];
                    self._headers = {};
                    if (opts.auth)
                        self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
                    Object.keys(opts.headers).forEach(function(name) {
                        self.setHeader(name, opts.headers[name]);
                    });

                    var preferBinary;
                    var useFetch = true;
                    if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
                        // If the use of XHR should be preferred. Not typically needed.
                        useFetch = false;
                        preferBinary = true;
                    } else if (opts.mode === 'prefer-streaming') {
                        // If streaming is a high priority but binary compatibility and
                        // the accuracy of the 'content-type' header aren't
                        preferBinary = false;
                    } else if (opts.mode === 'allow-wrong-content-type') {
                        // If streaming is more important than preserving the 'content-type' header
                        preferBinary = !capability.overrideMimeType;
                    } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
                        // Use binary if text streaming may corrupt data or the content-type header, or for speed
                        preferBinary = true;
                    } else {
                        throw new Error('Invalid value for opts.mode');
                    }
                    self._mode = decideMode(preferBinary, useFetch);
                    self._fetchTimer = null;

                    self.on('finish', function() {
                        self._onFinish();
                    });
                };

                inherits(ClientRequest, stream.Writable);

                ClientRequest.prototype.setHeader = function(name, value) {
                    var self = this;
                    var lowerName = name.toLowerCase();
                    // This check is not necessary, but it prevents warnings from browsers about setting unsafe
                    // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
                    // http-browserify did it, so I will too.
                    if (unsafeHeaders.indexOf(lowerName) !== -1)
                        return;

                    self._headers[lowerName] = {
                        name: name,
                        value: value
                    };
                };

                ClientRequest.prototype.getHeader = function(name) {
                    var header = this._headers[name.toLowerCase()];
                    if (header)
                        return header.value;
                    return null;
                };

                ClientRequest.prototype.removeHeader = function(name) {
                    var self = this;
                    delete self._headers[name.toLowerCase()];
                };

                ClientRequest.prototype._onFinish = function() {
                    var self = this;

                    if (self._destroyed)
                        return;
                    var opts = self._opts;

                    var headersObj = self._headers;
                    var body = null;
                    if (opts.method !== 'GET' && opts.method !== 'HEAD') {
                        if (capability.arraybuffer) {
                            body = toArrayBuffer(Buffer.concat(self._body));
                        } else if (capability.blobConstructor) {
                            body = new global.Blob(self._body.map(function(buffer) {
                                return toArrayBuffer(buffer);
                            }), {
                                type: (headersObj['content-type'] || {}).value || ''
                            });
                        } else {
                            // get utf8 string
                            body = Buffer.concat(self._body).toString();
                        }
                    }

                    // create flattened list of headers
                    var headersList = [];
                    Object.keys(headersObj).forEach(function(keyName) {
                        var name = headersObj[keyName].name;
                        var value = headersObj[keyName].value;
                        if (Array.isArray(value)) {
                            value.forEach(function(v) {
                                headersList.push([name, v]);
                            });
                        } else {
                            headersList.push([name, value]);
                        }
                    });

                    if (self._mode === 'fetch') {
                        var signal = null;
                        var fetchTimer = null;
                        if (capability.abortController) {
                            var controller = new AbortController();
                            signal = controller.signal;
                            self._fetchAbortController = controller;

                            if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
                                self._fetchTimer = global.setTimeout(function() {
                                    self.emit('requestTimeout');
                                    if (self._fetchAbortController)
                                        self._fetchAbortController.abort();
                                }, opts.requestTimeout);
                            }
                        }

                        global.fetch(self._opts.url, {
                            method: self._opts.method,
                            headers: headersList,
                            body: body || undefined,
                            mode: 'cors',
                            credentials: opts.withCredentials ? 'include' : 'same-origin',
                            signal: signal
                        }).then(function(response) {
                            self._fetchResponse = response;
                            self._connect();
                        }, function(reason) {
                            global.clearTimeout(self._fetchTimer);
                            if (!self._destroyed)
                                self.emit('error', reason);
                        });
                    } else {
                        var xhr = self._xhr = new global.XMLHttpRequest();
                        try {
                            xhr.open(self._opts.method, self._opts.url, true);
                        } catch (err) {
                            process.nextTick(function() {
                                self.emit('error', err);
                            });
                            return;
                        }

                        // Can't set responseType on really old browsers
                        if ('responseType' in xhr)
                            xhr.responseType = self._mode.split(':')[0];

                        if ('withCredentials' in xhr)
                            xhr.withCredentials = !!opts.withCredentials;

                        if (self._mode === 'text' && 'overrideMimeType' in xhr)
                            xhr.overrideMimeType('text/plain; charset=x-user-defined');

                        if ('requestTimeout' in opts) {
                            xhr.timeout = opts.requestTimeout;
                            xhr.ontimeout = function() {
                                self.emit('requestTimeout');
                            };
                        }

                        headersList.forEach(function(header) {
                            xhr.setRequestHeader(header[0], header[1]);
                        });

                        self._response = null;
                        xhr.onreadystatechange = function() {
                            switch (xhr.readyState) {
                                case rStates.LOADING:
                                case rStates.DONE:
                                    self._onXHRProgress();
                                    break;
                            }
                        };
                        // Necessary for streaming in Firefox, since xhr.response is ONLY defined
                        // in onprogress, not in onreadystatechange with xhr.readyState = 3
                        if (self._mode === 'moz-chunked-arraybuffer') {
                            xhr.onprogress = function() {
                                self._onXHRProgress();
                            };
                        }

                        xhr.onerror = function() {
                            if (self._destroyed)
                                return;
                            self.emit('error', new Error('XHR error'));
                        };

                        try {
                            xhr.send(body);
                        } catch (err) {
                            process.nextTick(function() {
                                self.emit('error', err);
                            });

                        }
                    }
                };

                /**
                 * Checks if xhr.status is readable and non-zero, indicating no error.
                 * Even though the spec says it should be available in readyState 3,
                 * accessing it throws an exception in IE8
                 */
                function statusValid(xhr) {
                    try {
                        var status = xhr.status;
                        return (status !== null && status !== 0);
                    } catch (e) {
                        return false;
                    }
                }

                ClientRequest.prototype._onXHRProgress = function() {
                    var self = this;

                    if (!statusValid(self._xhr) || self._destroyed)
                        return;

                    if (!self._response)
                        self._connect();

                    self._response._onXHRProgress();
                };

                ClientRequest.prototype._connect = function() {
                    var self = this;

                    if (self._destroyed)
                        return;

                    self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);
                    self._response.on('error', function(err) {
                        self.emit('error', err);
                    });

                    self.emit('response', self._response);
                };

                ClientRequest.prototype._write = function(chunk, encoding, cb) {
                    var self = this;

                    self._body.push(chunk);
                    cb();
                };

                ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
                    var self = this;
                    self._destroyed = true;
                    global.clearTimeout(self._fetchTimer);
                    if (self._response)
                        self._response._destroyed = true;
                    if (self._xhr)
                        self._xhr.abort();
                    else if (self._fetchAbortController)
                        self._fetchAbortController.abort();
                };

                ClientRequest.prototype.end = function(data, encoding, cb) {
                    var self = this;
                    if (typeof data === 'function') {
                        cb = data;
                        data = undefined;
                    }

                    stream.Writable.prototype.end.call(self, data, encoding, cb);
                };

                ClientRequest.prototype.flushHeaders = function() {
                };
                ClientRequest.prototype.setTimeout = function() {
                };
                ClientRequest.prototype.setNoDelay = function() {
                };
                ClientRequest.prototype.setSocketKeepAlive = function() {
                };

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
                var unsafeHeaders = [
                    'accept-charset',
                    'accept-encoding',
                    'access-control-request-headers',
                    'access-control-request-method',
                    'connection',
                    'content-length',
                    'cookie',
                    'cookie2',
                    'date',
                    'dnt',
                    'expect',
                    'host',
                    'keep-alive',
                    'origin',
                    'referer',
                    'te',
                    'trailer',
                    'transfer-encoding',
                    'upgrade',
                    'via'
                ];

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer);
        }, {
            './capability': 181,
            './response': 183,
            '_process': 141,
            'buffer': 59,
            'inherits': 116,
            'readable-stream': 165,
            'to-arraybuffer': 193
        }],
        183: [function(require, module, exports) {
            (function(process, global, Buffer) {
                var capability = require('./capability');
                var inherits = require('inherits');
                var stream = require('readable-stream');

                var rStates = exports.readyStates = {
                    UNSENT: 0,
                    OPENED: 1,
                    HEADERS_RECEIVED: 2,
                    LOADING: 3,
                    DONE: 4
                };

                var IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, fetchTimer) {
                    var self = this;
                    stream.Readable.call(self);

                    self._mode = mode;
                    self.headers = {};
                    self.rawHeaders = [];
                    self.trailers = {};
                    self.rawTrailers = [];

                    // Fake the 'close' event, but only once 'end' fires
                    self.on('end', function() {
                        // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
                        process.nextTick(function() {
                            self.emit('close');
                        });
                    });

                    if (mode === 'fetch') {
                        self._fetchResponse = response;

                        self.url = response.url;
                        self.statusCode = response.status;
                        self.statusMessage = response.statusText;

                        response.headers.forEach(function(header, key) {
                            self.headers[key.toLowerCase()] = header;
                            self.rawHeaders.push(key, header);
                        });

                        if (capability.writableStream) {
                            var writable = new WritableStream({
                                write: function(chunk) {
                                    return new Promise(function(resolve, reject) {
                                        if (self._destroyed) {
                                            reject();
                                        } else if (self.push(new Buffer(chunk))) {
                                            resolve();
                                        } else {
                                            self._resumeFetch = resolve;
                                        }
                                    });
                                },
                                close: function() {
                                    global.clearTimeout(fetchTimer);
                                    if (!self._destroyed)
                                        self.push(null);
                                },
                                abort: function(err) {
                                    if (!self._destroyed)
                                        self.emit('error', err);
                                }
                            });

                            try {
                                response.body.pipeTo(writable).catch(function(err) {
                                    global.clearTimeout(fetchTimer);
                                    if (!self._destroyed)
                                        self.emit('error', err);
                                });
                                return;
                            } catch (e) {
                            } // pipeTo method isn't defined. Can't find a better way to feature test this
                        }
                        // fallback for when writableStream or pipeTo aren't available
                        var reader = response.body.getReader();

                        function read() {
                            reader.read().then(function(result) {
                                if (self._destroyed)
                                    return;
                                if (result.done) {
                                    global.clearTimeout(fetchTimer);
                                    self.push(null);
                                    return;
                                }
                                self.push(new Buffer(result.value));
                                read();
                            }).catch(function(err) {
                                global.clearTimeout(fetchTimer);
                                if (!self._destroyed)
                                    self.emit('error', err);
                            });
                        }

                        read();
                    } else {
                        self._xhr = xhr;
                        self._pos = 0;

                        self.url = xhr.responseURL;
                        self.statusCode = xhr.status;
                        self.statusMessage = xhr.statusText;
                        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                        headers.forEach(function(header) {
                            var matches = header.match(/^([^:]+):\s*(.*)/);
                            if (matches) {
                                var key = matches[1].toLowerCase();
                                if (key === 'set-cookie') {
                                    if (self.headers[key] === undefined) {
                                        self.headers[key] = [];
                                    }
                                    self.headers[key].push(matches[2]);
                                } else if (self.headers[key] !== undefined) {
                                    self.headers[key] += ', ' + matches[2];
                                } else {
                                    self.headers[key] = matches[2];
                                }
                                self.rawHeaders.push(matches[1], matches[2]);
                            }
                        });

                        self._charset = 'x-user-defined';
                        if (!capability.overrideMimeType) {
                            var mimeType = self.rawHeaders['mime-type'];
                            if (mimeType) {
                                var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                                if (charsetMatch) {
                                    self._charset = charsetMatch[1].toLowerCase();
                                }
                            }
                            if (!self._charset)
                                self._charset = 'utf-8'; // best guess
                        }
                    }
                };

                inherits(IncomingMessage, stream.Readable);

                IncomingMessage.prototype._read = function() {
                    var self = this;

                    var resolve = self._resumeFetch;
                    if (resolve) {
                        self._resumeFetch = null;
                        resolve();
                    }
                };

                IncomingMessage.prototype._onXHRProgress = function() {
                    var self = this;

                    var xhr = self._xhr;

                    var response = null;
                    switch (self._mode) {
                        case 'text:vbarray': // For IE9
                            if (xhr.readyState !== rStates.DONE)
                                break;
                            try {
                                // This fails in IE8
                                response = new global.VBArray(xhr.responseBody).toArray();
                            } catch (e) {
                            }
                            if (response !== null) {
                                self.push(new Buffer(response));
                                break;
                            }
                        // Falls through in IE8
                        case 'text':
                            try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
                                response = xhr.responseText;
                            } catch (e) {
                                self._mode = 'text:vbarray';
                                break;
                            }
                            if (response.length > self._pos) {
                                var newData = response.substr(self._pos);
                                if (self._charset === 'x-user-defined') {
                                    var buffer = new Buffer(newData.length);
                                    for (var i = 0; i < newData.length; i++)
                                        buffer[i] = newData.charCodeAt(i) & 0xff;

                                    self.push(buffer);
                                } else {
                                    self.push(newData, self._charset);
                                }
                                self._pos = response.length;
                            }
                            break;
                        case 'arraybuffer':
                            if (xhr.readyState !== rStates.DONE || !xhr.response)
                                break;
                            response = xhr.response;
                            self.push(new Buffer(new Uint8Array(response)));
                            break;
                        case 'moz-chunked-arraybuffer': // take whole
                            response = xhr.response;
                            if (xhr.readyState !== rStates.LOADING || !response)
                                break;
                            self.push(new Buffer(new Uint8Array(response)));
                            break;
                        case 'ms-stream':
                            response = xhr.response;
                            if (xhr.readyState !== rStates.LOADING)
                                break;
                            var reader = new global.MSStreamReader();
                            reader.onprogress = function() {
                                if (reader.result.byteLength > self._pos) {
                                    self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
                                    self._pos = reader.result.byteLength;
                                }
                            };
                            reader.onload = function() {
                                self.push(null);
                            };
                            // reader.onerror = ??? // TODO: this
                            reader.readAsArrayBuffer(response);
                            break;
                    }

                    // The ms-stream case handles end separately in reader.onload()
                    if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
                        self.push(null);
                    }
                };

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, require('buffer').Buffer);
        }, { './capability': 181, '_process': 141, 'buffer': 59, 'inherits': 116, 'readable-stream': 165 }],
        184: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            var Buffer = require('buffer').Buffer;

            var isBufferEncoding = Buffer.isEncoding
                || function(encoding) {
                    switch (encoding && encoding.toLowerCase()) {
                        case 'hex':
                        case 'utf8':
                        case 'utf-8':
                        case 'ascii':
                        case 'binary':
                        case 'base64':
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                        case 'raw':
                            return true;
                        default:
                            return false;
                    }
                };


            function assertEncoding(encoding) {
                if (encoding && !isBufferEncoding(encoding)) {
                    throw new Error('Unknown encoding: ' + encoding);
                }
            }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
            var StringDecoder = exports.StringDecoder = function(encoding) {
                this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
                assertEncoding(encoding);
                switch (this.encoding) {
                    case 'utf8':
                        // CESU-8 represents each of Surrogate Pair by 3-bytes
                        this.surrogateSize = 3;
                        break;
                    case 'ucs2':
                    case 'utf16le':
                        // UTF-16 represents each of Surrogate Pair by 2-bytes
                        this.surrogateSize = 2;
                        this.detectIncompleteChar = utf16DetectIncompleteChar;
                        break;
                    case 'base64':
                        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                        this.surrogateSize = 3;
                        this.detectIncompleteChar = base64DetectIncompleteChar;
                        break;
                    default:
                        this.write = passThroughWrite;
                        return;
                }

                // Enough space to store all bytes of a single character. UTF-8 needs 4
                // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
                this.charBuffer = new Buffer(6);
                // Number of bytes received for the current incomplete multi-byte character.
                this.charReceived = 0;
                // Number of bytes expected for the current incomplete multi-byte character.
                this.charLength = 0;
            };


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
            StringDecoder.prototype.write = function(buffer) {
                var charStr = '';
                // if our last write ended with an incomplete multibyte character
                while (this.charLength) {
                    // determine how many remaining bytes this buffer has to offer for this char
                    var available = (buffer.length >= this.charLength - this.charReceived) ?
                        this.charLength - this.charReceived :
                        buffer.length;

                    // add the new bytes to the char buffer
                    buffer.copy(this.charBuffer, this.charReceived, 0, available);
                    this.charReceived += available;

                    if (this.charReceived < this.charLength) {
                        // still not enough chars in this buffer? wait for more ...
                        return '';
                    }

                    // remove bytes belonging to the current character from the buffer
                    buffer = buffer.slice(available, buffer.length);

                    // get the character that was split
                    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

                    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                    var charCode = charStr.charCodeAt(charStr.length - 1);
                    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                        this.charLength += this.surrogateSize;
                        charStr = '';
                        continue;
                    }
                    this.charReceived = this.charLength = 0;

                    // if there are no more bytes in this buffer, just emit our char
                    if (buffer.length === 0) {
                        return charStr;
                    }
                    break;
                }

                // determine and set charLength / charReceived
                this.detectIncompleteChar(buffer);

                var end = buffer.length;
                if (this.charLength) {
                    // buffer the incomplete character bytes we got
                    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                    end -= this.charReceived;
                }

                charStr += buffer.toString(this.encoding, 0, end);

                var end = charStr.length - 1;
                var charCode = charStr.charCodeAt(end);
                // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                    var size = this.surrogateSize;
                    this.charLength += size;
                    this.charReceived += size;
                    this.charBuffer.copy(this.charBuffer, size, 0, size);
                    buffer.copy(this.charBuffer, 0, 0, size);
                    return charStr.substring(0, end);
                }

                // or just emit the charStr
                return charStr;
            };

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
            StringDecoder.prototype.detectIncompleteChar = function(buffer) {
                // determine how many bytes we have to check at the end of this buffer
                var i = (buffer.length >= 3) ? 3 : buffer.length;

                // Figure out if one of the last i bytes of our buffer announces an
                // incomplete char.
                for (; i > 0; i--) {
                    var c = buffer[buffer.length - i];

                    // See http://en.wikipedia.org/wiki/UTF-8#Description

                    // 110XXXXX
                    if (i == 1 && c >> 5 == 0x06) {
                        this.charLength = 2;
                        break;
                    }

                    // 1110XXXX
                    if (i <= 2 && c >> 4 == 0x0E) {
                        this.charLength = 3;
                        break;
                    }

                    // 11110XXX
                    if (i <= 3 && c >> 3 == 0x1E) {
                        this.charLength = 4;
                        break;
                    }
                }
                this.charReceived = i;
            };

            StringDecoder.prototype.end = function(buffer) {
                var res = '';
                if (buffer && buffer.length)
                    res = this.write(buffer);

                if (this.charReceived) {
                    var cr = this.charReceived;
                    var buf = this.charBuffer;
                    var enc = this.encoding;
                    res += buf.slice(0, cr).toString(enc);
                }

                return res;
            };

            function passThroughWrite(buffer) {
                return buffer.toString(this.encoding);
            }

            function utf16DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 2;
                this.charLength = this.charReceived ? 2 : 0;
            }

            function base64DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 3;
                this.charLength = this.charReceived ? 3 : 0;
            }

        }, { 'buffer': 59 }],
        185: [function(require, module, exports) {
            module.exports = Array.isArray || function(arr) {
                return Object.prototype.toString.call(arr) == '[object Array]';
            };

        }, {}],
        186: [function(require, module, exports) {
            (function(process) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

                module.exports = Duplex;

                /*<replacement>*/
                var objectKeys = Object.keys || function(obj) {
                    var keys = [];
                    for (var key in obj) keys.push(key);
                    return keys;
                };
                /*</replacement>*/


                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/

                var Readable = require('./_stream_readable');
                var Writable = require('./_stream_writable');

                util.inherits(Duplex, Readable);

                forEach(objectKeys(Writable.prototype), function(method) {
                    if (!Duplex.prototype[method])
                        Duplex.prototype[method] = Writable.prototype[method];
                });

                function Duplex(options) {
                    if (!(this instanceof Duplex))
                        return new Duplex(options);

                    Readable.call(this, options);
                    Writable.call(this, options);

                    if (options && options.readable === false)
                        this.readable = false;

                    if (options && options.writable === false)
                        this.writable = false;

                    this.allowHalfOpen = true;
                    if (options && options.allowHalfOpen === false)
                        this.allowHalfOpen = false;

                    this.once('end', onend);
                }

// the no-half-open enforcer
                function onend() {
                    // if we allow half-open state, or if the writable side ended,
                    // then we're ok.
                    if (this.allowHalfOpen || this._writableState.ended)
                        return;

                    // no more data can be written.
                    // But allow more writes to happen in this tick.
                    process.nextTick(this.end.bind(this));
                }

                function forEach(xs, f) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        f(xs[i], i);
                    }
                }

            }).call(this, require('_process'));
        }, {
            './_stream_readable': 187,
            './_stream_writable': 189,
            '_process': 141,
            'core-util-is': 62,
            'inherits': 116
        }],
        187: [function(require, module, exports) {
            (function(process) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

                module.exports = Readable;

                /*<replacement>*/
                var isArray = require('isarray');
                /*</replacement>*/


                /*<replacement>*/
                var Buffer = require('buffer').Buffer;
                /*</replacement>*/

                Readable.ReadableState = ReadableState;

                var EE = require('events').EventEmitter;

                /*<replacement>*/
                if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
                    return emitter.listeners(type).length;
                };
                /*</replacement>*/

                var Stream = require('stream');

                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/

                var StringDecoder;

                util.inherits(Readable, Stream);

                function ReadableState(options, stream) {
                    options = options || {};

                    // the point at which it stops calling _read() to fill the buffer
                    // Note: 0 is a valid value, means "don't call _read preemptively ever"
                    var hwm = options.highWaterMark;
                    this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

                    // cast to ints.
                    this.highWaterMark = ~~this.highWaterMark;

                    this.buffer = [];
                    this.length = 0;
                    this.pipes = null;
                    this.pipesCount = 0;
                    this.flowing = false;
                    this.ended = false;
                    this.endEmitted = false;
                    this.reading = false;

                    // In streams that never have any data, and do push(null) right away,
                    // the consumer can miss the 'end' event if they do some I/O before
                    // consuming the stream.  So, we don't emit('end') until some reading
                    // happens.
                    this.calledRead = false;

                    // a flag to be able to tell if the onwrite cb is called immediately,
                    // or on a later tick.  We set this to true at first, becuase any
                    // actions that shouldn't happen until "later" should generally also
                    // not happen before the first write call.
                    this.sync = true;

                    // whenever we return null, then we set a flag to say
                    // that we're awaiting a 'readable' event emission.
                    this.needReadable = false;
                    this.emittedReadable = false;
                    this.readableListening = false;


                    // object stream flag. Used to make read(n) ignore n and to
                    // make all the buffer merging and length checks go away
                    this.objectMode = !!options.objectMode;

                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';

                    // when piping, we only care about 'readable' events that happen
                    // after read()ing all the bytes and not getting any pushback.
                    this.ranOut = false;

                    // the number of writers that are awaiting a drain event in .pipe()s
                    this.awaitDrain = 0;

                    // if true, a maybeReadMore has been scheduled
                    this.readingMore = false;

                    this.decoder = null;
                    this.encoding = null;
                    if (options.encoding) {
                        if (!StringDecoder)
                            StringDecoder = require('string_decoder/').StringDecoder;
                        this.decoder = new StringDecoder(options.encoding);
                        this.encoding = options.encoding;
                    }
                }

                function Readable(options) {
                    if (!(this instanceof Readable))
                        return new Readable(options);

                    this._readableState = new ReadableState(options, this);

                    // legacy
                    this.readable = true;

                    Stream.call(this);
                }

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
                Readable.prototype.push = function(chunk, encoding) {
                    var state = this._readableState;

                    if (typeof chunk === 'string' && !state.objectMode) {
                        encoding = encoding || state.defaultEncoding;
                        if (encoding !== state.encoding) {
                            chunk = new Buffer(chunk, encoding);
                            encoding = '';
                        }
                    }

                    return readableAddChunk(this, state, chunk, encoding, false);
                };

// Unshift should *always* be something directly out of read()
                Readable.prototype.unshift = function(chunk) {
                    var state = this._readableState;
                    return readableAddChunk(this, state, chunk, '', true);
                };

                function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                    var er = chunkInvalid(state, chunk);
                    if (er) {
                        stream.emit('error', er);
                    } else if (chunk === null || chunk === undefined) {
                        state.reading = false;
                        if (!state.ended)
                            onEofChunk(stream, state);
                    } else if (state.objectMode || chunk && chunk.length > 0) {
                        if (state.ended && !addToFront) {
                            var e = new Error('stream.push() after EOF');
                            stream.emit('error', e);
                        } else if (state.endEmitted && addToFront) {
                            var e = new Error('stream.unshift() after end event');
                            stream.emit('error', e);
                        } else {
                            if (state.decoder && !addToFront && !encoding)
                                chunk = state.decoder.write(chunk);

                            // update the buffer info.
                            state.length += state.objectMode ? 1 : chunk.length;
                            if (addToFront) {
                                state.buffer.unshift(chunk);
                            } else {
                                state.reading = false;
                                state.buffer.push(chunk);
                            }

                            if (state.needReadable)
                                emitReadable(stream);

                            maybeReadMore(stream, state);
                        }
                    } else if (!addToFront) {
                        state.reading = false;
                    }

                    return needMoreData(state);
                }


// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
                function needMoreData(state) {
                    return !state.ended &&
                        (state.needReadable ||
                            state.length < state.highWaterMark ||
                            state.length === 0);
                }

// backwards compatibility.
                Readable.prototype.setEncoding = function(enc) {
                    if (!StringDecoder)
                        StringDecoder = require('string_decoder/').StringDecoder;
                    this._readableState.decoder = new StringDecoder(enc);
                    this._readableState.encoding = enc;
                };

// Don't raise the hwm > 128MB
                var MAX_HWM = 0x800000;

                function roundUpToNextPowerOf2(n) {
                    if (n >= MAX_HWM) {
                        n = MAX_HWM;
                    } else {
                        // Get the next highest power of 2
                        n--;
                        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                        n++;
                    }
                    return n;
                }

                function howMuchToRead(n, state) {
                    if (state.length === 0 && state.ended)
                        return 0;

                    if (state.objectMode)
                        return n === 0 ? 0 : 1;

                    if (n === null || isNaN(n)) {
                        // only flow one buffer at a time
                        if (state.flowing && state.buffer.length)
                            return state.buffer[0].length;
                        else
                            return state.length;
                    }

                    if (n <= 0)
                        return 0;

                    // If we're asking for more than the target buffer level,
                    // then raise the water mark.  Bump up to the next highest
                    // power of 2, to prevent increasing it excessively in tiny
                    // amounts.
                    if (n > state.highWaterMark)
                        state.highWaterMark = roundUpToNextPowerOf2(n);

                    // don't have that much.  return null, unless we've ended.
                    if (n > state.length) {
                        if (!state.ended) {
                            state.needReadable = true;
                            return 0;
                        } else
                            return state.length;
                    }

                    return n;
                }

// you can override either this method, or the async _read(n) below.
                Readable.prototype.read = function(n) {
                    var state = this._readableState;
                    state.calledRead = true;
                    var nOrig = n;
                    var ret;

                    if (typeof n !== 'number' || n > 0)
                        state.emittedReadable = false;

                    // if we're doing read(0) to trigger a readable event, but we
                    // already have a bunch of data in the buffer, then just trigger
                    // the 'readable' event and move on.
                    if (n === 0 &&
                        state.needReadable &&
                        (state.length >= state.highWaterMark || state.ended)) {
                        emitReadable(this);
                        return null;
                    }

                    n = howMuchToRead(n, state);

                    // if we've ended, and we're now clear, then finish it up.
                    if (n === 0 && state.ended) {
                        ret = null;

                        // In cases where the decoder did not receive enough data
                        // to produce a full chunk, then immediately received an
                        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
                        // howMuchToRead will see this and coerce the amount to
                        // read to zero (because it's looking at the length of the
                        // first <Buffer > in state.buffer), and we'll end up here.
                        //
                        // This can only happen via state.decoder -- no other venue
                        // exists for pushing a zero-length chunk into state.buffer
                        // and triggering this behavior. In this case, we return our
                        // remaining data and end the stream, if appropriate.
                        if (state.length > 0 && state.decoder) {
                            ret = fromList(n, state);
                            state.length -= ret.length;
                        }

                        if (state.length === 0)
                            endReadable(this);

                        return ret;
                    }

                    // All the actual chunk generation logic needs to be
                    // *below* the call to _read.  The reason is that in certain
                    // synthetic stream cases, such as passthrough streams, _read
                    // may be a completely synchronous operation which may change
                    // the state of the read buffer, providing enough data when
                    // before there was *not* enough.
                    //
                    // So, the steps are:
                    // 1. Figure out what the state of things will be after we do
                    // a read from the buffer.
                    //
                    // 2. If that resulting state will trigger a _read, then call _read.
                    // Note that this may be asynchronous, or synchronous.  Yes, it is
                    // deeply ugly to write APIs this way, but that still doesn't mean
                    // that the Readable class should behave improperly, as streams are
                    // designed to be sync/async agnostic.
                    // Take note if the _read call is sync or async (ie, if the read call
                    // has returned yet), so that we know whether or not it's safe to emit
                    // 'readable' etc.
                    //
                    // 3. Actually pull the requested chunks out of the buffer and return.

                    // if we need a readable event, then we need to do some reading.
                    var doRead = state.needReadable;

                    // if we currently have less than the highWaterMark, then also read some
                    if (state.length - n <= state.highWaterMark)
                        doRead = true;

                    // however, if we've ended, then there's no point, and if we're already
                    // reading, then it's unnecessary.
                    if (state.ended || state.reading)
                        doRead = false;

                    if (doRead) {
                        state.reading = true;
                        state.sync = true;
                        // if the length is currently zero, then we *need* a readable event.
                        if (state.length === 0)
                            state.needReadable = true;
                        // call internal read method
                        this._read(state.highWaterMark);
                        state.sync = false;
                    }

                    // If _read called its callback synchronously, then `reading`
                    // will be false, and we need to re-evaluate how much data we
                    // can return to the user.
                    if (doRead && !state.reading)
                        n = howMuchToRead(nOrig, state);

                    if (n > 0)
                        ret = fromList(n, state);
                    else
                        ret = null;

                    if (ret === null) {
                        state.needReadable = true;
                        n = 0;
                    }

                    state.length -= n;

                    // If we have nothing in the buffer, then we want to know
                    // as soon as we *do* get something into the buffer.
                    if (state.length === 0 && !state.ended)
                        state.needReadable = true;

                    // If we happened to read() exactly the remaining amount in the
                    // buffer, and the EOF has been seen at this point, then make sure
                    // that we emit 'end' on the very next tick.
                    if (state.ended && !state.endEmitted && state.length === 0)
                        endReadable(this);

                    return ret;
                };

                function chunkInvalid(state, chunk) {
                    var er = null;
                    if (!Buffer.isBuffer(chunk) &&
                        'string' !== typeof chunk &&
                        chunk !== null &&
                        chunk !== undefined &&
                        !state.objectMode) {
                        er = new TypeError('Invalid non-string/buffer chunk');
                    }
                    return er;
                }


                function onEofChunk(stream, state) {
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length) {
                            state.buffer.push(chunk);
                            state.length += state.objectMode ? 1 : chunk.length;
                        }
                    }
                    state.ended = true;

                    // if we've ended and we have some data left, then emit
                    // 'readable' now to make sure it gets picked up.
                    if (state.length > 0)
                        emitReadable(stream);
                    else
                        endReadable(stream);
                }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
                function emitReadable(stream) {
                    var state = stream._readableState;
                    state.needReadable = false;
                    if (state.emittedReadable)
                        return;

                    state.emittedReadable = true;
                    if (state.sync)
                        process.nextTick(function() {
                            emitReadable_(stream);
                        });
                    else
                        emitReadable_(stream);
                }

                function emitReadable_(stream) {
                    stream.emit('readable');
                }


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
                function maybeReadMore(stream, state) {
                    if (!state.readingMore) {
                        state.readingMore = true;
                        process.nextTick(function() {
                            maybeReadMore_(stream, state);
                        });
                    }
                }

                function maybeReadMore_(stream, state) {
                    var len = state.length;
                    while (!state.reading && !state.flowing && !state.ended &&
                    state.length < state.highWaterMark) {
                        stream.read(0);
                        if (len === state.length)
                            // didn't get any data, stop spinning.
                            break;
                        else
                            len = state.length;
                    }
                    state.readingMore = false;
                }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
                Readable.prototype._read = function(n) {
                    this.emit('error', new Error('not implemented'));
                };

                Readable.prototype.pipe = function(dest, pipeOpts) {
                    var src = this;
                    var state = this._readableState;

                    switch (state.pipesCount) {
                        case 0:
                            state.pipes = dest;
                            break;
                        case 1:
                            state.pipes = [state.pipes, dest];
                            break;
                        default:
                            state.pipes.push(dest);
                            break;
                    }
                    state.pipesCount += 1;

                    var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                        dest !== process.stdout &&
                        dest !== process.stderr;

                    var endFn = doEnd ? onend : cleanup;
                    if (state.endEmitted)
                        process.nextTick(endFn);
                    else
                        src.once('end', endFn);

                    dest.on('unpipe', onunpipe);

                    function onunpipe(readable) {
                        if (readable !== src) return;
                        cleanup();
                    }

                    function onend() {
                        dest.end();
                    }

                    // when the dest drains, it reduces the awaitDrain counter
                    // on the source.  This would be more elegant with a .once()
                    // handler in flow(), but adding and removing repeatedly is
                    // too slow.
                    var ondrain = pipeOnDrain(src);
                    dest.on('drain', ondrain);

                    function cleanup() {
                        // cleanup event handlers once the pipe is broken
                        dest.removeListener('close', onclose);
                        dest.removeListener('finish', onfinish);
                        dest.removeListener('drain', ondrain);
                        dest.removeListener('error', onerror);
                        dest.removeListener('unpipe', onunpipe);
                        src.removeListener('end', onend);
                        src.removeListener('end', cleanup);

                        // if the reader is waiting for a drain event from this
                        // specific writer, then it would cause it to never start
                        // flowing again.
                        // So, if this is awaiting a drain, then we just call it now.
                        // If we don't know, then assume that we are waiting for one.
                        if (!dest._writableState || dest._writableState.needDrain)
                            ondrain();
                    }

                    // if the dest has an error, then stop piping into it.
                    // however, don't suppress the throwing behavior for this.
                    function onerror(er) {
                        unpipe();
                        dest.removeListener('error', onerror);
                        if (EE.listenerCount(dest, 'error') === 0)
                            dest.emit('error', er);
                    }

                    // This is a brutally ugly hack to make sure that our error handler
                    // is attached before any userland ones.  NEVER DO THIS.
                    if (!dest._events || !dest._events.error)
                        dest.on('error', onerror);
                    else if (isArray(dest._events.error))
                        dest._events.error.unshift(onerror);
                    else
                        dest._events.error = [onerror, dest._events.error];


                    // Both close and finish should trigger unpipe, but only once.
                    function onclose() {
                        dest.removeListener('finish', onfinish);
                        unpipe();
                    }

                    dest.once('close', onclose);

                    function onfinish() {
                        dest.removeListener('close', onclose);
                        unpipe();
                    }

                    dest.once('finish', onfinish);

                    function unpipe() {
                        src.unpipe(dest);
                    }

                    // tell the dest that it's being piped to
                    dest.emit('pipe', src);

                    // start the flow if it hasn't been started already.
                    if (!state.flowing) {
                        // the handler that waits for readable events after all
                        // the data gets sucked out in flow.
                        // This would be easier to follow with a .once() handler
                        // in flow(), but that is too slow.
                        this.on('readable', pipeOnReadable);

                        state.flowing = true;
                        process.nextTick(function() {
                            flow(src);
                        });
                    }

                    return dest;
                };

                function pipeOnDrain(src) {
                    return function() {
                        var dest = this;
                        var state = src._readableState;
                        state.awaitDrain--;
                        if (state.awaitDrain === 0)
                            flow(src);
                    };
                }

                function flow(src) {
                    var state = src._readableState;
                    var chunk;
                    state.awaitDrain = 0;

                    function write(dest, i, list) {
                        var written = dest.write(chunk);
                        if (false === written) {
                            state.awaitDrain++;
                        }
                    }

                    while (state.pipesCount && null !== (chunk = src.read())) {

                        if (state.pipesCount === 1)
                            write(state.pipes, 0, null);
                        else
                            forEach(state.pipes, write);

                        src.emit('data', chunk);

                        // if anyone needs a drain, then we have to wait for that.
                        if (state.awaitDrain > 0)
                            return;
                    }

                    // if every destination was unpiped, either before entering this
                    // function, or in the while loop, then stop flowing.
                    //
                    // NB: This is a pretty rare edge case.
                    if (state.pipesCount === 0) {
                        state.flowing = false;

                        // if there were data event listeners added, then switch to old mode.
                        if (EE.listenerCount(src, 'data') > 0)
                            emitDataEvents(src);
                        return;
                    }

                    // at this point, no one needed a drain, so we just ran out of data
                    // on the next readable event, start it over again.
                    state.ranOut = true;
                }

                function pipeOnReadable() {
                    if (this._readableState.ranOut) {
                        this._readableState.ranOut = false;
                        flow(this);
                    }
                }


                Readable.prototype.unpipe = function(dest) {
                    var state = this._readableState;

                    // if we're not piping anywhere, then do nothing.
                    if (state.pipesCount === 0)
                        return this;

                    // just one destination.  most common case.
                    if (state.pipesCount === 1) {
                        // passed in one, but it's not the right one.
                        if (dest && dest !== state.pipes)
                            return this;

                        if (!dest)
                            dest = state.pipes;

                        // got a match.
                        state.pipes = null;
                        state.pipesCount = 0;
                        this.removeListener('readable', pipeOnReadable);
                        state.flowing = false;
                        if (dest)
                            dest.emit('unpipe', this);
                        return this;
                    }

                    // slow case. multiple pipe destinations.

                    if (!dest) {
                        // remove all.
                        var dests = state.pipes;
                        var len = state.pipesCount;
                        state.pipes = null;
                        state.pipesCount = 0;
                        this.removeListener('readable', pipeOnReadable);
                        state.flowing = false;

                        for (var i = 0; i < len; i++)
                            dests[i].emit('unpipe', this);
                        return this;
                    }

                    // try to find the right one.
                    var i = indexOf(state.pipes, dest);
                    if (i === -1)
                        return this;

                    state.pipes.splice(i, 1);
                    state.pipesCount -= 1;
                    if (state.pipesCount === 1)
                        state.pipes = state.pipes[0];

                    dest.emit('unpipe', this);

                    return this;
                };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
                Readable.prototype.on = function(ev, fn) {
                    var res = Stream.prototype.on.call(this, ev, fn);

                    if (ev === 'data' && !this._readableState.flowing)
                        emitDataEvents(this);

                    if (ev === 'readable' && this.readable) {
                        var state = this._readableState;
                        if (!state.readableListening) {
                            state.readableListening = true;
                            state.emittedReadable = false;
                            state.needReadable = true;
                            if (!state.reading) {
                                this.read(0);
                            } else if (state.length) {
                                emitReadable(this, state);
                            }
                        }
                    }

                    return res;
                };
                Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
                Readable.prototype.resume = function() {
                    emitDataEvents(this);
                    this.read(0);
                    this.emit('resume');
                };

                Readable.prototype.pause = function() {
                    emitDataEvents(this, true);
                    this.emit('pause');
                };

                function emitDataEvents(stream, startPaused) {
                    var state = stream._readableState;

                    if (state.flowing) {
                        // https://github.com/isaacs/readable-stream/issues/16
                        throw new Error('Cannot switch to old mode now.');
                    }

                    var paused = startPaused || false;
                    var readable = false;

                    // convert to an old-style stream.
                    stream.readable = true;
                    stream.pipe = Stream.prototype.pipe;
                    stream.on = stream.addListener = Stream.prototype.on;

                    stream.on('readable', function() {
                        readable = true;

                        var c;
                        while (!paused && (null !== (c = stream.read())))
                            stream.emit('data', c);

                        if (c === null) {
                            readable = false;
                            stream._readableState.needReadable = true;
                        }
                    });

                    stream.pause = function() {
                        paused = true;
                        this.emit('pause');
                    };

                    stream.resume = function() {
                        paused = false;
                        if (readable)
                            process.nextTick(function() {
                                stream.emit('readable');
                            });
                        else
                            this.read(0);
                        this.emit('resume');
                    };

                    // now make it start, just in case it hadn't already.
                    stream.emit('readable');
                }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
                Readable.prototype.wrap = function(stream) {
                    var state = this._readableState;
                    var paused = false;

                    var self = this;
                    stream.on('end', function() {
                        if (state.decoder && !state.ended) {
                            var chunk = state.decoder.end();
                            if (chunk && chunk.length)
                                self.push(chunk);
                        }

                        self.push(null);
                    });

                    stream.on('data', function(chunk) {
                        if (state.decoder)
                            chunk = state.decoder.write(chunk);

                        // don't skip over falsy values in objectMode
                        //if (state.objectMode && util.isNullOrUndefined(chunk))
                        if (state.objectMode && (chunk === null || chunk === undefined))
                            return;
                        else if (!state.objectMode && (!chunk || !chunk.length))
                            return;

                        var ret = self.push(chunk);
                        if (!ret) {
                            paused = true;
                            stream.pause();
                        }
                    });

                    // proxy all the other methods.
                    // important when wrapping filters and duplexes.
                    for (var i in stream) {
                        if (typeof stream[i] === 'function' &&
                            typeof this[i] === 'undefined') {
                            this[i] = function(method) {
                                return function() {
                                    return stream[method].apply(stream, arguments);
                                };
                            }(i);
                        }
                    }

                    // proxy certain important events.
                    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
                    forEach(events, function(ev) {
                        stream.on(ev, self.emit.bind(self, ev));
                    });

                    // when we try to consume some more bytes, simply unpause the
                    // underlying stream.
                    self._read = function(n) {
                        if (paused) {
                            paused = false;
                            stream.resume();
                        }
                    };

                    return self;
                };


// exposed for testing purposes only.
                Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
                function fromList(n, state) {
                    var list = state.buffer;
                    var length = state.length;
                    var stringMode = !!state.decoder;
                    var objectMode = !!state.objectMode;
                    var ret;

                    // nothing in the list, definitely empty.
                    if (list.length === 0)
                        return null;

                    if (length === 0)
                        ret = null;
                    else if (objectMode)
                        ret = list.shift();
                    else if (!n || n >= length) {
                        // read it all, truncate the array.
                        if (stringMode)
                            ret = list.join('');
                        else
                            ret = Buffer.concat(list, length);
                        list.length = 0;
                    } else {
                        // read just some of it.
                        if (n < list[0].length) {
                            // just take a part of the first list item.
                            // slice is the same for buffers and strings.
                            var buf = list[0];
                            ret = buf.slice(0, n);
                            list[0] = buf.slice(n);
                        } else if (n === list[0].length) {
                            // first list is a perfect match
                            ret = list.shift();
                        } else {
                            // complex case.
                            // we have enough to cover it, but it spans past the first buffer.
                            if (stringMode)
                                ret = '';
                            else
                                ret = new Buffer(n);

                            var c = 0;
                            for (var i = 0, l = list.length; i < l && c < n; i++) {
                                var buf = list[0];
                                var cpy = Math.min(n - c, buf.length);

                                if (stringMode)
                                    ret += buf.slice(0, cpy);
                                else
                                    buf.copy(ret, c, 0, cpy);

                                if (cpy < buf.length)
                                    list[0] = buf.slice(cpy);
                                else
                                    list.shift();

                                c += cpy;
                            }
                        }
                    }

                    return ret;
                }

                function endReadable(stream) {
                    var state = stream._readableState;

                    // If we get here before consuming all the bytes, then that is a
                    // bug in node.  Should never happen.
                    if (state.length > 0)
                        throw new Error('endReadable called on non-empty stream');

                    if (!state.endEmitted && state.calledRead) {
                        state.ended = true;
                        process.nextTick(function() {
                            // Check that we didn't get one last unshift.
                            if (!state.endEmitted && state.length === 0) {
                                state.endEmitted = true;
                                stream.readable = false;
                                stream.emit('end');
                            }
                        });
                    }
                }

                function forEach(xs, f) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        f(xs[i], i);
                    }
                }

                function indexOf(xs, x) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        if (xs[i] === x) return i;
                    }
                    return -1;
                }

            }).call(this, require('_process'));
        }, {
            '_process': 141,
            'buffer': 59,
            'core-util-is': 62,
            'events': 97,
            'inherits': 116,
            'isarray': 185,
            'stream': 179,
            'string_decoder/': 184
        }],
        188: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

            module.exports = Transform;

            var Duplex = require('./_stream_duplex');

            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/

            util.inherits(Transform, Duplex);


            function TransformState(options, stream) {
                this.afterTransform = function(er, data) {
                    return afterTransform(stream, er, data);
                };

                this.needTransform = false;
                this.transforming = false;
                this.writecb = null;
                this.writechunk = null;
            }

            function afterTransform(stream, er, data) {
                var ts = stream._transformState;
                ts.transforming = false;

                var cb = ts.writecb;

                if (!cb)
                    return stream.emit('error', new Error('no writecb in Transform class'));

                ts.writechunk = null;
                ts.writecb = null;

                if (data !== null && data !== undefined)
                    stream.push(data);

                if (cb)
                    cb(er);

                var rs = stream._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                    stream._read(rs.highWaterMark);
                }
            }


            function Transform(options) {
                if (!(this instanceof Transform))
                    return new Transform(options);

                Duplex.call(this, options);

                var ts = this._transformState = new TransformState(options, this);

                // when the writable side finishes, then flush out anything remaining.
                var stream = this;

                // start out asking for a readable event once data is transformed.
                this._readableState.needReadable = true;

                // we have implemented the _read method, and done the other things
                // that Readable wants before the first _read call, so unset the
                // sync guard flag.
                this._readableState.sync = false;

                this.once('finish', function() {
                    if ('function' === typeof this._flush)
                        this._flush(function(er) {
                            done(stream, er);
                        });
                    else
                        done(stream);
                });
            }

            Transform.prototype.push = function(chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
            };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
            Transform.prototype._transform = function(chunk, encoding, cb) {
                throw new Error('not implemented');
            };

            Transform.prototype._write = function(chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform ||
                        rs.needReadable ||
                        rs.length < rs.highWaterMark)
                        this._read(rs.highWaterMark);
                }
            };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
            Transform.prototype._read = function(n) {
                var ts = this._transformState;

                if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                    // mark that we need a transform, so that any data that comes in
                    // will get processed, now that we've asked for it.
                    ts.needTransform = true;
                }
            };


            function done(stream, er) {
                if (er)
                    return stream.emit('error', er);

                // if there's nothing in the write buffer, then that means
                // that nothing more will ever be provided
                var ws = stream._writableState;
                var rs = stream._readableState;
                var ts = stream._transformState;

                if (ws.length)
                    throw new Error('calling transform done when ws.length != 0');

                if (ts.transforming)
                    throw new Error('calling transform done when still transforming');

                return stream.push(null);
            }

        }, { './_stream_duplex': 186, 'core-util-is': 62, 'inherits': 116 }],
        189: [function(require, module, exports) {
            (function(process) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

                module.exports = Writable;

                /*<replacement>*/
                var Buffer = require('buffer').Buffer;
                /*</replacement>*/

                Writable.WritableState = WritableState;


                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/

                var Stream = require('stream');

                util.inherits(Writable, Stream);

                function WriteReq(chunk, encoding, cb) {
                    this.chunk = chunk;
                    this.encoding = encoding;
                    this.callback = cb;
                }

                function WritableState(options, stream) {
                    options = options || {};

                    // the point at which write() starts returning false
                    // Note: 0 is a valid value, means that we always return false if
                    // the entire buffer is not flushed immediately on write()
                    var hwm = options.highWaterMark;
                    this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

                    // object stream flag to indicate whether or not this stream
                    // contains buffers or objects.
                    this.objectMode = !!options.objectMode;

                    // cast to ints.
                    this.highWaterMark = ~~this.highWaterMark;

                    this.needDrain = false;
                    // at the start of calling end()
                    this.ending = false;
                    // when end() has been called, and returned
                    this.ended = false;
                    // when 'finish' is emitted
                    this.finished = false;

                    // should we decode strings into buffers before passing to _write?
                    // this is here so that some node-core streams can optimize string
                    // handling at a lower level.
                    var noDecode = options.decodeStrings === false;
                    this.decodeStrings = !noDecode;

                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';

                    // not an actual buffer we keep track of, but a measurement
                    // of how much we're waiting to get pushed to some underlying
                    // socket or file.
                    this.length = 0;

                    // a flag to see when we're in the middle of a write.
                    this.writing = false;

                    // a flag to be able to tell if the onwrite cb is called immediately,
                    // or on a later tick.  We set this to true at first, becuase any
                    // actions that shouldn't happen until "later" should generally also
                    // not happen before the first write call.
                    this.sync = true;

                    // a flag to know if we're processing previously buffered items, which
                    // may call the _write() callback in the same tick, so that we don't
                    // end up in an overlapped onwrite situation.
                    this.bufferProcessing = false;

                    // the callback that's passed to _write(chunk,cb)
                    this.onwrite = function(er) {
                        onwrite(stream, er);
                    };

                    // the callback that the user supplies to write(chunk,encoding,cb)
                    this.writecb = null;

                    // the amount that is being written when _write is called.
                    this.writelen = 0;

                    this.buffer = [];

                    // True if the error was already emitted and should not be thrown again
                    this.errorEmitted = false;
                }

                function Writable(options) {
                    var Duplex = require('./_stream_duplex');

                    // Writable ctor is applied to Duplexes, though they're not
                    // instanceof Writable, they're instanceof Readable.
                    if (!(this instanceof Writable) && !(this instanceof Duplex))
                        return new Writable(options);

                    this._writableState = new WritableState(options, this);

                    // legacy.
                    this.writable = true;

                    Stream.call(this);
                }

// Otherwise people can pipe Writable streams, which is just wrong.
                Writable.prototype.pipe = function() {
                    this.emit('error', new Error('Cannot pipe. Not readable.'));
                };


                function writeAfterEnd(stream, state, cb) {
                    var er = new Error('write after end');
                    // TODO: defer error events consistently everywhere, not just the cb
                    stream.emit('error', er);
                    process.nextTick(function() {
                        cb(er);
                    });
                }

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
                function validChunk(stream, state, chunk, cb) {
                    var valid = true;
                    if (!Buffer.isBuffer(chunk) &&
                        'string' !== typeof chunk &&
                        chunk !== null &&
                        chunk !== undefined &&
                        !state.objectMode) {
                        var er = new TypeError('Invalid non-string/buffer chunk');
                        stream.emit('error', er);
                        process.nextTick(function() {
                            cb(er);
                        });
                        valid = false;
                    }
                    return valid;
                }

                Writable.prototype.write = function(chunk, encoding, cb) {
                    var state = this._writableState;
                    var ret = false;

                    if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = null;
                    }

                    if (Buffer.isBuffer(chunk))
                        encoding = 'buffer';
                    else if (!encoding)
                        encoding = state.defaultEncoding;

                    if (typeof cb !== 'function')
                        cb = function() {
                        };

                    if (state.ended)
                        writeAfterEnd(this, state, cb);
                    else if (validChunk(this, state, chunk, cb))
                        ret = writeOrBuffer(this, state, chunk, encoding, cb);

                    return ret;
                };

                function decodeChunk(state, chunk, encoding) {
                    if (!state.objectMode &&
                        state.decodeStrings !== false &&
                        typeof chunk === 'string') {
                        chunk = new Buffer(chunk, encoding);
                    }
                    return chunk;
                }

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
                function writeOrBuffer(stream, state, chunk, encoding, cb) {
                    chunk = decodeChunk(state, chunk, encoding);
                    if (Buffer.isBuffer(chunk))
                        encoding = 'buffer';
                    var len = state.objectMode ? 1 : chunk.length;

                    state.length += len;

                    var ret = state.length < state.highWaterMark;
                    // we must ensure that previous needDrain will not be reset to false.
                    if (!ret)
                        state.needDrain = true;

                    if (state.writing)
                        state.buffer.push(new WriteReq(chunk, encoding, cb));
                    else
                        doWrite(stream, state, len, chunk, encoding, cb);

                    return ret;
                }

                function doWrite(stream, state, len, chunk, encoding, cb) {
                    state.writelen = len;
                    state.writecb = cb;
                    state.writing = true;
                    state.sync = true;
                    stream._write(chunk, encoding, state.onwrite);
                    state.sync = false;
                }

                function onwriteError(stream, state, sync, er, cb) {
                    if (sync)
                        process.nextTick(function() {
                            cb(er);
                        });
                    else
                        cb(er);

                    stream._writableState.errorEmitted = true;
                    stream.emit('error', er);
                }

                function onwriteStateUpdate(state) {
                    state.writing = false;
                    state.writecb = null;
                    state.length -= state.writelen;
                    state.writelen = 0;
                }

                function onwrite(stream, er) {
                    var state = stream._writableState;
                    var sync = state.sync;
                    var cb = state.writecb;

                    onwriteStateUpdate(state);

                    if (er)
                        onwriteError(stream, state, sync, er, cb);
                    else {
                        // Check if we're actually ready to finish, but don't emit yet
                        var finished = needFinish(stream, state);

                        if (!finished && !state.bufferProcessing && state.buffer.length)
                            clearBuffer(stream, state);

                        if (sync) {
                            process.nextTick(function() {
                                afterWrite(stream, state, finished, cb);
                            });
                        } else {
                            afterWrite(stream, state, finished, cb);
                        }
                    }
                }

                function afterWrite(stream, state, finished, cb) {
                    if (!finished)
                        onwriteDrain(stream, state);
                    cb();
                    if (finished)
                        finishMaybe(stream, state);
                }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
                function onwriteDrain(stream, state) {
                    if (state.length === 0 && state.needDrain) {
                        state.needDrain = false;
                        stream.emit('drain');
                    }
                }


// if there's something in the buffer waiting, then process it
                function clearBuffer(stream, state) {
                    state.bufferProcessing = true;

                    for (var c = 0; c < state.buffer.length; c++) {
                        var entry = state.buffer[c];
                        var chunk = entry.chunk;
                        var encoding = entry.encoding;
                        var cb = entry.callback;
                        var len = state.objectMode ? 1 : chunk.length;

                        doWrite(stream, state, len, chunk, encoding, cb);

                        // if we didn't call the onwrite immediately, then
                        // it means that we need to wait until it does.
                        // also, that means that the chunk and cb are currently
                        // being processed, so move the buffer counter past them.
                        if (state.writing) {
                            c++;
                            break;
                        }
                    }

                    state.bufferProcessing = false;
                    if (c < state.buffer.length)
                        state.buffer = state.buffer.slice(c);
                    else
                        state.buffer.length = 0;
                }

                Writable.prototype._write = function(chunk, encoding, cb) {
                    cb(new Error('not implemented'));
                };

                Writable.prototype.end = function(chunk, encoding, cb) {
                    var state = this._writableState;

                    if (typeof chunk === 'function') {
                        cb = chunk;
                        chunk = null;
                        encoding = null;
                    } else if (typeof encoding === 'function') {
                        cb = encoding;
                        encoding = null;
                    }

                    if (typeof chunk !== 'undefined' && chunk !== null)
                        this.write(chunk, encoding);

                    // ignore unnecessary end() calls.
                    if (!state.ending && !state.finished)
                        endWritable(this, state, cb);
                };


                function needFinish(stream, state) {
                    return (state.ending &&
                        state.length === 0 &&
                        !state.finished &&
                        !state.writing);
                }

                function finishMaybe(stream, state) {
                    var need = needFinish(stream, state);
                    if (need) {
                        state.finished = true;
                        stream.emit('finish');
                    }
                    return need;
                }

                function endWritable(stream, state, cb) {
                    state.ending = true;
                    finishMaybe(stream, state);
                    if (cb) {
                        if (state.finished)
                            process.nextTick(cb);
                        else
                            stream.once('finish', cb);
                    }
                    state.ended = true;
                }

            }).call(this, require('_process'));
        }, {
            './_stream_duplex': 186,
            '_process': 141,
            'buffer': 59,
            'core-util-is': 62,
            'inherits': 116,
            'stream': 179
        }],
        190: [function(require, module, exports) {
            module.exports = require('./lib/_stream_transform.js');

        }, { './lib/_stream_transform.js': 188 }],
        191: [function(require, module, exports) {
            (function(process) {
                var Transform = require('readable-stream/transform')
                    , inherits = require('util').inherits
                    , xtend = require('xtend');

                function DestroyableTransform(opts) {
                    Transform.call(this, opts);
                    this._destroyed = false;
                }

                inherits(DestroyableTransform, Transform);

                DestroyableTransform.prototype.destroy = function(err) {
                    if (this._destroyed) return;
                    this._destroyed = true;

                    var self = this;
                    process.nextTick(function() {
                        if (err)
                            self.emit('error', err);
                        self.emit('close');
                    });
                };

// a noop _transform function
                function noop(chunk, enc, callback) {
                    callback(null, chunk);
                }


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
                function through2(construct) {
                    return function(options, transform, flush) {
                        if (typeof options == 'function') {
                            flush = transform;
                            transform = options;
                            options = {};
                        }

                        if (typeof transform != 'function')
                            transform = noop;

                        if (typeof flush != 'function')
                            flush = null;

                        return construct(options, transform, flush);
                    };
                }


// main export, just make me a transform stream!
                module.exports = through2(function(options, transform, flush) {
                    var t2 = new DestroyableTransform(options);

                    t2._transform = transform;

                    if (flush)
                        t2._flush = flush;

                    return t2;
                });


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
                module.exports.ctor = through2(function(options, transform, flush) {
                    function Through2(override) {
                        if (!(this instanceof Through2))
                            return new Through2(override);

                        this.options = xtend(options, override);

                        DestroyableTransform.call(this, this.options);
                    }

                    inherits(Through2, DestroyableTransform);

                    Through2.prototype._transform = transform;

                    if (flush)
                        Through2.prototype._flush = flush;

                    return Through2;
                });


                module.exports.obj = through2(function(options, transform, flush) {
                    var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options));

                    t2._transform = transform;

                    if (flush)
                        t2._flush = flush;

                    return t2;
                });

            }).call(this, require('_process'));
        }, { '_process': 141, 'readable-stream/transform': 190, 'util': 198, 'xtend': 230 }],
        192: [function(require, module, exports) {
            (function(setImmediate, clearImmediate) {
                var nextTick = require('process/browser.js').nextTick;
                var apply = Function.prototype.apply;
                var slice = Array.prototype.slice;
                var immediateIds = {};
                var nextImmediateId = 0;

// DOM APIs, for completeness

                exports.setTimeout = function() {
                    return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                };
                exports.setInterval = function() {
                    return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                };
                exports.clearTimeout =
                    exports.clearInterval = function(timeout) {
                        timeout.close();
                    };

                function Timeout(id, clearFn) {
                    this._id = id;
                    this._clearFn = clearFn;
                }

                Timeout.prototype.unref = Timeout.prototype.ref = function() {
                };
                Timeout.prototype.close = function() {
                    this._clearFn.call(window, this._id);
                };

// Does not start the time, just sets up the members needed.
                exports.enroll = function(item, msecs) {
                    clearTimeout(item._idleTimeoutId);
                    item._idleTimeout = msecs;
                };

                exports.unenroll = function(item) {
                    clearTimeout(item._idleTimeoutId);
                    item._idleTimeout = -1;
                };

                exports._unrefActive = exports.active = function(item) {
                    clearTimeout(item._idleTimeoutId);

                    var msecs = item._idleTimeout;
                    if (msecs >= 0) {
                        item._idleTimeoutId = setTimeout(function onTimeout() {
                            if (item._onTimeout)
                                item._onTimeout();
                        }, msecs);
                    }
                };

// That's not how node.js implements it but the exposed api is the same.
                exports.setImmediate = typeof setImmediate === 'function' ? setImmediate : function(fn) {
                    var id = nextImmediateId++;
                    var args = arguments.length < 2 ? false : slice.call(arguments, 1);

                    immediateIds[id] = true;

                    nextTick(function onNextTick() {
                        if (immediateIds[id]) {
                            // fn.call() is faster so we optimize for the common use-case
                            // @see http://jsperf.com/call-apply-segu
                            if (args) {
                                fn.apply(null, args);
                            } else {
                                fn.call(null);
                            }
                            // Prevent ids from leaking
                            exports.clearImmediate(id);
                        }
                    });

                    return id;
                };

                exports.clearImmediate = typeof clearImmediate === 'function' ? clearImmediate : function(id) {
                    delete immediateIds[id];
                };
            }).call(this, require('timers').setImmediate, require('timers').clearImmediate);
        }, { 'process/browser.js': 141, 'timers': 192 }],
        193: [function(require, module, exports) {
            var Buffer = require('buffer').Buffer;

            module.exports = function(buf) {
                // If the buffer is backed by a Uint8Array, a faster version will work
                if (buf instanceof Uint8Array) {
                    // If the buffer isn't a subarray, return the underlying ArrayBuffer
                    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
                        return buf.buffer;
                    } else if (typeof buf.buffer.slice === 'function') {
                        // Otherwise we need to get a proper copy
                        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    }
                }

                if (Buffer.isBuffer(buf)) {
                    // This is the slow version that will work with any Buffer
                    // implementation (even in old browsers)
                    var arrayCopy = new Uint8Array(buf.length);
                    var len = buf.length;
                    for (var i = 0; i < len; i++) {
                        arrayCopy[i] = buf[i];
                    }
                    return arrayCopy.buffer;
                } else {
                    throw new Error('Argument must be a Buffer');
                }
            };

        }, { 'buffer': 59 }],
        194: [function(require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

            'use strict';

            var punycode = require('punycode');
            var util = require('./util');

            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;

            exports.Url = Url;

            function Url() {
                this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null;
            }

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
            var protocolPattern = /^([a-z0-9.+-]+:)/i,
                portPattern = /:[0-9]*$/,

                // Special case for a simple path URL
                simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

                // RFC 2396: characters reserved for delimiting URLs.
                // We actually just auto-escape these.
                delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

                // RFC 2396: characters not allowed for various reasons.
                unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

                // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
                autoEscape = ['\''].concat(unwise),
                // Characters that are never ever allowed in a hostname.
                // Note that any invalid chars are also handled, but these
                // are the ones that are *expected* to be seen, so we fast-path
                // them.
                nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
                hostEndingChars = ['/', '?', '#'],
                hostnameMaxLen = 255,
                hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                // protocols that can allow "unsafe" and "unwise" chars.
                unsafeProtocol = {
                    'javascript': true,
                    'javascript:': true
                },
                // protocols that never have a hostname.
                hostlessProtocol = {
                    'javascript': true,
                    'javascript:': true
                },
                // protocols that always contain a // bit.
                slashedProtocol = {
                    'http': true,
                    'https': true,
                    'ftp': true,
                    'gopher': true,
                    'file': true,
                    'http:': true,
                    'https:': true,
                    'ftp:': true,
                    'gopher:': true,
                    'file:': true
                },
                querystring = require('querystring');

            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && util.isObject(url) && url instanceof Url) return url;

                var u = new Url;
                u.parse(url, parseQueryString, slashesDenoteHost);
                return u;
            }

            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) {
                    throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
                }

                // Copy chrome, IE, opera backslash-handling behavior.
                // Back slashes before the query string get converted to forward slashes
                // See: https://code.google.com/p/chromium/issues/detail?id=25916
                var queryIndex = url.indexOf('?'),
                    splitter =
                        (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
                    uSplit = url.split(splitter),
                    slashRegex = /\\/g;
                uSplit[0] = uSplit[0].replace(slashRegex, '/');
                url = uSplit.join(splitter);

                var rest = url;

                // trim before proceeding.
                // This is to support parse stuff like "  http://foo.com  \n"
                rest = rest.trim();

                if (!slashesDenoteHost && url.split('#').length === 1) {
                    // Try fast path regexp
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                        this.path = rest;
                        this.href = rest;
                        this.pathname = simplePath[1];
                        if (simplePath[2]) {
                            this.search = simplePath[2];
                            if (parseQueryString) {
                                this.query = querystring.parse(this.search.substr(1));
                            } else {
                                this.query = this.search.substr(1);
                            }
                        } else if (parseQueryString) {
                            this.search = '';
                            this.query = {};
                        }
                        return this;
                    }
                }

                var proto = protocolPattern.exec(rest);
                if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length);
                }

                // figure out if it's got a host
                // user@server is *always* interpreted as a hostname, and url
                // resolution will treat //foo/bar as host=foo,path=bar because that's
                // how the browser resolves relative URLs.
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === '//';
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                        rest = rest.substr(2);
                        this.slashes = true;
                    }
                }

                if (!hostlessProtocol[proto] &&
                    (slashes || (proto && !slashedProtocol[proto]))) {

                    // there's a hostname.
                    // the first instance of /, ?, ;, or # ends the host.
                    //
                    // If there is an @ in the hostname, then non-host chars *are* allowed
                    // to the left of the last @ sign, unless some host-ending character
                    // comes *before* the @-sign.
                    // URLs are obnoxious.
                    //
                    // ex:
                    // http://a@b@c/ => user:a@b host:c
                    // http://a@b?@c => user:a host:c path:/?@c

                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                    // Review our test case against browsers more comprehensively.

                    // find the first instance of any hostEndingChars
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }

                    // at this point, either we have an explicit point where the
                    // auth portion cannot go past, or the last @ char is the decider.
                    var auth, atSign;
                    if (hostEnd === -1) {
                        // atSign can be anywhere.
                        atSign = rest.lastIndexOf('@');
                    } else {
                        // atSign must be in auth portion.
                        // http://a@b/c@d => host:b auth:a path:/c@d
                        atSign = rest.lastIndexOf('@', hostEnd);
                    }

                    // Now we have a portion which is definitely the auth.
                    // Pull that off.
                    if (atSign !== -1) {
                        auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth);
                    }

                    // the host is the remaining to the left of the first non-host char
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    // if we still have not hit it, then the entire thing is a host.
                    if (hostEnd === -1)
                        hostEnd = rest.length;

                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);

                    // pull out port.
                    this.parseHost();

                    // we've indicated that there is a hostname,
                    // so even if it's empty, it has to be present.
                    this.hostname = this.hostname || '';

                    // if hostname begins with [ and ends with ]
                    // assume that it's an IPv6 address.
                    var ipv6Hostname = this.hostname[0] === '[' &&
                        this.hostname[this.hostname.length - 1] === ']';

                    // validate a little.
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part) continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = '';
                                for (var j = 0, k = part.length; j < k; j++) {
                                    if (part.charCodeAt(j) > 127) {
                                        // we replace non-ASCII char with a temporary placeholder
                                        // we need this to make sure size of hostname is not
                                        // broken by replacing non-ASCII by nothing
                                        newpart += 'x';
                                    } else {
                                        newpart += part[j];
                                    }
                                }
                                // we test again with ASCII char only
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) {
                                        validParts.push(bit[1]);
                                        notHost.unshift(bit[2]);
                                    }
                                    if (notHost.length) {
                                        rest = '/' + notHost.join('.') + rest;
                                    }
                                    this.hostname = validParts.join('.');
                                    break;
                                }
                            }
                        }
                    }

                    if (this.hostname.length > hostnameMaxLen) {
                        this.hostname = '';
                    } else {
                        // hostnames are always lower case.
                        this.hostname = this.hostname.toLowerCase();
                    }

                    if (!ipv6Hostname) {
                        // IDNA Support: Returns a punycoded representation of "domain".
                        // It only converts parts of the domain name that
                        // have non-ASCII characters, i.e. it doesn't matter if
                        // you call it with a domain that already is ASCII-only.
                        this.hostname = punycode.toASCII(this.hostname);
                    }

                    var p = this.port ? ':' + this.port : '';
                    var h = this.hostname || '';
                    this.host = h + p;
                    this.href += this.host;

                    // strip [ and ] from the hostname
                    // the host field still retains them, though
                    if (ipv6Hostname) {
                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                        if (rest[0] !== '/') {
                            rest = '/' + rest;
                        }
                    }
                }

                // now rest is set to the post-host stuff.
                // chop off any delim chars.
                if (!unsafeProtocol[lowerProto]) {

                    // First, make 100% sure that any "autoEscape" chars get
                    // escaped, even if encodeURIComponent doesn't think they
                    // need to be.
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        if (rest.indexOf(ae) === -1)
                            continue;
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) {
                            esc = escape(ae);
                        }
                        rest = rest.split(ae).join(esc);
                    }
                }


                // chop off from the tail first.
                var hash = rest.indexOf('#');
                if (hash !== -1) {
                    // got a fragment string.
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash);
                }
                var qm = rest.indexOf('?');
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                        this.query = querystring.parse(this.query);
                    }
                    rest = rest.slice(0, qm);
                } else if (parseQueryString) {
                    // no query string, but parseQueryString still requested
                    this.search = '';
                    this.query = {};
                }
                if (rest) this.pathname = rest;
                if (slashedProtocol[lowerProto] &&
                    this.hostname && !this.pathname) {
                    this.pathname = '/';
                }

                //to support http.request
                if (this.pathname || this.search) {
                    var p = this.pathname || '';
                    var s = this.search || '';
                    this.path = p + s;
                }

                // finally, reconstruct the href based on what has been validated.
                this.href = this.format();
                return this;
            };

// format a parsed object into a url string
            function urlFormat(obj) {
                // ensure it's an object, and not a string url.
                // If it's an obj, this is a no-op.
                // this way, you can call url_format() on strings
                // to clean up potentially wonky urls.
                if (util.isString(obj)) obj = urlParse(obj);
                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
                return obj.format();
            }

            Url.prototype.format = function() {
                var auth = this.auth || '';
                if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ':');
                    auth += '@';
                }

                var protocol = this.protocol || '',
                    pathname = this.pathname || '',
                    hash = this.hash || '',
                    host = false,
                    query = '';

                if (this.host) {
                    host = auth + this.host;
                } else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(':') === -1 ?
                        this.hostname :
                        '[' + this.hostname + ']');
                    if (this.port) {
                        host += ':' + this.port;
                    }
                }

                if (this.query &&
                    util.isObject(this.query) &&
                    Object.keys(this.query).length) {
                    query = querystring.stringify(this.query);
                }

                var search = this.search || (query && ('?' + query)) || '';

                if (protocol && protocol.substr(-1) !== ':') protocol += ':';

                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
                // unless they had them to begin with.
                if (this.slashes ||
                    (!protocol || slashedProtocol[protocol]) && host !== false) {
                    host = '//' + (host || '');
                    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
                } else if (!host) {
                    host = '';
                }

                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
                if (search && search.charAt(0) !== '?') search = '?' + search;

                pathname = pathname.replace(/[?#]/g, function(match) {
                    return encodeURIComponent(match);
                });
                search = search.replace('#', '%23');

                return protocol + host + pathname + search + hash;
            };

            function urlResolve(source, relative) {
                return urlParse(source, false, true).resolve(relative);
            }

            Url.prototype.resolve = function(relative) {
                return this.resolveObject(urlParse(relative, false, true)).format();
            };

            function urlResolveObject(source, relative) {
                if (!source) return relative;
                return urlParse(source, false, true).resolveObject(relative);
            }

            Url.prototype.resolveObject = function(relative) {
                if (util.isString(relative)) {
                    var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel;
                }

                var result = new Url();
                var tkeys = Object.keys(this);
                for (var tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey];
                }

                // hash is always overridden, no matter what.
                // even href="" will remove it.
                result.hash = relative.hash;

                // if the relative url is empty, then there's nothing left to do here.
                if (relative.href === '') {
                    result.href = result.format();
                    return result;
                }

                // hrefs like //foo/bar always cut to the protocol.
                if (relative.slashes && !relative.protocol) {
                    // take everything except the protocol from relative
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        if (rkey !== 'protocol')
                            result[rkey] = relative[rkey];
                    }

                    //urlParse appends trailing / to urls like http://www.example.com
                    if (slashedProtocol[result.protocol] &&
                        result.hostname && !result.pathname) {
                        result.path = result.pathname = '/';
                    }

                    result.href = result.format();
                    return result;
                }

                if (relative.protocol && relative.protocol !== result.protocol) {
                    // if it's a known url protocol, then changing
                    // the protocol does weird things
                    // first, if it's not file:, then we MUST have a host,
                    // and if there was a path
                    // to begin with, then we MUST have a path.
                    // if it is file:, then the host is dropped,
                    // because that's known to be hostless.
                    // anything else is assumed to be absolute.
                    if (!slashedProtocol[relative.protocol]) {
                        var keys = Object.keys(relative);
                        for (var v = 0; v < keys.length; v++) {
                            var k = keys[v];
                            result[k] = relative[k];
                        }
                        result.href = result.format();
                        return result;
                    }

                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                        var relPath = (relative.pathname || '').split('/');
                        while (relPath.length && !(relative.host = relPath.shift())) ;
                        if (!relative.host) relative.host = '';
                        if (!relative.hostname) relative.hostname = '';
                        if (relPath[0] !== '') relPath.unshift('');
                        if (relPath.length < 2) relPath.unshift('');
                        result.pathname = relPath.join('/');
                    } else {
                        result.pathname = relative.pathname;
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || '';
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    // to support http.request
                    if (result.pathname || result.search) {
                        var p = result.pathname || '';
                        var s = result.search || '';
                        result.path = p + s;
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                }

                var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
                    isRelAbs = (
                        relative.host ||
                        relative.pathname && relative.pathname.charAt(0) === '/'
                    ),
                    mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname)),
                    removeAllDots = mustEndAbs,
                    srcPath = result.pathname && result.pathname.split('/') || [],
                    relPath = relative.pathname && relative.pathname.split('/') || [],
                    psychotic = result.protocol && !slashedProtocol[result.protocol];

                // if the url is a non-slashed url, then relative
                // links like ../.. should be able
                // to crawl up to the hostname, as well.  This is strange.
                // result.protocol has already been set by now.
                // Later on, put the first path part into the host field.
                if (psychotic) {
                    result.hostname = '';
                    result.port = null;
                    if (result.host) {
                        if (srcPath[0] === '') srcPath[0] = result.host;
                        else srcPath.unshift(result.host);
                    }
                    result.host = '';
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) {
                            if (relPath[0] === '') relPath[0] = relative.host;
                            else relPath.unshift(relative.host);
                        }
                        relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
                }

                if (isRelAbs) {
                    // it's absolute.
                    result.host = (relative.host || relative.host === '') ?
                        relative.host : result.host;
                    result.hostname = (relative.hostname || relative.hostname === '') ?
                        relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath;
                    // fall through to the dot-handling below.
                } else if (relPath.length) {
                    // it's relative
                    // throw away the existing file, and take the new path instead.
                    if (!srcPath) srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query;
                } else if (!util.isNullOrUndefined(relative.search)) {
                    // just pull out the search.
                    // like href='?foo'.
                    // Put this after the other two cases because it simplifies the booleans
                    if (psychotic) {
                        result.hostname = result.host = srcPath.shift();
                        //occationaly the auth can get stuck only in host
                        //this especially happens in cases like
                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                            result.host.split('@') : false;
                        if (authInHost) {
                            result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift();
                        }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    //to support http.request
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : '') +
                            (result.search ? result.search : '');
                    }
                    result.href = result.format();
                    return result;
                }

                if (!srcPath.length) {
                    // no path at all.  easy.
                    // we've already handled the other stuff above.
                    result.pathname = null;
                    //to support http.request
                    if (result.search) {
                        result.path = '/' + result.search;
                    } else {
                        result.path = null;
                    }
                    result.href = result.format();
                    return result;
                }

                // if a url ENDs in . or .., then it must get a trailing slash.
                // however, if it ends in anything else non-slashy,
                // then it must NOT get a trailing slash.
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = (
                    (result.host || relative.host || srcPath.length > 1) &&
                    (last === '.' || last === '..') || last === '');

                // strip single dots, resolve double dots to parent dir
                // if the path tries to go above the root, `up` ends up > 0
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last === '.') {
                        srcPath.splice(i, 1);
                    } else if (last === '..') {
                        srcPath.splice(i, 1);
                        up++;
                    } else if (up) {
                        srcPath.splice(i, 1);
                        up--;
                    }
                }

                // if the path is allowed to go above the root, restore leading ..s
                if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                        srcPath.unshift('..');
                    }
                }

                if (mustEndAbs && srcPath[0] !== '' &&
                    (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                    srcPath.unshift('');
                }

                if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
                    srcPath.push('');
                }

                var isAbsolute = srcPath[0] === '' ||
                    (srcPath[0] && srcPath[0].charAt(0) === '/');

                // put the host back
                if (psychotic) {
                    result.hostname = result.host = isAbsolute ? '' :
                        srcPath.length ? srcPath.shift() : '';
                    //occationaly the auth can get stuck only in host
                    //this especially happens in cases like
                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                        result.host.split('@') : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }

                mustEndAbs = mustEndAbs || (result.host && srcPath.length);

                if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift('');
                }

                if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null;
                } else {
                    result.pathname = srcPath.join('/');
                }

                //to support request.http
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            };

            Url.prototype.parseHost = function() {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ':') {
                        this.port = port.substr(1);
                    }
                    host = host.substr(0, host.length - port.length);
                }
                if (host) this.hostname = host;
            };

        }, { './util': 195, 'punycode': 148, 'querystring': 151 }],
        195: [function(require, module, exports) {
            'use strict';

            module.exports = {
                isString: function(arg) {
                    return typeof (arg) === 'string';
                },
                isObject: function(arg) {
                    return typeof (arg) === 'object' && arg !== null;
                },
                isNull: function(arg) {
                    return arg === null;
                },
                isNullOrUndefined: function(arg) {
                    return arg == null;
                }
            };

        }, {}],
        196: [function(require, module, exports) {
            (function(global) {

                /**
                 * Module exports.
                 */

                module.exports = deprecate;

                /**
                 * Mark that a method should not be used.
                 * Returns a modified function which warns once by default.
                 *
                 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
                 *
                 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
                 * will throw an Error when invoked.
                 *
                 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
                 * will invoke `console.trace()` instead of `console.error()`.
                 *
                 * @param {Function} fn - the function to deprecate
                 * @param {String} msg - the string to print to the console when `fn` is invoked
                 * @returns {Function} a new "deprecated" version of `fn`
                 * @api public
                 */

                function deprecate(fn, msg) {
                    if (config('noDeprecation')) {
                        return fn;
                    }

                    var warned = false;

                    function deprecated() {
                        if (!warned) {
                            if (config('throwDeprecation')) {
                                throw new Error(msg);
                            } else if (config('traceDeprecation')) {
                                console.trace(msg);
                            } else {
                                console.warn(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }

                    return deprecated;
                }

                /**
                 * Checks `localStorage` for boolean values for the given `name`.
                 *
                 * @param {String} name
                 * @returns {Boolean}
                 * @api private
                 */

                function config(name) {
                    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
                    try {
                        if (!global.localStorage) return false;
                    } catch (_) {
                        return false;
                    }
                    var val = global.localStorage[name];
                    if (null == val) return false;
                    return String(val).toLowerCase() === 'true';
                }

            }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, {}],
        197: [function(require, module, exports) {
            module.exports = function isBuffer(arg) {
                return arg && typeof arg === 'object'
                    && typeof arg.copy === 'function'
                    && typeof arg.fill === 'function'
                    && typeof arg.readUInt8 === 'function';
            };
        }, {}],
        198: [function(require, module, exports) {
            (function(process, global) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

                var formatRegExp = /%[sdj%]/g;
                exports.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for (var i = 0; i < arguments.length; i++) {
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }

                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch (x) {
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for (var x = args[i]; i < len; x = args[++i]) {
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
                exports.deprecate = function(fn, msg) {
                    // Allow for deprecating things in the process of starting up.
                    if (isUndefined(global.process)) {
                        return function() {
                            return exports.deprecate(fn, msg).apply(this, arguments);
                        };
                    }

                    if (process.noDeprecation === true) {
                        return fn;
                    }

                    var warned = false;

                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }

                    return deprecated;
                };


                var debugs = {};
                var debugEnviron;
                exports.debuglog = function(set) {
                    if (isUndefined(debugEnviron))
                        debugEnviron = process.env.NODE_DEBUG || '';
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports.format.apply(exports, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {
                            };
                        }
                    }
                    return debugs[set];
                };


                /**
                 * Echos the value of a value. Trys to print the value out
                 * in the best way possible given the different types.
                 *
                 * @param {Object} obj The object to print out.
                 * @param {Object} opts Optional options object that alters the output.
                 */

                /* legacy: obj, showHidden, depth, colors*/
                function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }

                exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [1, 22],
                    'italic': [3, 23],
                    'underline': [4, 24],
                    'inverse': [7, 27],
                    'white': [37, 39],
                    'grey': [90, 39],
                    'black': [30, 39],
                    'blue': [34, 39],
                    'cyan': [36, 39],
                    'green': [32, 39],
                    'magenta': [35, 39],
                    'red': [31, 39],
                    'yellow': [33, 39]
                };

// Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };


                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];

                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                            '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }


                function stylizeNoColor(str, styleType) {
                    return str;
                }


                function arrayToHash(array) {
                    var hash = {};

                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });

                    return hash;
                }


                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect &&
                        value &&
                        isFunction(value.inspect) &&
                        // Filter out the util module, it's inspect function is special
                        value.inspect !== exports.inspect &&
                        // Also filter out any prototype objects using the circular check.
                        !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }

                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }

                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);

                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }

                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value)
                        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }

                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }

                    var base = '', array = false, braces = ['{', '}'];

                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = ['[', ']'];
                    }

                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }

                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }

                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }

                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }

                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }

                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }

                    ctx.seen.push(value);

                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }

                    ctx.seen.pop();

                    return reduceToSingleString(output, base, braces);
                }


                function formatPrimitive(ctx, value) {
                    if (isUndefined(value))
                        return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                            .replace(/'/g, '\\\'')
                            .replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value))
                        return ctx.stylize('' + value, 'number');
                    if (isBoolean(value))
                        return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value))
                        return ctx.stylize('null', 'null');
                }


                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }


                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for (var i = 0, l = value.length; i < l; ++i) {
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                                String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                                key, true));
                        }
                    });
                    return output;
                }


                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').substr(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.substr(1, name.length - 2);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, '\\\'')
                                .replace(/\\"/g, '"')
                                .replace(/(^"|"$)/g, '\'');
                            name = ctx.stylize(name, 'string');
                        }
                    }

                    return name + ': ' + str;
                }


                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);

                    if (length > 60) {
                        return braces[0] +
                            (base === '' ? '' : base + '\n ') +
                            ' ' +
                            output.join(',\n  ') +
                            ' ' +
                            braces[1];
                    }

                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
                function isArray(ar) {
                    return Array.isArray(ar);
                }

                exports.isArray = isArray;

                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }

                exports.isBoolean = isBoolean;

                function isNull(arg) {
                    return arg === null;
                }

                exports.isNull = isNull;

                function isNullOrUndefined(arg) {
                    return arg == null;
                }

                exports.isNullOrUndefined = isNullOrUndefined;

                function isNumber(arg) {
                    return typeof arg === 'number';
                }

                exports.isNumber = isNumber;

                function isString(arg) {
                    return typeof arg === 'string';
                }

                exports.isString = isString;

                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }

                exports.isSymbol = isSymbol;

                function isUndefined(arg) {
                    return arg === void 0;
                }

                exports.isUndefined = isUndefined;

                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }

                exports.isRegExp = isRegExp;

                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }

                exports.isObject = isObject;

                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }

                exports.isDate = isDate;

                function isError(e) {
                    return isObject(e) &&
                        (objectToString(e) === '[object Error]' || e instanceof Error);
                }

                exports.isError = isError;

                function isFunction(arg) {
                    return typeof arg === 'function';
                }

                exports.isFunction = isFunction;

                function isPrimitive(arg) {
                    return arg === null ||
                        typeof arg === 'boolean' ||
                        typeof arg === 'number' ||
                        typeof arg === 'string' ||
                        typeof arg === 'symbol' ||  // ES6 symbol
                        typeof arg === 'undefined';
                }

                exports.isPrimitive = isPrimitive;

                exports.isBuffer = require('./support/isBuffer');

                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }


                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }


                var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                    'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())].join(':');
                    return [d.getDate(), months[d.getMonth()], time].join(' ');
                }


// log is just a thin wrapper to console.log that prepends a timestamp
                exports.log = function() {
                    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
                };


                /**
                 * Inherit the prototype methods from one constructor into another.
                 *
                 * The Function.prototype.inherits from lang.js rewritten as a standalone
                 * function (not on Function.prototype). NOTE: If this file is to be loaded
                 * during bootstrapping this function needs to be rewritten using some native
                 * functions as prototype setup using normal JavaScript does not work as
                 * expected during bootstrapping (see mirror.js in r114903).
                 *
                 * @param {function} ctor Constructor function which needs to inherit the
                 *     prototype.
                 * @param {function} superCtor Constructor function to inherit prototype from.
                 */
                exports.inherits = require('inherits');

                exports._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;

                    var keys = Object.keys(add);
                    var i = keys.length;
                    while (i--) {
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };

                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }

            }).call(this, require('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
        }, { './support/isBuffer': 197, '_process': 141, 'inherits': 116 }],
        199: [function(require, module, exports) {
            var indexOf = require('indexof');

            var Object_keys = function(obj) {
                if (Object.keys) return Object.keys(obj);
                else {
                    var res = [];
                    for (var key in obj) res.push(key);
                    return res;
                }
            };

            var forEach = function(xs, fn) {
                if (xs.forEach) return xs.forEach(fn);
                else for (var i = 0; i < xs.length; i++) {
                    fn(xs[i], i, xs);
                }
            };

            var defineProp = (function() {
                try {
                    Object.defineProperty({}, '_', {});
                    return function(obj, name, value) {
                        Object.defineProperty(obj, name, {
                            writable: true,
                            enumerable: false,
                            configurable: true,
                            value: value
                        });
                    };
                } catch (e) {
                    return function(obj, name, value) {
                        obj[name] = value;
                    };
                }
            }());

            var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
                'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
                'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
                'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
                'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

            function Context() {
            }

            Context.prototype = {};

            var Script = exports.Script = function NodeScript(code) {
                if (!(this instanceof Script)) return new Script(code);
                this.code = code;
            };

            Script.prototype.runInContext = function(context) {
                if (!(context instanceof Context)) {
                    throw new TypeError('needs a \'context\' argument.');
                }

                var iframe = document.createElement('iframe');
                if (!iframe.style) iframe.style = {};
                iframe.style.display = 'none';

                document.body.appendChild(iframe);

                var win = iframe.contentWindow;
                var wEval = win.eval, wExecScript = win.execScript;

                if (!wEval && wExecScript) {
                    // win.eval() magically appears when this is called in IE:
                    wExecScript.call(win, 'null');
                    wEval = win.eval;
                }

                forEach(Object_keys(context), function(key) {
                    win[key] = context[key];
                });
                forEach(globals, function(key) {
                    if (context[key]) {
                        win[key] = context[key];
                    }
                });

                var winKeys = Object_keys(win);

                var res = wEval.call(win, this.code);

                forEach(Object_keys(win), function(key) {
                    // Avoid copying circular objects like `top` and `window` by only
                    // updating existing context properties or new properties in the `win`
                    // that was only introduced after the eval.
                    if (key in context || indexOf(winKeys, key) === -1) {
                        context[key] = win[key];
                    }
                });

                forEach(globals, function(key) {
                    if (!(key in context)) {
                        defineProp(context, key, win[key]);
                    }
                });

                document.body.removeChild(iframe);

                return res;
            };

            Script.prototype.runInThisContext = function() {
                return eval(this.code); // maybe...
            };

            Script.prototype.runInNewContext = function(context) {
                var ctx = Script.createContext(context);
                var res = this.runInContext(ctx);

                forEach(Object_keys(ctx), function(key) {
                    context[key] = ctx[key];
                });

                return res;
            };

            forEach(Object_keys(Script.prototype), function(name) {
                exports[name] = Script[name] = function(code) {
                    var s = Script(code);
                    return s[name].apply(s, [].slice.call(arguments, 1));
                };
            });

            exports.createScript = function(code) {
                return exports.Script(code);
            };

            exports.createContext = Script.createContext = function(context) {
                var copy = new Context();
                if (typeof context === 'object') {
                    forEach(Object_keys(context), function(key) {
                        copy[key] = context[key];
                    });
                }
                return copy;
            };

        }, { 'indexof': 115 }],
        200: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                'use strict';
                exports.stripBOM = function(str) {
                    if (str[0] === '\uFEFF') {
                        return str.substring(1);
                    } else {
                        return str;
                    }
                };

            }).call(this);

        }, {}],
        201: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                'use strict';
                var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
                    hasProp = {}.hasOwnProperty;

                builder = require('xmlbuilder');

                defaults = require('./defaults').defaults;

                requiresCDATA = function(entry) {
                    return typeof entry === 'string' && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
                };

                wrapCDATA = function(entry) {
                    return '<![CDATA[' + (escapeCDATA(entry)) + ']]>';
                };

                escapeCDATA = function(entry) {
                    return entry.replace(']]>', ']]]]><![CDATA[>');
                };

                exports.Builder = (function() {
                    function Builder(opts) {
                        var key, ref, value;
                        this.options = {};
                        ref = defaults['0.2'];
                        for (key in ref) {
                            if (!hasProp.call(ref, key)) continue;
                            value = ref[key];
                            this.options[key] = value;
                        }
                        for (key in opts) {
                            if (!hasProp.call(opts, key)) continue;
                            value = opts[key];
                            this.options[key] = value;
                        }
                    }

                    Builder.prototype.buildObject = function(rootObj) {
                        var attrkey, charkey, render, rootElement, rootName;
                        attrkey = this.options.attrkey;
                        charkey = this.options.charkey;
                        if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
                            rootName = Object.keys(rootObj)[0];
                            rootObj = rootObj[rootName];
                        } else {
                            rootName = this.options.rootName;
                        }
                        render = (function(_this) {
                            return function(element, obj) {
                                var attr, child, entry, index, key, value;
                                if (typeof obj !== 'object') {
                                    if (_this.options.cdata && requiresCDATA(obj)) {
                                        element.raw(wrapCDATA(obj));
                                    } else {
                                        element.txt(obj);
                                    }
                                } else if (Array.isArray(obj)) {
                                    for (index in obj) {
                                        if (!hasProp.call(obj, index)) continue;
                                        child = obj[index];
                                        for (key in child) {
                                            entry = child[key];
                                            element = render(element.ele(key), entry).up();
                                        }
                                    }
                                } else {
                                    for (key in obj) {
                                        if (!hasProp.call(obj, key)) continue;
                                        child = obj[key];
                                        if (key === attrkey) {
                                            if (typeof child === 'object') {
                                                for (attr in child) {
                                                    value = child[attr];
                                                    element = element.att(attr, value);
                                                }
                                            }
                                        } else if (key === charkey) {
                                            if (_this.options.cdata && requiresCDATA(child)) {
                                                element = element.raw(wrapCDATA(child));
                                            } else {
                                                element = element.txt(child);
                                            }
                                        } else if (Array.isArray(child)) {
                                            for (index in child) {
                                                if (!hasProp.call(child, index)) continue;
                                                entry = child[index];
                                                if (typeof entry === 'string') {
                                                    if (_this.options.cdata && requiresCDATA(entry)) {
                                                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                                                    } else {
                                                        element = element.ele(key, entry).up();
                                                    }
                                                } else {
                                                    element = render(element.ele(key), entry).up();
                                                }
                                            }
                                        } else if (typeof child === 'object') {
                                            element = render(element.ele(key), child).up();
                                        } else {
                                            if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                                                element = element.ele(key).raw(wrapCDATA(child)).up();
                                            } else {
                                                if (child == null) {
                                                    child = '';
                                                }
                                                element = element.ele(key, child.toString()).up();
                                            }
                                        }
                                    }
                                }
                                return element;
                            };
                        })(this);
                        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                            headless: this.options.headless,
                            allowSurrogateChars: this.options.allowSurrogateChars
                        });
                        return render(rootElement, rootObj).end(this.options.renderOpts);
                    };

                    return Builder;

                })();

            }).call(this);

        }, { './defaults': 202, 'xmlbuilder': 229 }],
        202: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                exports.defaults = {
                    '0.1': {
                        explicitCharkey: false,
                        trim: true,
                        normalize: true,
                        normalizeTags: false,
                        attrkey: '@',
                        charkey: '#',
                        explicitArray: false,
                        ignoreAttrs: false,
                        mergeAttrs: false,
                        explicitRoot: false,
                        validator: null,
                        xmlns: false,
                        explicitChildren: false,
                        childkey: '@@',
                        charsAsChildren: false,
                        includeWhiteChars: false,
                        async: false,
                        strict: true,
                        attrNameProcessors: null,
                        attrValueProcessors: null,
                        tagNameProcessors: null,
                        valueProcessors: null,
                        emptyTag: ''
                    },
                    '0.2': {
                        explicitCharkey: false,
                        trim: false,
                        normalize: false,
                        normalizeTags: false,
                        attrkey: '$',
                        charkey: '_',
                        explicitArray: true,
                        ignoreAttrs: false,
                        mergeAttrs: false,
                        explicitRoot: true,
                        validator: null,
                        xmlns: false,
                        explicitChildren: false,
                        preserveChildrenOrder: false,
                        childkey: '$$',
                        charsAsChildren: false,
                        includeWhiteChars: false,
                        async: false,
                        strict: true,
                        attrNameProcessors: null,
                        attrValueProcessors: null,
                        tagNameProcessors: null,
                        valueProcessors: null,
                        rootName: 'root',
                        xmldec: {
                            'version': '1.0',
                            'encoding': 'UTF-8',
                            'standalone': true
                        },
                        doctype: null,
                        renderOpts: {
                            'pretty': true,
                            'indent': '  ',
                            'newline': '\n'
                        },
                        headless: false,
                        chunkSize: 10000,
                        emptyTag: '',
                        cdata: false
                    }
                };

            }).call(this);

        }, {}],
        203: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                'use strict';
                var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
                    bind = function(fn, me) {
                        return function() {
                            return fn.apply(me, arguments);
                        };
                    },
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                sax = require('sax');

                events = require('events');

                bom = require('./bom');

                processors = require('./processors');

                setImmediate = require('timers').setImmediate;

                defaults = require('./defaults').defaults;

                isEmpty = function(thing) {
                    return typeof thing === 'object' && (thing != null) && Object.keys(thing).length === 0;
                };

                processItem = function(processors, item, key) {
                    var i, len, process;
                    for (i = 0, len = processors.length; i < len; i++) {
                        process = processors[i];
                        item = process(item, key);
                    }
                    return item;
                };

                exports.Parser = (function(superClass) {
                    extend(Parser, superClass);

                    function Parser(opts) {
                        this.parseString = bind(this.parseString, this);
                        this.reset = bind(this.reset, this);
                        this.assignOrPush = bind(this.assignOrPush, this);
                        this.processAsync = bind(this.processAsync, this);
                        var key, ref, value;
                        if (!(this instanceof exports.Parser)) {
                            return new exports.Parser(opts);
                        }
                        this.options = {};
                        ref = defaults['0.2'];
                        for (key in ref) {
                            if (!hasProp.call(ref, key)) continue;
                            value = ref[key];
                            this.options[key] = value;
                        }
                        for (key in opts) {
                            if (!hasProp.call(opts, key)) continue;
                            value = opts[key];
                            this.options[key] = value;
                        }
                        if (this.options.xmlns) {
                            this.options.xmlnskey = this.options.attrkey + 'ns';
                        }
                        if (this.options.normalizeTags) {
                            if (!this.options.tagNameProcessors) {
                                this.options.tagNameProcessors = [];
                            }
                            this.options.tagNameProcessors.unshift(processors.normalize);
                        }
                        this.reset();
                    }

                    Parser.prototype.processAsync = function() {
                        var chunk, err;
                        try {
                            if (this.remaining.length <= this.options.chunkSize) {
                                chunk = this.remaining;
                                this.remaining = '';
                                this.saxParser = this.saxParser.write(chunk);
                                return this.saxParser.close();
                            } else {
                                chunk = this.remaining.substr(0, this.options.chunkSize);
                                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                                this.saxParser = this.saxParser.write(chunk);
                                return setImmediate(this.processAsync);
                            }
                        } catch (error1) {
                            err = error1;
                            if (!this.saxParser.errThrown) {
                                this.saxParser.errThrown = true;
                                return this.emit(err);
                            }
                        }
                    };

                    Parser.prototype.assignOrPush = function(obj, key, newValue) {
                        if (!(key in obj)) {
                            if (!this.options.explicitArray) {
                                return obj[key] = newValue;
                            } else {
                                return obj[key] = [newValue];
                            }
                        } else {
                            if (!(obj[key] instanceof Array)) {
                                obj[key] = [obj[key]];
                            }
                            return obj[key].push(newValue);
                        }
                    };

                    Parser.prototype.reset = function() {
                        var attrkey, charkey, ontext, stack;
                        this.removeAllListeners();
                        this.saxParser = sax.parser(this.options.strict, {
                            trim: false,
                            normalize: false,
                            xmlns: this.options.xmlns
                        });
                        this.saxParser.errThrown = false;
                        this.saxParser.onerror = (function(_this) {
                            return function(error) {
                                _this.saxParser.resume();
                                if (!_this.saxParser.errThrown) {
                                    _this.saxParser.errThrown = true;
                                    return _this.emit('error', error);
                                }
                            };
                        })(this);
                        this.saxParser.onend = (function(_this) {
                            return function() {
                                if (!_this.saxParser.ended) {
                                    _this.saxParser.ended = true;
                                    return _this.emit('end', _this.resultObject);
                                }
                            };
                        })(this);
                        this.saxParser.ended = false;
                        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
                        this.resultObject = null;
                        stack = [];
                        attrkey = this.options.attrkey;
                        charkey = this.options.charkey;
                        this.saxParser.onopentag = (function(_this) {
                            return function(node) {
                                var key, newValue, obj, processedKey, ref;
                                obj = {};
                                obj[charkey] = '';
                                if (!_this.options.ignoreAttrs) {
                                    ref = node.attributes;
                                    for (key in ref) {
                                        if (!hasProp.call(ref, key)) continue;
                                        if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                            obj[attrkey] = {};
                                        }
                                        newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                                        processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                                        if (_this.options.mergeAttrs) {
                                            _this.assignOrPush(obj, processedKey, newValue);
                                        } else {
                                            obj[attrkey][processedKey] = newValue;
                                        }
                                    }
                                }
                                obj['#name'] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                                if (_this.options.xmlns) {
                                    obj[_this.options.xmlnskey] = {
                                        uri: node.uri,
                                        local: node.local
                                    };
                                }
                                return stack.push(obj);
                            };
                        })(this);
                        this.saxParser.onclosetag = (function(_this) {
                            return function() {
                                var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                                obj = stack.pop();
                                nodeName = obj['#name'];
                                if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                                    delete obj['#name'];
                                }
                                if (obj.cdata === true) {
                                    cdata = obj.cdata;
                                    delete obj.cdata;
                                }
                                s = stack[stack.length - 1];
                                if (obj[charkey].match(/^\s*$/) && !cdata) {
                                    emptyStr = obj[charkey];
                                    delete obj[charkey];
                                } else {
                                    if (_this.options.trim) {
                                        obj[charkey] = obj[charkey].trim();
                                    }
                                    if (_this.options.normalize) {
                                        obj[charkey] = obj[charkey].replace(/\s{2,}/g, ' ').trim();
                                    }
                                    obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                        obj = obj[charkey];
                                    }
                                }
                                if (isEmpty(obj)) {
                                    obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                                }
                                if (_this.options.validator != null) {
                                    xpath = '/' + ((function() {
                                        var i, len, results;
                                        results = [];
                                        for (i = 0, len = stack.length; i < len; i++) {
                                            node = stack[i];
                                            results.push(node['#name']);
                                        }
                                        return results;
                                    })()).concat(nodeName).join('/');
                                    (function() {
                                        var err;
                                        try {
                                            return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                                        } catch (error1) {
                                            err = error1;
                                            return _this.emit('error', err);
                                        }
                                    })();
                                }
                                if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                                    if (!_this.options.preserveChildrenOrder) {
                                        node = {};
                                        if (_this.options.attrkey in obj) {
                                            node[_this.options.attrkey] = obj[_this.options.attrkey];
                                            delete obj[_this.options.attrkey];
                                        }
                                        if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                            node[_this.options.charkey] = obj[_this.options.charkey];
                                            delete obj[_this.options.charkey];
                                        }
                                        if (Object.getOwnPropertyNames(obj).length > 0) {
                                            node[_this.options.childkey] = obj;
                                        }
                                        obj = node;
                                    } else if (s) {
                                        s[_this.options.childkey] = s[_this.options.childkey] || [];
                                        objClone = {};
                                        for (key in obj) {
                                            if (!hasProp.call(obj, key)) continue;
                                            objClone[key] = obj[key];
                                        }
                                        s[_this.options.childkey].push(objClone);
                                        delete obj['#name'];
                                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                            obj = obj[charkey];
                                        }
                                    }
                                }
                                if (stack.length > 0) {
                                    return _this.assignOrPush(s, nodeName, obj);
                                } else {
                                    if (_this.options.explicitRoot) {
                                        old = obj;
                                        obj = {};
                                        obj[nodeName] = old;
                                    }
                                    _this.resultObject = obj;
                                    _this.saxParser.ended = true;
                                    return _this.emit('end', _this.resultObject);
                                }
                            };
                        })(this);
                        ontext = (function(_this) {
                            return function(text) {
                                var charChild, s;
                                s = stack[stack.length - 1];
                                if (s) {
                                    s[charkey] += text;
                                    if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                                        s[_this.options.childkey] = s[_this.options.childkey] || [];
                                        charChild = {
                                            '#name': '__text__'
                                        };
                                        charChild[charkey] = text;
                                        if (_this.options.normalize) {
                                            charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, ' ').trim();
                                        }
                                        s[_this.options.childkey].push(charChild);
                                    }
                                    return s;
                                }
                            };
                        })(this);
                        this.saxParser.ontext = ontext;
                        return this.saxParser.oncdata = (function(_this) {
                            return function(text) {
                                var s;
                                s = ontext(text);
                                if (s) {
                                    return s.cdata = true;
                                }
                            };
                        })(this);
                    };

                    Parser.prototype.parseString = function(str, cb) {
                        var err;
                        if ((cb != null) && typeof cb === 'function') {
                            this.on('end', function(result) {
                                this.reset();
                                return cb(null, result);
                            });
                            this.on('error', function(err) {
                                this.reset();
                                return cb(err);
                            });
                        }
                        try {
                            str = str.toString();
                            if (str.trim() === '') {
                                this.emit('end', null);
                                return true;
                            }
                            str = bom.stripBOM(str);
                            if (this.options.async) {
                                this.remaining = str;
                                setImmediate(this.processAsync);
                                return this.saxParser;
                            }
                            return this.saxParser.write(str).close();
                        } catch (error1) {
                            err = error1;
                            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                                this.emit('error', err);
                                return this.saxParser.errThrown = true;
                            } else if (this.saxParser.ended) {
                                throw err;
                            }
                        }
                    };

                    return Parser;

                })(events.EventEmitter);

                exports.parseString = function(str, a, b) {
                    var cb, options, parser;
                    if (b != null) {
                        if (typeof b === 'function') {
                            cb = b;
                        }
                        if (typeof a === 'object') {
                            options = a;
                        }
                    } else {
                        if (typeof a === 'function') {
                            cb = a;
                        }
                        options = {};
                    }
                    parser = new exports.Parser(options);
                    return parser.parseString(str, cb);
                };

            }).call(this);

        }, { './bom': 200, './defaults': 202, './processors': 204, 'events': 97, 'sax': 170, 'timers': 192 }],
        204: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                'use strict';
                var prefixMatch;

                prefixMatch = new RegExp(/(?!xmlns)^.*:/);

                exports.normalize = function(str) {
                    return str.toLowerCase();
                };

                exports.firstCharLowerCase = function(str) {
                    return str.charAt(0).toLowerCase() + str.slice(1);
                };

                exports.stripPrefix = function(str) {
                    return str.replace(prefixMatch, '');
                };

                exports.parseNumbers = function(str) {
                    if (!isNaN(str)) {
                        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
                    }
                    return str;
                };

                exports.parseBooleans = function(str) {
                    if (/^(?:true|false)$/i.test(str)) {
                        str = str.toLowerCase() === 'true';
                    }
                    return str;
                };

            }).call(this);

        }, {}],
        205: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                'use strict';
                var builder, defaults, parser, processors,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                defaults = require('./defaults');

                builder = require('./builder');

                parser = require('./parser');

                processors = require('./processors');

                exports.defaults = defaults.defaults;

                exports.processors = processors;

                exports.ValidationError = (function(superClass) {
                    extend(ValidationError, superClass);

                    function ValidationError(message) {
                        this.message = message;
                    }

                    return ValidationError;

                })(Error);

                exports.Builder = builder.Builder;

                exports.Parser = parser.Parser;

                exports.parseString = parser.parseString;

            }).call(this);

        }, { './builder': 201, './defaults': 202, './parser': 203, './processors': 204 }],
        206: [function(require, module, exports) {

            var XML_CHARACTER_MAP = {
                '&': '&amp;',
                '"': '&quot;',
                '\'': '&apos;',
                '<': '&lt;',
                '>': '&gt;'
            };

            function escapeForXML(string) {
                return string && string.replace
                    ? string.replace(/([&"<>'])/g, function(str, item) {
                        return XML_CHARACTER_MAP[item];
                    })
                    : string;
            }

            module.exports = escapeForXML;

        }, {}],
        207: [function(require, module, exports) {
            (function(process) {
                var escapeForXML = require('./escapeForXML');
                var Stream = require('stream').Stream;

                var DEFAULT_INDENT = '    ';

                function xml(input, options) {

                    if (typeof options !== 'object') {
                        options = {
                            indent: options
                        };
                    }

                    var stream = options.stream ? new Stream() : null,
                        output = '',
                        interrupted = false,
                        indent = !options.indent ? ''
                            : options.indent === true ? DEFAULT_INDENT
                                : options.indent,
                        instant = true;


                    function delay(func) {
                        if (!instant) {
                            func();
                        } else {
                            process.nextTick(func);
                        }
                    }

                    function append(interrupt, out) {
                        if (out !== undefined) {
                            output += out;
                        }
                        if (interrupt && !interrupted) {
                            stream = stream || new Stream();
                            interrupted = true;
                        }
                        if (interrupt && interrupted) {
                            var data = output;
                            delay(function() {
                                stream.emit('data', data);
                            });
                            output = '';
                        }
                    }

                    function add(value, last) {
                        format(append, resolve(value, indent, indent ? 1 : 0), last);
                    }

                    function end() {
                        if (stream) {
                            var data = output;
                            delay(function() {
                                stream.emit('data', data);
                                stream.emit('end');
                                stream.readable = false;
                                stream.emit('close');
                            });
                        }
                    }

                    function addXmlDeclaration(declaration) {
                        var encoding = declaration.encoding || 'UTF-8',
                            attr = { version: '1.0', encoding: encoding };

                        if (declaration.standalone) {
                            attr.standalone = declaration.standalone;
                        }

                        add({ '?xml': { _attr: attr } });
                        output = output.replace('/>', '?>');
                    }

                    // disable delay delayed
                    delay(function() {
                        instant = false;
                    });

                    if (options.declaration) {
                        addXmlDeclaration(options.declaration);
                    }

                    if (input && input.forEach) {
                        input.forEach(function(value, i) {
                            var last;
                            if (i + 1 === input.length)
                                last = end;
                            add(value, last);
                        });
                    } else {
                        add(input, end);
                    }

                    if (stream) {
                        stream.readable = true;
                        return stream;
                    }
                    return output;
                }

                function element(/*input, …*/) {
                    var input = Array.prototype.slice.call(arguments),
                        self = {
                            _elem: resolve(input)
                        };

                    self.push = function(input) {
                        if (!this.append) {
                            throw new Error('not assigned to a parent!');
                        }
                        var that = this;
                        var indent = this._elem.indent;
                        format(this.append, resolve(
                                input, indent, this._elem.icount + (indent ? 1 : 0)),
                            function() {
                                that.append(true);
                            });
                    };

                    self.close = function(input) {
                        if (input !== undefined) {
                            this.push(input);
                        }
                        if (this.end) {
                            this.end();
                        }
                    };

                    return self;
                }

                function create_indent(character, count) {
                    return (new Array(count || 0).join(character || ''));
                }

                function resolve(data, indent, indent_count) {
                    indent_count = indent_count || 0;
                    var indent_spaces = create_indent(indent, indent_count);
                    var name;
                    var values = data;
                    var interrupt = false;

                    if (typeof data === 'object') {
                        var keys = Object.keys(data);
                        name = keys[0];
                        values = data[name];

                        if (values && values._elem) {
                            values._elem.name = name;
                            values._elem.icount = indent_count;
                            values._elem.indent = indent;
                            values._elem.indents = indent_spaces;
                            values._elem.interrupt = values;
                            return values._elem;
                        }
                    }

                    var attributes = [],
                        content = [];

                    var isStringContent;

                    function get_attributes(obj) {
                        var keys = Object.keys(obj);
                        keys.forEach(function(key) {
                            attributes.push(attribute(key, obj[key]));
                        });
                    }

                    switch (typeof values) {
                        case 'object':
                            if (values === null) break;

                            if (values._attr) {
                                get_attributes(values._attr);
                            }

                            if (values._cdata) {
                                content.push(
                                    ('<![CDATA[' + values._cdata).replace(/\]\]>/g, ']]]]><![CDATA[>') + ']]>'
                                );
                            }

                            if (values.forEach) {
                                isStringContent = false;
                                content.push('');
                                values.forEach(function(value) {
                                    if (typeof value == 'object') {
                                        var _name = Object.keys(value)[0];

                                        if (_name == '_attr') {
                                            get_attributes(value._attr);
                                        } else {
                                            content.push(resolve(
                                                value, indent, indent_count + 1));
                                        }
                                    } else {
                                        //string
                                        content.pop();
                                        isStringContent = true;
                                        content.push(escapeForXML(value));
                                    }

                                });
                                if (!isStringContent) {
                                    content.push('');
                                }
                            }
                            break;

                        default:
                            //string
                            content.push(escapeForXML(values));

                    }

                    return {
                        name: name,
                        interrupt: interrupt,
                        attributes: attributes,
                        content: content,
                        icount: indent_count,
                        indents: indent_spaces,
                        indent: indent
                    };
                }

                function format(append, elem, end) {

                    if (typeof elem != 'object') {
                        return append(false, elem);
                    }

                    var len = elem.interrupt ? 1 : elem.content.length;

                    function proceed() {
                        while (elem.content.length) {
                            var value = elem.content.shift();

                            if (value === undefined) continue;
                            if (interrupt(value)) return;

                            format(append, value);
                        }

                        append(false, (len > 1 ? elem.indents : '')
                            + (elem.name ? '</' + elem.name + '>' : '')
                            + (elem.indent && !end ? '\n' : ''));

                        if (end) {
                            end();
                        }
                    }

                    function interrupt(value) {
                        if (value.interrupt) {
                            value.interrupt.append = append;
                            value.interrupt.end = proceed;
                            value.interrupt = false;
                            append(true);
                            return true;
                        }
                        return false;
                    }

                    append(false, elem.indents
                        + (elem.name ? '<' + elem.name : '')
                        + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '')
                        + (len ? (elem.name ? '>' : '') : (elem.name ? '/>' : ''))
                        + (elem.indent && len > 1 ? '\n' : ''));

                    if (!len) {
                        return append(false, elem.indent ? '\n' : '');
                    }

                    if (!interrupt(elem)) {
                        proceed();
                    }
                }

                function attribute(key, value) {
                    return key + '=' + '"' + escapeForXML(value) + '"';
                }

                module.exports = xml;
                module.exports.element = module.exports.Element = element;

            }).call(this, require('_process'));
        }, { './escapeForXML': 206, '_process': 141, 'stream': 179 }],
        208: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
                    slice = [].slice,
                    hasProp = {}.hasOwnProperty;

                assign = function() {
                    var i, key, len, source, sources, target;
                    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                    if (isFunction(Object.assign)) {
                        Object.assign.apply(null, arguments);
                    } else {
                        for (i = 0, len = sources.length; i < len; i++) {
                            source = sources[i];
                            if (source != null) {
                                for (key in source) {
                                    if (!hasProp.call(source, key)) continue;
                                    target[key] = source[key];
                                }
                            }
                        }
                    }
                    return target;
                };

                isFunction = function(val) {
                    return !!val && Object.prototype.toString.call(val) === '[object Function]';
                };

                isObject = function(val) {
                    var ref;
                    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
                };

                isArray = function(val) {
                    if (isFunction(Array.isArray)) {
                        return Array.isArray(val);
                    } else {
                        return Object.prototype.toString.call(val) === '[object Array]';
                    }
                };

                isEmpty = function(val) {
                    var key;
                    if (isArray(val)) {
                        return !val.length;
                    } else {
                        for (key in val) {
                            if (!hasProp.call(val, key)) continue;
                            return false;
                        }
                        return true;
                    }
                };

                isPlainObject = function(val) {
                    var ctor, proto;
                    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
                };

                module.exports.assign = assign;

                module.exports.isFunction = isFunction;

                module.exports.isObject = isObject;

                module.exports.isArray = isArray;

                module.exports.isEmpty = isEmpty;

                module.exports.isPlainObject = isPlainObject;

            }).call(this);

        }, {}],
        209: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLAttribute;

                module.exports = XMLAttribute = (function() {
                    function XMLAttribute(parent, name, value) {
                        this.options = parent.options;
                        this.stringify = parent.stringify;
                        if (name == null) {
                            throw new Error('Missing attribute name of element ' + parent.name);
                        }
                        if (value == null) {
                            throw new Error('Missing attribute value for attribute ' + name + ' of element ' + parent.name);
                        }
                        this.name = this.stringify.attName(name);
                        this.value = this.stringify.attValue(value);
                    }

                    XMLAttribute.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLAttribute.prototype.toString = function(options) {
                        return this.options.writer.set(options).attribute(this);
                    };

                    return XMLAttribute;

                })();

            }).call(this);

        }, {}],
        210: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLCData, XMLNode,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLCData = (function(superClass) {
                    extend(XMLCData, superClass);

                    function XMLCData(parent, text) {
                        XMLCData.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error('Missing CDATA text');
                        }
                        this.text = this.stringify.cdata(text);
                    }

                    XMLCData.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLCData.prototype.toString = function(options) {
                        return this.options.writer.set(options).cdata(this);
                    };

                    return XMLCData;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        211: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLComment, XMLNode,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLComment = (function(superClass) {
                    extend(XMLComment, superClass);

                    function XMLComment(parent, text) {
                        XMLComment.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error('Missing comment text');
                        }
                        this.text = this.stringify.comment(text);
                    }

                    XMLComment.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLComment.prototype.toString = function(options) {
                        return this.options.writer.set(options).comment(this);
                    };

                    return XMLComment;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        212: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDTDAttList, XMLNode,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLDTDAttList = (function(superClass) {
                    extend(XMLDTDAttList, superClass);

                    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        XMLDTDAttList.__super__.constructor.call(this, parent);
                        if (elementName == null) {
                            throw new Error('Missing DTD element name');
                        }
                        if (attributeName == null) {
                            throw new Error('Missing DTD attribute name');
                        }
                        if (!attributeType) {
                            throw new Error('Missing DTD attribute type');
                        }
                        if (!defaultValueType) {
                            throw new Error('Missing DTD attribute default');
                        }
                        if (defaultValueType.indexOf('#') !== 0) {
                            defaultValueType = '#' + defaultValueType;
                        }
                        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
                            throw new Error('Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT');
                        }
                        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
                            throw new Error('Default value only applies to #FIXED or #DEFAULT');
                        }
                        this.elementName = this.stringify.eleName(elementName);
                        this.attributeName = this.stringify.attName(attributeName);
                        this.attributeType = this.stringify.dtdAttType(attributeType);
                        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
                        this.defaultValueType = defaultValueType;
                    }

                    XMLDTDAttList.prototype.toString = function(options) {
                        return this.options.writer.set(options).dtdAttList(this);
                    };

                    return XMLDTDAttList;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        213: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDTDElement, XMLNode,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLDTDElement = (function(superClass) {
                    extend(XMLDTDElement, superClass);

                    function XMLDTDElement(parent, name, value) {
                        XMLDTDElement.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error('Missing DTD element name');
                        }
                        if (!value) {
                            value = '(#PCDATA)';
                        }
                        if (Array.isArray(value)) {
                            value = '(' + value.join(',') + ')';
                        }
                        this.name = this.stringify.eleName(name);
                        this.value = this.stringify.dtdElementValue(value);
                    }

                    XMLDTDElement.prototype.toString = function(options) {
                        return this.options.writer.set(options).dtdElement(this);
                    };

                    return XMLDTDElement;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        214: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDTDEntity, XMLNode, isObject,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                isObject = require('./Utility').isObject;

                XMLNode = require('./XMLNode');

                module.exports = XMLDTDEntity = (function(superClass) {
                    extend(XMLDTDEntity, superClass);

                    function XMLDTDEntity(parent, pe, name, value) {
                        XMLDTDEntity.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error('Missing entity name');
                        }
                        if (value == null) {
                            throw new Error('Missing entity value');
                        }
                        this.pe = !!pe;
                        this.name = this.stringify.eleName(name);
                        if (!isObject(value)) {
                            this.value = this.stringify.dtdEntityValue(value);
                        } else {
                            if (!value.pubID && !value.sysID) {
                                throw new Error('Public and/or system identifiers are required for an external entity');
                            }
                            if (value.pubID && !value.sysID) {
                                throw new Error('System identifier is required for a public external entity');
                            }
                            if (value.pubID != null) {
                                this.pubID = this.stringify.dtdPubID(value.pubID);
                            }
                            if (value.sysID != null) {
                                this.sysID = this.stringify.dtdSysID(value.sysID);
                            }
                            if (value.nData != null) {
                                this.nData = this.stringify.dtdNData(value.nData);
                            }
                            if (this.pe && this.nData) {
                                throw new Error('Notation declaration is not allowed in a parameter entity');
                            }
                        }
                    }

                    XMLDTDEntity.prototype.toString = function(options) {
                        return this.options.writer.set(options).dtdEntity(this);
                    };

                    return XMLDTDEntity;

                })(XMLNode);

            }).call(this);

        }, { './Utility': 208, './XMLNode': 221 }],
        215: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDTDNotation, XMLNode,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLDTDNotation = (function(superClass) {
                    extend(XMLDTDNotation, superClass);

                    function XMLDTDNotation(parent, name, value) {
                        XMLDTDNotation.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error('Missing notation name');
                        }
                        if (!value.pubID && !value.sysID) {
                            throw new Error('Public or system identifiers are required for an external entity');
                        }
                        this.name = this.stringify.eleName(name);
                        if (value.pubID != null) {
                            this.pubID = this.stringify.dtdPubID(value.pubID);
                        }
                        if (value.sysID != null) {
                            this.sysID = this.stringify.dtdSysID(value.sysID);
                        }
                    }

                    XMLDTDNotation.prototype.toString = function(options) {
                        return this.options.writer.set(options).dtdNotation(this);
                    };

                    return XMLDTDNotation;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        216: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDeclaration, XMLNode, isObject,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                isObject = require('./Utility').isObject;

                XMLNode = require('./XMLNode');

                module.exports = XMLDeclaration = (function(superClass) {
                    extend(XMLDeclaration, superClass);

                    function XMLDeclaration(parent, version, encoding, standalone) {
                        var ref;
                        XMLDeclaration.__super__.constructor.call(this, parent);
                        if (isObject(version)) {
                            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
                        }
                        if (!version) {
                            version = '1.0';
                        }
                        this.version = this.stringify.xmlVersion(version);
                        if (encoding != null) {
                            this.encoding = this.stringify.xmlEncoding(encoding);
                        }
                        if (standalone != null) {
                            this.standalone = this.stringify.xmlStandalone(standalone);
                        }
                    }

                    XMLDeclaration.prototype.toString = function(options) {
                        return this.options.writer.set(options).declaration(this);
                    };

                    return XMLDeclaration;

                })(XMLNode);

            }).call(this);

        }, { './Utility': 208, './XMLNode': 221 }],
        217: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                isObject = require('./Utility').isObject;

                XMLNode = require('./XMLNode');

                XMLDTDAttList = require('./XMLDTDAttList');

                XMLDTDEntity = require('./XMLDTDEntity');

                XMLDTDElement = require('./XMLDTDElement');

                XMLDTDNotation = require('./XMLDTDNotation');

                module.exports = XMLDocType = (function(superClass) {
                    extend(XMLDocType, superClass);

                    function XMLDocType(parent, pubID, sysID) {
                        var ref, ref1;
                        XMLDocType.__super__.constructor.call(this, parent);
                        this.documentObject = parent;
                        if (isObject(pubID)) {
                            ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
                        }
                        if (sysID == null) {
                            ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
                        }
                        if (pubID != null) {
                            this.pubID = this.stringify.dtdPubID(pubID);
                        }
                        if (sysID != null) {
                            this.sysID = this.stringify.dtdSysID(sysID);
                        }
                    }

                    XMLDocType.prototype.element = function(name, value) {
                        var child;
                        child = new XMLDTDElement(this, name, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        var child;
                        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                        this.children.push(child);
                        return this;
                    };

                    XMLDocType.prototype.entity = function(name, value) {
                        var child;
                        child = new XMLDTDEntity(this, false, name, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLDocType.prototype.pEntity = function(name, value) {
                        var child;
                        child = new XMLDTDEntity(this, true, name, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLDocType.prototype.notation = function(name, value) {
                        var child;
                        child = new XMLDTDNotation(this, name, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLDocType.prototype.toString = function(options) {
                        return this.options.writer.set(options).docType(this);
                    };

                    XMLDocType.prototype.ele = function(name, value) {
                        return this.element(name, value);
                    };

                    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
                    };

                    XMLDocType.prototype.ent = function(name, value) {
                        return this.entity(name, value);
                    };

                    XMLDocType.prototype.pent = function(name, value) {
                        return this.pEntity(name, value);
                    };

                    XMLDocType.prototype.not = function(name, value) {
                        return this.notation(name, value);
                    };

                    XMLDocType.prototype.up = function() {
                        return this.root() || this.documentObject;
                    };

                    return XMLDocType;

                })(XMLNode);

            }).call(this);

        }, {
            './Utility': 208,
            './XMLDTDAttList': 212,
            './XMLDTDElement': 213,
            './XMLDTDEntity': 214,
            './XMLDTDNotation': 215,
            './XMLNode': 221
        }],
        218: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                isPlainObject = require('./Utility').isPlainObject;

                XMLNode = require('./XMLNode');

                XMLStringifier = require('./XMLStringifier');

                XMLStringWriter = require('./XMLStringWriter');

                module.exports = XMLDocument = (function(superClass) {
                    extend(XMLDocument, superClass);

                    function XMLDocument(options) {
                        XMLDocument.__super__.constructor.call(this, null);
                        options || (options = {});
                        if (!options.writer) {
                            options.writer = new XMLStringWriter();
                        }
                        this.options = options;
                        this.stringify = new XMLStringifier(options);
                        this.isDocument = true;
                    }

                    XMLDocument.prototype.end = function(writer) {
                        var writerOptions;
                        if (!writer) {
                            writer = this.options.writer;
                        } else if (isPlainObject(writer)) {
                            writerOptions = writer;
                            writer = this.options.writer.set(writerOptions);
                        }
                        return writer.document(this);
                    };

                    XMLDocument.prototype.toString = function(options) {
                        return this.options.writer.set(options).document(this);
                    };

                    return XMLDocument;

                })(XMLNode);

            }).call(this);

        }, { './Utility': 208, './XMLNode': 221, './XMLStringWriter': 225, './XMLStringifier': 226 }],
        219: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation,
                    XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw,
                    XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
                    hasProp = {}.hasOwnProperty;

                ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

                XMLElement = require('./XMLElement');

                XMLCData = require('./XMLCData');

                XMLComment = require('./XMLComment');

                XMLRaw = require('./XMLRaw');

                XMLText = require('./XMLText');

                XMLProcessingInstruction = require('./XMLProcessingInstruction');

                XMLDeclaration = require('./XMLDeclaration');

                XMLDocType = require('./XMLDocType');

                XMLDTDAttList = require('./XMLDTDAttList');

                XMLDTDEntity = require('./XMLDTDEntity');

                XMLDTDElement = require('./XMLDTDElement');

                XMLDTDNotation = require('./XMLDTDNotation');

                XMLAttribute = require('./XMLAttribute');

                XMLStringifier = require('./XMLStringifier');

                XMLStringWriter = require('./XMLStringWriter');

                module.exports = XMLDocumentCB = (function() {
                    function XMLDocumentCB(options, onData, onEnd) {
                        var writerOptions;
                        options || (options = {});
                        if (!options.writer) {
                            options.writer = new XMLStringWriter(options);
                        } else if (isPlainObject(options.writer)) {
                            writerOptions = options.writer;
                            options.writer = new XMLStringWriter(writerOptions);
                        }
                        this.options = options;
                        this.writer = options.writer;
                        this.stringify = new XMLStringifier(options);
                        this.onDataCallback = onData || function() {
                        };
                        this.onEndCallback = onEnd || function() {
                        };
                        this.currentNode = null;
                        this.currentLevel = -1;
                        this.openTags = {};
                        this.documentStarted = false;
                        this.documentCompleted = false;
                        this.root = null;
                    }

                    XMLDocumentCB.prototype.node = function(name, attributes, text) {
                        var ref1;
                        if (name == null) {
                            throw new Error('Missing node name');
                        }
                        if (this.root && this.currentLevel === -1) {
                            throw new Error('Document can only have one root node');
                        }
                        this.openCurrent();
                        name = name.valueOf();
                        if (attributes == null) {
                            attributes = {};
                        }
                        attributes = attributes.valueOf();
                        if (!isObject(attributes)) {
                            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
                        }
                        this.currentNode = new XMLElement(this, name, attributes);
                        this.currentNode.children = false;
                        this.currentLevel++;
                        this.openTags[this.currentLevel] = this.currentNode;
                        if (text != null) {
                            this.text(text);
                        }
                        return this;
                    };

                    XMLDocumentCB.prototype.element = function(name, attributes, text) {
                        if (this.currentNode && this.currentNode instanceof XMLDocType) {
                            return this.dtdElement.apply(this, arguments);
                        } else {
                            return this.node(name, attributes, text);
                        }
                    };

                    XMLDocumentCB.prototype.attribute = function(name, value) {
                        var attName, attValue;
                        if (!this.currentNode || this.currentNode.children) {
                            throw new Error('att() can only be used immediately after an ele() call in callback mode');
                        }
                        if (name != null) {
                            name = name.valueOf();
                        }
                        if (isObject(name)) {
                            for (attName in name) {
                                if (!hasProp.call(name, attName)) continue;
                                attValue = name[attName];
                                this.attribute(attName, attValue);
                            }
                        } else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            if (!this.options.skipNullAttributes || (value != null)) {
                                this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
                            }
                        }
                        return this;
                    };

                    XMLDocumentCB.prototype.text = function(value) {
                        var node;
                        this.openCurrent();
                        node = new XMLText(this, value);
                        this.onData(this.writer.text(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.cdata = function(value) {
                        var node;
                        this.openCurrent();
                        node = new XMLCData(this, value);
                        this.onData(this.writer.cdata(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.comment = function(value) {
                        var node;
                        this.openCurrent();
                        node = new XMLComment(this, value);
                        this.onData(this.writer.comment(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.raw = function(value) {
                        var node;
                        this.openCurrent();
                        node = new XMLRaw(this, value);
                        this.onData(this.writer.raw(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.instruction = function(target, value) {
                        var i, insTarget, insValue, len, node;
                        this.openCurrent();
                        if (target != null) {
                            target = target.valueOf();
                        }
                        if (value != null) {
                            value = value.valueOf();
                        }
                        if (Array.isArray(target)) {
                            for (i = 0, len = target.length; i < len; i++) {
                                insTarget = target[i];
                                this.instruction(insTarget);
                            }
                        } else if (isObject(target)) {
                            for (insTarget in target) {
                                if (!hasProp.call(target, insTarget)) continue;
                                insValue = target[insTarget];
                                this.instruction(insTarget, insValue);
                            }
                        } else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            node = new XMLProcessingInstruction(this, target, value);
                            this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
                        }
                        return this;
                    };

                    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
                        var node;
                        this.openCurrent();
                        if (this.documentStarted) {
                            throw new Error('declaration() must be the first node');
                        }
                        node = new XMLDeclaration(this, version, encoding, standalone);
                        this.onData(this.writer.declaration(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
                        this.openCurrent();
                        if (root == null) {
                            throw new Error('Missing root node name');
                        }
                        if (this.root) {
                            throw new Error('dtd() must come before the root node');
                        }
                        this.currentNode = new XMLDocType(this, pubID, sysID);
                        this.currentNode.rootNodeName = root;
                        this.currentNode.children = false;
                        this.currentLevel++;
                        this.openTags[this.currentLevel] = this.currentNode;
                        return this;
                    };

                    XMLDocumentCB.prototype.dtdElement = function(name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDElement(this, name, value);
                        this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
                        this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.entity = function(name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDEntity(this, false, name, value);
                        this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.pEntity = function(name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDEntity(this, true, name, value);
                        this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.notation = function(name, value) {
                        var node;
                        this.openCurrent();
                        node = new XMLDTDNotation(this, name, value);
                        this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
                        return this;
                    };

                    XMLDocumentCB.prototype.up = function() {
                        if (this.currentLevel < 0) {
                            throw new Error('The document node has no parent');
                        }
                        if (this.currentNode) {
                            if (this.currentNode.children) {
                                this.closeNode(this.currentNode);
                            } else {
                                this.openNode(this.currentNode);
                            }
                            this.currentNode = null;
                        } else {
                            this.closeNode(this.openTags[this.currentLevel]);
                        }
                        delete this.openTags[this.currentLevel];
                        this.currentLevel--;
                        return this;
                    };

                    XMLDocumentCB.prototype.end = function() {
                        while (this.currentLevel >= 0) {
                            this.up();
                        }
                        return this.onEnd();
                    };

                    XMLDocumentCB.prototype.openCurrent = function() {
                        if (this.currentNode) {
                            this.currentNode.children = true;
                            return this.openNode(this.currentNode);
                        }
                    };

                    XMLDocumentCB.prototype.openNode = function(node) {
                        if (!node.isOpen) {
                            if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
                                this.root = node;
                            }
                            this.onData(this.writer.openNode(node, this.currentLevel));
                            return node.isOpen = true;
                        }
                    };

                    XMLDocumentCB.prototype.closeNode = function(node) {
                        if (!node.isClosed) {
                            this.onData(this.writer.closeNode(node, this.currentLevel));
                            return node.isClosed = true;
                        }
                    };

                    XMLDocumentCB.prototype.onData = function(chunk) {
                        this.documentStarted = true;
                        return this.onDataCallback(chunk);
                    };

                    XMLDocumentCB.prototype.onEnd = function() {
                        this.documentCompleted = true;
                        return this.onEndCallback();
                    };

                    XMLDocumentCB.prototype.ele = function() {
                        return this.element.apply(this, arguments);
                    };

                    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
                        return this.node(name, attributes, text);
                    };

                    XMLDocumentCB.prototype.txt = function(value) {
                        return this.text(value);
                    };

                    XMLDocumentCB.prototype.dat = function(value) {
                        return this.cdata(value);
                    };

                    XMLDocumentCB.prototype.com = function(value) {
                        return this.comment(value);
                    };

                    XMLDocumentCB.prototype.ins = function(target, value) {
                        return this.instruction(target, value);
                    };

                    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
                        return this.declaration(version, encoding, standalone);
                    };

                    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
                        return this.doctype(root, pubID, sysID);
                    };

                    XMLDocumentCB.prototype.e = function(name, attributes, text) {
                        return this.element(name, attributes, text);
                    };

                    XMLDocumentCB.prototype.n = function(name, attributes, text) {
                        return this.node(name, attributes, text);
                    };

                    XMLDocumentCB.prototype.t = function(value) {
                        return this.text(value);
                    };

                    XMLDocumentCB.prototype.d = function(value) {
                        return this.cdata(value);
                    };

                    XMLDocumentCB.prototype.c = function(value) {
                        return this.comment(value);
                    };

                    XMLDocumentCB.prototype.r = function(value) {
                        return this.raw(value);
                    };

                    XMLDocumentCB.prototype.i = function(target, value) {
                        return this.instruction(target, value);
                    };

                    XMLDocumentCB.prototype.att = function() {
                        if (this.currentNode && this.currentNode instanceof XMLDocType) {
                            return this.attList.apply(this, arguments);
                        } else {
                            return this.attribute.apply(this, arguments);
                        }
                    };

                    XMLDocumentCB.prototype.a = function() {
                        if (this.currentNode && this.currentNode instanceof XMLDocType) {
                            return this.attList.apply(this, arguments);
                        } else {
                            return this.attribute.apply(this, arguments);
                        }
                    };

                    XMLDocumentCB.prototype.ent = function(name, value) {
                        return this.entity(name, value);
                    };

                    XMLDocumentCB.prototype.pent = function(name, value) {
                        return this.pEntity(name, value);
                    };

                    XMLDocumentCB.prototype.not = function(name, value) {
                        return this.notation(name, value);
                    };

                    return XMLDocumentCB;

                })();

            }).call(this);

        }, {
            './Utility': 208,
            './XMLAttribute': 209,
            './XMLCData': 210,
            './XMLComment': 211,
            './XMLDTDAttList': 212,
            './XMLDTDElement': 213,
            './XMLDTDEntity': 214,
            './XMLDTDNotation': 215,
            './XMLDeclaration': 216,
            './XMLDocType': 217,
            './XMLElement': 220,
            './XMLProcessingInstruction': 222,
            './XMLRaw': 223,
            './XMLStringWriter': 225,
            './XMLStringifier': 226,
            './XMLText': 227
        }],
        220: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction;

                XMLNode = require('./XMLNode');

                XMLAttribute = require('./XMLAttribute');

                module.exports = XMLElement = (function(superClass) {
                    extend(XMLElement, superClass);

                    function XMLElement(parent, name, attributes) {
                        XMLElement.__super__.constructor.call(this, parent);
                        if (name == null) {
                            throw new Error('Missing element name');
                        }
                        this.name = this.stringify.eleName(name);
                        this.attributes = {};
                        if (attributes != null) {
                            this.attribute(attributes);
                        }
                        if (parent.isDocument) {
                            this.isRoot = true;
                            this.documentObject = parent;
                            parent.rootObject = this;
                        }
                    }

                    XMLElement.prototype.clone = function() {
                        var att, attName, clonedSelf, ref1;
                        clonedSelf = Object.create(this);
                        if (clonedSelf.isRoot) {
                            clonedSelf.documentObject = null;
                        }
                        clonedSelf.attributes = {};
                        ref1 = this.attributes;
                        for (attName in ref1) {
                            if (!hasProp.call(ref1, attName)) continue;
                            att = ref1[attName];
                            clonedSelf.attributes[attName] = att.clone();
                        }
                        clonedSelf.children = [];
                        this.children.forEach(function(child) {
                            var clonedChild;
                            clonedChild = child.clone();
                            clonedChild.parent = clonedSelf;
                            return clonedSelf.children.push(clonedChild);
                        });
                        return clonedSelf;
                    };

                    XMLElement.prototype.attribute = function(name, value) {
                        var attName, attValue;
                        if (name != null) {
                            name = name.valueOf();
                        }
                        if (isObject(name)) {
                            for (attName in name) {
                                if (!hasProp.call(name, attName)) continue;
                                attValue = name[attName];
                                this.attribute(attName, attValue);
                            }
                        } else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            if (!this.options.skipNullAttributes || (value != null)) {
                                this.attributes[name] = new XMLAttribute(this, name, value);
                            }
                        }
                        return this;
                    };

                    XMLElement.prototype.removeAttribute = function(name) {
                        var attName, i, len;
                        if (name == null) {
                            throw new Error('Missing attribute name');
                        }
                        name = name.valueOf();
                        if (Array.isArray(name)) {
                            for (i = 0, len = name.length; i < len; i++) {
                                attName = name[i];
                                delete this.attributes[attName];
                            }
                        } else {
                            delete this.attributes[name];
                        }
                        return this;
                    };

                    XMLElement.prototype.toString = function(options) {
                        return this.options.writer.set(options).element(this);
                    };

                    XMLElement.prototype.att = function(name, value) {
                        return this.attribute(name, value);
                    };

                    XMLElement.prototype.a = function(name, value) {
                        return this.attribute(name, value);
                    };

                    return XMLElement;

                })(XMLNode);

            }).call(this);

        }, { './Utility': 208, './XMLAttribute': 209, './XMLNode': 221 }],
        221: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction,
                    XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
                    hasProp = {}.hasOwnProperty;

                ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

                XMLElement = null;

                XMLCData = null;

                XMLComment = null;

                XMLDeclaration = null;

                XMLDocType = null;

                XMLRaw = null;

                XMLText = null;

                XMLProcessingInstruction = null;

                module.exports = XMLNode = (function() {
                    function XMLNode(parent) {
                        this.parent = parent;
                        if (this.parent) {
                            this.options = this.parent.options;
                            this.stringify = this.parent.stringify;
                        }
                        this.children = [];
                        if (!XMLElement) {
                            XMLElement = require('./XMLElement');
                            XMLCData = require('./XMLCData');
                            XMLComment = require('./XMLComment');
                            XMLDeclaration = require('./XMLDeclaration');
                            XMLDocType = require('./XMLDocType');
                            XMLRaw = require('./XMLRaw');
                            XMLText = require('./XMLText');
                            XMLProcessingInstruction = require('./XMLProcessingInstruction');
                        }
                    }

                    XMLNode.prototype.element = function(name, attributes, text) {
                        var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
                        lastChild = null;
                        if (attributes == null) {
                            attributes = {};
                        }
                        attributes = attributes.valueOf();
                        if (!isObject(attributes)) {
                            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
                        }
                        if (name != null) {
                            name = name.valueOf();
                        }
                        if (Array.isArray(name)) {
                            for (j = 0, len = name.length; j < len; j++) {
                                item = name[j];
                                lastChild = this.element(item);
                            }
                        } else if (isFunction(name)) {
                            lastChild = this.element(name.apply());
                        } else if (isObject(name)) {
                            for (key in name) {
                                if (!hasProp.call(name, key)) continue;
                                val = name[key];
                                if (isFunction(val)) {
                                    val = val.apply();
                                }
                                if ((isObject(val)) && (isEmpty(val))) {
                                    val = null;
                                }
                                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                                    lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                                } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                                    for (k = 0, len1 = val.length; k < len1; k++) {
                                        item = val[k];
                                        childNode = {};
                                        childNode[key] = item;
                                        lastChild = this.element(childNode);
                                    }
                                } else if (isObject(val)) {
                                    lastChild = this.element(key);
                                    lastChild.element(val);
                                } else {
                                    lastChild = this.element(key, val);
                                }
                            }
                        } else {
                            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                                lastChild = this.text(text);
                            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                                lastChild = this.cdata(text);
                            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                                lastChild = this.comment(text);
                            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                                lastChild = this.raw(text);
                            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
                            } else {
                                lastChild = this.node(name, attributes, text);
                            }
                        }
                        if (lastChild == null) {
                            throw new Error('Could not create any elements with: ' + name);
                        }
                        return lastChild;
                    };

                    XMLNode.prototype.insertBefore = function(name, attributes, text) {
                        var child, i, removed;
                        if (this.isRoot) {
                            throw new Error('Cannot insert elements at root level');
                        }
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i);
                        child = this.parent.element(name, attributes, text);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return child;
                    };

                    XMLNode.prototype.insertAfter = function(name, attributes, text) {
                        var child, i, removed;
                        if (this.isRoot) {
                            throw new Error('Cannot insert elements at root level');
                        }
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.element(name, attributes, text);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return child;
                    };

                    XMLNode.prototype.remove = function() {
                        var i, ref1;
                        if (this.isRoot) {
                            throw new Error('Cannot remove the root element');
                        }
                        i = this.parent.children.indexOf(this);
                        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
                        return this.parent;
                    };

                    XMLNode.prototype.node = function(name, attributes, text) {
                        var child, ref1;
                        if (name != null) {
                            name = name.valueOf();
                        }
                        attributes || (attributes = {});
                        attributes = attributes.valueOf();
                        if (!isObject(attributes)) {
                            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
                        }
                        child = new XMLElement(this, name, attributes);
                        if (text != null) {
                            child.text(text);
                        }
                        this.children.push(child);
                        return child;
                    };

                    XMLNode.prototype.text = function(value) {
                        var child;
                        child = new XMLText(this, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLNode.prototype.cdata = function(value) {
                        var child;
                        child = new XMLCData(this, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLNode.prototype.comment = function(value) {
                        var child;
                        child = new XMLComment(this, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLNode.prototype.commentBefore = function(value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i);
                        child = this.parent.comment(value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };

                    XMLNode.prototype.commentAfter = function(value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.comment(value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };

                    XMLNode.prototype.raw = function(value) {
                        var child;
                        child = new XMLRaw(this, value);
                        this.children.push(child);
                        return this;
                    };

                    XMLNode.prototype.instruction = function(target, value) {
                        var insTarget, insValue, instruction, j, len;
                        if (target != null) {
                            target = target.valueOf();
                        }
                        if (value != null) {
                            value = value.valueOf();
                        }
                        if (Array.isArray(target)) {
                            for (j = 0, len = target.length; j < len; j++) {
                                insTarget = target[j];
                                this.instruction(insTarget);
                            }
                        } else if (isObject(target)) {
                            for (insTarget in target) {
                                if (!hasProp.call(target, insTarget)) continue;
                                insValue = target[insTarget];
                                this.instruction(insTarget, insValue);
                            }
                        } else {
                            if (isFunction(value)) {
                                value = value.apply();
                            }
                            instruction = new XMLProcessingInstruction(this, target, value);
                            this.children.push(instruction);
                        }
                        return this;
                    };

                    XMLNode.prototype.instructionBefore = function(target, value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i);
                        child = this.parent.instruction(target, value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };

                    XMLNode.prototype.instructionAfter = function(target, value) {
                        var child, i, removed;
                        i = this.parent.children.indexOf(this);
                        removed = this.parent.children.splice(i + 1);
                        child = this.parent.instruction(target, value);
                        Array.prototype.push.apply(this.parent.children, removed);
                        return this;
                    };

                    XMLNode.prototype.declaration = function(version, encoding, standalone) {
                        var doc, xmldec;
                        doc = this.document();
                        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
                        if (doc.children[0] instanceof XMLDeclaration) {
                            doc.children[0] = xmldec;
                        } else {
                            doc.children.unshift(xmldec);
                        }
                        return doc.root() || doc;
                    };

                    XMLNode.prototype.doctype = function(pubID, sysID) {
                        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
                        doc = this.document();
                        doctype = new XMLDocType(doc, pubID, sysID);
                        ref1 = doc.children;
                        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
                            child = ref1[i];
                            if (child instanceof XMLDocType) {
                                doc.children[i] = doctype;
                                return doctype;
                            }
                        }
                        ref2 = doc.children;
                        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
                            child = ref2[i];
                            if (child.isRoot) {
                                doc.children.splice(i, 0, doctype);
                                return doctype;
                            }
                        }
                        doc.children.push(doctype);
                        return doctype;
                    };

                    XMLNode.prototype.up = function() {
                        if (this.isRoot) {
                            throw new Error('The root node has no parent. Use doc() if you need to get the document object.');
                        }
                        return this.parent;
                    };

                    XMLNode.prototype.root = function() {
                        var node;
                        node = this;
                        while (node) {
                            if (node.isDocument) {
                                return node.rootObject;
                            } else if (node.isRoot) {
                                return node;
                            } else {
                                node = node.parent;
                            }
                        }
                    };

                    XMLNode.prototype.document = function() {
                        var node;
                        node = this;
                        while (node) {
                            if (node.isDocument) {
                                return node;
                            } else {
                                node = node.parent;
                            }
                        }
                    };

                    XMLNode.prototype.end = function(options) {
                        return this.document().end(options);
                    };

                    XMLNode.prototype.prev = function() {
                        var i;
                        i = this.parent.children.indexOf(this);
                        if (i < 1) {
                            throw new Error('Already at the first node');
                        }
                        return this.parent.children[i - 1];
                    };

                    XMLNode.prototype.next = function() {
                        var i;
                        i = this.parent.children.indexOf(this);
                        if (i === -1 || i === this.parent.children.length - 1) {
                            throw new Error('Already at the last node');
                        }
                        return this.parent.children[i + 1];
                    };

                    XMLNode.prototype.importDocument = function(doc) {
                        var clonedRoot;
                        clonedRoot = doc.root().clone();
                        clonedRoot.parent = this;
                        clonedRoot.isRoot = false;
                        this.children.push(clonedRoot);
                        return this;
                    };

                    XMLNode.prototype.ele = function(name, attributes, text) {
                        return this.element(name, attributes, text);
                    };

                    XMLNode.prototype.nod = function(name, attributes, text) {
                        return this.node(name, attributes, text);
                    };

                    XMLNode.prototype.txt = function(value) {
                        return this.text(value);
                    };

                    XMLNode.prototype.dat = function(value) {
                        return this.cdata(value);
                    };

                    XMLNode.prototype.com = function(value) {
                        return this.comment(value);
                    };

                    XMLNode.prototype.ins = function(target, value) {
                        return this.instruction(target, value);
                    };

                    XMLNode.prototype.doc = function() {
                        return this.document();
                    };

                    XMLNode.prototype.dec = function(version, encoding, standalone) {
                        return this.declaration(version, encoding, standalone);
                    };

                    XMLNode.prototype.dtd = function(pubID, sysID) {
                        return this.doctype(pubID, sysID);
                    };

                    XMLNode.prototype.e = function(name, attributes, text) {
                        return this.element(name, attributes, text);
                    };

                    XMLNode.prototype.n = function(name, attributes, text) {
                        return this.node(name, attributes, text);
                    };

                    XMLNode.prototype.t = function(value) {
                        return this.text(value);
                    };

                    XMLNode.prototype.d = function(value) {
                        return this.cdata(value);
                    };

                    XMLNode.prototype.c = function(value) {
                        return this.comment(value);
                    };

                    XMLNode.prototype.r = function(value) {
                        return this.raw(value);
                    };

                    XMLNode.prototype.i = function(target, value) {
                        return this.instruction(target, value);
                    };

                    XMLNode.prototype.u = function() {
                        return this.up();
                    };

                    XMLNode.prototype.importXMLBuilder = function(doc) {
                        return this.importDocument(doc);
                    };

                    return XMLNode;

                })();

            }).call(this);

        }, {
            './Utility': 208,
            './XMLCData': 210,
            './XMLComment': 211,
            './XMLDeclaration': 216,
            './XMLDocType': 217,
            './XMLElement': 220,
            './XMLProcessingInstruction': 222,
            './XMLRaw': 223,
            './XMLText': 227
        }],
        222: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLNode, XMLProcessingInstruction,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLProcessingInstruction = (function(superClass) {
                    extend(XMLProcessingInstruction, superClass);

                    function XMLProcessingInstruction(parent, target, value) {
                        XMLProcessingInstruction.__super__.constructor.call(this, parent);
                        if (target == null) {
                            throw new Error('Missing instruction target');
                        }
                        this.target = this.stringify.insTarget(target);
                        if (value) {
                            this.value = this.stringify.insValue(value);
                        }
                    }

                    XMLProcessingInstruction.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLProcessingInstruction.prototype.toString = function(options) {
                        return this.options.writer.set(options).processingInstruction(this);
                    };

                    return XMLProcessingInstruction;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        223: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLNode, XMLRaw,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLRaw = (function(superClass) {
                    extend(XMLRaw, superClass);

                    function XMLRaw(parent, text) {
                        XMLRaw.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error('Missing raw text');
                        }
                        this.value = this.stringify.raw(text);
                    }

                    XMLRaw.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLRaw.prototype.toString = function(options) {
                        return this.options.writer.set(options).raw(this);
                    };

                    return XMLRaw;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        224: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration,
                    XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLDeclaration = require('./XMLDeclaration');

                XMLDocType = require('./XMLDocType');

                XMLCData = require('./XMLCData');

                XMLComment = require('./XMLComment');

                XMLElement = require('./XMLElement');

                XMLRaw = require('./XMLRaw');

                XMLText = require('./XMLText');

                XMLProcessingInstruction = require('./XMLProcessingInstruction');

                XMLDTDAttList = require('./XMLDTDAttList');

                XMLDTDElement = require('./XMLDTDElement');

                XMLDTDEntity = require('./XMLDTDEntity');

                XMLDTDNotation = require('./XMLDTDNotation');

                XMLWriterBase = require('./XMLWriterBase');

                module.exports = XMLStreamWriter = (function(superClass) {
                    extend(XMLStreamWriter, superClass);

                    function XMLStreamWriter(stream, options) {
                        XMLStreamWriter.__super__.constructor.call(this, options);
                        this.stream = stream;
                    }

                    XMLStreamWriter.prototype.document = function(doc) {
                        var child, i, j, len, len1, ref, ref1, results;
                        ref = doc.children;
                        for (i = 0, len = ref.length; i < len; i++) {
                            child = ref[i];
                            child.isLastRootNode = false;
                        }
                        doc.children[doc.children.length - 1].isLastRootNode = true;
                        ref1 = doc.children;
                        results = [];
                        for (j = 0, len1 = ref1.length; j < len1; j++) {
                            child = ref1[j];
                            switch (false) {
                                case !(child instanceof XMLDeclaration):
                                    results.push(this.declaration(child));
                                    break;
                                case !(child instanceof XMLDocType):
                                    results.push(this.docType(child));
                                    break;
                                case !(child instanceof XMLComment):
                                    results.push(this.comment(child));
                                    break;
                                case !(child instanceof XMLProcessingInstruction):
                                    results.push(this.processingInstruction(child));
                                    break;
                                default:
                                    results.push(this.element(child));
                            }
                        }
                        return results;
                    };

                    XMLStreamWriter.prototype.attribute = function(att) {
                        return this.stream.write(' ' + att.name + '="' + att.value + '"');
                    };

                    XMLStreamWriter.prototype.cdata = function(node, level) {
                        return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.comment = function(node, level) {
                        return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.declaration = function(node, level) {
                        this.stream.write(this.space(level));
                        this.stream.write('<?xml version="' + node.version + '"');
                        if (node.encoding != null) {
                            this.stream.write(' encoding="' + node.encoding + '"');
                        }
                        if (node.standalone != null) {
                            this.stream.write(' standalone="' + node.standalone + '"');
                        }
                        this.stream.write(this.spacebeforeslash + '?>');
                        return this.stream.write(this.endline(node));
                    };

                    XMLStreamWriter.prototype.docType = function(node, level) {
                        var child, i, len, ref;
                        level || (level = 0);
                        this.stream.write(this.space(level));
                        this.stream.write('<!DOCTYPE ' + node.root().name);
                        if (node.pubID && node.sysID) {
                            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                        } else if (node.sysID) {
                            this.stream.write(' SYSTEM "' + node.sysID + '"');
                        }
                        if (node.children.length > 0) {
                            this.stream.write(' [');
                            this.stream.write(this.endline(node));
                            ref = node.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                switch (false) {
                                    case !(child instanceof XMLDTDAttList):
                                        this.dtdAttList(child, level + 1);
                                        break;
                                    case !(child instanceof XMLDTDElement):
                                        this.dtdElement(child, level + 1);
                                        break;
                                    case !(child instanceof XMLDTDEntity):
                                        this.dtdEntity(child, level + 1);
                                        break;
                                    case !(child instanceof XMLDTDNotation):
                                        this.dtdNotation(child, level + 1);
                                        break;
                                    case !(child instanceof XMLCData):
                                        this.cdata(child, level + 1);
                                        break;
                                    case !(child instanceof XMLComment):
                                        this.comment(child, level + 1);
                                        break;
                                    case !(child instanceof XMLProcessingInstruction):
                                        this.processingInstruction(child, level + 1);
                                        break;
                                    default:
                                        throw new Error('Unknown DTD node type: ' + child.constructor.name);
                                }
                            }
                            this.stream.write(']');
                        }
                        this.stream.write(this.spacebeforeslash + '>');
                        return this.stream.write(this.endline(node));
                    };

                    XMLStreamWriter.prototype.element = function(node, level) {
                        var att, child, i, len, name, ref, ref1, space;
                        level || (level = 0);
                        space = this.space(level);
                        this.stream.write(space + '<' + node.name);
                        ref = node.attributes;
                        for (name in ref) {
                            if (!hasProp.call(ref, name)) continue;
                            att = ref[name];
                            this.attribute(att);
                        }
                        if (node.children.length === 0 || node.children.every(function(e) {
                            return e.value === '';
                        })) {
                            if (this.allowEmpty) {
                                this.stream.write('></' + node.name + '>');
                            } else {
                                this.stream.write(this.spacebeforeslash + '/>');
                            }
                        } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
                            this.stream.write('>');
                            this.stream.write(node.children[0].value);
                            this.stream.write('</' + node.name + '>');
                        } else {
                            this.stream.write('>' + this.newline);
                            ref1 = node.children;
                            for (i = 0, len = ref1.length; i < len; i++) {
                                child = ref1[i];
                                switch (false) {
                                    case !(child instanceof XMLCData):
                                        this.cdata(child, level + 1);
                                        break;
                                    case !(child instanceof XMLComment):
                                        this.comment(child, level + 1);
                                        break;
                                    case !(child instanceof XMLElement):
                                        this.element(child, level + 1);
                                        break;
                                    case !(child instanceof XMLRaw):
                                        this.raw(child, level + 1);
                                        break;
                                    case !(child instanceof XMLText):
                                        this.text(child, level + 1);
                                        break;
                                    case !(child instanceof XMLProcessingInstruction):
                                        this.processingInstruction(child, level + 1);
                                        break;
                                    default:
                                        throw new Error('Unknown XML node type: ' + child.constructor.name);
                                }
                            }
                            this.stream.write(space + '</' + node.name + '>');
                        }
                        return this.stream.write(this.endline(node));
                    };

                    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
                        this.stream.write(this.space(level) + '<?' + node.target);
                        if (node.value) {
                            this.stream.write(' ' + node.value);
                        }
                        return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.raw = function(node, level) {
                        return this.stream.write(this.space(level) + node.value + this.endline(node));
                    };

                    XMLStreamWriter.prototype.text = function(node, level) {
                        return this.stream.write(this.space(level) + node.value + this.endline(node));
                    };

                    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
                        this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
                        if (node.defaultValueType !== '#DEFAULT') {
                            this.stream.write(' ' + node.defaultValueType);
                        }
                        if (node.defaultValue) {
                            this.stream.write(' "' + node.defaultValue + '"');
                        }
                        return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.dtdElement = function(node, level) {
                        this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
                        return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
                        this.stream.write(this.space(level) + '<!ENTITY');
                        if (node.pe) {
                            this.stream.write(' %');
                        }
                        this.stream.write(' ' + node.name);
                        if (node.value) {
                            this.stream.write(' "' + node.value + '"');
                        } else {
                            if (node.pubID && node.sysID) {
                                this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                            } else if (node.sysID) {
                                this.stream.write(' SYSTEM "' + node.sysID + '"');
                            }
                            if (node.nData) {
                                this.stream.write(' NDATA ' + node.nData);
                            }
                        }
                        return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
                        this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
                        if (node.pubID && node.sysID) {
                            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
                        } else if (node.pubID) {
                            this.stream.write(' PUBLIC "' + node.pubID + '"');
                        } else if (node.sysID) {
                            this.stream.write(' SYSTEM "' + node.sysID + '"');
                        }
                        return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
                    };

                    XMLStreamWriter.prototype.endline = function(node) {
                        if (!node.isLastRootNode) {
                            return this.newline;
                        } else {
                            return '';
                        }
                    };

                    return XMLStreamWriter;

                })(XMLWriterBase);

            }).call(this);

        }, {
            './XMLCData': 210,
            './XMLComment': 211,
            './XMLDTDAttList': 212,
            './XMLDTDElement': 213,
            './XMLDTDEntity': 214,
            './XMLDTDNotation': 215,
            './XMLDeclaration': 216,
            './XMLDocType': 217,
            './XMLElement': 220,
            './XMLProcessingInstruction': 222,
            './XMLRaw': 223,
            './XMLText': 227,
            './XMLWriterBase': 228
        }],
        225: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration,
                    XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLDeclaration = require('./XMLDeclaration');

                XMLDocType = require('./XMLDocType');

                XMLCData = require('./XMLCData');

                XMLComment = require('./XMLComment');

                XMLElement = require('./XMLElement');

                XMLRaw = require('./XMLRaw');

                XMLText = require('./XMLText');

                XMLProcessingInstruction = require('./XMLProcessingInstruction');

                XMLDTDAttList = require('./XMLDTDAttList');

                XMLDTDElement = require('./XMLDTDElement');

                XMLDTDEntity = require('./XMLDTDEntity');

                XMLDTDNotation = require('./XMLDTDNotation');

                XMLWriterBase = require('./XMLWriterBase');

                module.exports = XMLStringWriter = (function(superClass) {
                    extend(XMLStringWriter, superClass);

                    function XMLStringWriter(options) {
                        XMLStringWriter.__super__.constructor.call(this, options);
                    }

                    XMLStringWriter.prototype.document = function(doc) {
                        var child, i, len, r, ref;
                        this.textispresent = false;
                        r = '';
                        ref = doc.children;
                        for (i = 0, len = ref.length; i < len; i++) {
                            child = ref[i];
                            r += (function() {
                                switch (false) {
                                    case !(child instanceof XMLDeclaration):
                                        return this.declaration(child);
                                    case !(child instanceof XMLDocType):
                                        return this.docType(child);
                                    case !(child instanceof XMLComment):
                                        return this.comment(child);
                                    case !(child instanceof XMLProcessingInstruction):
                                        return this.processingInstruction(child);
                                    default:
                                        return this.element(child, 0);
                                }
                            }).call(this);
                        }
                        if (this.pretty && r.slice(-this.newline.length) === this.newline) {
                            r = r.slice(0, -this.newline.length);
                        }
                        return r;
                    };

                    XMLStringWriter.prototype.attribute = function(att) {
                        return ' ' + att.name + '="' + att.value + '"';
                    };

                    XMLStringWriter.prototype.cdata = function(node, level) {
                        return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
                    };

                    XMLStringWriter.prototype.comment = function(node, level) {
                        return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
                    };

                    XMLStringWriter.prototype.declaration = function(node, level) {
                        var r;
                        r = this.space(level);
                        r += '<?xml version="' + node.version + '"';
                        if (node.encoding != null) {
                            r += ' encoding="' + node.encoding + '"';
                        }
                        if (node.standalone != null) {
                            r += ' standalone="' + node.standalone + '"';
                        }
                        r += this.spacebeforeslash + '?>';
                        r += this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.docType = function(node, level) {
                        var child, i, len, r, ref;
                        level || (level = 0);
                        r = this.space(level);
                        r += '<!DOCTYPE ' + node.root().name;
                        if (node.pubID && node.sysID) {
                            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                        } else if (node.sysID) {
                            r += ' SYSTEM "' + node.sysID + '"';
                        }
                        if (node.children.length > 0) {
                            r += ' [';
                            r += this.newline;
                            ref = node.children;
                            for (i = 0, len = ref.length; i < len; i++) {
                                child = ref[i];
                                r += (function() {
                                    switch (false) {
                                        case !(child instanceof XMLDTDAttList):
                                            return this.dtdAttList(child, level + 1);
                                        case !(child instanceof XMLDTDElement):
                                            return this.dtdElement(child, level + 1);
                                        case !(child instanceof XMLDTDEntity):
                                            return this.dtdEntity(child, level + 1);
                                        case !(child instanceof XMLDTDNotation):
                                            return this.dtdNotation(child, level + 1);
                                        case !(child instanceof XMLCData):
                                            return this.cdata(child, level + 1);
                                        case !(child instanceof XMLComment):
                                            return this.comment(child, level + 1);
                                        case !(child instanceof XMLProcessingInstruction):
                                            return this.processingInstruction(child, level + 1);
                                        default:
                                            throw new Error('Unknown DTD node type: ' + child.constructor.name);
                                    }
                                }).call(this);
                            }
                            r += ']';
                        }
                        r += this.spacebeforeslash + '>';
                        r += this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.element = function(node, level) {
                        var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
                        level || (level = 0);
                        textispresentwasset = false;
                        if (this.textispresent) {
                            this.newline = '';
                            this.pretty = false;
                        } else {
                            this.newline = this.newlinedefault;
                            this.pretty = this.prettydefault;
                        }
                        space = this.space(level);
                        r = '';
                        r += space + '<' + node.name;
                        ref = node.attributes;
                        for (name in ref) {
                            if (!hasProp.call(ref, name)) continue;
                            att = ref[name];
                            r += this.attribute(att);
                        }
                        if (node.children.length === 0 || node.children.every(function(e) {
                            return e.value === '';
                        })) {
                            if (this.allowEmpty) {
                                r += '></' + node.name + '>' + this.newline;
                            } else {
                                r += this.spacebeforeslash + '/>' + this.newline;
                            }
                        } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
                            r += '>';
                            r += node.children[0].value;
                            r += '</' + node.name + '>' + this.newline;
                        } else {
                            if (this.dontprettytextnodes) {
                                ref1 = node.children;
                                for (i = 0, len = ref1.length; i < len; i++) {
                                    child = ref1[i];
                                    if (child.value != null) {
                                        this.textispresent++;
                                        textispresentwasset = true;
                                        break;
                                    }
                                }
                            }
                            if (this.textispresent) {
                                this.newline = '';
                                this.pretty = false;
                                space = this.space(level);
                            }
                            r += '>' + this.newline;
                            ref2 = node.children;
                            for (j = 0, len1 = ref2.length; j < len1; j++) {
                                child = ref2[j];
                                r += (function() {
                                    switch (false) {
                                        case !(child instanceof XMLCData):
                                            return this.cdata(child, level + 1);
                                        case !(child instanceof XMLComment):
                                            return this.comment(child, level + 1);
                                        case !(child instanceof XMLElement):
                                            return this.element(child, level + 1);
                                        case !(child instanceof XMLRaw):
                                            return this.raw(child, level + 1);
                                        case !(child instanceof XMLText):
                                            return this.text(child, level + 1);
                                        case !(child instanceof XMLProcessingInstruction):
                                            return this.processingInstruction(child, level + 1);
                                        default:
                                            throw new Error('Unknown XML node type: ' + child.constructor.name);
                                    }
                                }).call(this);
                            }
                            if (textispresentwasset) {
                                this.textispresent--;
                            }
                            if (!this.textispresent) {
                                this.newline = this.newlinedefault;
                                this.pretty = this.prettydefault;
                            }
                            r += space + '</' + node.name + '>' + this.newline;
                        }
                        return r;
                    };

                    XMLStringWriter.prototype.processingInstruction = function(node, level) {
                        var r;
                        r = this.space(level) + '<?' + node.target;
                        if (node.value) {
                            r += ' ' + node.value;
                        }
                        r += this.spacebeforeslash + '?>' + this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.raw = function(node, level) {
                        return this.space(level) + node.value + this.newline;
                    };

                    XMLStringWriter.prototype.text = function(node, level) {
                        return this.space(level) + node.value + this.newline;
                    };

                    XMLStringWriter.prototype.dtdAttList = function(node, level) {
                        var r;
                        r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
                        if (node.defaultValueType !== '#DEFAULT') {
                            r += ' ' + node.defaultValueType;
                        }
                        if (node.defaultValue) {
                            r += ' "' + node.defaultValue + '"';
                        }
                        r += this.spacebeforeslash + '>' + this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.dtdElement = function(node, level) {
                        return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
                    };

                    XMLStringWriter.prototype.dtdEntity = function(node, level) {
                        var r;
                        r = this.space(level) + '<!ENTITY';
                        if (node.pe) {
                            r += ' %';
                        }
                        r += ' ' + node.name;
                        if (node.value) {
                            r += ' "' + node.value + '"';
                        } else {
                            if (node.pubID && node.sysID) {
                                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                            } else if (node.sysID) {
                                r += ' SYSTEM "' + node.sysID + '"';
                            }
                            if (node.nData) {
                                r += ' NDATA ' + node.nData;
                            }
                        }
                        r += this.spacebeforeslash + '>' + this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.dtdNotation = function(node, level) {
                        var r;
                        r = this.space(level) + '<!NOTATION ' + node.name;
                        if (node.pubID && node.sysID) {
                            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                        } else if (node.pubID) {
                            r += ' PUBLIC "' + node.pubID + '"';
                        } else if (node.sysID) {
                            r += ' SYSTEM "' + node.sysID + '"';
                        }
                        r += this.spacebeforeslash + '>' + this.newline;
                        return r;
                    };

                    XMLStringWriter.prototype.openNode = function(node, level) {
                        var att, name, r, ref;
                        level || (level = 0);
                        if (node instanceof XMLElement) {
                            r = this.space(level) + '<' + node.name;
                            ref = node.attributes;
                            for (name in ref) {
                                if (!hasProp.call(ref, name)) continue;
                                att = ref[name];
                                r += this.attribute(att);
                            }
                            r += (node.children ? '>' : '/>') + this.newline;
                            return r;
                        } else {
                            r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
                            if (node.pubID && node.sysID) {
                                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                            } else if (node.sysID) {
                                r += ' SYSTEM "' + node.sysID + '"';
                            }
                            r += (node.children ? ' [' : '>') + this.newline;
                            return r;
                        }
                    };

                    XMLStringWriter.prototype.closeNode = function(node, level) {
                        level || (level = 0);
                        switch (false) {
                            case !(node instanceof XMLElement):
                                return this.space(level) + '</' + node.name + '>' + this.newline;
                            case !(node instanceof XMLDocType):
                                return this.space(level) + ']>' + this.newline;
                        }
                    };

                    return XMLStringWriter;

                })(XMLWriterBase);

            }).call(this);

        }, {
            './XMLCData': 210,
            './XMLComment': 211,
            './XMLDTDAttList': 212,
            './XMLDTDElement': 213,
            './XMLDTDEntity': 214,
            './XMLDTDNotation': 215,
            './XMLDeclaration': 216,
            './XMLDocType': 217,
            './XMLElement': 220,
            './XMLProcessingInstruction': 222,
            './XMLRaw': 223,
            './XMLText': 227,
            './XMLWriterBase': 228
        }],
        226: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLStringifier,
                    bind = function(fn, me) {
                        return function() {
                            return fn.apply(me, arguments);
                        };
                    },
                    hasProp = {}.hasOwnProperty;

                module.exports = XMLStringifier = (function() {
                    function XMLStringifier(options) {
                        this.assertLegalChar = bind(this.assertLegalChar, this);
                        var key, ref, value;
                        options || (options = {});
                        this.noDoubleEncoding = options.noDoubleEncoding;
                        ref = options.stringify || {};
                        for (key in ref) {
                            if (!hasProp.call(ref, key)) continue;
                            value = ref[key];
                            this[key] = value;
                        }
                    }

                    XMLStringifier.prototype.eleName = function(val) {
                        val = '' + val || '';
                        return this.assertLegalChar(val);
                    };

                    XMLStringifier.prototype.eleText = function(val) {
                        val = '' + val || '';
                        return this.assertLegalChar(this.elEscape(val));
                    };

                    XMLStringifier.prototype.cdata = function(val) {
                        val = '' + val || '';
                        val = val.replace(']]>', ']]]]><![CDATA[>');
                        return this.assertLegalChar(val);
                    };

                    XMLStringifier.prototype.comment = function(val) {
                        val = '' + val || '';
                        if (val.match(/--/)) {
                            throw new Error('Comment text cannot contain double-hypen: ' + val);
                        }
                        return this.assertLegalChar(val);
                    };

                    XMLStringifier.prototype.raw = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.attName = function(val) {
                        return val = '' + val || '';
                    };

                    XMLStringifier.prototype.attValue = function(val) {
                        val = '' + val || '';
                        return this.attEscape(val);
                    };

                    XMLStringifier.prototype.insTarget = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.insValue = function(val) {
                        val = '' + val || '';
                        if (val.match(/\?>/)) {
                            throw new Error('Invalid processing instruction value: ' + val);
                        }
                        return val;
                    };

                    XMLStringifier.prototype.xmlVersion = function(val) {
                        val = '' + val || '';
                        if (!val.match(/1\.[0-9]+/)) {
                            throw new Error('Invalid version number: ' + val);
                        }
                        return val;
                    };

                    XMLStringifier.prototype.xmlEncoding = function(val) {
                        val = '' + val || '';
                        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
                            throw new Error('Invalid encoding: ' + val);
                        }
                        return val;
                    };

                    XMLStringifier.prototype.xmlStandalone = function(val) {
                        if (val) {
                            return 'yes';
                        } else {
                            return 'no';
                        }
                    };

                    XMLStringifier.prototype.dtdPubID = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.dtdSysID = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.dtdElementValue = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.dtdAttType = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.dtdAttDefault = function(val) {
                        if (val != null) {
                            return '' + val || '';
                        } else {
                            return val;
                        }
                    };

                    XMLStringifier.prototype.dtdEntityValue = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.dtdNData = function(val) {
                        return '' + val || '';
                    };

                    XMLStringifier.prototype.convertAttKey = '@';

                    XMLStringifier.prototype.convertPIKey = '?';

                    XMLStringifier.prototype.convertTextKey = '#text';

                    XMLStringifier.prototype.convertCDataKey = '#cdata';

                    XMLStringifier.prototype.convertCommentKey = '#comment';

                    XMLStringifier.prototype.convertRawKey = '#raw';

                    XMLStringifier.prototype.assertLegalChar = function(str) {
                        var res;
                        res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
                        if (res) {
                            throw new Error('Invalid character in string: ' + str + ' at index ' + res.index);
                        }
                        return str;
                    };

                    XMLStringifier.prototype.elEscape = function(str) {
                        var ampregex;
                        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
                    };

                    XMLStringifier.prototype.attEscape = function(str) {
                        var ampregex;
                        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
                        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
                    };

                    return XMLStringifier;

                })();

            }).call(this);

        }, {}],
        227: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLNode, XMLText,
                    extend = function(child, parent) {
                        for (var key in parent) {
                            if (hasProp.call(parent, key)) child[key] = parent[key];
                        }

                        function ctor() {
                            this.constructor = child;
                        }

                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    },
                    hasProp = {}.hasOwnProperty;

                XMLNode = require('./XMLNode');

                module.exports = XMLText = (function(superClass) {
                    extend(XMLText, superClass);

                    function XMLText(parent, text) {
                        XMLText.__super__.constructor.call(this, parent);
                        if (text == null) {
                            throw new Error('Missing element text');
                        }
                        this.value = this.stringify.eleText(text);
                    }

                    XMLText.prototype.clone = function() {
                        return Object.create(this);
                    };

                    XMLText.prototype.toString = function(options) {
                        return this.options.writer.set(options).text(this);
                    };

                    return XMLText;

                })(XMLNode);

            }).call(this);

        }, { './XMLNode': 221 }],
        228: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLWriterBase,
                    hasProp = {}.hasOwnProperty;

                module.exports = XMLWriterBase = (function() {
                    function XMLWriterBase(options) {
                        var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
                        options || (options = {});
                        this.pretty = options.pretty || false;
                        this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
                        if (this.pretty) {
                            this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
                            this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
                            this.offset = (ref3 = options.offset) != null ? ref3 : 0;
                            this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
                        } else {
                            this.indent = '';
                            this.newline = '';
                            this.offset = 0;
                            this.dontprettytextnodes = 0;
                        }
                        this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
                        if (this.spacebeforeslash === true) {
                            this.spacebeforeslash = ' ';
                        }
                        this.newlinedefault = this.newline;
                        this.prettydefault = this.pretty;
                        ref6 = options.writer || {};
                        for (key in ref6) {
                            if (!hasProp.call(ref6, key)) continue;
                            value = ref6[key];
                            this[key] = value;
                        }
                    }

                    XMLWriterBase.prototype.set = function(options) {
                        var key, ref, value;
                        options || (options = {});
                        if ('pretty' in options) {
                            this.pretty = options.pretty;
                        }
                        if ('allowEmpty' in options) {
                            this.allowEmpty = options.allowEmpty;
                        }
                        if (this.pretty) {
                            this.indent = 'indent' in options ? options.indent : '  ';
                            this.newline = 'newline' in options ? options.newline : '\n';
                            this.offset = 'offset' in options ? options.offset : 0;
                            this.dontprettytextnodes = 'dontprettytextnodes' in options ? options.dontprettytextnodes : 0;
                        } else {
                            this.indent = '';
                            this.newline = '';
                            this.offset = 0;
                            this.dontprettytextnodes = 0;
                        }
                        this.spacebeforeslash = 'spacebeforeslash' in options ? options.spacebeforeslash : '';
                        if (this.spacebeforeslash === true) {
                            this.spacebeforeslash = ' ';
                        }
                        this.newlinedefault = this.newline;
                        this.prettydefault = this.pretty;
                        ref = options.writer || {};
                        for (key in ref) {
                            if (!hasProp.call(ref, key)) continue;
                            value = ref[key];
                            this[key] = value;
                        }
                        return this;
                    };

                    XMLWriterBase.prototype.space = function(level) {
                        var indent;
                        if (this.pretty) {
                            indent = (level || 0) + this.offset + 1;
                            if (indent > 0) {
                                return new Array(indent).join(this.indent);
                            } else {
                                return '';
                            }
                        } else {
                            return '';
                        }
                    };

                    return XMLWriterBase;

                })();

            }).call(this);

        }, {}],
        229: [function(require, module, exports) {
// Generated by CoffeeScript 1.12.7
            (function() {
                var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

                ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;

                XMLDocument = require('./XMLDocument');

                XMLDocumentCB = require('./XMLDocumentCB');

                XMLStringWriter = require('./XMLStringWriter');

                XMLStreamWriter = require('./XMLStreamWriter');

                module.exports.create = function(name, xmldec, doctype, options) {
                    var doc, root;
                    if (name == null) {
                        throw new Error('Root element needs a name');
                    }
                    options = assign({}, xmldec, doctype, options);
                    doc = new XMLDocument(options);
                    root = doc.element(name);
                    if (!options.headless) {
                        doc.declaration(options);
                        if ((options.pubID != null) || (options.sysID != null)) {
                            doc.doctype(options);
                        }
                    }
                    return root;
                };

                module.exports.begin = function(options, onData, onEnd) {
                    var ref1;
                    if (isFunction(options)) {
                        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
                        options = {};
                    }
                    if (onData) {
                        return new XMLDocumentCB(options, onData, onEnd);
                    } else {
                        return new XMLDocument(options);
                    }
                };

                module.exports.stringWriter = function(options) {
                    return new XMLStringWriter(options);
                };

                module.exports.streamWriter = function(stream, options) {
                    return new XMLStreamWriter(stream, options);
                };

            }).call(this);

        }, {
            './Utility': 208,
            './XMLDocument': 218,
            './XMLDocumentCB': 219,
            './XMLStreamWriter': 224,
            './XMLStringWriter': 225
        }],
        230: [function(require, module, exports) {
            module.exports = extend;

            var hasOwnProperty = Object.prototype.hasOwnProperty;

            function extend() {
                var target = {};

                for (var i = 0; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            }

        }, {}],
        231: [function(require, module, exports) {
            module.exports = {
                'name': 'minio',
                'version': '7.0.2',
                'description': 'S3 Compatible Cloud Storage client',
                'main': './dist/main/minio.js',
                'scripts': {
                    'compile': 'gulp compile',
                    'test': 'gulp test',
                    'prepublish': 'gulp test',
                    'functional': 'gulp functional-test',
                    'browserify': 'gulp browserify',
                    'prepare': 'npm run compile'
                },
                'repository': {
                    'type': 'git',
                    'url': 'git+https://github.com/minio/minio-js.git'
                },
                'author': {
                    'name': 'Minio, Inc.',
                    'email': '',
                    'url': 'https://minio.io'
                },
                'engines': {
                    'node': '>= 0.10.0'
                },
                'license': 'Apache-2.0',
                'bugs': {
                    'url': 'https://github.com/minio/minio-js/issues',
                    'mail': ''
                },
                'homepage': 'https://github.com/minio/minio-js#readme',
                'dependencies': {
                    'async': '^1.5.2',
                    'block-stream2': '^1.0.0',
                    'concat-stream': '^1.4.8',
                    'es6-error': '^2.0.2',
                    'json-stream': '^1.0.0',
                    'lodash': '^4.14.2',
                    'mime-types': '^2.1.14',
                    'mkdirp': '^0.5.1',
                    'querystring': '0.2.0',
                    'through2': '^0.6.5',
                    'uuid': '^3.1.0',
                    'xml': '^1.0.0',
                    'xml2js': '^0.4.15'
                },
                'devDependencies': {
                    'browserify': '^12.0.1',
                    'chai': '^3.5.0',
                    'eslint': '^4.1.1',
                    'gulp': '^3.9.0',
                    'gulp-babel': '^5.2.1',
                    'gulp-eslint': '^4.0.0',
                    'gulp-mocha': '^2.1.0',
                    'gulp-notify': '^2.2.0',
                    'gulp-sourcemaps': '^1.5.2',
                    'mocha': '^2.3.2',
                    'mocha-steps': '^1.1.0',
                    'nock': '^2.12.0',
                    'rewire': '^2.3.3',
                    'source-map-support': '^0.4.12',
                    'superagent': '^3.7.0'
                },
                'keywords': [
                    'api',
                    'amazon',
                    'minio',
                    'cloud',
                    's3',
                    'storage'
                ]
            };

        }, {}]
    }, {}, [3])(3);
});
